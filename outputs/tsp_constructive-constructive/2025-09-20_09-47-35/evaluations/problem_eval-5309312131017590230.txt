def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate potential savings for each unvisited node, considering both immediate and next-step distances
    potential_savings = {}
    for node in unvisited_nodes:
        immediate_cost = distance_matrix[current_node][node]
        # Look ahead to the next possible step
        remaining_nodes = unvisited_nodes - {node}
        if remaining_nodes:
            next_step_cost = min(distance_matrix[node][next_node] for next_node in remaining_nodes)
        else:
            next_step_cost = distance_matrix[node][destination_node]
        total_cost = immediate_cost + next_step_cost - distance_matrix[current_node][destination_node]
        potential_savings[node] = total_cost

    # Select the node with the minimum potential cost
    next_node = min(potential_savings, key=potential_savings.get)
    return next_node
