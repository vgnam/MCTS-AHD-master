[
     {
          "algorithm": "The algorithm prioritizes selecting the destination node last (if unvisited) and otherwise chooses the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority). The score is calculated as `distance_to_node - 0.3 * avg_distance`, where the distance to the current node dominates the selection.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a proximity and centrality trade-off inspired by No.1, selecting the next node by minimizing the sum of distance to the current node and a slight penalty for high average distances to other nodes, while ensuring the destination is chosen last if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.3 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's still unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and penalizing nodes with high average distances to others (lower priority, weighted by -0.2). The score is calculated as `distance_to_node - 0.2 * avg_distance`, favoring closer nodes while slightly discouraging those with longer average connections.",
          "thought": "The new algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority), similar to No.1 but with a different weighting factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.2 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.84405,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the closest unvisited node based on the distance matrix. The function checks if the destination is still unvisited and returns it immediately if true, otherwise it iterates through unvisited nodes to find the one with the smallest distance from the current node. This ensures the path is optimized by minimizing immediate distances while ensuring the destination is reached last.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the smallest distance from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node (if unvisited) and otherwise combines greedy selection (70% chance) with stochastic selection (30%), where the latter uses a weighted random factor (0.7\u20131.3) to balance exploration and exploitation. The destination node has the highest priority, followed by the closest unvisited node (70% of the time), and a randomly selected node with a scaled distance (30% of the time).",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the probabilistic selection between greedy and stochastic choices of No.1, using a 70% probability for the closest node and 30% for a weighted random node with distance scaling between 0.7 and 1.3.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:  # 70% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 30% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.7, 1.3)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.06338,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node when it's unvisited, otherwise it selects the next node by balancing immediate distance from the current node with a reduced contribution (30%) from the node's distance to the destination, ensuring a trade-off between proximity and future efficiency. The destination is given full priority when unvisited, while other nodes are evaluated based on a weighted heuristic combining their distance from the current node and their distance to the destination.",
          "thought": "The new algorithm prioritizes the destination node when it's unvisited, otherwise it balances immediate distance minimization with a reduced contribution from the node's distance to the destination (weighted 0.3), ensuring a trade-off between proximity and future efficiency while maintaining the destination's priority.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        heuristic_value = current_distance + 0.3 * potential_distance\n        if heuristic_value < min_distance:\n            min_distance = heuristic_value\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the closest unvisited node with 70% probability or a random node with a weighted distance (scaled by a random factor between 0.5-1.5) with 30% probability. This balances exploitation (finding the closest node) and exploration (randomly choosing a node with varied distance weights) while ensuring the destination is reached last. The code uses a distance matrix to evaluate node distances and a probabilistic approach to decide between exploitation and exploration.",
          "thought": "The new algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the closest unvisited node with 70% probability or a random node with a weighted distance (scaled by a random factor between 0.5-1.5) with 30% probability, balancing exploitation and exploration while ensuring the destination is reached last.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:  # 70% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 30% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.5, 1.5)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.37317,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and destination-priority strategies using a weighted score (0.7 for immediate distance, 0.3 for destination proximity), prioritizing the destination if it remains unvisited and ensures efficiency by balancing short-term and long-term path optimization. The function first checks if the destination is still unvisited and returns it immediately if true, otherwise it computes a weighted score for each unvisited node and selects the one with the minimum score.",
          "thought": "The new algorithm introduces a hybrid selection mechanism that combines nearest-neighbor and destination-priority strategies, using a weighted score that balances immediate distance minimization with destination proximity to ensure efficient path planning while prioritizing the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    weighted_scores = {}\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_score = 0.7 * distance_to_node + 0.3 * distance_to_destination\n        weighted_scores[node] = weighted_score\n    next_node = min(weighted_scores, key=weighted_scores.get)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's the only remaining unvisited node or if it's still unvisited but not the only option. Otherwise, it balances immediate distance minimization with strategic positioning by combining the current distance to a node (weighted 1.0) with a reduced contribution from the node's distance to the destination (weighted 0.5). This ensures a trade-off between proximity and future efficiency, with the destination node taking precedence when feasible.",
          "thought": "The new algorithm prioritizes the destination node if it's the only unvisited node, otherwise it selects the next node by balancing between minimizing immediate distances and maximizing the potential to reach the destination efficiently, introducing a heuristic that considers both proximity and strategic positioning for the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        current_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        heuristic_value = current_distance + 0.5 * potential_distance\n        if heuristic_value < min_distance:\n            min_distance = heuristic_value\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and not the last node, otherwise it selects the closest unvisited node with 70% probability or a random node with a weighted distance (scaled by a factor between 0.5-1.5) with 30% probability, ensuring the destination is reached last while balancing exploitation (closest node) and exploration (random weighted node). The code uses a distance matrix to compute distances and randomness to introduce variability in node selection.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the closest node with 70% probability or a random node with a weighted distance (scaled by a factor between 0.5-1.5) with 30% probability, balancing exploitation and exploration while ensuring the destination is reached last.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.5, 1.5)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.46521,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and not the last node, otherwise it selects the closest unvisited node with 60% probability or a random node with weighted distance (scaled by 0.5-1.5) with 40% probability, balancing exploitation (closest node) and exploration (random node with distance scaling) while ensuring the destination is prioritized. The destination node is always selected first if unvisited and not last, otherwise the algorithm probabilistically chooses between greedy (closest) and stochastic (weighted random) selection. The `random_factor` introduces variability in distance weighting, favoring nodes with shorter distances but allowing some randomness.",
          "thought": "The new algorithm will prioritize the destination node if unvisited, otherwise it will select the closest unvisited node with 60% probability or a random node with weighted distance (scaled by a random factor between 0.5-1.5) with 40% probability, balancing exploitation and exploration while ensuring the destination is reached last.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.6:  # 60% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 40% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.5, 1.5)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.52749,
          "other_inf": null
     }
]