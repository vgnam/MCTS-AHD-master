[
     {
          "algorithm": "The algorithm prioritizes selecting the destination node last (if unvisited) and otherwise chooses the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority). The score is calculated as `distance_to_node - 0.3 * avg_distance`, where the distance to the current node dominates the selection.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a proximity and centrality trade-off inspired by No.1, selecting the next node by minimizing the sum of distance to the current node and a slight penalty for high average distances to other nodes, while ensuring the destination is chosen last if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.3 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's still unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and penalizing nodes with high average distances to others (lower priority, weighted by -0.2). The score is calculated as `distance_to_node - 0.2 * avg_distance`, favoring closer nodes while slightly discouraging those with longer average connections.",
          "thought": "The new algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority), similar to No.1 but with a different weighting factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.2 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.84405,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the closest unvisited node based on the distance matrix. The function checks if the destination is still unvisited and returns it immediately if true, otherwise it iterates through unvisited nodes to find the one with the smallest distance from the current node. This ensures the path is optimized by minimizing immediate distances while ensuring the destination is reached last.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the smallest distance from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and not the last remaining node, otherwise it selects the closest unvisited node with 80% probability or a random node weighted by a distance factor (0.9\u20131.1) to balance efficiency and exploration. The critical design choices are the 80% probability threshold for greedy selection and the random distance weighting to avoid local optima, with the destination node always prioritized when possible.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the closest unvisited node with 80% probability or a random node weighted by a distance factor (0.9\u20131.1) otherwise, balancing efficiency and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.8:\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.9, 1.1)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.02331,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node (if unvisited) and otherwise combines greedy selection (70% chance) with stochastic selection (30%), where the latter uses a weighted random factor (0.7\u20131.3) to balance exploration and exploitation. The destination node has the highest priority, followed by the closest unvisited node (70% of the time), and a randomly selected node with a scaled distance (30% of the time).",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the probabilistic selection between greedy and stochastic choices of No.1, using a 70% probability for the closest node and 30% for a weighted random node with distance scaling between 0.7 and 1.3.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:  # 70% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 30% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.7, 1.3)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.06338,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it greedily selects the closest node with 70% probability, or a random node weighted by a distance factor (0.8\u20131.2) otherwise, balancing exploration and exploitation. The destination node is always prioritized when possible, while unvisited nodes are chosen either deterministically (closest) or probabilistically (random with distance adjustment). The random factor introduces variability to escape local optima, with the greedy choice dominating (70%) to maintain efficiency.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a hybrid greedy-stochastic selection from No.1, where it prioritizes the destination, then selects the closest node with a 70% chance, and a random node with a weighted distance factor (0.8\u20131.2) otherwise.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.8, 1.2)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.08591,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and not the last node, otherwise it selects the next node by balancing proximity (distance from current node) and average connection distance (penalized by 10% weight). The destination node is given absolute priority when possible, while other nodes are scored based on a weighted combination of their distance from the current node and their average connectivity to all other nodes. This ensures a mix of locality and global connectivity awareness in path selection.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a proximity and average distance balance from No.1, favoring closer unvisited nodes while slightly penalizing those with longer average connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node + 0.1 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.18938,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node when it's unvisited, otherwise it selects the closest unvisited node 70% of the time and a randomly scaled node 30% of the time, balancing exploitation (shortest distance) with exploration (randomized scaling). The random factor (0.7\u20131.3) introduces variability in the 30% case, while the 70% case strictly follows the shortest-path heuristic. The `distance_matrix` provides the edge weights, and `unvisited_nodes` tracks remaining nodes.",
          "thought": "The new algorithm combines the destination node prioritization from No.2 with a 70% chance of selecting the closest unvisited node and a 30% chance of selecting a node with a scaled distance (weighted by a random factor between 0.7\u20131.3) to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.7:\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.7, 1.3)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.21459,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's still unvisited, otherwise it selects the next node by balancing immediate distance (80% weight) with a reduced contribution (20%) from the node's distance to the destination, ensuring a trade-off between proximity and future efficiency. The code uses a heuristic value combining these distances to guide node selection, with the destination node having special handling when it's the last remaining unvisited node.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the next node by balancing immediate distance with a reduced contribution (20%) from the node's distance to the destination, ensuring a trade-off between proximity and future efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        heuristic_value = current_distance + 0.2 * potential_distance\n        if heuristic_value < min_distance:\n            min_distance = heuristic_value\n            next_node = node\n    return next_node",
          "objective": 7.25108,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the next node by minimizing a weighted sum of immediate distance and average distance (15% weight), balancing proximity and connectivity. The destination node is given the highest priority, followed by nodes with the lowest combined score of current distance and penalized average distance. The 15% penalty on average distance ensures the algorithm avoids nodes that are generally distant from others, while still favoring nearby nodes.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the next node by minimizing the distance while slightly penalizing nodes with high average distances (15% weight), balancing immediate proximity and overall connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node + 0.15 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.30824,
          "other_inf": null
     }
]