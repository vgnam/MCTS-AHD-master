[
     {
          "algorithm": "The algorithm prioritizes selecting the destination node last (if unvisited) and otherwise chooses the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority). The score is calculated as `distance_to_node - 0.3 * avg_distance`, where the distance to the current node dominates the selection.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a proximity and centrality trade-off inspired by No.1, selecting the next node by minimizing the sum of distance to the current node and a slight penalty for high average distances to other nodes, while ensuring the destination is chosen last if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.3 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's still unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and penalizing nodes with high average distances to others (lower priority, weighted by -0.2). The score is calculated as `distance_to_node - 0.2 * avg_distance`, favoring closer nodes while slightly discouraging those with longer average connections.",
          "thought": "The new algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the next node by balancing proximity to the current node (higher priority) and a slight penalty for nodes with high average distances to other nodes (lower priority), similar to No.1 but with a different weighting factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node - 0.2 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.84405,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it remains unvisited, otherwise it selects the closest unvisited node based on the distance matrix. The function checks if the destination is still unvisited and returns it immediately if true, otherwise it iterates through unvisited nodes to find the one with the smallest distance from the current node. This ensures the path is optimized by minimizing immediate distances while ensuring the destination is reached last.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the smallest distance from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and destination-priority strategies using a weighted score (0.7 for immediate distance, 0.3 for destination proximity), prioritizing the destination if it remains unvisited and ensures efficiency by balancing short-term and long-term path optimization. The function first checks if the destination is still unvisited and returns it immediately if true, otherwise it computes a weighted score for each unvisited node and selects the one with the minimum score.",
          "thought": "The new algorithm introduces a hybrid selection mechanism that combines nearest-neighbor and destination-priority strategies, using a weighted score that balances immediate distance minimization with destination proximity to ensure efficient path planning while prioritizing the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    weighted_scores = {}\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_score = 0.7 * distance_to_node + 0.3 * distance_to_destination\n        weighted_scores[node] = weighted_score\n    next_node = min(weighted_scores, key=weighted_scores.get)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and not the last node, otherwise it selects the closest unvisited node with 60% probability or a random node with weighted distance (scaled by 0.5-1.5) with 40% probability, balancing exploitation (closest node) and exploration (random node with distance scaling) while ensuring the destination is prioritized. The destination node is always selected first if unvisited and not last, otherwise the algorithm probabilistically chooses between greedy (closest) and stochastic (weighted random) selection. The `random_factor` introduces variability in distance weighting, favoring nodes with shorter distances but allowing some randomness.",
          "thought": "The new algorithm will prioritize the destination node if unvisited, otherwise it will select the closest unvisited node with 60% probability or a random node with weighted distance (scaled by a random factor between 0.5-1.5) with 40% probability, balancing exploitation and exploration while ensuring the destination is reached last.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.6:  # 60% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 40% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.5, 1.5)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.52749,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node and the destination (minimizing `distance_to_node + distance_to_dest`) while slightly penalizing nodes with high average distances to others (`-0.5 * avg_distance`), balancing efficiency and centrality. The destination is always chosen if unvisited. The score calculation ensures a trade-off between immediate proximity and long-term path efficiency.",
          "thought": "This algorithm selects the next node by minimizing the sum of the distance from the current node and the distance from the node to the destination, while also incorporating a penalty for nodes that are not central (i.e., have high average distances to other nodes), ensuring a balance between proximity and centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node + distance_to_dest - 0.5 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.57753,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node when it's still unvisited, otherwise it selects the closest unvisited node with 30% probability or a random node with weighted distance (scaled by a random factor between 0.5-1.5) with 70% probability, balancing exploitation and exploration while favoring the destination when possible. The destination node is given the highest priority, followed by the closest node (30% chance), and finally a random node with a weighted distance (70% chance).",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the closest unvisited node with a 30% probability or a random node with a weighted distance (random factor between 0.5-1.5) with a 70% probability, ensuring a balance between exploitation and exploration while favoring the destination when possible.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        return destination_node\n    if random.random() < 0.3:  # 30% chance to select closest node\n        min_distance = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            if distance_matrix[current_node][node] < min_distance:\n                min_distance = distance_matrix[current_node][node]\n                next_node = node\n        return next_node\n    else:  # 70% chance to select random node with weighted distance\n        min_score = float('inf')\n        next_node = None\n        for node in unvisited_nodes:\n            distance = distance_matrix[current_node][node]\n            random_factor = random.uniform(0.5, 1.5)\n            score = distance * random_factor\n            if score < min_score:\n                min_score = score\n                next_node = node\n        return next_node",
          "objective": 7.86566,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of the distance from the current node and the distance to the destination, ensuring the path is optimized to reach the destination quickly while balancing proximity to the current node and the destination. It first checks if the destination is unvisited and selects it immediately if so, otherwise it iterates through unvisited nodes to find the one that minimizes the total distance (current node \u2192 candidate \u2192 destination). The destination is given higher priority, while intermediate nodes are selected based on their combined proximity to the current node and the destination.",
          "thought": "The new algorithm prioritizes nodes that are closest to the destination first, ensuring the path is optimized to reach the destination quickly while minimizing total distance by always considering the destination's proximity during node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        total_distance = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node with a 70% chance if it remains unvisited, otherwise it chooses the next node based on a weighted distance with a random factor (0.5-1.5), slightly favoring the destination (30% weight) if not the last node. It balances exploration (randomness) and exploitation (distance minimization) to guide the path toward the destination while maintaining variability.",
          "thought": "The new algorithm modifies the original by incorporating a probabilistic selection mechanism where the destination node has a higher probability of being chosen as the next node if it remains unvisited, while other nodes are selected based on a weighted combination of distance and a random factor to introduce variability in the path selection.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and len(unvisited_nodes) > 1:\n        if random.random() < 0.7:  # Higher probability to select destination\n            return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        random_factor = random.uniform(0.5, 1.5)  # Random weight between 0.5 and 1.5\n        score = distance * random_factor\n        if node == destination_node and len(unvisited_nodes) > 1:\n            score *= 0.3  # Slightly favor destination if not last node\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.02933,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by minimizing the product of the distance from the current node and the distance to the destination, while also considering the node's centrality via its average distance to all other nodes. The score balances short-term proximity (distance_to_node \u00d7 distance_to_dest) with long-term centrality (avg_distance), ensuring a trade-off between immediate and global optimization. The code iterates through unvisited nodes, computes the score, and selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the distance from the current node and the distance to the destination, ensuring a balance between proximity and potential for long-term optimization, while also considering the node's centrality in the graph by incorporating the average distance to all other nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])\n        score = distance_to_node * distance_to_dest + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 9.50586,
          "other_inf": null
     }
]