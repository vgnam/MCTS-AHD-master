def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate destination probability
    remaining_nodes = len(unvisited_nodes)
    destination_prob = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Decaying probability

    if destination_node in unvisited_nodes and remaining_nodes > 1:
        if random.random() < destination_prob:
            return destination_node

    # Calculate heuristic values for other nodes
    heuristic_values = {}
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        distance = distance_matrix[current_node][node]
        # Heuristic: inverse of distance multiplied by node degree (simplified)
        node_degree = sum(1 for d in distance_matrix[node] if d > 0)
        heuristic_values[node] = (1 / (distance + 1e-6)) * node_degree

    if heuristic_values:
        next_node = max(heuristic_values.items(), key=lambda x: x[1])[0]
    else:
        next_node = destination_node if destination_node in unvisited_nodes else unvisited_nodes[0]

    return next_node
