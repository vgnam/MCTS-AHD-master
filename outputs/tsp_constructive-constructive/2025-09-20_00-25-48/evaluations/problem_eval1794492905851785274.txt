def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    scores = []
    candidates = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if remaining_nodes:
            nearest_neighbor = min(remaining_nodes, key=lambda x: distance_matrix[node][x])
            sum_nearest = distance_matrix[node][nearest_neighbor]
        else:
            sum_nearest = distance_matrix[node][destination_node]
        score = current_distance * sum_nearest
        scores.append(score)
        candidates.append(node)
    min_score = min(scores)
    max_score = max(scores)
    if max_score == min_score:
        probabilities = [1.0 / len(scores) for _ in scores]
    else:
        normalized_scores = [(s - min_score) / (max_score - min_score) for s in scores]
        probabilities = [1.0 - (s / sum(normalized_scores)) for s in normalized_scores]
    selected_index = np.random.choice(len(candidates), p=probabilities)
    return next_node
