[
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing immediate proximity (70% weight) and potential path efficiency (30% weight), while penalizing nodes too close to the current node to avoid cycles. The `select_next_node` function evaluates unvisited nodes based on their distance from the current node and their contribution to the overall path length, adjusting scores with a penalty term for very short distances.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between immediate proximity to the current node and the potential to reduce the total path length, using a heuristic that considers both the current step and the overall path efficiency, while also introducing a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Penalize nodes that are too close to avoid revisiting\n        penalty = 0.1 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.5 else 0\n\n        # Weighted score: balance between immediate proximity and path efficiency\n        score = 0.7 * current_to_node + 0.3 * total_increase - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.5779,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (prioritized early in the tour) and path efficiency (weighted more as the tour progresses) while penalizing nodes too close to the current one to avoid cycling. It estimates the impact of each node on the remaining tour using a heuristic and adjusts weights based on remaining unvisited nodes. The score combines these factors to select the next node, with penalties and heuristics refining the selection process.",
          "thought": "The new algorithm enhances the selection process by incorporating a dynamic weighting mechanism that adjusts the balance between immediate proximity and path efficiency based on the remaining unvisited nodes, while also introducing a local search penalty to prevent cycling and a heuristic for estimating the impact of choosing a node on the overall tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    # Dynamic weighting based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    weight_proximity = 0.7 if remaining_nodes > 2 else 0.5\n    weight_efficiency = 1.0 - weight_proximity\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Local search penalty for nodes too close to current\n        penalty = 0.2 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.3 else 0\n\n        # Heuristic for path efficiency (estimates impact on remaining tour)\n        heuristic = sum(min(distance_matrix[node][n], distance_matrix[n][node]) for n in unvisited_nodes if n != node)\n\n        # Combined score with dynamic weights and heuristic\n        score = (weight_proximity * current_to_node +\n                 weight_efficiency * total_increase +\n                 0.2 * heuristic) - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.87563,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node probabilistically, balancing immediate distance (prioritized) and a global estimate of remaining path length (secondary priority) via weighted random choice. The weight for each node is inversely proportional to the sum of the immediate distance and 30% of the global estimate, ensuring closer and more promising nodes are favored. The code normalizes these weights and uses them to randomly select the next node, avoiding deterministic traps while maintaining efficiency.",
          "thought": "The new algorithm uses a probabilistic approach, selecting the next node based on a weighted random choice that balances immediate distance and a global estimate of the remaining path length, aiming to escape local optima while maintaining efficiency.",
          "code": "import random\n    import math\n\n    weights = []\n    total_weight = 0.0\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        global_estimate = distance_matrix[node][destination_node]\n        weight = 1.0 / (immediate_distance + 0.3 * global_estimate)\n        weights.append(weight)\n        total_weight += weight\n\n    if total_weight == 0:\n        return random.choice(unvisited_nodes)\n\n    normalized_weights = [w / total_weight for w in weights]\n    next_node = random.choices(unvisited_nodes, weights=normalized_weights, k=1)[0]\n\n    return next_node",
          "objective": 7.3084,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the product of the distance from the current node and the distance to the destination, balancing proximity and efficiency. This multiplicative approach ensures that nodes closer to both the current and destination positions are favored, avoiding long detours while still ensuring progress toward the goal. The function iterates through unvisited nodes, computes the product of distances, and selects the node with the smallest value.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the distance from the current node and the distance to the destination, balancing proximity and efficiency by considering multiplicative factors instead of additive ones.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_product = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        product = current_to_node * node_to_dest\n\n        if product < min_product:\n            min_product = product\n            best_node = node\n\n    return next_node",
          "objective": 7.43862,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends a greedy-plus-lookahead approach by dynamically adjusting weights to prioritize immediate distance when few nodes remain unvisited, while balancing exploration and exploitation through probabilistic selection based on normalized scores. The code uses `random.choices` with weights derived from `normalized_scores` to select the next node probabilistically, where higher scores (likely representing better candidates) have a higher chance of being chosen. The `destination_node` and unvisited nodes influence the scoring mechanism, but the selection is probabilistic rather than deterministic.",
          "thought": "The new algorithm extends the greedy-plus-lookahead approach by incorporating a dynamic weight adjustment mechanism that prioritizes immediate distance when few nodes remain unvisited, while balancing exploration and exploitation through a probabilistic selection based on normalized scores.",
          "code": "import random\n    selected_index = random.choices(range(len(nodes)), weights=normalized_scores, k=1)[0]\n    next_node = nodes[selected_index]\n\n    return next_node",
          "objective": 7.52604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (current distance) and future efficiency (average distance to remaining unvisited nodes), using a weighted sum where the current distance is prioritized (1.0 weight) and the average future distance is given lower weight (0.5). The function iterates through unvisited nodes, computes the weighted increase, and selects the node with the smallest value, ensuring a trade-off between short-term and long-term optimization. The code structure clearly separates the calculation of immediate and future costs, with special handling for the last node.",
          "thought": "The new algorithm prioritizes the next node by balancing immediate proximity and the node's potential to reduce future detours, using a weighted sum of the current distance and the average distance to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_weighted_increase = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_remaining_dist = 0\n\n        weighted_increase = current_to_node + 0.5 * avg_remaining_dist\n\n        if weighted_increase < min_weighted_increase:\n            min_weighted_increase = weighted_increase\n            best_node = node\n\n    return next_node",
          "objective": 7.68701,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing **proximity (60%)**, **path efficiency (30%)**, and a **dynamic penalty (10%)** to avoid cycles. Proximity prioritizes nearby nodes, efficiency considers the total path increase, and the penalty discourages revisiting distant nodes. The penalty is adaptive, scaling with distance to the next node, and only applied if the distance is below 0.3 units. The code iterates through unvisited nodes, computes a weighted score, and selects the node with the lowest score.",
          "thought": "The new algorithm combines the immediate proximity and path efficiency from both algorithms with an adaptive penalty to avoid cycles, using a weighted score (60% proximity, 30% efficiency, 10% penalty) and dynamic penalty adjustment based on the current distance to the next node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Adaptive penalty based on distance\n        penalty = 0.1 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.3 else 0\n\n        # Weighted score: balance between proximity, efficiency, and penalty\n        score = 0.6 * current_to_node + 0.3 * total_increase + 0.1 * penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 7.77166,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a lookahead estimate to the destination, prioritizing the former (weight 1.0) over the latter (weight 0.5) in a greedy-plus-lookahead strategy. The code iterates through unvisited nodes, computes a weighted sum of distances, and selects the node with the lowest total score, efficiently combining exploration and exploitation. The function returns the destination node if no unvisited nodes remain.",
          "thought": "The algorithm selects the next node by considering both the immediate distance to the current node and the estimated total path length if that node is chosen, using a combination of greedy and lookahead strategies to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        total_score = immediate_distance + 0.5 * lookahead_distance\n\n        if total_score < best_score:\n            best_score = total_score\n            best_node = node\n\n    return next_node",
          "objective": 7.81822,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the potential impact on the remaining path length, using a weighted sum where weights are dynamically adjusted based on the ratio of the node-to-destination distance to the remaining path length. Nodes closer to the current node and those with a higher impact on the overall path efficiency are prioritized, with the weight dynamically favoring either proximity or efficiency based on the remaining distance. The score combines these factors to choose the best node, ensuring a trade-off between immediate and long-term path optimization.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of distances, where weights are dynamically adjusted based on the remaining path length, favoring nodes that balance proximity to the current node and potential impact on the overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        remaining_distance = distance_matrix[current_node][destination_node]\n\n        if remaining_distance == 0:\n            weight = 1.0\n        else:\n            weight = node_to_dest / remaining_distance\n\n        score = (1 - weight) * current_to_node + weight * node_to_dest\n\n        if score < min_score:\n            min_score = score\n            best_node = node\n\n    return next_node",
          "objective": 7.86227,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing nodes that are significantly closer to the current node (using an exponential weight factor) while still considering their distance to the destination. The score is calculated as `(current_to_node ** weight) * node_to_dest`, where the exponential weighting (weight=0.5) emphasizes immediate proximity, balancing short-term and long-term efficiency. The node with the lowest score is chosen as the next step.",
          "thought": "The new algorithm modifies the selection criteria by incorporating an exponential weighting factor to prioritize nodes that are significantly closer to the current node while still considering their proximity to the destination, aiming for a balance between immediate progress and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        weight = 0.5  # Exponential weight factor\n        score = (current_to_node ** weight) * node_to_dest\n\n        if score < min_score:\n            min_score = score\n            best_node = node\n\n    return next_node",
          "objective": 8.01956,
          "other_inf": null
     }
]