def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = 1.0 - remaining_nodes / total_nodes

    # Dynamic weights: prioritize immediate distance early, future potential later
    immediate_weight = 0.7 - 0.5 * progress
    future_weight = 1.0 - immediate_weight

    # Track recently visited nodes (last 2 nodes) to avoid cycles
    recently_visited = set()
    if len(unvisited_nodes) < total_nodes - 2:
        recently_visited.add(current_node)

    best_node = None
    best_score = float('inf')

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Penalty for recently visited nodes
        penalty = 0.5 if node in recently_visited else 0

        # Combined score with dynamic weights and penalty
        score = (immediate_weight * immediate_distance + future_weight * future_distance) + penalty

        if score < best_score:
            best_score = score
            best_node = node

    return next_node
