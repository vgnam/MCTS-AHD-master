def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_node = None
    best_score = float('inf')

    # Adaptive weighting based on tour progress
    remaining_nodes = len(unvisited_nodes)
    weight_proximity = 0.8 - 0.2 * (remaining_nodes / len(distance_matrix))
    weight_efficiency = 1.0 - weight_proximity

    # Track recently visited nodes to avoid cycling
    recently_visited = set()
    if hasattr(select_next_node, 'last_visited'):
        recently_visited = select_next_node.last_visited
    select_next_node.last_visited = recently_visited

    for node in unvisited_nodes:
        current_to_node = distance_matrix[current_node][node]
        node_to_dest = distance_matrix[node][destination_node]
        total_increase = current_to_node + node_to_dest

        # Dynamic penalty for nodes too close to current or recently visited
        proximity_penalty = 0.3 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.2 else 0
        recency_penalty = 0.5 if node in recently_visited else 0

        # Greedy heuristic with lookahead for path efficiency
        lookahead = min(3, remaining_nodes)
        heuristic = sum(sorted(distance_matrix[node][n] for n in unvisited_nodes if n != node)[:lookahead])

        # Combined score with adaptive weights and penalties
        score = (weight_proximity * current_to_node +
                 weight_efficiency * total_increase +
                 0.3 * heuristic) - (proximity_penalty + recency_penalty)

        if score < best_score:
            best_score = score
            best_node = node

    # Update recently visited nodes
    if best_node is not None:
        recently_visited.add(best_node)
        if len(recently_visited) > 2:
            recently_visited.remove(next(iter(recently_visited)))

    return next_node
