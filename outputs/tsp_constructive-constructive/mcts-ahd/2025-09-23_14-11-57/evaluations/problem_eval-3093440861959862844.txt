def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)
    progress = (total_nodes - remaining_nodes) / total_nodes

    # Dynamic weight adjustment using sigmoid function
    exploration_weight = 1 / (1 + math.exp(5 * (progress - 0.5)))
    exploitation_weight = 1 - exploration_weight

    # Calculate node centrality (average distance to all other nodes)
    centrality = []
    for node in unvisited_nodes:
        avg_distance = sum(distance_matrix[node]) / total_nodes
        centrality.append(avg_distance)

    # Calculate path smoothness (angle between current path and potential next path)
    smoothness = []
    for node in unvisited_nodes:
        if current_node == node:
            smoothness.append(0)
            continue
        vec1 = (distance_matrix[current_node][node],)
        vec2 = (distance_matrix[node][destination_node],)
        angle = math.atan2(vec1[0]*vec2[0], vec1[0]*vec2[0])
        smoothness.append(angle)

    for i, node in enumerate(unvisited_nodes):
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Weighted score components
        distance_score = exploitation_weight * immediate_distance
        future_score = exploitation_weight * future_distance
        centrality_score = exploration_weight * centrality[i]
        smoothness_score = exploration_weight * smoothness[i]

        combined_score = (distance_score + future_score) + \
                         (centrality_score - smoothness_score)

        scores.append(combined_score)

    selected_index = scores.index(min(scores))
    next_node = list(unvisited_nodes)[selected_index]

    return next_node
