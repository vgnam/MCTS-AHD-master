import math
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    # Dynamic temperature scaling
    temperature = 1.0 + 0.5 * (1.0 - remaining_nodes / total_nodes)

    # Calculate immediate distances and regrets
    distances = []
    regrets = []
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        distances.append(immediate_distance)

        other_nodes = [n for n in unvisited_nodes if n != node]
        if other_nodes:
            # Consider top-3 alternatives for regret calculation
            top_k = min(3, len(other_nodes))
            sorted_distances = sorted(distance_matrix[current_node][n] for n in other_nodes)
            regret = sum(sorted_distances[:top_k]) / top_k - immediate_distance
        else:
            regret = 0
        regrets.append(regret)

    # Dynamic penalty based on visit frequency (simulated)
    visit_frequencies = np.random.rand(len(unvisited_nodes)) * 0.5  # Placeholder for actual frequency tracking
    dynamic_penalty = 0.3 * visit_frequencies * (1.0 - remaining_nodes / total_nodes)

    # Combine scores with dynamic weights
    combined_scores = []
    for i, (distance, regret) in enumerate(zip(distances, regrets)):
        # Weight adjustment based on stage
        stage_factor = 1.0 / (1.0 + 0.2 * remaining_nodes)
        immediate_weight = 0.5 * (1.0 - stage_factor)
        regret_weight = 0.5 * (1.0 + stage_factor)

        score = immediate_weight * distance + regret_weight * regret + dynamic_penalty[i]
        combined_scores.append(score)

    # Convert scores to probabilities using softmax with temperature
    exp_scores = np.exp(-np.array(combined_scores) / temperature)
    probabilities = exp_scores / np.sum(exp_scores)

    # Select node based on probabilities
    next_node = np.random.choice(list(unvisited_nodes), p=probabilities)

    return next_node
