import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    nodes = list(unvisited_nodes)
    scores = []

    # Dynamically adjust weights based on remaining nodes
    remaining = len(unvisited_nodes)
    weight_immediate = 1.0 if remaining > 1 else 1.5  # Prioritize immediate distance when few nodes left
    weight_lookahead = 0.5 if remaining > 1 else 0.3  # Reduce lookahead influence when few nodes left

    for node in nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]
        total_score = immediate_distance * weight_immediate + lookahead_distance * weight_lookahead
        scores.append(total_score)

    # Normalize scores for probabilistic selection
    min_score = min(scores)
    max_score = max(scores)
    normalized_scores = [(max_score - score) / (max_score - min_score + 1e-10) for score in scores]

    # Select node probabilistically (higher score = higher chance)
    selected_index = random.choices(range(len(nodes)), weights=normalized_scores, k=1)[0]
    next_node = nodes[selected_index]

    return next_node
