importance scoring, and a multi-stage selection process that prioritizes immediate distance, long-term connectivity, and exploration balance, with weights adjusted based on remaining nodes and path history.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_scores = []
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Path memory: track recent nodes to avoid cycles
        recent_nodes = min(3, len(unvisited_nodes))  # Look back at most 3 nodes
        path_memory_penalty = sum(distance_matrix[node][recent] for recent in unvisited_nodes[-recent_nodes:] if recent in unvisited_nodes)

        # Dynamic importance: balance distance and connectivity
        connectivity_score = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)
        importance_score = (immediate_distance + future_distance) / (1 + connectivity_score)

        # Exploration vs exploitation: favor nodes with balanced potential
        exploration_factor = len(unvisited_nodes) / len(distance_matrix)
        score = (0.5 * immediate_distance + 0.3 * importance_score + 0.2 * exploration_factor) * (1 + path_memory_penalty)

        node_scores.append(score)

    min_score = min(node_scores)
    selected_index = node_scores.index(min_score)
    next_node = list(unvisited_nodes)[selected_index]

    return next_node
