def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_node = None
    best_score = float('inf')
    total_nodes = len(unvisited_nodes) + 1
    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0
    penalty_factor = 0.5 + 0.4 * remaining_ratio  # Dynamic penalty scaling

    for node in unvisited_nodes:
        current_to_node = distance_matrix[current_node][node]

        # Lookahead: average distance to next two nodes
        lookahead_dist = 0
        if len(unvisited_nodes) > 1:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            if len(remaining_nodes) >= 2:
                next_node1 = min(remaining_nodes, key=lambda n: distance_matrix[node][n])
                remaining_nodes.remove(next_node1)
                next_node2 = min(remaining_nodes, key=lambda n: distance_matrix[node][n])
                lookahead_dist = (distance_matrix[node][next_node1] + distance_matrix[node][next_node2]) / 2
            else:
                lookahead_dist = distance_matrix[node][remaining_nodes[0]]

        # Node-specific attractiveness
        attractiveness = 1 / (1 + current_to_node)  # Higher for closer nodes
        revisit_penalty = penalty_factor * distance_matrix[current_node][node] * len(unvisited_nodes)

        # Combined score
        score = (1 - attractiveness) * current_to_node + 0.3 * lookahead_dist + revisit_penalty

        if score < best_score:
            best_score = score
            best_node = node

    return next_node
