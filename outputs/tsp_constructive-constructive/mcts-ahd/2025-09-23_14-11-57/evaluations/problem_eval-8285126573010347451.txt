def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    immediate_weight = 0.8 if remaining_nodes > 4 else 0.2
    future_weight = 0.2 if remaining_nodes > 4 else 0.8
    connectivity_weight = 0.3 if remaining_nodes > 2 else 0.1

    node_connectivity = [sum(1 for d in distance_matrix[node] if d > 0) for node in unvisited_nodes]
    max_connectivity = max(node_connectivity) if node_connectivity else 1
    connectivity_scores = [1 - (c / max_connectivity) for c in node_connectivity]

    path_history = [distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes]
    avg_history = sum(path_history) / len(path_history) if path_history else 0

    scores = []
    for i, node in enumerate(unvisited_nodes):
        current_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]
        total_dist = current_dist + future_dist

        connectivity_penalty = connectivity_weight * connectivity_scores[i]
        history_factor = 0.4 * (1 - (total_dist / (avg_history + 1e-6))) if avg_history > 0 else 0

        combined_score = (immediate_weight * current_dist) + (future_weight * future_dist) - connectivity_penalty + history_factor
        scores.append(combined_score)

    selected_index = scores.index(min(scores))
    next_node = list(unvisited_nodes)[selected_node]

    return next_node
