importance scores (calculated via degree centrality and betweenness centrality) and a probabilistic selection mechanism that balances exploitation (short-term gains) and exploration (long-term potential), with weights that adapt to both progress and node significance.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)
    progress = 1 - remaining_nodes / total_nodes

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Calculate node importance scores
        degree_centrality = sum(1 for dist in distance_matrix[node] if dist > 0) / (total_nodes - 1)
        betweenness_centrality = sum(distance_matrix[node]) / (total_nodes * (total_nodes - 1) / 2)

        # Dynamic weight adjustment
        exploration_weight = 0.3 + 0.4 * progress
        exploitation_weight = 0.7 - 0.4 * progress
        importance_weight = 0.5 * (degree_centrality + betweenness_centrality)

        # Probabilistic selection factors
        distance_factor = (1 / (1 + immediate_distance)) ** exploitation_weight
        future_factor = (1 / (1 + future_distance)) ** exploration_weight
        importance_factor = importance_weight ** 0.5

        combined_score = (distance_factor + future_factor) / (1 + importance_factor)

        scores.append(combined_score)

    # Probabilistic selection based on scores
    min_score = min(scores)
    max_score = max(scores)
    normalized_scores = [(max_score - s) / (max_score - min_score + 1e-6) for s in scores]

    # Apply softmax to get probabilities
    exp_scores = [math.exp(s) for s in normalized_scores]
    sum_exp = sum(exp_scores)
    probabilities = [e / sum_exp for e in exp_scores]

    # Select node based on probabilities
    next_node = random.choices(list(unvisited_nodes), weights=probabilities, k=1)[0]

    return next_node
