def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize metrics
    regret_scores = []
    clustering_coeffs = []
    path_potentials = []
    connectivity_pressures = []
    density_weights = []

    for node in unvisited_nodes:
        # Calculate regret with adaptive scaling
        other_nodes = [n for n in unvisited_nodes if n != node]
        if other_nodes:
            other_distances = [distance_matrix[current_node][n] for n in other_nodes]
            min_dist = min(other_distances)
            max_dist = max(other_distances)
            regret = (distance_matrix[current_node][node] - min_dist) / (max_dist - min_dist + 1e-10)
        else:
            regret = 0
        regret_scores.append(regret)

        # Clustering coefficient (normalized)
        nearest_neighbors = sorted(other_nodes, key=lambda n: distance_matrix[node][n])[:3]
        if nearest_neighbors:
            avg_cluster_dist = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors)
            clustering_coeff = 1 / (1 + avg_cluster_dist)
        else:
            clustering_coeff = 0
        clustering_coeffs.append(clustering_coeff)

        # Path potential with exponential decay
        remaining_nodes = len(unvisited_nodes)
        immediate_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]
        path_potential = (immediate_dist + future_dist) * (0.8 ** remaining_nodes)
        path_potentials.append(path_potential)

        # Connectivity pressure (inverse of average distance to unvisited)
        if other_nodes:
            avg_dist = sum(distance_matrix[node][n] for n in other_nodes) / len(other_nodes)
            connectivity_pressure = 1 / (1 + avg_dist)
        else:
            connectivity_pressure = 0
        connectivity_pressures.append(connectivity_pressure)

        # Density weight (inverse of local density)
        if other_nodes:
            local_density = sum(distance_matrix[node][n] for n in other_nodes) / len(other_nodes)
            density_weight = 1 / (1 + local_density)
        else:
            density_weight = 0
        density_weights.append(density_weight)

    # Adaptive weights with non-linear progression
    total_nodes = len(distance_matrix)
    progress = (total_nodes - len(unvisited_nodes)) / total_nodes

    regret_weight = 0.5 * (1 - progress**2)
    clustering_weight = 0.3 * progress
    path_weight = 0.4 * (1 - progress**1.5)
    pressure_weight = 0.2 * progress**1.5
    density_weight = 0.3 * progress**2

    # Combine scores with weighted sum
    scores = [
        regret_weight * regret + clustering_weight * cluster +
        path_weight * path + pressure_weight * pressure +
        density_weight * density
        for regret, cluster, path, pressure, density in zip(
            regret_scores, clustering_coeffs, path_potentials,
            connectivity_pressures, density_weights
        )
    ]

    # Select node with minimum score
    selected_index = scores.index(min(scores))
    next_node = list(unvisited_nodes)[selected_index]

    return next_node
