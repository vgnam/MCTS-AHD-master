import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Parameters
    exploration_factor = 0.3
    decay_rate = 0.7
    randomness = 0.2

    # Calculate scores for each unvisited node
    scores = []
    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]
        remaining_nodes = len(unvisited_nodes) - 1

        # Dynamic score combining distance and remaining nodes
        score = (1 - exploration_factor) * distance_to_node + exploration_factor * distance_to_dest
        score *= (decay_rate ** remaining_nodes)  # Decay score based on remaining nodes

        scores.append(score)

    # Normalize scores
    total_score = sum(scores)
    normalized_scores = [s / total_score for s in scores] if total_score > 0 else [1.0 / len(scores)] * len(scores)

    # Introduce randomness into selection
    if random.random() < randomness:
        next_node = random.choice(unvisited_nodes)
    else:
        # Select node with highest normalized score
        selected_index = normalized_scores.index(max(normalized_scores))
        next_node = unvisited_nodes[selected_index]

    return next_node
