def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_potentials = []
    exploration_factors = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Calculate regret with dynamic scaling
        other_nodes = [n for n in unvisited_nodes if n != node]
        if other_nodes:
            other_distances = [distance_matrix[current_node][n] for n in other_nodes]
            regret = immediate_distance - min(other_distances)
            regret_scaled = regret * (1 + (sum(other_distances) / len(other_distances)) - immediate_distance)
        else:
            regret_scaled = 0

        # Calculate exploration factor (future connectivity)
        exploration = sum(1 for n in unvisited_nodes if n != node and
                         distance_matrix[node][n] < 1.5 * immediate_distance)

        # Calculate local clustering (inverse of average distance to nearby nodes)
        nearby_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        clustering = 1 / (sum(nearby_distances) / len(nearby_distances)) if nearby_distances else 0

        # Node potential combines distance, regret, and clustering
        node_potential = (0.5 * immediate_distance + 0.3 * regret_scaled + 0.2 * clustering)
        node_potentials.append(node_potential)

        # Exploration factor balances immediate and future potential
        exploration_factor = (0.6 * immediate_distance + 0.4 * future_distance) * (0.9 ** len(unvisited_nodes))
        exploration_factors.append(exploration_factor)

    # Adaptive weights with phase-based adjustment
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    phase = 1 - (remaining_nodes / total_nodes)

    regret_weight = 0.4 * (1 - phase**2)
    exploration_weight = 0.5 * phase
    clustering_weight = 0.1 * phase**2

    # Combine scores with dynamic weights
    scores = [
        regret_weight * potential + exploration_weight * factor + clustering_weight * (factor**0.5)
        for potential, factor in zip(node_potentials, exploration_factors)
    ]

    min_score = min(scores)
    selected_index = scores.index(min_score)
    next_node = list(unvisited_nodes)[selected_index]

    return next_node
