[
     {
          "algorithm": "The algorithm adaptively balances immediate distance, future potential (weighted dynamically by progress), and penalties for reconsidered nodes, prioritizing immediate distances early and future costs later while penalizing late reconsiderations. It uses a normalized progress metric (0 to 1) to adjust the dynamic weight, decreasing future cost influence as the tour progresses. The weighted score combines these factors, with penalties applied only after half the nodes are visited.",
          "thought": "The new algorithm combines No.1's weighted balance between immediate and future distances with No.2's dynamic weight adjustment and penalty mechanism. It adaptively shifts focus from immediate distances to future costs while penalizing reconsidered nodes late in the process, using a normalized progress metric to modulate the dynamic weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_weighted_score = float('inf')\n    progress = 1 - len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Normalized progress (0 to 1)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes) if progress > 0.5 else 0\n        else:\n            avg_remaining_dist = 0\n            penalty = 0\n\n        dynamic_weight = 0.6 - 0.4 * progress  # Decrease future weight as progress increases\n        weighted_score = immediate_distance + dynamic_weight * future_potential + penalty\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            best_node = node\n\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distances (given a fixed weight of 0.5) while considering future potential (distance to the destination) for node selection. It applies a quadratic penalty to reconsidered nodes only after 70% progress, dynamically adjusting the penalty strength based on a linear progress metric. The code balances short-term and long-term considerations, with penalties only activated late in the process to refine choices.",
          "thought": "The new algorithm prioritizes immediate distances with a fixed future potential weight, applies a quadratic penalty for reconsidered nodes only after 70% progress, and uses a linear progress metric to dynamically adjust the penalty strength.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_weighted_score = float('inf')\n    progress = 1 - len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Linear progress metric (0 to 1)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = (sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)) ** 2 if progress > 0.7 else 0\n        else:\n            avg_remaining_dist = 0\n            penalty = 0\n\n        dynamic_weight = 0.5  # Fixed future potential weight\n        weighted_score = immediate_distance + dynamic_weight * future_potential + penalty\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            best_node = node\n\n    return next_node",
          "objective": 6.44688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing immediate proximity (70% weight) and potential path efficiency (30% weight), while penalizing nodes too close to the current node to avoid cycles. The `select_next_node` function evaluates unvisited nodes based on their distance from the current node and their contribution to the overall path length, adjusting scores with a penalty term for very short distances.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between immediate proximity to the current node and the potential to reduce the total path length, using a heuristic that considers both the current step and the overall path efficiency, while also introducing a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Penalize nodes that are too close to avoid revisiting\n        penalty = 0.1 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.5 else 0\n\n        # Weighted score: balance between immediate proximity and path efficiency\n        score = 0.7 * current_to_node + 0.3 * total_increase - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.5779,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate and lookahead distances with a weighted approach, prioritizing immediate distance (60%) over the best possible subsequent step (40%). It evaluates each unvisited node by computing a weighted sum of its direct distance from the current node and the shortest subsequent distance from that node, then selects the node with the lowest total score. The loop structure ensures all unvisited nodes are considered, while the distance matrix provides the necessary connectivity data.",
          "thought": "The new algorithm combines the balanced approach of No.2 (equal weights for immediate and lookahead distances) with the refined lookahead strategy of No.1 (evaluating the best possible subsequent step after the current candidate), while slightly adjusting the weights to favor immediate distance more than lookahead (60% vs. 40%).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        best_lookahead_distance = float('inf')\n        for next_node in unvisited_nodes:\n            if next_node != node:\n                lookahead_distance = distance_matrix[node][next_node]\n                if lookahead_distance < best_lookahead_distance:\n                    best_lookahead_distance = lookahead_distance\n\n        score = 0.6 * immediate_distance + 0.4 * best_lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.59312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (prioritized early in the tour) and path efficiency (weighted more as the tour progresses) while penalizing nodes too close to the current one to avoid cycling. It estimates the impact of each node on the remaining tour using a heuristic and adjusts weights based on remaining unvisited nodes. The score combines these factors to select the next node, with penalties and heuristics refining the selection process.",
          "thought": "The new algorithm enhances the selection process by incorporating a dynamic weighting mechanism that adjusts the balance between immediate proximity and path efficiency based on the remaining unvisited nodes, while also introducing a local search penalty to prevent cycling and a heuristic for estimating the impact of choosing a node on the overall tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    # Dynamic weighting based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    weight_proximity = 0.7 if remaining_nodes > 2 else 0.5\n    weight_efficiency = 1.0 - weight_proximity\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Local search penalty for nodes too close to current\n        penalty = 0.2 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.3 else 0\n\n        # Heuristic for path efficiency (estimates impact on remaining tour)\n        heuristic = sum(min(distance_matrix[node][n], distance_matrix[n][node]) for n in unvisited_nodes if n != node)\n\n        # Combined score with dynamic weights and heuristic\n        score = (weight_proximity * current_to_node +\n                 weight_efficiency * total_increase +\n                 0.2 * heuristic) - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.87563,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach with a look-ahead mechanism, prioritizing immediate distance (70%) over the best possible next-step distance (30%) to balance short-term and mid-term path efficiency. It iterates through unvisited nodes, evaluates each candidate's immediate distance and its potential to lead to efficient subsequent steps, and selects the node with the lowest weighted score. The function returns the destination node if no unvisited nodes remain.",
          "thought": "The new algorithm combines a greedy approach for immediate proximity with a look-ahead mechanism that evaluates pairs of nodes to balance short-term gains with mid-term path efficiency, using a weighted score that prioritizes both immediate distance and the potential to form efficient sub-paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        # Look-ahead: evaluate the best possible next node after 'node'\n        best_lookahead_distance = float('inf')\n        for next_node in unvisited_nodes:\n            if next_node != node:\n                lookahead_distance = distance_matrix[node][next_node]\n                if lookahead_distance < best_lookahead_distance:\n                    best_lookahead_distance = lookahead_distance\n\n        # Weighted score: balance immediate distance and lookahead efficiency\n        score = 0.7 * immediate_distance + 0.3 * best_lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.97586,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity and future potential by combining normalized immediate and future distances, with weights adjusted based on the traversal stage (prioritizing immediate distance early and future potential later). It penalizes nodes with high immediate distances and rewards exploration via an adaptive exploration factor, selecting the next node via a weighted score that minimizes immediate and future costs while accounting for dynamic penalties.",
          "thought": "\nThe new algorithm introduces a dynamic penalty mechanism that scales with both the immediate distance and the remaining nodes, prioritizing nodes that balance proximity and potential while adaptively adjusting weights based on the stage of traversal, using a novel scoring function that combines normalized distances and a node-specific exploration factor.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    base_immediate_weight = 0.7\n    base_future_weight = 0.3\n    stage_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    immediate_weight = base_immediate_weight * (1.0 - stage_factor)\n    future_weight = base_future_weight * (1.0 + stage_factor)\n\n    exploration_factor = 1.0 + 0.5 * (1.0 - (remaining_nodes / len(distance_matrix)))\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n\n        normalized_immediate = immediate_distance / (sum(distance_matrix[current_node]) / len(distance_matrix))\n        normalized_future = future_potential / (sum(distance_matrix[node]) / len(distance_matrix))\n\n        penalty = 0.2 * (1.0 / (immediate_distance + 1e-6)) * exploration_factor\n        combined_score = immediate_weight * normalized_immediate + future_weight * normalized_future - penalty\n\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.15223,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (70% weight) over future potential (30% weight) when nodes are plentiful, but shifts to 90% immediate and 10% future when nodes are scarce. It applies a penalty for very close nodes (<0.3 distance) to prevent cycles, using a dynamic weight adjustment to balance exploration and exploitation. The selection is based on minimizing a combined score of weighted distances and penalties.",
          "thought": "The new algorithm dynamically adjusts weights for immediate distance and future potential based on node scarcity, using a higher immediate weight and lower future weight when nodes are scarce, while incorporating a stronger penalty for very close nodes to prevent cycles and ensure diversity in path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.7 if remaining_nodes > 1 else 0.9\n    future_weight = 0.3 if remaining_nodes > 1 else 0.1\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        penalty = 0.2 * (1.0 / (immediate_distance + 1e-6)) if immediate_distance < 0.3 else 0\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential - penalty\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.22152,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (higher immediate weight when fewer nodes remain) with a penalty for very close nodes (to avoid cycles), prioritizing immediate distance early but shifting toward future potential (distance to destination) as the problem shrinks. The penalty (0.1 * inverse immediate distance) discourages revisiting nearby nodes, while weights balance immediate and future considerations based on remaining nodes. The structure iterates through unvisited nodes, computes a combined score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the penalty for close nodes from No.1, shifting weights aggressively toward future potential as nodes decrease and penalizing very close nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.5 if remaining_nodes > 3 else 0.7\n    future_weight = 0.3 if remaining_nodes > 3 else 0.5\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        penalty = 0.1 * (1.0 / (immediate_distance + 1e-6)) if immediate_distance < 0.5 else 0\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential - penalty\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.26623,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (higher weight when more nodes remain) and future potential (lower weight when nodes are scarce), while penalizing very close nodes to avoid cycles. It prioritizes minimizing a weighted sum of these factors, adjusting weights adaptively based on remaining nodes and penalizing short distances to prevent premature convergence. The code structure processes unvisited nodes, calculates scores, and selects the node with the minimal combined score.",
          "thought": "The new algorithm combines the adaptive weight adjustment from No.2 with the proximity and efficiency balancing from No.1, dynamically adjusting weights based on remaining nodes while penalizing very close nodes to avoid cycles. It minimizes a weighted sum of immediate distance, future potential, and a penalty term for short distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.6 if remaining_nodes > 2 else 0.8\n    future_weight = 0.4 if remaining_nodes > 2 else 0.2\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        penalty = 0.1 * (1.0 / (immediate_distance + 1e-6)) if immediate_distance < 0.5 else 0\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential - penalty\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.28888,
          "other_inf": null
     }
]