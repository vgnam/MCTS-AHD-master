[
     {
          "algorithm": "The algorithm adaptively balances immediate distance, future potential (weighted dynamically by progress), and penalties for reconsidered nodes, prioritizing immediate distances early and future costs later while penalizing late reconsiderations. It uses a normalized progress metric (0 to 1) to adjust the dynamic weight, decreasing future cost influence as the tour progresses. The weighted score combines these factors, with penalties applied only after half the nodes are visited.",
          "thought": "The new algorithm combines No.1's weighted balance between immediate and future distances with No.2's dynamic weight adjustment and penalty mechanism. It adaptively shifts focus from immediate distances to future costs while penalizing reconsidered nodes late in the process, using a normalized progress metric to modulate the dynamic weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_weighted_score = float('inf')\n    progress = 1 - len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Normalized progress (0 to 1)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes) if progress > 0.5 else 0\n        else:\n            avg_remaining_dist = 0\n            penalty = 0\n\n        dynamic_weight = 0.6 - 0.4 * progress  # Decrease future weight as progress increases\n        weighted_score = immediate_distance + dynamic_weight * future_potential + penalty\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            best_node = node\n\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing immediate proximity (70% weight) and potential path efficiency (30% weight), while penalizing nodes too close to the current node to avoid cycles. The `select_next_node` function evaluates unvisited nodes based on their distance from the current node and their contribution to the overall path length, adjusting scores with a penalty term for very short distances.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between immediate proximity to the current node and the potential to reduce the total path length, using a heuristic that considers both the current step and the overall path efficiency, while also introducing a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Penalize nodes that are too close to avoid revisiting\n        penalty = 0.1 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.5 else 0\n\n        # Weighted score: balance between immediate proximity and path efficiency\n        score = 0.7 * current_to_node + 0.3 * total_increase - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.5779,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (prioritized early in the tour) and path efficiency (weighted more as the tour progresses) while penalizing nodes too close to the current one to avoid cycling. It estimates the impact of each node on the remaining tour using a heuristic and adjusts weights based on remaining unvisited nodes. The score combines these factors to select the next node, with penalties and heuristics refining the selection process.",
          "thought": "The new algorithm enhances the selection process by incorporating a dynamic weighting mechanism that adjusts the balance between immediate proximity and path efficiency based on the remaining unvisited nodes, while also introducing a local search penalty to prevent cycling and a heuristic for estimating the impact of choosing a node on the overall tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    best_score = float('inf')\n\n    # Dynamic weighting based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    weight_proximity = 0.7 if remaining_nodes > 2 else 0.5\n    weight_efficiency = 1.0 - weight_proximity\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        total_increase = current_to_node + node_to_dest\n\n        # Local search penalty for nodes too close to current\n        penalty = 0.2 * (1.0 / (current_to_node + 1e-6)) if current_to_node < 0.3 else 0\n\n        # Heuristic for path efficiency (estimates impact on remaining tour)\n        heuristic = sum(min(distance_matrix[node][n], distance_matrix[n][node]) for n in unvisited_nodes if n != node)\n\n        # Combined score with dynamic weights and heuristic\n        score = (weight_proximity * current_to_node +\n                 weight_efficiency * total_increase +\n                 0.2 * heuristic) - penalty\n\n        if score < best_score:\n            best_score = score\n            best_node = node\n\n    return next_node",
          "objective": 6.87563,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (higher weight when more nodes remain) and future potential (lower weight when nodes are scarce), while penalizing very close nodes to avoid cycles. It prioritizes minimizing a weighted sum of these factors, adjusting weights adaptively based on remaining nodes and penalizing short distances to prevent premature convergence. The code structure processes unvisited nodes, calculates scores, and selects the node with the minimal combined score.",
          "thought": "The new algorithm combines the adaptive weight adjustment from No.2 with the proximity and efficiency balancing from No.1, dynamically adjusting weights based on remaining nodes while penalizing very close nodes to avoid cycles. It minimizes a weighted sum of immediate distance, future potential, and a penalty term for short distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.6 if remaining_nodes > 2 else 0.8\n    future_weight = 0.4 if remaining_nodes > 2 else 0.2\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        penalty = 0.1 * (1.0 / (immediate_distance + 1e-6)) if immediate_distance < 0.5 else 0\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential - penalty\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.28888,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node probabilistically, balancing immediate distance (prioritized) and a global estimate of remaining path length (secondary priority) via weighted random choice. The weight for each node is inversely proportional to the sum of the immediate distance and 30% of the global estimate, ensuring closer and more promising nodes are favored. The code normalizes these weights and uses them to randomly select the next node, avoiding deterministic traps while maintaining efficiency.",
          "thought": "The new algorithm uses a probabilistic approach, selecting the next node based on a weighted random choice that balances immediate distance and a global estimate of the remaining path length, aiming to escape local optima while maintaining efficiency.",
          "code": "import random\n    import math\n\n    weights = []\n    total_weight = 0.0\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        global_estimate = distance_matrix[node][destination_node]\n        weight = 1.0 / (immediate_distance + 0.3 * global_estimate)\n        weights.append(weight)\n        total_weight += weight\n\n    if total_weight == 0:\n        return random.choice(unvisited_nodes)\n\n    normalized_weights = [w / total_weight for w in weights]\n    next_node = random.choices(unvisited_nodes, weights=normalized_weights, k=1)[0]\n\n    return next_node",
          "objective": 7.3084,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration (current-to-node distance) and exploitation (future costs) by adjusting a weight that decreases as progress increases, while penalizing reconsidered nodes when progress exceeds 50%. It prioritizes immediate distances early but shifts focus to minimizing future costs as the tour progresses, using a normalized progress metric (0-1) to adapt the dynamic weight. The penalty term further refines selection by discouraging revisits late in the process, ensuring a smoother transition between exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that adapts based on the current progress (fraction of nodes visited) and a penalty for revisiting nodes that were previously considered but not chosen, aiming to balance exploration and exploitation more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_weighted_increase = float('inf')\n    progress = 1 - len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Normalized progress (0 to 1)\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes) if progress > 0.5 else 0\n        else:\n            avg_remaining_dist = 0\n            penalty = 0\n\n        dynamic_weight = 1.0 - 0.3 * progress  # Decrease weight of future cost as progress increases\n        weighted_increase = current_to_node + dynamic_weight * avg_remaining_dist + penalty\n\n        if weighted_increase < min_weighted_increase:\n            min_weighted_increase = weighted_increase\n            best_node = node\n\n    return next_node",
          "objective": 7.39994,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the product of the distance from the current node and the distance to the destination, balancing proximity and efficiency. This multiplicative approach ensures that nodes closer to both the current and destination positions are favored, avoiding long detours while still ensuring progress toward the goal. The function iterates through unvisited nodes, computes the product of distances, and selects the node with the smallest value.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the distance from the current node and the distance to the destination, balancing proximity and efficiency by considering multiplicative factors instead of additive ones.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_node = None\n    min_product = float('inf')\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        product = current_to_node * node_to_dest\n\n        if product < min_product:\n            min_product = product\n            best_node = node\n\n    return next_node",
          "objective": 7.43862,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends a greedy-plus-lookahead approach by dynamically adjusting weights to prioritize immediate distance when few nodes remain unvisited, while balancing exploration and exploitation through probabilistic selection based on normalized scores. The code uses `random.choices` with weights derived from `normalized_scores` to select the next node probabilistically, where higher scores (likely representing better candidates) have a higher chance of being chosen. The `destination_node` and unvisited nodes influence the scoring mechanism, but the selection is probabilistic rather than deterministic.",
          "thought": "The new algorithm extends the greedy-plus-lookahead approach by incorporating a dynamic weight adjustment mechanism that prioritizes immediate distance when few nodes remain unvisited, while balancing exploration and exploitation through a probabilistic selection based on normalized scores.",
          "code": "import random\n    selected_index = random.choices(range(len(nodes)), weights=normalized_scores, k=1)[0]\n    next_node = nodes[selected_index]\n\n    return next_node",
          "objective": 7.52604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (50\u201370% weight) and future potential (30\u201350% weight) based on remaining unvisited nodes, adjusting weights dynamically to favor future potential as nodes decrease. It selects the next node by minimizing a weighted sum of current distance and the node's distance to the destination, balancing exploration (shorter immediate paths) and exploitation (closer to the end). The weights shift aggressively to exploitation as the tour nears completion.",
          "thought": "The new algorithm prioritizes immediate distance (50-70% weight) and future potential (30-50% weight) based on remaining nodes, using a more aggressive exploration-exploitation balance by increasing future potential weight as nodes decrease, and selecting the node that minimizes a weighted sum of current and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.5 if remaining_nodes > 3 else 0.7\n    future_weight = 0.3 if remaining_nodes > 3 else 0.5\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.61406,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with dynamic lookahead, prioritizing immediate distance (60-80% weight) and future potential (40-20% weight) based on remaining nodes. It adaptively balances exploration (shorter-term) and exploitation (longer-term) by adjusting weights as the number of unvisited nodes decreases. The selection is made by minimizing a weighted sum of current and future distances.",
          "thought": "This algorithm combines a nearest-neighbor approach with a dynamic lookahead that considers both immediate distance and the potential to form a good path, using a weighted sum with adaptive weights based on the number of remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    immediate_weight = 0.6 if remaining_nodes > 2 else 0.8\n    future_weight = 0.4 if remaining_nodes > 2 else 0.2\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_potential = distance_matrix[node][destination_node]\n        combined_score = immediate_weight * immediate_distance + future_weight * future_potential\n        scores.append(combined_score)\n\n    min_score = min(scores)\n    selected_index = scores.index(min_score)\n    next_node = list(unvisited_nodes)[selected_index]\n\n    return next_node",
          "objective": 7.62163,
          "other_inf": null
     }
]