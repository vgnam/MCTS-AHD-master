[
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, detour penalties (40% weight), and exploration bonuses (40% weight). It prioritizes nodes that minimize detours (by comparing direct distance to destination via the node) and reward nodes with high connectivity to unvisited nodes (exploration bonus). The score combines these factors to choose the most promising next node, with detour penalties and exploration bonuses given equal weight (0.4 each).",
          "thought": "The new algorithm combines the detour penalty from No.1 (0.4 weight) with the exploration bonus from No.2 (0.4 weight), while using a more balanced exploration bonus calculation based on remaining nodes and direct distances. It selects the next node by minimizing immediate distance, penalizing detours, and rewarding nodes that connect to many unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_node + distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n\n            exploration_bonus = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    exploration_bonus += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                exploration_bonus /= (remaining_nodes - 1)\n\n            score = distance_to_node + 0.4 * detour_penalty - 0.4 * exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.28936,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing detour penalties by balancing the immediate distance to the next node with the ratio of that node's distance to the destination versus the direct distance from the current node to the destination. It assigns higher priority to nodes that reduce detours (penalizing nodes where the path to the destination is significantly longer than the direct route) while still considering immediate distance, with a small weight (0.5) on the penalty term. The code iterates through unvisited nodes, computes a score combining distance and detour penalty, and selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes minimizing the detour penalty by emphasizing the ratio of the candidate node's distance to the destination versus the direct distance, with a stronger penalty for detours, and balances this with a smaller weight on immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.5 * (normalization_factor - 1) * distance_to_destination\n            score = penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance and detour impact while balancing exploration early on. It assigns higher priority to nodes that reduce distance and detour penalty (via `penalty`) but balances this with an `exploration_bonus` that decreases as more nodes are visited. The `score` is a weighted combination of these factors, favoring shorter paths with controlled detours while encouraging early exploration.",
          "thought": "The new algorithm combines the detour penalty from No.1 with the exploration bonus from No.2, prioritizing nodes that minimize immediate distance, detour impact, and encourage exploration early on.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / distance_to_destination\n            penalty = distance_to_node + 0.5 * (detour_ratio - 1) * direct_distance\n            exploration_bonus = 1.0 / (1.0 + remaining_nodes)\n            score = penalty - exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.57696,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity to the current node with a detour penalty, weighted by the remaining unvisited nodes. It prioritizes minimizing immediate distance while penalizing nodes that increase the detour to the destination, with the weighting dynamically adjusted based on the number of remaining nodes. The score balances these factors, favoring closer nodes early but considering long-term efficiency as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weighting of No.2 with the detour penalty from No.1, using a weight based on remaining nodes to balance proximity and long-term efficiency while penalizing nodes that increase detour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.5 * (normalization_factor - 1) * distance_to_destination\n            score = weight * penalty + (1 - weight) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60308,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, detour penalties, and exploration-exploitation trade-offs. It prioritizes nodes minimizing direct distance while penalizing detours (with a weight of 0.4) and adjusts exploration based on remaining unvisited nodes (using a squared weight). The exploration bonus decreases with distance and increases with fewer remaining nodes. The score combines these factors, favoring nodes that minimize immediate travel while adaptively adjusting for detours and exploration.",
          "thought": "The new algorithm combines the detour penalty from No.1 with the dynamic exploration-exploitation balance from No.2, using a weighted score that prioritizes nodes minimizing immediate distance while penalizing detours and adjusting for remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            exploration_weight = (remaining_nodes / total_nodes) ** 2\n            exploration_bonus = exploration_weight * (1.0 / (1.0 + distance_to_node))\n\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n            score = distance_to_node + 0.4 * detour_penalty - exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61322,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing detour penalties (60% weight), exploration bonuses (30% weight), and direct distance (10% weight), prioritizing nodes that minimize detours while encouraging exploration of unvisited nodes. The detour penalty penalizes nodes that increase the path length significantly, while the exploration bonus rewards nodes that reduce the number of remaining unvisited nodes. The direct distance ensures the immediate step is as short as possible.",
          "thought": "The new algorithm combines the detour penalty and exploration bonus from No.1 with the weighted local-global balance from No.2, selecting the next node by minimizing a score that includes immediate distance, detour impact, and exploration incentive, while weighting these factors (e.g., 0.6 for detour penalty, 0.3 for exploration bonus, and 0.1 for direct distance).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / distance_to_destination\n            detour_penalty = 0.6 * (distance_to_node + 0.5 * (detour_ratio - 1) * direct_distance)\n            exploration_bonus = 0.3 * (1.0 / (1.0 + remaining_nodes))\n            direct_weight = 0.1 * distance_to_node\n            score = detour_penalty - exploration_bonus + direct_weight\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64756,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing immediate distance (via `ratio`) and long-term detours (via `detour_penalty`), while also adjusting for efficiency through a `penalty` term. The weighted sum (`score = ratio + 0.2 * penalty + 0.3 * detour_penalty`) ensures that closer nodes with minimal detours are selected, with `detour_penalty` (30%) and `penalty` (20%) given higher weights than the raw distance ratio (50%). The `normalization_factor` scales the penalty based on distance to the destination, further refining the selection.",
          "thought": "The new algorithm combines the dynamic detour penalty from No.1 with the proximity and efficiency balance from No.2, using a weighted sum of the ratio of distances and a scaled detour penalty to prioritize nodes that minimize both immediate distance and long-term detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour_penalty = (distance_to_node + distance_to_destination - direct_distance) / (1.0 + direct_distance)\n\n        normalization_factor = direct_distance / distance_to_destination if distance_to_destination != 0 else 1.0\n        penalty = distance_to_node + 0.4 * (normalization_factor - 1) * distance_to_destination\n        score = ratio + 0.2 * penalty + 0.3 * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65384,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines detour penalty and ratio balancing with dynamic weight adjustment, prioritizing nodes that minimize immediate distance and detour while adaptively adjusting the trade-off based on remaining nodes. It uses a weighted score combining the ratio of current distance to destination distance and a detour penalty, with dynamic weights (0.5 for small detours, 0.2 otherwise) and remaining node-based weights. The score balances immediate efficiency (ratio) and long-term path quality (detour penalty) dynamically.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the detour penalty and ratio balancing from No.1, prioritizing nodes that minimize both immediate distance and detour while adaptively adjusting the trade-off based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour = distance_to_node + distance_to_destination - direct_distance\n        detour_penalty = detour / (1.0 + direct_distance)\n\n        dynamic_weight = 0.5 if detour <= direct_distance * 0.1 else 0.2\n        remaining_weight = 1.0 / (1.0 + remaining_nodes)\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        score = (1 - remaining_weight) * ratio + remaining_weight * (dynamic_weight * detour_penalty)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.66518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing the ratio of the distance to the candidate node and its distance to the destination, while dynamically penalizing detours (excess distance beyond a direct path). Nodes with smaller detours (\u226410% of direct distance) receive a higher penalty weight (0.5), while others use a lower weight (0.2). The score combines the ratio and weighted detour penalty to prioritize nodes that minimize both travel distance and detours, favoring closer or more direct paths.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for the detour penalty based on the node's position in the path, favoring nodes that either reduce the detour or extend the path in a controlled manner, while still balancing proximity and efficiency through a normalized ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour = distance_to_node + distance_to_destination - direct_distance\n        detour_penalty = detour / (1.0 + direct_distance)\n\n        # Dynamic weight for detour penalty based on node's position\n        dynamic_weight = 0.5 if detour <= direct_distance * 0.1 else 0.2\n\n        score = ratio + dynamic_weight * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.66924,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances detour awareness (40%) and exploration (60%) to select the next node in TSP, prioritizing nodes that minimize deviation from the direct path while gradually encouraging exploration as fewer nodes remain unvisited. It calculates a weighted score combining the distance to the candidate node, a detour ratio, and an exploration factor, favoring lower scores. The detour ratio (0.4 weight) penalizes paths that deviate significantly, while the exploration factor (0.6 weight) increases influence as unvisited nodes decrease, ensuring a mix of efficiency and completeness.",
          "thought": "The new algorithm combines the detour-aware scoring of No.1 with the exploration factor of No.2, using a weighted balance (0.4 for detour ratio and 0.6 for exploration factor) to prioritize nodes that minimize detours while encouraging exploration early in the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        direct_distance = distance_matrix[current_node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            detour_ratio = direct_distance / distance_to_destination\n            exploration_factor = 1.0 / (1.0 + len(unvisited_nodes))\n            score = distance_to_node + (detour_ratio * 0.4 + exploration_factor * 0.6) * direct_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.67359,
          "other_inf": null
     }
]