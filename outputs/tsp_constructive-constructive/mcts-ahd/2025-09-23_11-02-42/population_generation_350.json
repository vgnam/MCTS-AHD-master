[
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, detour penalties (40% weight), and exploration bonuses (40% weight). It prioritizes nodes that minimize detours (by comparing direct distance to destination via the node) and reward nodes with high connectivity to unvisited nodes (exploration bonus). The score combines these factors to choose the most promising next node, with detour penalties and exploration bonuses given equal weight (0.4 each).",
          "thought": "The new algorithm combines the detour penalty from No.1 (0.4 weight) with the exploration bonus from No.2 (0.4 weight), while using a more balanced exploration bonus calculation based on remaining nodes and direct distances. It selects the next node by minimizing immediate distance, penalizing detours, and rewarding nodes that connect to many unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_node + distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n\n            exploration_bonus = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    exploration_bonus += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                exploration_bonus /= (remaining_nodes - 1)\n\n            score = distance_to_node + 0.4 * detour_penalty - 0.4 * exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.28936,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, detour penalties, exploration bonuses, and connectivity-based penalties, with dynamic adjustments based on remaining nodes. It prioritizes shorter distances, penalizes detours, rewards exploration, and adjusts connectivity penalties dynamically as the search progresses. The dynamic factor (1 - remaining_nodes/total_nodes) reduces the influence of connectivity penalties over time, favoring exploitation near the end.",
          "thought": "The new algorithm extends the original by incorporating a dynamic penalty factor that adjusts based on the remaining nodes' connectivity, using a novel scoring mechanism that combines immediate distance, detour penalties, exploration bonuses, and a connectivity-based penalty term to balance exploration and exploitation more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_node + distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n\n            exploration_bonus = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    exploration_bonus += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                exploration_bonus /= (remaining_nodes - 1)\n\n            connectivity_penalty = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    connectivity_penalty += distance_matrix[node][other_node]\n            connectivity_penalty = connectivity_penalty / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n\n            dynamic_factor = 1.0 - (remaining_nodes / total_nodes)\n            score = distance_to_node + (0.4 * detour_penalty) - (0.4 * exploration_bonus) + (0.2 * dynamic_factor * connectivity_penalty)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, detour penalties (weighted 0.5), and exploration bonuses (weighted -0.3). It prioritizes shorter direct paths while penalizing excessive detours and rewarding nodes that connect to many remaining unvisited nodes. The score calculation favors nodes that minimize distance and detour while maximizing exploration potential.",
          "thought": "The new algorithm combines the detour penalty mechanism from No.1 (with a 0.5 weight) and the exploration bonus from No.2 (with a 0.3 weight), while prioritizing immediate distance and balancing detour penalties and exploration bonuses to find a more optimal path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_node + distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n\n            exploration_bonus = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    exploration_bonus += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                exploration_bonus /= (remaining_nodes - 1)\n\n            score = distance_to_node + 0.5 * detour_penalty - 0.3 * exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.38049,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing detour minimization (with a threshold that adapts during the tour) and exploration (using node centrality to prioritize highly connected nodes), while penalizing excessive detours and rewarding early-stage exploration. It prioritizes minimizing detour penalties and exploration bonuses, with lower weights on progress factors, and dynamically adjusts the exploration weight based on tour progress. The score combines distance, detour penalty, centrality bonus, and progress factor, favoring nodes that reduce detours and encourage exploration early.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic detour threshold that adapts based on the tour's progress, using a heuristic that balances detour minimization with exploration by integrating a novel \"node centrality\" metric to prioritize nodes with high connectivity, while still penalizing excessive detours and rewarding early-stage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = -distance_to_node - distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / (distance_to_node + distance_to_destination)\n            detour_threshold = 1.0 + 0.5 * (1.0 - (total_nodes - remaining_nodes) / total_nodes)\n            detour_penalty = max(0, (1.0 - detour_ratio) * direct_distance - (detour_threshold * direct_distance))\n\n            node_centrality = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    node_centrality += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                node_centrality /= (remaining_nodes - 1)\n\n            exploration_bonus = node_centrality * (1.0 - (total_nodes - remaining_nodes) / total_nodes)\n            progress_factor = (total_nodes - remaining_nodes) / total_nodes\n            exploration_weight = 0.4 + 0.3 * (1 - progress_factor)\n\n            score = -distance_to_node - 0.6 * detour_penalty + exploration_weight * exploration_bonus - 0.3 * progress_factor\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40491,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance while heavily penalizing detours (60% weight) and slightly discouraging exploration (20% weight), favoring nodes that reduce the detour penalty while still considering some exploration bonuses. The `score` calculation balances direct distance, detour penalties, and exploration bonuses, with the detour penalty dominating the decision-making process. The algorithm ensures the path remains efficient by focusing on minimizing detours while allowing limited exploration to avoid getting stuck in local optima.",
          "thought": "The new algorithm prioritizes minimizing immediate distance with a stronger focus on detour penalties (60% weight) and slightly reduces exploration bonuses (20% weight), favoring nodes that reduce detours while still encouraging some exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_node + distance_to_destination\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n\n            exploration_bonus = 0.0\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    exploration_bonus += distance_matrix[node][other_node]\n            if remaining_nodes > 1:\n                exploration_bonus /= (remaining_nodes - 1)\n\n            score = distance_to_node + 0.6 * detour_penalty - 0.2 * exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47476,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing detour penalties by balancing the immediate distance to the next node with the ratio of that node's distance to the destination versus the direct distance from the current node to the destination. It assigns higher priority to nodes that reduce detours (penalizing nodes where the path to the destination is significantly longer than the direct route) while still considering immediate distance, with a small weight (0.5) on the penalty term. The code iterates through unvisited nodes, computes a score combining distance and detour penalty, and selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes minimizing the detour penalty by emphasizing the ratio of the candidate node's distance to the destination versus the direct distance, with a stronger penalty for detours, and balances this with a smaller weight on immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.5 * (normalization_factor - 1) * distance_to_destination\n            score = penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance and detour impact while balancing exploration early on. It assigns higher priority to nodes that reduce distance and detour penalty (via `penalty`) but balances this with an `exploration_bonus` that decreases as more nodes are visited. The `score` is a weighted combination of these factors, favoring shorter paths with controlled detours while encouraging early exploration.",
          "thought": "The new algorithm combines the detour penalty from No.1 with the exploration bonus from No.2, prioritizing nodes that minimize immediate distance, detour impact, and encourage exploration early on.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / distance_to_destination\n            penalty = distance_to_node + 0.5 * (detour_ratio - 1) * direct_distance\n            exploration_bonus = 1.0 / (1.0 + remaining_nodes)\n            score = penalty - exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.57696,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity to the current node with a detour penalty, weighted by the remaining unvisited nodes. It prioritizes minimizing immediate distance while penalizing nodes that increase the detour to the destination, with the weighting dynamically adjusted based on the number of remaining nodes. The score balances these factors, favoring closer nodes early but considering long-term efficiency as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weighting of No.2 with the detour penalty from No.1, using a weight based on remaining nodes to balance proximity and long-term efficiency while penalizing nodes that increase detour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.5 * (normalization_factor - 1) * distance_to_destination\n            score = weight * penalty + (1 - weight) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60308,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, detour penalties, and exploration-exploitation trade-offs. It prioritizes nodes minimizing direct distance while penalizing detours (with a weight of 0.4) and adjusts exploration based on remaining unvisited nodes (using a squared weight). The exploration bonus decreases with distance and increases with fewer remaining nodes. The score combines these factors, favoring nodes that minimize immediate travel while adaptively adjusting for detours and exploration.",
          "thought": "The new algorithm combines the detour penalty from No.1 with the dynamic exploration-exploitation balance from No.2, using a weighted score that prioritizes nodes minimizing immediate distance while penalizing detours and adjusting for remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            exploration_weight = (remaining_nodes / total_nodes) ** 2\n            exploration_bonus = exploration_weight * (1.0 / (1.0 + distance_to_node))\n\n            detour_penalty = (direct_distance / distance_to_destination - 1) * distance_to_destination\n            score = distance_to_node + 0.4 * detour_penalty - exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61322,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing detour penalties (60% weight), exploration bonuses (30% weight), and direct distance (10% weight), prioritizing nodes that minimize detours while encouraging exploration of unvisited nodes. The detour penalty penalizes nodes that increase the path length significantly, while the exploration bonus rewards nodes that reduce the number of remaining unvisited nodes. The direct distance ensures the immediate step is as short as possible.",
          "thought": "The new algorithm combines the detour penalty and exploration bonus from No.1 with the weighted local-global balance from No.2, selecting the next node by minimizing a score that includes immediate distance, detour impact, and exploration incentive, while weighting these factors (e.g., 0.6 for detour penalty, 0.3 for exploration bonus, and 0.1 for direct distance).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / distance_to_destination\n            detour_penalty = 0.6 * (distance_to_node + 0.5 * (detour_ratio - 1) * direct_distance)\n            exploration_bonus = 0.3 * (1.0 / (1.0 + remaining_nodes))\n            direct_weight = 0.1 * distance_to_node\n            score = detour_penalty - exploration_bonus + direct_weight\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64756,
          "other_inf": null
     }
]