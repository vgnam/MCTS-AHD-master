import math
    import random

    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    temperature = 1.0 / (remaining_nodes + 1)  # Decreasing temperature over time

    attractiveness_scores = []
    total_attractiveness = 0.0

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        if distance_to_destination == 0:
            attractiveness = math.exp(-distance_to_node / temperature)
        else:
            direct_distance = distance_matrix[current_node][destination_node]
            detour_ratio = direct_distance / distance_to_destination
            centrality_penalty = sum(distance_matrix[node]) / len(distance_matrix[node])
            dynamic_penalty = (1 - detour_ratio) ** 2 * centrality_penalty * (remaining_nodes / (remaining_nodes + 1))
            attractiveness = math.exp(-(distance_to_node + dynamic_penalty) / temperature)

        attractiveness_scores.append((node, attractiveness))
        total_attractiveness += attractiveness

    if total_attractiveness == 0:
        return random.choice(unvisited_nodes)

    # Select node probabilistically based on attractiveness
    rand_val = random.uniform(0, total_attractiveness)
    cumulative = 0.0
    for node, score in attractiveness_scores:
        cumulative += score
        if rand_val <= cumulative:
            return node

    return next_node
