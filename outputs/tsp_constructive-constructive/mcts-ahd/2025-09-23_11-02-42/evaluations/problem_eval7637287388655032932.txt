importance metric that combines distance, detour penalties, exploration bonuses, and node centrality, but with adaptive weights that prioritize exploration early and optimize detour penalties as the number of remaining nodes decreases, while also introducing a novel "node influence" term to favor nodes that are critical for connecting distant clusters of unvisited nodes.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('inf')
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        if remaining_nodes == 1:
            score = distance_to_node + distance_to_destination
        else:
            direct_distance = distance_matrix[current_node][destination_node]
            detour_ratio = direct_distance / (distance_to_node + distance_to_destination)
            detour_penalty = (1.0 - detour_ratio) * direct_distance

            exploration_bonus = sum(distance_matrix[node][other_node] for other_node in unvisited_nodes if other_node != node)
            exploration_bonus /= (remaining_nodes - 1) if remaining_nodes > 1 else 1

            node_centrality = sum(distance_matrix[node][other_node] for other_node in unvisited_nodes) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

            node_influence = 0
            for other_node in unvisited_nodes:
                if other_node != node:
                    min_distance = min(distance_matrix[node][other_node], distance_matrix[node][current_node] + distance_matrix[current_node][other_node])
                    node_influence += (distance_matrix[node][other_node] - min_distance)

            dynamic_exploration_weight = 0.5 if remaining_nodes > 5 else 0.2
            dynamic_detour_weight = 0.3 if remaining_nodes > 3 else 0.5

            score = (distance_to_node + dynamic_detour_weight * detour_penalty) - dynamic_exploration_weight * exploration_bonus + 0.2 * node_centrality + 0.1 * node_influence

        if score < best_score:
            best_score = score
            next_node = node

    return next_node
