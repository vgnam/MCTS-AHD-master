def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)

    if remaining_nodes == 0:
        return destination_node

    # Calculate centroid of unvisited nodes for distribution awareness
    centroid_x, centroid_y = 0, 0
    for node in unvisited_nodes:
        centroid_x += node[0]
        centroid_y += node[1]
    centroid_x /= remaining_nodes
    centroid_y /= remaining_nodes

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Dynamic weights based on node distribution
        weight_short_term = 0.5 + 0.4 * (remaining_nodes / len(distance_matrix))
        weight_long_term = 1.0 - weight_short_term

        # Proximity-based penalty
        penalty = 0.2 * (1.0 - (distance_matrix[current_node][node] / max(distance_matrix[current_node])))

        # Heuristic lookahead: average distance to nearby nodes
        lookahead = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

        # Normalized Euclidean distance to centroid
        dist_to_centroid = ((node[0] - centroid_x)**2 + (node[1] - centroid_y)**2)**0.5
        centroid_factor = 0.1 * (1.0 - (dist_to_centroid / max((((x - centroid_x)**2 + (y - centroid_y)**2)**0.5 for x, y in unvisited_nodes), default=1)))

        # Combined score
        score = (weight_short_term * distance_to_node +
                 weight_long_term * distance_to_destination +
                 penalty * lookahead +
                 centroid_factor)

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
