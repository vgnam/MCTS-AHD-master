def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_value = float('inf')
    candidates = []

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Dynamic weight with penalty factor
        remaining_nodes = len(unvisited_nodes)
        penalty = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 1.0
        weight = 0.5 + 0.5 * penalty  # Favor proximity as nodes decrease

        value = weight * distance_to_node + (1 - weight) * distance_to_destination
        candidates.append((node, value))

    # Select top 3 candidates and pick one probabilistically
    candidates.sort(key=lambda x: x[1])
    top_candidates = candidates[:min(3, len(candidates))]

    if top_candidates:
        # Probabilistic selection: closer candidates have higher chance
        total_weight = sum(1 / (val + 1) for _, val in top_candidates)
        rand_val = random.random() * total_weight
        cumulative = 0

        for node, val in top_candidates:
            cumulative += 1 / (val + 1)
            if rand_val <= cumulative:
                next_node = node
                break

    return next_node
