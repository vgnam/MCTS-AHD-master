def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)

    # Dynamic weights: Shift from exploration to exploitation
    weight_immediate = 0.6 if remaining_nodes > total_nodes // 2 else 0.4
    weight_lookahead = 0.4 if remaining_nodes > total_nodes // 2 else 0.6

    # Precompute normalized distances for immediate selection
    immediate_scores = {}
    for node in unvisited_nodes:
        immediate_scores[node] = 1 / (distance_matrix[current_node][node] + 1e-6)

    # Novel lookahead: Evaluate potential sub-path efficiency
    lookahead_scores = {}
    for node in unvisited_nodes:
        lookahead_score = 0
        if remaining_nodes > 1:
            for neighbor in unvisited_nodes:
                if neighbor != node:
                    # Evaluate the gain of including this node in a sub-path
                    direct = distance_matrix[current_node][neighbor] + distance_matrix[neighbor][destination_node]
                    via_node = distance_matrix[current_node][node] + distance_matrix[node][neighbor] + distance_matrix[neighbor][destination_node]
                    lookahead_score += (direct - via_node) / (direct + 1e-6)
        lookahead_scores[node] = lookahead_score

    # Combine scores with adaptive weights
    node_scores = {}
    for node in unvisited_nodes:
        node_scores[node] = (weight_immediate * immediate_scores[node] +
                            weight_lookahead * lookahead_scores[node])

    # Probabilistic selection: Higher scores have higher chance of being selected
    if node_scores:
        max_score = max(node_scores.values())
        normalized_scores = {node: (score / max_score) for node, score in node_scores.items()}
        total_prob = sum(normalized_scores.values())
        rand_val = random.random() * total_prob
        cumulative_prob = 0.0

        for node, prob in normalized_scores.items():
            cumulative_prob += prob
            if rand_val <= cumulative_prob:
                next_node = node
                break

    return next_node
