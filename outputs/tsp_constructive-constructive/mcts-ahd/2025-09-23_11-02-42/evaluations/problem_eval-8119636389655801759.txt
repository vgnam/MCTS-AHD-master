def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    remaining_nodes = len(unvisited_nodes)
    temperature = max(1, 10 / (remaining_nodes + 1))
    next_node = None
    scores = []

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        if distance_to_destination == 0:
            score = distance_to_node
        else:
            direct_distance = distance_matrix[current_node][destination_node]
            detour_ratio = direct_distance / distance_to_destination
            global_detour_factor = (sum(distance_matrix[node]) / len(distance_matrix[node])) * (1 - detour_ratio)
            dynamic_weight = temperature * (remaining_nodes / (remaining_nodes + 1))
            score = distance_to_node + dynamic_weight * global_detour_factor

        scores.append((node, score))

    if temperature > 1:
        probabilities = [1 / (s + 1e-10) for _, s in scores]
        total = sum(probabilities)
        probabilities = [p / total for p in probabilities]
        next_node = random.choices([n for n, _ in scores], weights=probabilities, k=1)[0]
    else:
        next_node = min(scores, key=lambda x: x[1])[0]

    return next_node
