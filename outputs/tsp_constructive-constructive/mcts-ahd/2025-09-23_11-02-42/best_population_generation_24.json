{
     "algorithm": "The algorithm selects the next node by prioritizing immediate proximity while dynamically adjusting the score based on the ratio of the candidate node's distance to the destination versus the direct distance, with a penalty applied when the candidate node detours from the optimal path. The score balances the immediate distance (`distance_to_node`) and a detour penalty (`0.1 * (normalization_factor - 1) * distance_to_destination`), where higher penalties discourage unnecessary detours. The loop iterates through unvisited nodes, updating the best candidate based on the lowest computed score.",
     "thought": "The new algorithm combines the prioritization of immediate proximity from No.2 with a dynamic penalty mechanism from No.1, adjusting the score based on the ratio of the direct distance to the destination versus the path via the candidate node, while balancing the immediate distance and the detour penalty.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.1 * (normalization_factor - 1) * distance_to_destination\n            score = penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.85988,
     "other_inf": null
}