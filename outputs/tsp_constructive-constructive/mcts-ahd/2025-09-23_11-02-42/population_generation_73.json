[
     {
          "algorithm": "The algorithm prioritizes minimizing detour penalties by balancing the immediate distance to the next node with the ratio of that node's distance to the destination versus the direct distance from the current node to the destination. It assigns higher priority to nodes that reduce detours (penalizing nodes where the path to the destination is significantly longer than the direct route) while still considering immediate distance, with a small weight (0.5) on the penalty term. The code iterates through unvisited nodes, computes a score combining distance and detour penalty, and selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes minimizing the detour penalty by emphasizing the ratio of the candidate node's distance to the destination versus the direct distance, with a stronger penalty for detours, and balances this with a smaller weight on immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.5 * (normalization_factor - 1) * distance_to_destination\n            score = penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance and detour impact while balancing exploration early on. It assigns higher priority to nodes that reduce distance and detour penalty (via `penalty`) but balances this with an `exploration_bonus` that decreases as more nodes are visited. The `score` is a weighted combination of these factors, favoring shorter paths with controlled detours while encouraging early exploration.",
          "thought": "The new algorithm combines the detour penalty from No.1 with the exploration bonus from No.2, prioritizing nodes that minimize immediate distance, detour impact, and encourage exploration early on.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            direct_distance = distance_matrix[current_node][destination_node]\n            detour_ratio = direct_distance / distance_to_destination\n            penalty = distance_to_node + 0.5 * (detour_ratio - 1) * direct_distance\n            exploration_bonus = 1.0 / (1.0 + remaining_nodes)\n            score = penalty - exploration_bonus\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.57696,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing immediate distance (via `ratio`) and long-term detours (via `detour_penalty`), while also adjusting for efficiency through a `penalty` term. The weighted sum (`score = ratio + 0.2 * penalty + 0.3 * detour_penalty`) ensures that closer nodes with minimal detours are selected, with `detour_penalty` (30%) and `penalty` (20%) given higher weights than the raw distance ratio (50%). The `normalization_factor` scales the penalty based on distance to the destination, further refining the selection.",
          "thought": "The new algorithm combines the dynamic detour penalty from No.1 with the proximity and efficiency balance from No.2, using a weighted sum of the ratio of distances and a scaled detour penalty to prioritize nodes that minimize both immediate distance and long-term detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour_penalty = (distance_to_node + distance_to_destination - direct_distance) / (1.0 + direct_distance)\n\n        normalization_factor = direct_distance / distance_to_destination if distance_to_destination != 0 else 1.0\n        penalty = distance_to_node + 0.4 * (normalization_factor - 1) * distance_to_destination\n        score = ratio + 0.2 * penalty + 0.3 * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65384,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing the ratio of the distance to the candidate node and its distance to the destination, while dynamically penalizing detours (excess distance beyond a direct path). Nodes with smaller detours (\u226410% of direct distance) receive a higher penalty weight (0.5), while others use a lower weight (0.2). The score combines the ratio and weighted detour penalty to prioritize nodes that minimize both travel distance and detours, favoring closer or more direct paths.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for the detour penalty based on the node's position in the path, favoring nodes that either reduce the detour or extend the path in a controlled manner, while still balancing proximity and efficiency through a normalized ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour = distance_to_node + distance_to_destination - direct_distance\n        detour_penalty = detour / (1.0 + direct_distance)\n\n        # Dynamic weight for detour penalty based on node's position\n        dynamic_weight = 0.5 if detour <= direct_distance * 0.1 else 0.2\n\n        score = ratio + dynamic_weight * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.66924,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity and long-term efficiency by scoring each unvisited node based on a normalized distance ratio (prioritized early) and a dynamic detour penalty (prioritized later). The progress factor adjusts weights between these components, favoring the ratio early (when many nodes remain) and the penalty later (as fewer nodes remain). The score is computed as a weighted sum of these factors, with the node having the lowest score selected next.",
          "thought": "The new algorithm prioritizes both immediate proximity and long-term path efficiency by combining a normalized distance ratio with a dynamic detour penalty that adapts to the current path's progress, ensuring a balance between exploration and exploitation through a weighted scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour_penalty = (distance_to_node + distance_to_destination - direct_distance) ** 2 / (1.0 + direct_distance)\n\n        progress_factor = 1.0 - (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        score = (1.0 - progress_factor) * ratio + progress_factor * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68204,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing proximity to the current node and long-term efficiency (ratio of `distance_to_node` to `distance_to_destination`), while penalizing unnecessary detours (`detour_penalty`). The score is a weighted sum (ratio + 0.3 * detour_penalty), where proximity and efficiency are prioritized more than detour penalties. The node with the lowest score is chosen, ensuring a trade-off between immediate and long-term path optimality.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 (balancing proximity and long-term efficiency) with the score-based trade-off from No.2 (incorporating detour penalties and exploration bonuses). It calculates a score for each candidate node as a weighted sum of the ratio (distance_to_node / distance_to_destination) and a detour penalty, then selects the node with the lowest score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour_penalty = (distance_to_node + distance_to_destination - direct_distance) / (1.0 + direct_distance)\n\n        score = ratio + 0.3 * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69529,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance to the node with an adaptive penalty that favors nodes closer to the destination, while adding a stochastic exploration term controlled by temperature. The score prioritizes minimizing direct distance but adjusts dynamically based on relative proximity to the destination, with lower priority given to nodes that deviate significantly from the optimal path. The temperature parameter introduces probabilistic exploration, allowing the algorithm to escape local optima.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic penalty that adapts to the node's potential to reduce the remaining path length, using a heuristic that balances immediate distance with future path optimization, while also introducing a stochastic component to explore alternative paths probabilistically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    temperature = 0.5  # Controls exploration vs. exploitation\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            adaptive_penalty = 0.2 * (normalization_factor - 1) * distance_to_destination\n            exploration_term = temperature * (distance_to_node * (1 / (distance_to_destination + 1e-5)))\n            score = distance_to_node + adaptive_penalty + exploration_term\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.70356,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing shorter distances to the current node while considering detour impact and exploration, where the detour ratio (direct distance / distance to destination) is weighted lower (0.3) than an exploration factor (0.7), with the score balancing direct distance and these factors. The function iterates through unvisited nodes, computes a score for each, and selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes with shorter distances to the current node and higher potential for reducing the total path length, using a different scoring mechanism that emphasizes direct distance and detour impact with a fixed exploration factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        direct_distance = distance_matrix[current_node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            detour_ratio = direct_distance / distance_to_destination\n            exploration_factor = 0.5\n            score = distance_to_node + (detour_ratio * 0.3 + exploration_factor * 0.7) * direct_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.72493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance reduction (60% weight) while applying a stronger detour penalty (40% weight), balancing optimization of the current step with long-term path efficiency. It calculates a ratio of the current step's distance to the distance from the candidate node to the destination, then penalizes detours more aggressively by comparing the sum of step distances to the direct path. The weights (0.6 and 0.4) reflect a preference for maintaining near-optimal immediate steps while minimizing unnecessary deviations.",
          "thought": "The new algorithm prioritizes immediate distance reduction while incorporating a stronger detour penalty and a more balanced weight between ratio and penalty terms, aiming for a more aggressive path optimization with reduced unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = distance_to_node\n        else:\n            ratio = distance_to_node / distance_to_destination\n\n        direct_distance = distance_matrix[current_node][destination_node]\n        detour_penalty = (distance_to_node + distance_to_destination - direct_distance) / (1.0 + direct_distance)\n\n        score = 0.6 * ratio + 0.4 * detour_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.842,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate proximity while dynamically adjusting the score based on the ratio of the candidate node's distance to the destination versus the direct distance, with a penalty applied when the candidate node detours from the optimal path. The score balances the immediate distance (`distance_to_node`) and a detour penalty (`0.1 * (normalization_factor - 1) * distance_to_destination`), where higher penalties discourage unnecessary detours. The loop iterates through unvisited nodes, updating the best candidate based on the lowest computed score.",
          "thought": "The new algorithm combines the prioritization of immediate proximity from No.2 with a dynamic penalty mechanism from No.1, adjusting the score based on the ratio of the direct distance to the destination versus the path via the candidate node, while balancing the immediate distance and the detour penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = distance_to_node\n        else:\n            normalization_factor = distance_matrix[current_node][destination_node] / distance_to_destination\n            penalty = distance_to_node + 0.1 * (normalization_factor - 1) * distance_to_destination\n            score = penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85988,
          "other_inf": null
     }
]