{
     "algorithm": "The algorithm prioritizes long-term optimization by using an average remaining distance as a key factor, while dynamically penalizing immediate distance squared to balance short-term efficiency. It adjusts weights based on remaining nodes and includes a lower-weighted immediate cost term to ensure the solution remains feasible. The score calculation balances these factors, favoring nodes that minimize future costs while accounting for immediate distance penalties.",
     "thought": "The new algorithm combines the savings-based approach of No.1 with the weighted balance of No.2 and the dynamic penalty of No.3, using a non-linear penalty term scaled by the square of immediate distance and the remaining node count, while also incorporating a lower-weighted immediate cost factor to balance short-term and long-term optimization.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_factor = 1.0 - (remaining_count / (remaining_count + len(unvisited_nodes)))\n        penalty_term = (distance_to_node ** 2) * weight_factor\n        score = (avg_remaining_distance - distance_to_node) - penalty_term - 0.2 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.37524,
     "other_inf": null
}