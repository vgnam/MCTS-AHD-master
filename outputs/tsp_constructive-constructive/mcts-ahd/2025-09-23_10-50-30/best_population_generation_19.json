{
     "algorithm": "The algorithm selects the next node by balancing immediate travel cost and long-term savings, prioritizing nodes that reduce future travel while penalizing high immediate distances. It scores each candidate node using a weighted combination of the average remaining distance (after visiting the node) and the direct travel cost, with the latter given a lower weight (0.3). The node with the highest score is chosen, ensuring a trade-off between short-term efficiency and long-term path optimization.",
     "thought": "The new algorithm combines the proximity-based selection from No.1 with the savings-oriented approach of No.2, prioritizing nodes that offer high savings while also considering immediate travel cost, creating a balanced heuristic that optimizes both short-term and long-term path efficiency.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        score = (avg_remaining_distance - distance_to_node) - 0.3 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.41645,
     "other_inf": null
}