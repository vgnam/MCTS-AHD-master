[
     {
          "algorithm": "The algorithm prioritizes long-term optimization by using an average remaining distance as a key factor, while dynamically penalizing immediate distance squared to balance short-term efficiency. It adjusts weights based on remaining nodes and includes a lower-weighted immediate cost term to ensure the solution remains feasible. The score calculation balances these factors, favoring nodes that minimize future costs while accounting for immediate distance penalties.",
          "thought": "The new algorithm combines the savings-based approach of No.1 with the weighted balance of No.2 and the dynamic penalty of No.3, using a non-linear penalty term scaled by the square of immediate distance and the remaining node count, while also incorporating a lower-weighted immediate cost factor to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_factor = 1.0 - (remaining_count / (remaining_count + len(unvisited_nodes)))\n        penalty_term = (distance_to_node ** 2) * weight_factor\n        score = (avg_remaining_distance - distance_to_node) - penalty_term - 0.2 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.37524,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances short-term (current distance) and long-term (average remaining distances) costs, penalizing higher immediate costs more heavily when few nodes remain and prioritizing long-term savings when more nodes are left. The scoring function uses a non-linear penalty term based on the proportion of unvisited nodes, where the penalty for immediate distance is squared and weighted by the remaining node count. The algorithm prioritizes nodes that minimize the difference between long-term savings and penalized immediate costs, adapting decisions based on the remaining problem scale.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances short-term and long-term costs, where higher immediate costs are penalized more heavily when fewer nodes remain, while long-term savings are prioritized when more nodes are left. The scoring function incorporates a non-linear penalty term based on the proportion of unvisited nodes to ensure adaptive decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_factor = 1.0 - (remaining_count / (remaining_count + len(unvisited_nodes)))\n        penalty_term = (distance_to_node ** 2) * weight_factor\n        score = (avg_remaining_distance - distance_to_node) - penalty_term\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41068,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate travel cost and long-term savings, prioritizing nodes that reduce future travel while penalizing high immediate distances. It scores each candidate node using a weighted combination of the average remaining distance (after visiting the node) and the direct travel cost, with the latter given a lower weight (0.3). The node with the highest score is chosen, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the proximity-based selection from No.1 with the savings-oriented approach of No.2, prioritizing nodes that offer high savings while also considering immediate travel cost, creating a balanced heuristic that optimizes both short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        score = (avg_remaining_distance - distance_to_node) - 0.3 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41645,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate cost (short-term distance) with long-term reduction in maximum remaining distances and average savings, while penalizing long detours relative to average distances. It prioritizes nodes that maximize reduction and savings (long-term benefits) while minimizing immediate cost and distance penalties (short-term costs), with dynamic weights adjusting based on remaining unvisited nodes. The score combines these factors with adaptive weighting, favoring nodes that reduce future maximum detours and improve average path efficiency.",
          "thought": "The new algorithm combines the dynamic weight for immediate cost and distance penalty from No.1 with the adaptive weighting of reduction and savings from No.2, selecting nodes that maximize long-term reduction while balancing immediate cost and avoiding long detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    remaining_nodes = unvisited_nodes - {current_node}\n    if remaining_nodes:\n        total_avg_distance = sum(distance_matrix[n1][n2] for n1 in remaining_nodes for n2 in remaining_nodes if n1 != n2)\n        avg_distance = total_avg_distance / (len(remaining_nodes) * (len(remaining_nodes) - 1)) if len(remaining_nodes) > 1 else 0\n    else:\n        avg_distance = 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if not remaining_nodes:\n            max_remaining_distance = 0\n            avg_remaining_distance = 0\n        else:\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = total_remaining_distance / len(remaining_nodes)\n\n        reduction = max_remaining_distance - distance_to_node\n        savings = avg_remaining_distance - distance_to_node\n        weight = len(remaining_nodes) / (len(unvisited_nodes) + 1) if unvisited_nodes else 0\n\n        immediate_weight = 0.3 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        distance_penalty = max(0, (distance_to_node - avg_distance) / (avg_distance + 1e-6)) if avg_distance > 0 else 0\n\n        score = (1 - weight) * reduction + weight * savings - immediate_weight * distance_to_node - distance_penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.42568,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance savings with long-term potential by dynamically adjusting a penalty term based on the square of the remaining nodes, favoring shorter-term savings when few nodes remain and long-term potential when many are left. The score is computed as the difference between the average remaining distance and the immediate distance, adjusted by a penalty term that scales with the distance squared and a weight factor inversely proportional to the remaining nodes. This ensures the algorithm adapts aggressively to problem scale, favoring closer nodes when progress is near completion and more strategic choices when many nodes remain.",
          "thought": "The new algorithm prioritizes nodes that balance immediate distance savings with long-term potential by using a linear penalty term that grows with the square of the remaining node count, creating a more aggressive adaptation to problem scale, favoring immediate savings when few nodes remain and long-term potential when many are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Aggressive dynamic weight adjustment based on remaining nodes\n        weight_factor = (1.0 - (remaining_count / (remaining_count + len(unvisited_nodes)))) ** 2\n        penalty_term = (distance_to_node ** 2) * weight_factor\n        score = (avg_remaining_distance - distance_to_node) - penalty_term\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.42773,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance savings over worst-case optimization by dynamically weighting savings (average remaining distance minus current distance) and reduction (maximum remaining distance minus current distance), with higher weight given to savings as unvisited nodes decrease. It selects the next node by balancing these two metrics, favoring savings when few nodes remain, while the original approach balances worst-case reduction and average savings with a fixed weight. The score calculation dynamically adjusts based on the number of remaining nodes, ensuring adaptability to the problem's evolving state.",
          "thought": "The new algorithm prioritizes immediate distance savings over worst-case optimization, using a dynamic weight that emphasizes savings as the number of unvisited nodes decreases, while the original algorithm balances worst-case reduction and average savings with a weight favoring reduction when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if not remaining_nodes:\n            max_remaining_distance = 0\n            avg_remaining_distance = 0\n        else:\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = total_remaining_distance / len(remaining_nodes)\n\n        reduction = max_remaining_distance - distance_to_node\n        savings = avg_remaining_distance - distance_to_node\n        weight = (len(unvisited_nodes) + 1) / (len(remaining_nodes) + 1) if remaining_nodes else 1\n\n        score = weight * savings + (1 - weight) * reduction\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.4442,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that maximize weighted savings (difference between average remaining distances and immediate distance) while penalizing high immediate costs, with the weight dynamically adjusted based on the number of remaining nodes. It balances short-term efficiency (immediate distance) and long-term savings (remaining distances) by scaling the immediate cost penalty with a weight inversely proportional to the number of remaining nodes. The scoring function (`score = savings - weight * distance_to_node`) ensures nodes with high savings but manageable immediate costs are favored.",
          "thought": "The new algorithm combines the savings-based selection from No.1 with the weighted scoring approach from No.2, introducing a dynamic weight for the immediate distance based on the remaining nodes' count to balance short-term and long-term efficiency, and prioritizes nodes that maximize the weighted savings while penalizing high immediate costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n        weight = 0.5 / (len(remaining_nodes) + 1)\n        score = savings - weight * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45716,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that offer the highest savings in average remaining distance after accounting for the immediate travel cost, balancing proximity with potential future path efficiency. It evaluates each unvisited node's contribution to savings (avg_remaining_distance - distance_to_node) and chooses the one with maximum savings, ensuring a greedy yet strategic approach to path optimization. The critical design prioritizes savings over direct distance, with the savings calculation being the core heuristic.",
          "thought": "This algorithm selects the next node by prioritizing those with the highest immediate distance reduction relative to the remaining path's average distance, ensuring a balance between proximity and potential future savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_savings = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n\n        if savings > max_savings:\n            max_savings = savings\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two criteria\u2014maximizing remaining distance reduction (prioritizing worst-case optimization) and balancing immediate travel cost with average remaining distance savings (inspired by savings-based approaches)\u2014dynamically weighted by the remaining path length. It selects the next node by scoring each candidate based on a weighted combination of these criteria, where the weight adjusts adaptively based on the number of unvisited nodes. The score prioritizes reduction over savings when fewer nodes remain, while balancing both when more nodes are left.",
          "thought": "The new algorithm combines the worst-case optimization from No.1 (prioritizing maximum remaining distance reduction) with the savings-based approach from No.2 (balancing immediate travel cost and average remaining distance savings), while adding a dynamic weighting factor to adaptively balance these criteria based on the remaining path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if not remaining_nodes:\n            max_remaining_distance = 0\n            avg_remaining_distance = 0\n        else:\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = total_remaining_distance / len(remaining_nodes)\n\n        reduction = max_remaining_distance - distance_to_node\n        savings = avg_remaining_distance - distance_to_node\n        weight = len(remaining_nodes) / (len(unvisited_nodes) + 1) if unvisited_nodes else 0\n\n        score = (1 - weight) * reduction + weight * savings\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48034,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP tour by balancing two competing objectives: maximizing the reduction in the worst-case remaining distance (prioritized with weight `alpha`) and minimizing the immediate travel distance (prioritized with weight `1-alpha`). It evaluates each unvisited node by computing a composite score that combines these factors, then chooses the node with the highest score. The parameter `alpha` controls the trade-off between these objectives, with higher values favoring worst-case optimization.",
          "thought": "The new algorithm modifies the original approach by incorporating a weighted combination of the maximum remaining distance reduction and the direct distance to the candidate node, using a tunable parameter to balance between worst-case optimization and immediate distance efficiency. It selects the next node based on a composite score that prioritizes nodes which not only reduce the worst-case path but also minimize immediate travel distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n    alpha = 0.7  # Weight for reduction, 1-alpha for distance\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        reduction = max_remaining_distance - distance_to_node\n        composite_score = alpha * reduction - (1 - alpha) * distance_to_node\n\n        if composite_score > best_score:\n            best_score = composite_score\n            next_node = node\n\n    return next_node",
          "objective": 6.5023,
          "other_inf": null
     }
]