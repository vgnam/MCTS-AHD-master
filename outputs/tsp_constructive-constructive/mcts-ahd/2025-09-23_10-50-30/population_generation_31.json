[
     {
          "algorithm": "The algorithm dynamically balances short-term (current distance) and long-term (average remaining distances) costs, penalizing higher immediate costs more heavily when few nodes remain and prioritizing long-term savings when more nodes are left. The scoring function uses a non-linear penalty term based on the proportion of unvisited nodes, where the penalty for immediate distance is squared and weighted by the remaining node count. The algorithm prioritizes nodes that minimize the difference between long-term savings and penalized immediate costs, adapting decisions based on the remaining problem scale.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances short-term and long-term costs, where higher immediate costs are penalized more heavily when fewer nodes remain, while long-term savings are prioritized when more nodes are left. The scoring function incorporates a non-linear penalty term based on the proportion of unvisited nodes to ensure adaptive decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_factor = 1.0 - (remaining_count / (remaining_count + len(unvisited_nodes)))\n        penalty_term = (distance_to_node ** 2) * weight_factor\n        score = (avg_remaining_distance - distance_to_node) - penalty_term\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41068,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate travel cost and long-term savings, prioritizing nodes that reduce future travel while penalizing high immediate distances. It scores each candidate node using a weighted combination of the average remaining distance (after visiting the node) and the direct travel cost, with the latter given a lower weight (0.3). The node with the highest score is chosen, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the proximity-based selection from No.1 with the savings-oriented approach of No.2, prioritizing nodes that offer high savings while also considering immediate travel cost, creating a balanced heuristic that optimizes both short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        score = (avg_remaining_distance - distance_to_node) - 0.3 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41645,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that maximize weighted savings (difference between average remaining distances and immediate distance) while penalizing high immediate costs, with the weight dynamically adjusted based on the number of remaining nodes. It balances short-term efficiency (immediate distance) and long-term savings (remaining distances) by scaling the immediate cost penalty with a weight inversely proportional to the number of remaining nodes. The scoring function (`score = savings - weight * distance_to_node`) ensures nodes with high savings but manageable immediate costs are favored.",
          "thought": "The new algorithm combines the savings-based selection from No.1 with the weighted scoring approach from No.2, introducing a dynamic weight for the immediate distance based on the remaining nodes' count to balance short-term and long-term efficiency, and prioritizes nodes that maximize the weighted savings while penalizing high immediate costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n        weight = 0.5 / (len(remaining_nodes) + 1)\n        score = savings - weight * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45716,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that offer the highest savings in average remaining distance after accounting for the immediate travel cost, balancing proximity with potential future path efficiency. It evaluates each unvisited node's contribution to savings (avg_remaining_distance - distance_to_node) and chooses the one with maximum savings, ensuring a greedy yet strategic approach to path optimization. The critical design prioritizes savings over direct distance, with the savings calculation being the core heuristic.",
          "thought": "This algorithm selects the next node by prioritizing those with the highest immediate distance reduction relative to the remaining path's average distance, ensuring a balance between proximity and potential future savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_savings = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n\n        if savings > max_savings:\n            max_savings = savings\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances short-term efficiency and long-term savings by assigning a higher weight to immediate travel cost when many nodes remain (promoting exploration) and a penalty for distant nodes relative to the average remaining distance (avoiding detours). The score combines the savings from reducing the distance to the destination, the weighted immediate cost, and the distance penalty, prioritizing nodes that maximize savings while avoiding long detours. The dynamic weight (`immediate_weight`) and penalty (`distance_penalty`) adapt to the remaining nodes, making the selection more flexible and efficient.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight for the immediate travel cost, where the weight is inversely proportional to the number of remaining unvisited nodes, promoting short-term efficiency when few nodes remain. It also introduces a penalty for nodes that are distant from the current node relative to the average distance in the remaining graph, fostering more balanced path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    # Calculate average distance in the remaining graph\n    remaining_nodes = unvisited_nodes - {current_node}\n    if remaining_nodes:\n        total_avg_distance = sum(distance_matrix[n1][n2] for n1 in remaining_nodes for n2 in remaining_nodes if n1 != n2)\n        avg_distance = total_avg_distance / (len(remaining_nodes) * (len(remaining_nodes) - 1)) if len(remaining_nodes) > 1 else 0\n    else:\n        avg_distance = 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_after_visit = unvisited_nodes - {node}\n\n        # Dynamic weight for immediate cost (higher when more nodes remain)\n        immediate_weight = 0.3 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n\n        # Penalty for nodes distant from current node relative to average distance\n        distance_penalty = max(0, (distance_to_node - avg_distance) / (avg_distance + 1e-6)) if avg_distance > 0 else 0\n\n        # Score combines immediate cost and long-term savings with dynamic weight\n        score = (distance_matrix[node][destination_node] - distance_to_node) - immediate_weight * distance_to_node - distance_penalty\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62991,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes by selecting the next node that reduces the longest remaining distance the most, ensuring worst-case path efficiency. It iterates through unvisited nodes, calculates the reduction in the maximum remaining distance for each candidate, and selects the node that yields the highest reduction. The code emphasizes worst-case optimization over average-case performance.",
          "thought": "The new algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes, selecting the next node that reduces the longest remaining distance the most, ensuring a focus on worst-case path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_reduction = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        reduction = max_remaining_distance - distance_to_node\n\n        if reduction > max_reduction:\n            max_reduction = reduction\n            next_node = node\n\n    return next_node",
          "objective": 6.85653,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance from the destination, with higher priority given to distance from the destination as the number of unvisited nodes decreases (controlled by the dynamic weight). It prioritizes nodes that are closer to the destination while gradually favoring nodes near the current position as the tour nears completion. The weight adjusts based on remaining nodes, ensuring exploration early and convergence later.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts the balance between proximity to the current node and distance from the destination based on the remaining unvisited nodes, promoting exploration of distant regions while ensuring gradual convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = remaining_nodes / (remaining_nodes + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = (1 - weight) * distance_to_destination - weight * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85712,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration (early stages) and exploitation (later stages) by adjusting weights: higher weights favor closer unvisited nodes and lower weights prioritize centrality (distance to other unvisited nodes). It scores nodes based on distance to the current node, distance to the destination, and centrality, with exploration_weight controlling the trade-off. Centrality is given higher priority in later stages (lower exploration_weight).",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight that adjusts based on the number of remaining unvisited nodes, prioritizing exploration early and exploitation later, while also considering the node's centrality in the graph to avoid isolated nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_weight = 1.0 if remaining_nodes > len(distance_matrix) // 2 else 0.5\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n        score = (exploration_weight * distance_to_destination - distance_to_node) + (1 - exploration_weight) * centrality\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node only if it is unvisited and closer than all other options. The code first checks if there are no unvisited nodes, returning the destination node. Otherwise, it iterates through unvisited nodes to find the closest one, explicitly checking if the destination node is closer than the current closest candidate. The destination node is given higher priority than other unvisited nodes only if it is closer than the nearest neighbor.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and closer than all other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        if distance_to_destination < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning. It calculates a score for each unvisited node as the difference between the distance from the node to the destination and the distance from the current node to the node, selecting the node with the highest score. This balances proximity to the current node and distance from the destination, aiming for a more optimal path by avoiding premature convergence.",
          "thought": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning, which may lead to a more optimal path by avoiding premature convergence to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_destination - distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     }
]