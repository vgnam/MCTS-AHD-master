[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate travel cost and long-term savings, prioritizing nodes that reduce future travel while penalizing high immediate distances. It scores each candidate node using a weighted combination of the average remaining distance (after visiting the node) and the direct travel cost, with the latter given a lower weight (0.3). The node with the highest score is chosen, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the proximity-based selection from No.1 with the savings-oriented approach of No.2, prioritizing nodes that offer high savings while also considering immediate travel cost, creating a balanced heuristic that optimizes both short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        score = (avg_remaining_distance - distance_to_node) - 0.3 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41645,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that offer the highest savings in average remaining distance after accounting for the immediate travel cost, balancing proximity with potential future path efficiency. It evaluates each unvisited node's contribution to savings (avg_remaining_distance - distance_to_node) and chooses the one with maximum savings, ensuring a greedy yet strategic approach to path optimization. The critical design prioritizes savings over direct distance, with the savings calculation being the core heuristic.",
          "thought": "This algorithm selects the next node by prioritizing those with the highest immediate distance reduction relative to the remaining path's average distance, ensuring a balance between proximity and potential future savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_savings = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n\n        if savings > max_savings:\n            max_savings = savings\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes by selecting the next node that reduces the longest remaining distance the most, ensuring worst-case path efficiency. It iterates through unvisited nodes, calculates the reduction in the maximum remaining distance for each candidate, and selects the node that yields the highest reduction. The code emphasizes worst-case optimization over average-case performance.",
          "thought": "The new algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes, selecting the next node that reduces the longest remaining distance the most, ensuring a focus on worst-case path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_reduction = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        reduction = max_remaining_distance - distance_to_node\n\n        if reduction > max_reduction:\n            max_reduction = reduction\n            next_node = node\n\n    return next_node",
          "objective": 6.85653,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node only if it is unvisited and closer than all other options. The code first checks if there are no unvisited nodes, returning the destination node. Otherwise, it iterates through unvisited nodes to find the closest one, explicitly checking if the destination node is closer than the current closest candidate. The destination node is given higher priority than other unvisited nodes only if it is closer than the nearest neighbor.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and closer than all other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        if distance_to_destination < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning. It calculates a score for each unvisited node as the difference between the distance from the node to the destination and the distance from the current node to the node, selecting the node with the highest score. This balances proximity to the current node and distance from the destination, aiming for a more optimal path by avoiding premature convergence.",
          "thought": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning, which may lead to a more optimal path by avoiding premature convergence to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_destination - distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate travel cost and long-term exploration, using a dynamic weight factor that prioritizes average remaining distance early (high weight) and immediate distance later (low weight). The score for each candidate node combines these factors, penalizing nodes that disrupt future connections, while the weight adjusts based on the number of remaining nodes. The function iterates through unvisited nodes, calculates the weighted score, and selects the node with the highest score, ensuring both exploration and exploitation.",
          "thought": "The new algorithm modifies the savings heuristic by incorporating a weighted combination of average remaining distance and the immediate travel cost, using a dynamic weight factor that adjusts based on the number of remaining nodes, encouraging exploration early and exploitation later, while penalizing nodes that disrupt potential future connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if not remaining_nodes:\n            score = -distance_to_node\n        else:\n            total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = total_remaining_distance / len(remaining_nodes)\n            weight = len(remaining_nodes) / (len(unvisited_nodes) + 1)\n            score = (weight * avg_remaining_distance) - ((1 - weight) * distance_to_node)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 10.48104,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing savings (reduced average remaining distance) and path coherence (penalty for distant nodes), with a weighting factor that increases exploration when fewer nodes remain. It prioritizes higher savings scores while adjusting for path continuity, favoring nearby nodes early on and more distant ones as the tour nears completion. The exploration factor (`exploration_factor`) and coherence penalty (`path_coherence_penalty`) are key variables that dynamically adjust priorities.",
          "thought": "The new algorithm modifies the savings heuristic by incorporating a dynamic weighting factor that adjusts based on the proportion of unvisited nodes, favoring exploration when fewer nodes remain, and balances the savings calculation with a penalty for revisiting nodes that are far from the current path, thus enhancing path coherence and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node if needed\n    exploration_factor = 1 - (len(unvisited_nodes) / total_nodes)  # Higher when fewer nodes left\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        # Penalty for nodes far from current path\n        path_coherence_penalty = distance_matrix[current_node][node] * exploration_factor\n        savings = avg_remaining_distance - path_coherence_penalty\n        score = savings * (1 + exploration_factor)  # Emphasize savings with exploration\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 12.05112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and global optimization (estimated remaining path length), prioritizing nodes with lower combined scores. The `distance_to_node` (immediate cost) is given higher weight than `total_remaining_distance` (global estimate), with the latter scaled by 0.5. The function iterates through unvisited nodes, computes a weighted score for each, and chooses the node with the minimum score. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node while also considering the total remaining distance to unvisited nodes, aiming to balance immediate proximity and global path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        score = distance_to_node + 0.5 * total_remaining_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 16.74734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future efficiency: it prioritizes nodes that are close to the current node but also have lower average distances to remaining unvisited nodes, ensuring a trade-off between short-term and long-term travel costs. The key design is the ratio calculation (`distance_to_node / avg_remaining_distance`), where higher ratios favor nodes that are both nearby and central to unvisited clusters. The code iterates through unvisited nodes, computes this ratio, and selects the node with the highest ratio, with special handling for the last node.",
          "thought": "The new algorithm prioritizes minimizing the immediate travel cost while considering the potential to reduce future travel costs, balancing direct distance with the potential savings from selecting nodes that are close to clusters of unvisited nodes. It selects the next node by evaluating the ratio of the immediate distance to the node and the average distance to the remaining unvisited nodes, choosing the node that maximizes this ratio to ensure a balance between proximity and future efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_ratio = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n\n        if avg_remaining_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_node / avg_remaining_distance\n\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 37.22146,
          "other_inf": null
     }
]