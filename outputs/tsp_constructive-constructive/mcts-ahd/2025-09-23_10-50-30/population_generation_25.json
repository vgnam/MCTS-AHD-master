[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate travel cost and long-term savings, prioritizing nodes that reduce future travel while penalizing high immediate distances. It scores each candidate node using a weighted combination of the average remaining distance (after visiting the node) and the direct travel cost, with the latter given a lower weight (0.3). The node with the highest score is chosen, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the proximity-based selection from No.1 with the savings-oriented approach of No.2, prioritizing nodes that offer high savings while also considering immediate travel cost, creating a balanced heuristic that optimizes both short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        score = (avg_remaining_distance - distance_to_node) - 0.3 * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41645,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that offer the highest savings in average remaining distance after accounting for the immediate travel cost, balancing proximity with potential future path efficiency. It evaluates each unvisited node's contribution to savings (avg_remaining_distance - distance_to_node) and chooses the one with maximum savings, ensuring a greedy yet strategic approach to path optimization. The critical design prioritizes savings over direct distance, with the savings calculation being the core heuristic.",
          "thought": "This algorithm selects the next node by prioritizing those with the highest immediate distance reduction relative to the remaining path's average distance, ensuring a balance between proximity and potential future savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_savings = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        total_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        avg_remaining_distance = total_remaining_distance / len(remaining_nodes) if remaining_nodes else 0\n        savings = avg_remaining_distance - distance_to_node\n\n        if savings > max_savings:\n            max_savings = savings\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes by selecting the next node that reduces the longest remaining distance the most, ensuring worst-case path efficiency. It iterates through unvisited nodes, calculates the reduction in the maximum remaining distance for each candidate, and selects the node that yields the highest reduction. The code emphasizes worst-case optimization over average-case performance.",
          "thought": "The new algorithm prioritizes minimizing the maximum remaining distance to unvisited nodes, selecting the next node that reduces the longest remaining distance the most, ensuring a focus on worst-case path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_reduction = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n        reduction = max_remaining_distance - distance_to_node\n\n        if reduction > max_reduction:\n            max_reduction = reduction\n            next_node = node\n\n    return next_node",
          "objective": 6.85653,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance from the destination, with higher priority given to distance from the destination as the number of unvisited nodes decreases (controlled by the dynamic weight). It prioritizes nodes that are closer to the destination while gradually favoring nodes near the current position as the tour nears completion. The weight adjusts based on remaining nodes, ensuring exploration early and convergence later.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts the balance between proximity to the current node and distance from the destination based on the remaining unvisited nodes, promoting exploration of distant regions while ensuring gradual convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = remaining_nodes / (remaining_nodes + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = (1 - weight) * distance_to_destination - weight * distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85712,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration (early stages) and exploitation (later stages) by adjusting weights: higher weights favor closer unvisited nodes and lower weights prioritize centrality (distance to other unvisited nodes). It scores nodes based on distance to the current node, distance to the destination, and centrality, with exploration_weight controlling the trade-off. Centrality is given higher priority in later stages (lower exploration_weight).",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight that adjusts based on the number of remaining unvisited nodes, prioritizing exploration early and exploitation later, while also considering the node's centrality in the graph to avoid isolated nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_weight = 1.0 if remaining_nodes > len(distance_matrix) // 2 else 0.5\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n        score = (exploration_weight * distance_to_destination - distance_to_node) + (1 - exploration_weight) * centrality\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node only if it is unvisited and closer than all other options. The code first checks if there are no unvisited nodes, returning the destination node. Otherwise, it iterates through unvisited nodes to find the closest one, explicitly checking if the destination node is closer than the current closest candidate. The destination node is given higher priority than other unvisited nodes only if it is closer than the nearest neighbor.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and closer than all other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        if distance_to_destination < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning. It calculates a score for each unvisited node as the difference between the distance from the node to the destination and the distance from the current node to the node, selecting the node with the highest score. This balances proximity to the current node and distance from the destination, aiming for a more optimal path by avoiding premature convergence.",
          "thought": "The algorithm prioritizes nodes that are both close to the current node and far from the destination, encouraging exploration of distant regions before returning, which may lead to a more optimal path by avoiding premature convergence to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_destination - distance_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing two factors: the distance from the current node and a bias toward nodes closer to the destination. If the destination is unvisited and closer than other options, it is chosen directly. Otherwise, the algorithm selects the unvisited node closest to the current node, but with a 50% weight on the node's distance to the destination to guide the path toward the destination. The code ensures the path is efficient while aggressively steering toward the destination.",
          "thought": "The new algorithm prioritizes the destination node only if it is unvisited and closer than all other options, otherwise it selects the next node by choosing the unvisited node closest to the current node, but with a bias towards nodes that are closer to the destination node to guide the path towards the destination more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n    destination_distance = distance_matrix[current_node][destination_node] if destination_node in unvisited_nodes else float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        bias = distance_matrix[node][destination_node] if node != destination_node else 0\n        total_cost = distance + 0.5 * bias\n\n        if total_cost < min_distance:\n            min_distance = total_cost\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing nodes that minimize the sum of their distance from the current node and their distance to the destination, balancing local and global proximity. It iterates through unvisited nodes, calculates a score for each based on these distances, and selects the node with the lowest score, ensuring efficient progression toward the destination. The `distance_matrix` provides the necessary distance measurements, while `current_node`, `destination_node`, and `unvisited_nodes` guide the selection process.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node and also close to the destination, encouraging efficient progression towards the destination by balancing local and global distances, unlike the original which focused on distant regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_node + distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances exploration and exploitation by prioritizing nodes closer to the destination while penalizing those farther from the current node, using a weighted score of `distance_to_destination - 0.5 * distance_to_node` to guide selection. The bias toward the destination ensures progress toward the goal, while the penalty for distance from the current node promotes local exploration, avoiding premature convergence. The `0.5` weight adjusts the trade-off between these factors.",
          "thought": "The new algorithm combines the No.1 algorithm's bias toward nodes closer to the destination with the No.2 algorithm's exploration of distant regions. It selects the next node by balancing the distance to the current node and a weighted bias toward the destination, ensuring a more optimal path while avoiding premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_destination - distance_to_node * 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.21934,
          "other_inf": null
     }
]