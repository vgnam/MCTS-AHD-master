[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This ensures a balance between immediate proximity (lower numerator) and long-term efficiency (lower denominator), dynamically adjusting the path based on the remaining unvisited nodes. The code explicitly checks for and avoids division by zero when a node is the destination, ensuring robustness.",
          "thought": "The new algorithm prioritizes nodes that minimize the ratio of the distance to the current node divided by the distance to the destination, ensuring a balance between immediate proximity and long-term path efficiency while dynamically adjusting the selection based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically balances immediate distance and long-term path guidance by adjusting a weight factor based on remaining unvisited nodes. Early in the search, it prioritizes closer nodes (lower `distance_to_current`), while later it favors nodes that better connect to the destination (higher `distance_to_destination`). The weight factor (`weight_factor = 1.0 / (1.0 + remaining_nodes)`) ensures the balance shifts toward long-term planning as the number of unvisited nodes decreases.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating a dynamic weighting factor to balance immediate distance and long-term path guidance, where the weight adjusts based on the remaining unvisited nodes, favoring closer nodes early and more strategic choices later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Decreases as more nodes are visited\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_score = (1 - weight_factor) * distance_to_current + weight_factor * distance_to_destination\n\n        if weighted_score < min_score:\n            min_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a ratio of the product of distances (current to node and node to destination, with a decay factor applied to the latter) to their sum, balancing closeness to both the current node and destination while prioritizing nodes that are closer to the destination (due to the decay factor). The decay factor (0.7) reduces the influence of the destination distance, favoring nodes that are both close to the current node and the destination, but with the destination's influence dampened. The code efficiently iterates through unvisited nodes to find the optimal next node.",
          "thought": "The new algorithm combines the balanced approach of No.1 (minimizing product of distances with decay) and No.2 (minimizing ratio of distances) by using a ratio of the product of distances (with decay) to the sum of distances, favoring nodes that are both close to the current node and the destination, while dynamically adjusting the balance based on the remaining tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n    decay_factor = 0.7\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            product = distance_to_current * (distance_to_destination ** decay_factor)\n            sum_distances = distance_to_current + distance_to_destination\n            ratio = product / sum_distances\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 7.29549,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances near-term and long-term optimization by combining normalized distances to the current node and destination, with a decay factor that prioritizes the destination distance as more nodes are visited. It uses a dynamic weight based on remaining unvisited nodes to adjust the influence of these distances, favoring closer current nodes early and closer destination nodes later. The score calculation ensures a smooth transition between these priorities.",
          "thought": "This new algorithm introduces a dynamic weighting mechanism that adjusts the influence of both current and destination distances based on the remaining number of unvisited nodes, using a heuristic score that combines normalized distances and a progressive decay factor to balance near-term and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_decay_factor = 0.7\n    dynamic_weight = 1.0 / (1.0 + remaining_nodes)  # Decreases as more nodes are visited\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Normalize distances\n        max_distance = max(distance_to_current, distance_to_destination, 1.0)  # Avoid division by zero\n        normalized_current = distance_to_current / max_distance\n        normalized_destination = distance_to_destination / max_distance\n\n        # Dynamic decay factor\n        decay_factor = base_decay_factor * (1.0 - dynamic_weight)\n        score = normalized_current * (normalized_destination ** decay_factor)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.39562,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the distance to the current node and the distance to the destination, with the destination distance weighted by a decay factor (0.7) to balance immediate and long-term path considerations. The score is computed as `distance_to_current * (distance_to_destination ** decay_factor)`, favoring nodes closer to both the current and destination nodes, while the decay factor reduces the influence of the destination distance as the tour progresses. The algorithm ensures the tour returns to the destination node when all other nodes are visited.",
          "thought": "This algorithm prioritizes nodes that minimize the product of the distance to the current node and the distance to the destination, balancing both immediate and long-term path considerations, and uses a decay factor to adjust the influence of the destination distance based on remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    decay_factor = 0.7  # Adjusts influence of destination distance\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current * (distance_to_destination ** decay_factor)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.4284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity and strategic planning by prioritizing nodes closer to the current node while adjusting the influence of destination distance based on remaining unvisited nodes (higher weight when fewer nodes remain). It penalizes nodes too far from the current node to avoid detours, with the score combining these factors to select the next node. The `remaining_ratio` and `decay_factor` control the dynamic weighting and penalty strength, respectively.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of the destination distance based on the proportion of remaining unvisited nodes, while also incorporating a penalty term for nodes that are too far from the current node, creating a balance between proximity and strategic planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    decay_factor = 0.7\n    remaining_ratio = len(unvisited_nodes) / (len(distance_matrix) - 1)  # Ratio of remaining nodes\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weighting: more emphasis on destination distance when fewer nodes remain\n        dynamic_weight = 1.0 - remaining_ratio\n        weighted_destination = distance_to_destination * (1 + dynamic_weight)\n\n        # Penalty for nodes too far from current node\n        penalty = max(0, distance_to_current - 2 * distance_matrix[current_node][destination_node])\n\n        score = distance_to_current * (weighted_destination ** decay_factor) + penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43313,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of their distance from the current node and their distance to the destination, with the destination distance weighted by 0.5 to balance short-term and long-term path considerations. The lowest-scoring node (current distance + 0.5 \u00d7 destination distance) is selected next, ensuring the tour efficiently progresses toward the destination while minimizing detours. The algorithm defaults to the destination node when no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance to the current node and the distance to the destination, with the destination distance weighted by a factor of 0.5 to balance immediate and long-term path considerations. The score is computed as `distance_to_current + (distance_to_destination * 0.5)`, favoring nodes closer to both the current and destination nodes, while the factor reduces the influence of the destination distance as the tour progresses. The algorithm ensures the tour returns to the destination node when all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    weight_factor = 0.5  # Adjusts influence of destination distance\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + (distance_to_destination * weight_factor)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the product of distances from the current node to the candidate and from the candidate to the destination, balancing immediate proximity and long-term efficiency. It avoids division by zero and checks for invalid nodes, ensuring robustness. The code dynamically evaluates unvisited nodes based on this ratio and returns the optimal candidate, defaulting to the destination if no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node multiplied by the distance from the candidate node to the destination, ensuring a balance between immediate proximity and long-term efficiency while dynamically adjusting the path based on the remaining unvisited nodes. The code avoids division by zero and checks for invalid nodes, ensuring robustness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0 or distance_to_current == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current * distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate proximity (60% weight) and proximity to the destination (40% weight), prioritizing shorter-term distances over long-term ones. It iterates through unvisited nodes, calculates a weighted score combining the distance to the current node and the estimated distance to the destination, and chooses the node with the lowest score. The function ensures the tour returns to the destination node when no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of immediate distance and potential future distance, allowing for adjustable emphasis on either short-term or long-term path considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_score = 0.6 * distance_to_current + 0.4 * distance_to_destination\n\n        if weighted_score < min_score:\n            min_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     }
]