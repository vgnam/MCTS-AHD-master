[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
          "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance to current node) and long-term connectivity (node's connections to unvisited nodes), with connectivity weighted more heavily as the number of remaining nodes decreases. It prioritizes nodes that are closer to the current node but also have strong connections to other unvisited nodes, adjusting the balance dynamically. The score calculation combines distance and connectivity, favoring nodes with lower scores.",
          "thought": "The new algorithm combines the score calculation from No.1 (distance_to_current - avg_distance) with the dynamic connectivity weighting from No.2, creating a hybrid approach that balances immediate proximity and long-term connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance_to_unvisited)\n        connectivity_weight = 1.0 + (1.0 - (remaining_nodes / total_nodes)) * (connectivity / (total_nodes - 1)) * 0.5\n\n        score = (distance_to_current - avg_distance_to_unvisited) * connectivity_weight\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both locally close to the current node and globally well-connected to unvisited nodes, dynamically adjusting its focus based on the visited ratio. It balances proximity (distance_to_current) and connectivity (avg_distance) with a weighted score, while penalizing high-connectivity nodes (avg_neighbor_distance > 1.5x distance_to_current) to avoid clustering. The weight factor (0.5 + 0.5*(1-visited_ratio)) shifts emphasis from local proximity early (high weight) to global connectivity later (lower weight).",
          "thought": "The new algorithm combines the No.1's balance between local proximity and global connectivity with No.2's dynamic weighting and penalty for high-connectivity nodes, using a score that prioritizes closer nodes with high average distances to unvisited nodes, while dynamically adjusting weights based on visited ratio and penalizing nodes with significantly higher neighbor distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            if avg_neighbor_distance > 1.5 * distance_to_current:\n                score *= 1.1\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45911,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node (60% weight) with future average distances to unvisited nodes (30% weight, dynamically adjusted by remaining nodes) while penalizing nodes close to the destination to encourage exploration. The weight increases as remaining nodes decrease, prioritizing strategic choices later, and the penalty term discourages early visits to nodes near the destination. The score combines these factors to select the next node with the lowest cost.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate and future distance balancing from No.2, using a weight that increases as remaining nodes decrease to prioritize strategic choices later, while penalizing nodes close to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment, normalization, and decay factors to balance immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination. Immediate distance is prioritized (0.5 weight), followed by future average distance (0.3 weight with decay), and penalizes nodes close to the destination to avoid premature convergence. The weights adapt based on remaining nodes, with higher penalties for nodes near the destination to encourage exploration.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the normalization and decay factor from No.2, using a weighted score of immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n    dynamic_weight = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        max_distance = max(distance_to_current, distance_to_destination, 1.0)\n        normalized_current = distance_to_current / max_distance\n        normalized_future = avg_future_distance / max_distance if avg_future_distance > 0 else 0\n\n        decay_factor = 0.7 * (1.0 - dynamic_weight)\n        score = immediate_weight * normalized_current + future_weight * (normalized_future ** decay_factor) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50058,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, future connectivity, node popularity, and a penalty term that favors central nodes closer to the destination, with weights adjusted by an exploration factor that increases as the tour progresses. Higher priority is given to immediate distance and future connectivity early on, while popularity and penalties gain importance later to refine the path. The exploration factor (0.7 * remaining_nodes / (remaining_nodes + 1)) controls the trade-off between exploitation and exploration.",
          "thought": "The new algorithm modifies the provided approach by introducing a dynamic exploration factor that adapts to the remaining nodes, incorporating a node popularity metric based on historical visits, and using a weighted combination of immediate distance, average future distance, and a penalty term that considers both distance to destination and node centrality, with the exploration factor increasing as the tour progresses to balance exploitation and exploration more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_nodes / (remaining_nodes + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n\n        immediate_weight = 0.5 + 0.2 * exploration_factor\n        future_weight = 0.3 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination + 0.5 * node_centrality)\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance + popularity_weight * popularity - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50857,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, node centrality (higher priority early on), and future connectivity (lower priority), with adaptive weights and a penalty for nodes too close to the destination. It prioritizes centrality and connectivity early (higher weights) but shifts focus to immediate distance as nodes remain. The score combines weighted components (immediate distance: 50%, centrality: 30%, connectivity: 20%) minus a penalty for nodes near the destination.",
          "thought": "The new algorithm introduces a dynamic priority system that combines immediate distance with probabilistic selection based on node centrality and future connectivity, using a novel scoring mechanism that balances exploration and exploitation through adaptive weights and a connectivity penalty term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            # Calculate node centrality (inverse of average distance to other nodes)\n            centrality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)) if remaining_nodes > 1 else 0\n\n            # Calculate future connectivity (number of nearby nodes)\n            connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * distance_to_current) / remaining_nodes\n\n            # Dynamic weights based on remaining nodes\n            weight_factor = 0.4 + 0.6 * (remaining_nodes / (remaining_nodes + 3))\n            immediate_weight = 0.5 * weight_factor\n            centrality_weight = 0.3 * (1 - weight_factor)\n            connectivity_weight = 0.2 * (1 - weight_factor)\n\n            # Penalty for nodes that are too close to destination\n            penalty_weight = 0.3 * (1.0 - connectivity_weight)\n            penalty = penalty_weight * (distance_to_destination / (1.0 + distance_to_current)) if distance_to_current > 0 else 0\n\n            # Score combines weighted components with penalty\n            score = (immediate_weight * distance_to_current +\n                     centrality_weight * centrality +\n                     connectivity_weight * connectivity) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51679,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by dynamically balancing immediate distance to the current node, node centrality (inverse of average distance to unvisited nodes), and connectivity (proximity to nearby nodes), with weights adjusted based on remaining nodes. It penalizes nodes too close to the destination and prioritizes centrality early in the search while favoring immediate distance later, using a weighted scoring system to optimize the path. The algorithm ensures connectivity by rewarding nodes with many nearby unvisited neighbors, while the penalty discourages prematurely approaching the destination.",
          "thought": "The new algorithm combines the centrality and connectivity prioritization from No.1 with the distance ratio optimization from No.2, using dynamic weights that favor centrality early and immediate distance later, while penalizing nodes too close to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            # Calculate node centrality (inverse of average distance to other nodes)\n            centrality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)) if remaining_nodes > 1 else 0\n\n            # Calculate future connectivity (number of nearby nodes)\n            connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * distance_to_current) / remaining_nodes\n\n            # Dynamic weights based on remaining nodes\n            weight_factor = 0.4 + 0.6 * (remaining_nodes / (remaining_nodes + 3))\n            immediate_weight = 0.4 * weight_factor\n            centrality_weight = 0.4 * (1 - weight_factor)\n            connectivity_weight = 0.2 * (1 - weight_factor)\n\n            # Penalty for nodes that are too close to destination\n            penalty_weight = 0.3 * (1.0 - connectivity_weight)\n            penalty = penalty_weight * (distance_to_destination / (1.0 + distance_to_current)) if distance_to_current > 0 else 0\n\n            # Score combines weighted components with penalty\n            score = (immediate_weight * distance_to_current +\n                     centrality_weight * centrality +\n                     connectivity_weight * connectivity) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54313,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weight 0.6) and connectivity (weight 0.3) while slightly considering centrality (weight 0.1), with dynamic weight adjustments based on remaining nodes to balance greedy and global optimization. A penalty term discourages premature convergence by penalizing high distances to the destination, especially when the current node is far away. The weights are adjusted using a weight factor that increases as nodes remain unvisited, favoring immediate and connectivity-based decisions early on.",
          "thought": "The new algorithm prioritizes immediate distance (0.6 weight) and connectivity (0.3 weight) with a fixed centrality (0.1 weight), using a penalty based on distance to destination to avoid premature convergence, while dynamically adjusting weights based on remaining nodes to balance greedy and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            centrality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)) if remaining_nodes > 1 else 0\n            connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * distance_to_current) / remaining_nodes\n\n            weight_factor = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 2))\n            immediate_weight = 0.6 * weight_factor\n            centrality_weight = 0.1 * (1 - weight_factor)\n            connectivity_weight = 0.3 * (1 - weight_factor)\n\n            penalty_weight = 0.4 * (1.0 - connectivity_weight)\n            penalty = penalty_weight * (distance_to_destination / (1.0 + distance_to_current)) if distance_to_current > 0 else 0\n\n            score = (immediate_weight * distance_to_current +\n                     centrality_weight * centrality +\n                     connectivity_weight * connectivity) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56098,
          "other_inf": null
     }
]