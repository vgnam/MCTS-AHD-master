[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early (with `immediate_weight` decreasing as exploration progresses) while adaptively balancing lookahead (nearest neighbors), centrality (node average distance), and connectivity (local density) via weights that adjust based on `exploration_factor` and `visited_ratio`. The scoring function penalizes nodes with poor connectivity and high centrality, while rewarding those with shorter immediate distances and better lookahead potential. The weights dynamically shift focus from local optimization to global connectivity as the tour progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead, centrality, and connectivity penalties, with a stronger emphasis on balancing global connectivity and local optimization via exploration_factor and visited_ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.6 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.29321,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic balances immediate distance (50% weight) with dynamic centrality (30% weight) and connectivity penalties (20% weight), adjusting weights based on progress (visited_ratio) and using lookahead (nearest neighbors) to refine decisions, while penalizing nodes with poor local connectivity. The algorithm prioritizes proximity but adapts its focus on centrality and connectivity as the tour progresses, using a dynamic scaling factor for refined decisions.",
          "thought": "This new algorithm combines the balanced approach of No.1 (distance and connectivity), the dynamic weight adjustment of No.2 (60-40% weights), the connectivity penalty of No.3 (0.3 weight), and the exploration factor of No.4 (1.0-0.7 scaling) to create a hybrid heuristic that prioritizes immediate distance (50% weight) while dynamically adjusting centrality (30% weight) and connectivity penalties (20% weight) based on visited ratio, with lookahead depth scaling for refined decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.7)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30638,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
          "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with refined centrality and connectivity scoring, prioritizing immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing) while using lookahead and scaling factors to balance short-term and long-term decisions. Weights are adjusted based on visited ratio, and penalties avoid clustering by penalizing nodes with high average neighbor distances. The score calculation integrates immediate distance, centrality, and connectivity, dynamically adjusted for remaining nodes and visited progress.",
          "thought": "This new algorithm combines the dynamic weight adjustment of No.2 with the refined centrality and connectivity scoring of No.1, using immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing), with dynamic lookahead and scaling factors to balance short-term and long-term decisions while avoiding clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * (0.2 + 0.1 * visited_ratio)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (0.5 + 0.2 * visited_ratio)\n        penalty_weight = 0.2 * (0.5 + 0.3 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead and centrality, with penalties for highly connected nodes to prevent clustering. It balances immediate distance (weighted higher early) with lookahead and centrality (weighted lower initially) and adjusts penalties based on visited ratio. Key variables: `immediate_weight` (prioritized early), `lookahead_weight` and `centrality_weight` (lower priority initially), `penalty_weight` (scales with visited ratio).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity penalty and exploration factor refinement of No.1, using a balanced scoring mechanism that prioritizes immediate distance early while incorporating lookahead and centrality adaptively, with penalties for highly connected nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32084,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm prioritizes immediate distance (60-50% weight) while dynamically adjusting weights for centrality (30-10%) and connectivity penalties (0.2-0.1 weight) based on visited ratio. It balances exploration via lookahead depth (1-3 nodes) and penalizes high-connectivity nodes, with weights shifting toward global optimization as the tour progresses. The algorithm dynamically adjusts exploration factors and connectivity penalties, favoring immediate distance early but incorporating centrality and penalties later to refine the path.",
          "thought": "The new algorithm combines dynamic weight adjustment, immediate distance prioritization (60-50% weight), and reduced connectivity penalties (0.2-0.1 weight) with lookahead depth (3-1 nodes) and centrality-based scoring, while dynamically adjusting exploration factors based on visited ratio and penalizing high-connectivity nodes to balance local coverage and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - exploration_factor)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32251,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for TSP prioritizes immediate distance and node centrality in early stages (high immediate_weight and centrality_weight) while gradually shifting to lookahead and connectivity-aware selection as the search progresses (adjusting exploration_factor, lookahead_weight, and connectivity_factor). The algorithm dynamically balances these factors using visited_ratio and exploration progress, with penalties applied when neighbors are too close to avoid suboptimal paths. The score calculation combines immediate distance, lookahead potential, centrality, and connectivity to select the next node.",
          "thought": "The new algorithm focuses on aggressive early-stage optimization with high initial weight on immediate distance and centrality, gradually shifting to lookahead and connectivity-aware selection, while dynamically adjusting weights based on visited ratio and exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.1 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.5 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.3 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60-50% weight) early but dynamically adjusts weights based on progress, balancing exploration via lookahead depth (1-5 nodes) and centrality (30-10% weight) while penalizing high-connectivity nodes and shifting toward global optimization as the tour progresses. It dynamically adjusts weights (e.g., immediate_weight, centrality_weight, penalty_weight) based on visited_ratio and exploration_factor, while connectivity_factor and penalty terms further refine node selection.",
          "thought": "The new algorithm prioritizes immediate distance (60-50% weight) early, dynamically balances exploration via lookahead depth (1-5 nodes) and centrality (30-10% weight), while penalizing high-connectivity nodes and shifting toward global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - exploration_factor)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32415,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with multi-factor scoring, prioritizing immediate distance early (60-80% weight) while reducing lookahead depth and penalizing high-connectivity nodes to balance local coverage and global optimization. It dynamically adjusts weights based on remaining nodes, applies penalties to avoid clustering, and incorporates centrality and connectivity with progressively lower emphasis as the search progresses. The key variables are immediate distance (high early weight), lookahead depth (reduced dynamically), and connectivity penalties (applied later). The structure iteratively evaluates each unvisited node using these weighted factors to select the next node.",
          "thought": "The new algorithm combines dynamic weight adjustment with multi-factor scoring, prioritizing immediate distance (60-80% weight early) and lookahead depth (reduced as nodes remain), while penalizing high-connectivity nodes to balance local coverage and global connectivity. It dynamically adjusts weights based on remaining nodes, applies penalties to avoid clustering, and incorporates centrality and connectivity with progressively lower emphasis as the search progresses, favoring local exploration early and global optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 + 0.2 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32996,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (55-40% weight) and lookahead connectivity (40-25% weight) while dynamically balancing centrality (35-20% weight) through exploration-driven penalties and connectivity factors, ensuring efficient node selection toward lower objective values by adjusting weights based on exploration progress and node centrality. The code uses dynamic weights, penalties, and connectivity factors to guide selection, with immediate distance and lookahead contributing more significantly than centrality as exploration progresses.",
          "thought": "The new algorithm combines the adaptive weighting and dynamic penalties from No.1 with the dynamic balancing of No.2, prioritizing immediate distance (55-40% weight), lookahead connectivity (40-25% weight), and centrality (35-20% weight), while applying exploration-driven penalties and connectivity factors to guide node selection toward lower objective values.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n    avg_total_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_count\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n        node_centrality = avg_remaining_distance\n\n        connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_remaining_distance)\n        connectivity_factor = 1.0 + (connectivity / remaining_count) * 0.3\n\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.55 - 0.15 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.35 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_remaining_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33453,
          "other_inf": null
     }
]