[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early (with `immediate_weight` decreasing as exploration progresses) while adaptively balancing lookahead (nearest neighbors), centrality (node average distance), and connectivity (local density) via weights that adjust based on `exploration_factor` and `visited_ratio`. The scoring function penalizes nodes with poor connectivity and high centrality, while rewarding those with shorter immediate distances and better lookahead potential. The weights dynamically shift focus from local optimization to global connectivity as the tour progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead, centrality, and connectivity penalties, with a stronger emphasis on balancing global connectivity and local optimization via exploration_factor and visited_ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.6 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.29321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (40% weight) with decay, centrality (25% weight) with exponential growth, and connectivity penalties (35% weight) with quadratic adjustment, dynamically adjusting weights based on progress and incorporating lookahead (up to 4 steps) to balance proximity, centrality, and connectivity while scaling penalties with node density. Immediate distance dominates early, while centrality and penalties gain importance as progress increases.",
          "thought": "The new algorithm prioritizes immediate distance (40% weight) with a linear decay, centrality (25% weight) with exponential growth, and connectivity penalties (35% weight) with a quadratic adjustment, using a dynamic lookahead depth (up to 4 steps) and scaling penalties based on node density and progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / remaining_count) * 0.4\n        lookahead_depth = min(4, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.4 - 0.15 * visited_ratio\n        centrality_weight = 0.25 * (1.0 - (remaining_count / total_nodes) ** 2)\n        penalty_weight = 0.35 * (1 - visited_ratio ** 2)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio ** 2)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.29431,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, centrality, and connectivity by adjusting weights based on progress (visited_ratio) and node density, while incorporating penalties for long-term inefficiency and scaling lookahead depth with remaining nodes. It prioritizes immediate distance early (higher weight) and gradually shifts focus to centrality and connectivity as the tour progresses, using penalties to avoid poor long-term choices. The score combines these factors with penalties based on average neighbor distance and progress, favoring nodes that balance short-term efficiency with long-term connectivity.",
          "thought": "This new algorithm combines the strengths of all four algorithms by dynamically balancing immediate distance, centrality, connectivity, and lookahead depth, with weights adjusted based on progress and node density, while incorporating penalties for long-term inefficiency and scaling lookahead depth with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / remaining_count) * 0.4\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.4 - 0.15 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) ** 1.5)\n        penalty_weight = 0.3 * (1 - visited_ratio ** 1.5)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio ** 1.5)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30492,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic balances immediate distance (50% weight) with dynamic centrality (30% weight) and connectivity penalties (20% weight), adjusting weights based on progress (visited_ratio) and using lookahead (nearest neighbors) to refine decisions, while penalizing nodes with poor local connectivity. The algorithm prioritizes proximity but adapts its focus on centrality and connectivity as the tour progresses, using a dynamic scaling factor for refined decisions.",
          "thought": "This new algorithm combines the balanced approach of No.1 (distance and connectivity), the dynamic weight adjustment of No.2 (60-40% weights), the connectivity penalty of No.3 (0.3 weight), and the exploration factor of No.4 (1.0-0.7 scaling) to create a hybrid heuristic that prioritizes immediate distance (50% weight) while dynamically adjusting centrality (30% weight) and connectivity penalties (20% weight) based on visited ratio, with lookahead depth scaling for refined decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.7)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30638,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP dynamically balances immediate distance, node connectivity, and path history by adjusting weights based on progress (visited_ratio) and incorporating a lookahead mechanism that evaluates short-term neighbors while penalizing detours. It prioritizes immediate distance early (weight 0.6) but shifts focus to connectivity and centrality (weights 0.25) as the tour progresses, with penalties (weight 0.15) increasing for long-term inefficiencies. The algorithm adapts by reducing lookahead depth and increasing penalty weights as fewer nodes remain.",
          "thought": "The new algorithm modifies the scoring system by incorporating a dynamic penalty based on node centrality and path history, with adaptive weights for immediate distance, connectivity, and detour avoidance, while introducing a novel lookahead mechanism that evaluates multiple potential paths to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n            node_centrality = avg_distance\n            lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 2\n            nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n            path_history_penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n            avg_neighbor_distance = 0\n            path_history_penalty = 0\n\n        connectivity_factor = 1.0 + (connectivity / (remaining_count + 1e-6)) * 0.4\n        immediate_weight = 0.6 - 0.2 * visited_ratio\n        centrality_weight = 0.25 * (0.6 + 0.2 * visited_ratio)\n        penalty_weight = 0.15 * (0.5 + 0.3 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio) + (0.3 * path_history_penalty / (immediate_distance + 1e-6)) * visited_ratio\n        score *= penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
          "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weight 0.7, decreasing as the tour progresses) but balances it with node centrality (weight 0.2, increasing) and connectivity (weight 0.1), while penalizing long-term inefficiencies (weight 0.3, increasing). It adapts dynamically by adjusting lookahead depth and penalty weights based on remaining nodes, favoring closer, central, and well-connected nodes early but refining choices as the tour nears completion.",
          "thought": "The new algorithm prioritizes immediate distance early (weight 0.7) but shifts focus to node centrality (weight 0.2) and connectivity (weight 0.1) as the tour progresses, with penalties (weight 0.3) increasing for long-term inefficiencies. It adapts by increasing lookahead depth and reducing penalty weights as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n            node_centrality = avg_distance\n            lookahead_depth = min(3, remaining_count) if remaining_count > 2 else 1\n            nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n            path_history_penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n            avg_neighbor_distance = 0\n            path_history_penalty = 0\n\n        connectivity_factor = 1.0 + (connectivity / (remaining_count + 1e-6)) * 0.5\n        immediate_weight = 0.7 - 0.3 * visited_ratio\n        centrality_weight = 0.2 * (0.5 + 0.3 * visited_ratio)\n        penalty_weight = 0.3 * (0.4 + 0.2 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (node_centrality * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio) + (0.2 * path_history_penalty / (immediate_distance + 1e-6)) * visited_ratio\n        score *= penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, connectivity, and centrality by prioritizing short-term efficiency early (higher immediate weight) and long-term structure later (higher centrality weight), while penalizing poor connectivity and favoring nodes that minimize the weighted sum of distances, with weights scaled based on remaining nodes and progress. The code assigns higher priority to immediate distance early on (immediate_weight) and gradually shifts focus to centrality (centrality_weight) as the tour progresses, using connectivity and lookahead depth to refine decisions. The penalty term further discourages poor connectivity choices, with weights adapting to the remaining nodes and visited ratio.",
          "thought": "This new algorithm combines the strengths of the existing approaches by dynamically balancing immediate distance, connectivity, centrality, and lookahead depth with adaptive weights that prioritize short-term efficiency early and long-term structure later, while penalizing poor connectivity and favoring nodes that minimize the weighted sum of distances, connectivity, and centrality, with weights scaled based on remaining nodes and progress to ensure a trade-off between proximity and tour quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / remaining_count) * 0.4\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.2 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.7)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31526,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with refined centrality and connectivity scoring, prioritizing immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing) while using lookahead and scaling factors to balance short-term and long-term decisions. Weights are adjusted based on visited ratio, and penalties avoid clustering by penalizing nodes with high average neighbor distances. The score calculation integrates immediate distance, centrality, and connectivity, dynamically adjusted for remaining nodes and visited progress.",
          "thought": "This new algorithm combines the dynamic weight adjustment of No.2 with the refined centrality and connectivity scoring of No.1, using immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing), with dynamic lookahead and scaling factors to balance short-term and long-term decisions while avoiding clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * (0.2 + 0.1 * visited_ratio)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (0.5 + 0.2 * visited_ratio)\n        penalty_weight = 0.2 * (0.5 + 0.3 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by 0.65\u20130.45) while balancing centrality (0.55\u20130.35) and connectivity (0.4\u20130.85), with dynamic weights adjusting based on exploration progress and visited ratio. It uses adaptive lookahead (depth 1\u20135) to estimate future steps, penalizing high-density regions more as the tour progresses. The score function combines immediate, lookahead, and penalty terms to select the next node, favoring closer, centralized, and well-connected nodes early, shifting toward efficiency as the tour completes.",
          "thought": "This new algorithm integrates dynamic weight adjustment, adaptive exploration factors, enhanced connectivity penalties, and multi-stage lookahead with variable depth, while balancing immediate distance, centrality, and connectivity through progressively shifting weights and penalties that scale with visited ratio and exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.25 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(5, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.65 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.55 * (1.0 - lookahead_weight)\n        penalty_weight = 0.45 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.55 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31931,
          "other_inf": null
     }
]