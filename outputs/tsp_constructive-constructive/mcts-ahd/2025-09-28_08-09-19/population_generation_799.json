[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early (with `immediate_weight` decreasing as exploration progresses) while adaptively balancing lookahead (nearest neighbors), centrality (node average distance), and connectivity (local density) via weights that adjust based on `exploration_factor` and `visited_ratio`. The scoring function penalizes nodes with poor connectivity and high centrality, while rewarding those with shorter immediate distances and better lookahead potential. The weights dynamically shift focus from local optimization to global connectivity as the tour progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead, centrality, and connectivity penalties, with a stronger emphasis on balancing global connectivity and local optimization via exploration_factor and visited_ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.6 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.29321,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic balances immediate distance (50% weight) with dynamic centrality (30% weight) and connectivity penalties (20% weight), adjusting weights based on progress (visited_ratio) and using lookahead (nearest neighbors) to refine decisions, while penalizing nodes with poor local connectivity. The algorithm prioritizes proximity but adapts its focus on centrality and connectivity as the tour progresses, using a dynamic scaling factor for refined decisions.",
          "thought": "This new algorithm combines the balanced approach of No.1 (distance and connectivity), the dynamic weight adjustment of No.2 (60-40% weights), the connectivity penalty of No.3 (0.3 weight), and the exploration factor of No.4 (1.0-0.7 scaling) to create a hybrid heuristic that prioritizes immediate distance (50% weight) while dynamically adjusting centrality (30% weight) and connectivity penalties (20% weight) based on visited ratio, with lookahead depth scaling for refined decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.7)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30638,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
          "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead and centrality, with penalties for highly connected nodes to prevent clustering. It balances immediate distance (weighted higher early) with lookahead and centrality (weighted lower initially) and adjusts penalties based on visited ratio. Key variables: `immediate_weight` (prioritized early), `lookahead_weight` and `centrality_weight` (lower priority initially), `penalty_weight` (scales with visited ratio).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity penalty and exploration factor refinement of No.1, using a balanced scoring mechanism that prioritizes immediate distance early while incorporating lookahead and centrality adaptively, with penalties for highly connected nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32084,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm prioritizes immediate distance (60-50% weight) while dynamically adjusting weights for centrality (30-10%) and connectivity penalties (0.2-0.1 weight) based on visited ratio. It balances exploration via lookahead depth (1-3 nodes) and penalizes high-connectivity nodes, with weights shifting toward global optimization as the tour progresses. The algorithm dynamically adjusts exploration factors and connectivity penalties, favoring immediate distance early but incorporating centrality and penalties later to refine the path.",
          "thought": "The new algorithm combines dynamic weight adjustment, immediate distance prioritization (60-50% weight), and reduced connectivity penalties (0.2-0.1 weight) with lookahead depth (3-1 nodes) and centrality-based scoring, while dynamically adjusting exploration factors based on visited ratio and penalizing high-connectivity nodes to balance local coverage and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - exploration_factor)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32251,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for TSP prioritizes immediate distance and node centrality in early stages (high immediate_weight and centrality_weight) while gradually shifting to lookahead and connectivity-aware selection as the search progresses (adjusting exploration_factor, lookahead_weight, and connectivity_factor). The algorithm dynamically balances these factors using visited_ratio and exploration progress, with penalties applied when neighbors are too close to avoid suboptimal paths. The score calculation combines immediate distance, lookahead potential, centrality, and connectivity to select the next node.",
          "thought": "The new algorithm focuses on aggressive early-stage optimization with high initial weight on immediate distance and centrality, gradually shifting to lookahead and connectivity-aware selection, while dynamically adjusting weights based on visited ratio and exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.1 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.5 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.3 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60-50% weight) early but dynamically adjusts weights based on progress, balancing exploration via lookahead depth (1-5 nodes) and centrality (30-10% weight) while penalizing high-connectivity nodes and shifting toward global optimization as the tour progresses. It dynamically adjusts weights (e.g., immediate_weight, centrality_weight, penalty_weight) based on visited_ratio and exploration_factor, while connectivity_factor and penalty terms further refine node selection.",
          "thought": "The new algorithm prioritizes immediate distance (60-50% weight) early, dynamically balances exploration via lookahead depth (1-5 nodes) and centrality (30-10% weight), while penalizing high-connectivity nodes and shifting toward global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - exploration_factor)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32415,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
          "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60-45% weight) with adaptive weighting, balances lookahead connectivity (35-15% weight) and centrality (40-20% weight), and applies dynamic penalties for high connectivity and exploration factors, adjusting exploration vs. exploitation based on visited ratio. It uses a multi-stage scoring mechanism with connectivity factors and penalties to guide node selection toward optimal local and global paths.",
          "thought": "The new algorithm integrates dynamic weight adjustment for immediate distance, lookahead connectivity, and centrality, with adaptive penalties for high connectivity and exploration factors that prioritize local optimization early while balancing global connectivity later, using a multi-stage scoring mechanism that combines immediate distance, lookahead differences, and centrality with adaptive weights and penalties based on visited ratio and remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.4 * (1.0 - lookahead_weight)\n        penalty_weight = 0.25 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with multi-factor scoring, prioritizing immediate distance (60-90% weight early) and lookahead depth (reduced as nodes remain), while penalizing high-connectivity nodes to balance local coverage and global connectivity. It dynamically adjusts weights based on remaining nodes and applies penalties to avoid clustering, with centrality and connectivity given progressively lower emphasis as the search progresses. The exploration factor and visited ratio further refine node selection by favoring local exploration early and global optimization later.",
          "thought": "The new algorithm combines dynamic weight adjustment with multi-factor scoring, balancing immediate distance (60-90% weight early), lookahead depth (reduced as nodes remain), centrality (lower weight), connectivity (penalized for high connectivity), and progressive exploration factor to favor local coverage early and global connectivity later, while dynamically adjusting weights based on remaining nodes and applying penalties for high-connectivity nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.8\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3461,
          "other_inf": null
     }
]