{
     "algorithm": "The algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early (with `immediate_weight` decreasing as exploration progresses) while adaptively balancing lookahead (nearest neighbors), centrality (node average distance), and connectivity (local density) via weights that adjust based on `exploration_factor` and `visited_ratio`. The scoring function penalizes nodes with poor connectivity and high centrality, while rewarding those with shorter immediate distances and better lookahead potential. The weights dynamically shift focus from local optimization to global connectivity as the tour progresses.",
     "thought": "The new algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead, centrality, and connectivity penalties, with a stronger emphasis on balancing global connectivity and local optimization via exploration_factor and visited_ratio.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.6 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.29321,
     "other_inf": null
}