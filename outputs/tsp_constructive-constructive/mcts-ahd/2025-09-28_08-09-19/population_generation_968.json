[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early (with `immediate_weight` decreasing as exploration progresses) while adaptively balancing lookahead (nearest neighbors), centrality (node average distance), and connectivity (local density) via weights that adjust based on `exploration_factor` and `visited_ratio`. The scoring function penalizes nodes with poor connectivity and high centrality, while rewarding those with shorter immediate distances and better lookahead potential. The weights dynamically shift focus from local optimization to global connectivity as the tour progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with enhanced connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead, centrality, and connectivity penalties, with a stronger emphasis on balancing global connectivity and local optimization via exploration_factor and visited_ratio.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.15 * exploration_factor\n        lookahead_weight = 0.35 * (1.0 - exploration_factor)\n        centrality_weight = 0.6 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.29321,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic balances immediate distance (50% weight) with dynamic centrality (30% weight) and connectivity penalties (20% weight), adjusting weights based on progress (visited_ratio) and using lookahead (nearest neighbors) to refine decisions, while penalizing nodes with poor local connectivity. The algorithm prioritizes proximity but adapts its focus on centrality and connectivity as the tour progresses, using a dynamic scaling factor for refined decisions.",
          "thought": "This new algorithm combines the balanced approach of No.1 (distance and connectivity), the dynamic weight adjustment of No.2 (60-40% weights), the connectivity penalty of No.3 (0.3 weight), and the exploration factor of No.4 (1.0-0.7 scaling) to create a hybrid heuristic that prioritizes immediate distance (50% weight) while dynamically adjusting centrality (30% weight) and connectivity penalties (20% weight) based on visited ratio, with lookahead depth scaling for refined decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.7)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30638,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP dynamically balances immediate distance, node connectivity, and path history by adjusting weights based on progress (visited_ratio) and incorporating a lookahead mechanism that evaluates short-term neighbors while penalizing detours. It prioritizes immediate distance early (weight 0.6) but shifts focus to connectivity and centrality (weights 0.25) as the tour progresses, with penalties (weight 0.15) increasing for long-term inefficiencies. The algorithm adapts by reducing lookahead depth and increasing penalty weights as fewer nodes remain.",
          "thought": "The new algorithm modifies the scoring system by incorporating a dynamic penalty based on node centrality and path history, with adaptive weights for immediate distance, connectivity, and detour avoidance, while introducing a novel lookahead mechanism that evaluates multiple potential paths to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n            node_centrality = avg_distance\n            lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 2\n            nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n            path_history_penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n            avg_neighbor_distance = 0\n            path_history_penalty = 0\n\n        connectivity_factor = 1.0 + (connectivity / (remaining_count + 1e-6)) * 0.4\n        immediate_weight = 0.6 - 0.2 * visited_ratio\n        centrality_weight = 0.25 * (0.6 + 0.2 * visited_ratio)\n        penalty_weight = 0.15 * (0.5 + 0.3 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio) + (0.3 * path_history_penalty / (immediate_distance + 1e-6)) * visited_ratio\n        score *= penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
          "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weight 0.7, decreasing as the tour progresses) but balances it with node centrality (weight 0.2, increasing) and connectivity (weight 0.1), while penalizing long-term inefficiencies (weight 0.3, increasing). It adapts dynamically by adjusting lookahead depth and penalty weights based on remaining nodes, favoring closer, central, and well-connected nodes early but refining choices as the tour nears completion.",
          "thought": "The new algorithm prioritizes immediate distance early (weight 0.7) but shifts focus to node centrality (weight 0.2) and connectivity (weight 0.1) as the tour progresses, with penalties (weight 0.3) increasing for long-term inefficiencies. It adapts by increasing lookahead depth and reducing penalty weights as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.3 * avg_distance)\n            node_centrality = avg_distance\n            lookahead_depth = min(3, remaining_count) if remaining_count > 2 else 1\n            nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n            path_history_penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n            avg_neighbor_distance = 0\n            path_history_penalty = 0\n\n        connectivity_factor = 1.0 + (connectivity / (remaining_count + 1e-6)) * 0.5\n        immediate_weight = 0.7 - 0.3 * visited_ratio\n        centrality_weight = 0.2 * (0.5 + 0.3 * visited_ratio)\n        penalty_weight = 0.3 * (0.4 + 0.2 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (node_centrality * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio) + (0.2 * path_history_penalty / (immediate_distance + 1e-6)) * visited_ratio\n        score *= penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with refined centrality and connectivity scoring, prioritizing immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing) while using lookahead and scaling factors to balance short-term and long-term decisions. Weights are adjusted based on visited ratio, and penalties avoid clustering by penalizing nodes with high average neighbor distances. The score calculation integrates immediate distance, centrality, and connectivity, dynamically adjusted for remaining nodes and visited progress.",
          "thought": "This new algorithm combines the dynamic weight adjustment of No.2 with the refined centrality and connectivity scoring of No.1, using immediate distance (50% early, decreasing), centrality (30% early, increasing), and connectivity penalties (20% early, increasing), with dynamic lookahead and scaling factors to balance short-term and long-term decisions while avoiding clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            connectivity = 0\n            node_centrality = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * (0.2 + 0.1 * visited_ratio)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (0.5 + 0.2 * visited_ratio)\n        penalty_weight = 0.2 * (0.5 + 0.3 * visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by 0.65\u20130.45) while balancing centrality (0.55\u20130.35) and connectivity (0.4\u20130.85), with dynamic weights adjusting based on exploration progress and visited ratio. It uses adaptive lookahead (depth 1\u20135) to estimate future steps, penalizing high-density regions more as the tour progresses. The score function combines immediate, lookahead, and penalty terms to select the next node, favoring closer, centralized, and well-connected nodes early, shifting toward efficiency as the tour completes.",
          "thought": "This new algorithm integrates dynamic weight adjustment, adaptive exploration factors, enhanced connectivity penalties, and multi-stage lookahead with variable depth, while balancing immediate distance, centrality, and connectivity through progressively shifting weights and penalties that scale with visited ratio and exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.25 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(5, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.65 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.55 * (1.0 - lookahead_weight)\n        penalty_weight = 0.45 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.55 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead and centrality, with penalties for highly connected nodes to prevent clustering. It balances immediate distance (weighted higher early) with lookahead and centrality (weighted lower initially) and adjusts penalties based on visited ratio. Key variables: `immediate_weight` (prioritized early), `lookahead_weight` and `centrality_weight` (lower priority initially), `penalty_weight` (scales with visited ratio).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity penalty and exploration factor refinement of No.1, using a balanced scoring mechanism that prioritizes immediate distance early while incorporating lookahead and centrality adaptively, with penalties for highly connected nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32084,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines three key factors\u2014immediate distance (50% weight), centrality (30% weight), and connectivity penalties (20% weight)\u2014with dynamic adjustments based on progress (e.g., higher weights for distance early on, penalties for poor connectivity). It balances greedy selection with lookahead (up to 3 nodes) and penalizes nodes with poor local connectivity, favoring those that minimize a weighted sum of distances and connectivity factors. The weights and penalties are adjusted based on the fraction of remaining nodes, ensuring adaptability throughout the search.",
          "thought": "This new algorithm combines the best features of all five algorithms by dynamically balancing immediate distance (50% weight), centrality (30% weight), and connectivity penalties (20% weight), with weights adjusted based on progress and lookahead depth (1-3 nodes), while incorporating penalties for poor local connectivity and favoring nodes that minimize the weighted sum of distances and connectivity factors.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.5 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - (remaining_count / total_nodes) * 0.8)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32115,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm prioritizes immediate distance (60-50% weight) while dynamically adjusting weights for centrality (30-10%) and connectivity penalties (0.2-0.1 weight) based on visited ratio. It balances exploration via lookahead depth (1-3 nodes) and penalizes high-connectivity nodes, with weights shifting toward global optimization as the tour progresses. The algorithm dynamically adjusts exploration factors and connectivity penalties, favoring immediate distance early but incorporating centrality and penalties later to refine the path.",
          "thought": "The new algorithm combines dynamic weight adjustment, immediate distance prioritization (60-50% weight), and reduced connectivity penalties (0.2-0.1 weight) with lookahead depth (3-1 nodes) and centrality-based scoring, while dynamically adjusting exploration factors based on visited ratio and penalizing high-connectivity nodes to balance local coverage and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    visited_ratio = 1 - (remaining_count / total_nodes)\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        else:\n            avg_distance = 0\n            node_centrality = 0\n            connectivity = 0\n\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.2\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 - 0.1 * visited_ratio\n        centrality_weight = 0.3 * (1.0 - exploration_factor)\n        penalty_weight = 0.2 * (1 - visited_ratio)\n\n        score = immediate_weight * (immediate_distance - avg_distance) + centrality_weight * (immediate_distance * connectivity_factor)\n        penalty = 1 + (0.4 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32251,
          "other_inf": null
     }
]