{
     "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
     "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.33829,
     "other_inf": null
}