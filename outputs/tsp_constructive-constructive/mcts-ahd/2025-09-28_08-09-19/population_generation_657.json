[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
          "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with shorter immediate distances while balancing them with higher average distances to remaining unvisited nodes, using a dynamic lookahead depth (up to 3 or half of remaining nodes) to avoid excessive computation. The score is a weighted combination (70% for the distance-average difference, 30% for immediate distance), ensuring a trade-off between immediate and long-term benefits. The code efficiently handles edge cases (empty unvisited nodes) and dynamically adjusts lookahead depth based on remaining nodes.",
          "thought": "The new algorithm combines the balanced scoring of No.1 (distance_to_current - avg_distance) with the weighted immediate/lookahead approach of No.2, using a dynamic lookahead depth (up to 3 or half of remaining nodes) and a score that prioritizes nodes with lower immediate distance and higher average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        # Dynamic lookahead depth based on remaining nodes (up to 3 or half the remaining count)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n\n        # Weighted score: 70% of (distance_to_current - avg_distance), 30% of immediate_distance\n        score = 0.7 * (immediate_distance - avg_distance) + 0.3 * immediate_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, lookahead depth, and node centrality. Immediate distance is prioritized (60% weight) with exploration/exploitation tradeoff, while lookahead (40% weight) and centrality (50% weight) refine choices based on remaining nodes. The lookahead depth dynamically adjusts (up to 3 levels) to estimate future costs, and centrality penalizes nodes far from unvisited nodes, ensuring a tradeoff between proximity and global coverage.",
          "thought": "The new algorithm combines the dynamic lookahead depth and exploration/exploitation balance from No.1 with the distance-average difference and immediate distance weighting from No.2, while adding node centrality as a penalty to prioritize nodes that are central to the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.39988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, lookahead connectivity, and node popularity with adaptive weights, prioritizing immediate distance (60-90%) and lookahead (10-40%) based on exploration progress, while penalizing distant nodes and less central nodes (20-50% weight). It dynamically adjusts lookahead depth (up to 3) and balances exploration/exploitation via exploration_factor. The score is minimized to select the next node, ensuring a trade-off between short-term and long-term optimality.",
          "thought": "This new algorithm combines the weighted scoring from No.1 and No.2 with dynamic lookahead depth and popularity-based selection from No.3, while adding adaptive weights based on exploration progress and a penalty for distant nodes, ensuring a balance between immediate distance, future connectivity, and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.5 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.5 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40888,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (50% weight), variable-depth lookahead (30% weight, decreasing with exploration progress), and node popularity (20% weight, increasing with exploration progress), while penalizing nodes far from the destination. It adapts weights dynamically based on remaining unvisited nodes and prioritizes shorter-term gains early, shifting toward long-term optimization as exploration progresses. The lookahead depth adjusts based on remaining nodes, and centrality penalizes nodes that are too distant from the destination.",
          "thought": "The new algorithm combines dynamic lookahead with a weighted balance between immediate distance (50% weight), variable-depth lookahead (30%), and node popularity (20%), while adapting weights based on exploration progress and penalizing nodes far from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + 2 * node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.3 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.3 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60% weight) with dynamic lookahead (25% weight, depth proportional to remaining nodes) and node popularity (15% weight, based on centrality), while penalizing nodes far from the destination (30% weight) and adjusting weights based on exploration progress. It balances short-term and long-term considerations, with exploration factor modulating the importance of lookahead and popularity. The lookahead depth scales with remaining nodes (max 5), and centrality is calculated as average distance to unvisited nodes.",
          "thought": "The new algorithm prioritizes immediate distance with a fixed weight, emphasizes dynamic lookahead with depth proportional to remaining nodes, and incorporates node popularity based on average distance to unvisited nodes, while penalizing nodes far from the destination and adjusting weights based on exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + 2 * node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        lookahead_weight = 0.25 * (1.0 - exploration_factor)\n        popularity_weight = 0.15 * exploration_factor\n        penalty_weight = 0.3 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.3 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.42886,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance reduction (via `distance_to_current`) while dynamically balancing local and global choices using a decaying weight (`time_decay`) and connectivity penalties (via `avg_neighbor_distance` and `penalty`). It refines selections with nearest-neighbor refinements (top 3 neighbors) and adjusts weights (`weight_factor`) to favor local choices early and global connectivity later, with higher priority given to minimizing immediate distance and penalizing highly connected nodes.",
          "thought": "The new algorithm prioritizes immediate distance reduction with a dynamic exploration-exploitation trade-off, using a decaying weight to balance local distance and global connectivity, while penalizing nodes with high connectivity and incorporating nearest-neighbor refinements to refine choices later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 0.5)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - 0.7 * avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(3, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.4 + 0.6 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * (0.8 * avg_neighbor_distance)\n\n            penalty = 1 + (0.5 * avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.3 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43045,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines adaptive lookahead (up to 4 steps) with dynamic weights, prioritizing immediate distance (50-80%), lookahead connectivity (20-50%), node popularity (10-30%), and penalties (10-40%). It balances local and global considerations using an exploration factor that adjusts weights based on remaining nodes, while centrality (average and minimum distances) influences node popularity and penalties. The score function dynamically trades off these factors to select the next node.",
          "thought": "This new algorithm combines adaptive lookahead depth (up to 4 steps) with dynamic weights (immediate distance: 50-80%, lookahead: 20-50%, popularity: 10-30%, penalty: 10-40%), where weights adjust based on exploration progress and node centrality is calculated using both average and minimum distances to unvisited nodes. The score balances immediate distance, long-term connectivity, node popularity, and penalties for distant nodes, with exploration_factor controlling the trade-off between local and global considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.6\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 3 else 2\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        avg_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        min_centrality = min(distance_matrix[node][n] for n in unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + 0.5 * avg_centrality + 0.5 * min_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5 + 0.3 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.4 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.4 * avg_centrality + 0.6 * min_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43124,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines immediate distance (70-80% weight), dynamic lookahead (20-30% weight), and node popularity (10% weight), with exploration progress modulating weights. It penalizes distant nodes and less central nodes (30-40% weight) to balance short-term and long-term considerations, dynamically adjusting weights based on remaining unvisited nodes. The lookahead depth (up to 4) evaluates potential future steps, while penalties discourage suboptimal choices, making it adaptive to different exploration stages.",
          "thought": "The new algorithm combines immediate distance (70-80% weight), dynamic lookahead (20-30% weight, depth up to 4), and node popularity (10% weight), with exploration progress modulating weights. It penalizes distant nodes and less central nodes (30-40% weight) and balances short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.6\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(4, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.7 + 0.1 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        popularity_weight = 0.1 * exploration_factor\n        penalty_weight = 0.4 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.4 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.44135,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance to current node) and long-term connectivity (node's connections to unvisited nodes), with connectivity weighted more heavily as the number of remaining nodes decreases. It prioritizes nodes that are closer to the current node but also have strong connections to other unvisited nodes, adjusting the balance dynamically. The score calculation combines distance and connectivity, favoring nodes with lower scores.",
          "thought": "The new algorithm combines the score calculation from No.1 (distance_to_current - avg_distance) with the dynamic connectivity weighting from No.2, creating a hybrid approach that balances immediate proximity and long-term connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance_to_unvisited)\n        connectivity_weight = 1.0 + (1.0 - (remaining_nodes / total_nodes)) * (connectivity / (total_nodes - 1)) * 0.5\n\n        score = (distance_to_current - avg_distance_to_unvisited) * connectivity_weight\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45301,
          "other_inf": null
     }
]