def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1
    scores = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if remaining_nodes:
            remaining_distances = [distance_matrix[node][n] for n in remaining_nodes]
            avg_distance = sum(remaining_distances) / len(remaining_distances)
            variance_penalty = sum((d - avg_distance) ** 2 for d in remaining_distances) / len(remaining_distances)
        else:
            avg_distance = 0
            variance_penalty = 0

        # Dynamic weight based on remaining nodes (higher weight for immediate distance when few nodes left)
        weight_immediate = 0.5 if remaining_count < 5 else 0.3
        score = weight_immediate * immediate_distance + 0.5 * (immediate_distance - avg_distance) + 0.2 * variance_penalty

        scores.append((node, score))

    # Temperature-based softmax selection (higher temperature for early stages)
    temperature = 1.0 if remaining_count > 10 else 0.5
    exp_scores = [math.exp(-score / temperature) for _, score in scores]
    probabilities = [exp / sum(exp_scores) for exp in exp_scores]

    # Select node with probability proportional to its score
    next_node = numpy.random.choice([node for node, _ in scores], p=probabilities)

    return next_node
