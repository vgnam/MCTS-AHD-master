def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    exploration_factor = 1.0 / (1.0 + remaining_nodes)  # Decreases as more nodes are visited
    exploitation_factor = 1.0 - exploration_factor

    scores = []
    total_utility = 0.0

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        max_distance = max(distance_to_current, distance_to_destination, 1.0)
        normalized_current = distance_to_current / max_distance
        normalized_destination = distance_to_destination / max_distance

        node_significance = 1.0 / (1.0 + distance_to_destination)  # Higher for nodes closer to destination
        utility = (exploitation_factor * normalized_current) + (exploration_factor * normalized_destination * node_significance)

        score = math.exp(-utility)  # Convert utility to probability-like score
        scores.append(score)
        total_utility += score

    # Normalize scores to probabilities
    probabilities = [score / total_utility for score in scores]

    # Select node based on probabilities
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]

    return next_node
