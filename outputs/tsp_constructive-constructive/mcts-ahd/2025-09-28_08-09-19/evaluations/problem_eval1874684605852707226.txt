def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    candidates = []
    scores = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = 0

        # Dynamic lookahead depth using geometric distribution (mean=2)
        lookahead_depth = min(3, max(1, int(np.random.geometric(1/2))))
        remaining_nodes = unvisited_nodes - {node}

        if remaining_nodes:
            current = node
            for _ in range(min(lookahead_depth, 2)):
                if not remaining_nodes:
                    break
                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])
                lookahead_distance += distance_matrix[current][next_candidate]
                current = next_candidate
                remaining_nodes -= {next_candidate}

        # Weighted score with dynamic temperature (decreases as remaining nodes decrease)
        temperature = max(0.1, 1.0 - (1.0 / remaining_count))
        score = (0.7 * immediate_distance + 0.3 * lookahead_distance) / temperature
        candidates.append(node)
        scores.append(score)

    # Probabilistic selection based on scores
    probabilities = np.exp(-np.array(scores))
    probabilities = probabilities / np.sum(probabilities)
    next_node = np.random.choice(candidates, p=probabilities)

    return next_node
