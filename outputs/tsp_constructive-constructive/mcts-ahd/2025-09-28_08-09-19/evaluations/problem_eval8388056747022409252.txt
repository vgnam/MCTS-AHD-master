def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = float('inf')
    remaining_count = len(unvisited_nodes)

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        short_term_score = 0
        long_term_score = 0

        # Short-term lookahead (next 2 steps)
        remaining_nodes = unvisited_nodes - {node}
        if remaining_nodes:
            next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[node][x])
            short_term_score = distance_matrix[node][next_candidate]
            remaining_nodes -= {next_candidate}

            if remaining_nodes:
                next_next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[next_candidate][x])
                short_term_score += distance_matrix[next_candidate][next_next_candidate]

        # Long-term lookahead (distance to destination)
        long_term_score = distance_matrix[node][destination_node]

        # Dynamic weight based on remaining nodes
        weight = 0.7 if remaining_count > 4 else 0.5
        score = (1 - weight) * immediate_distance + weight * (0.6 * short_term_score + 0.4 * long_term_score)

        if score < best_score:
            best_score = score
            next_node = node

    return next_node
