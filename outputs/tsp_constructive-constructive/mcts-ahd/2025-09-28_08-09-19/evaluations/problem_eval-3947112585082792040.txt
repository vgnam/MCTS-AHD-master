def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = float('inf')
    total_nodes = len(unvisited_nodes) + 1
    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)

    # Calculate average path length so far
    if visited_ratio > 0:
        avg_path_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    else:
        avg_path_length = 0

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]

        # Calculate normalized connectivity metric
        if len(unvisited_nodes) == 1:
            connectivity = 0
        else:
            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(3, len(unvisited_nodes)-1)]
            connectivity = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors)
            connectivity /= (avg_path_length + 1e-6)  # Normalize by current path length

        # Dynamic threshold based on visited ratio
        threshold = 1.0 + 0.5 * (1 - visited_ratio)

        # Score combines distance and connectivity with dynamic weighting
        weight_factor = 0.6 + 0.4 * visited_ratio
        score = (weight_factor * distance_to_current +
                (1 - weight_factor) * connectivity)

        # Penalize nodes that are too close to others
        if connectivity < threshold:
            score *= 1.2

        if score < best_score:
            best_score = score
            next_node = node

    # Early exploration: with probability proportional to unvisited ratio
    if len(unvisited_nodes) > 3 and visited_ratio < 0.7:
        exploration_prob = 0.3 * (1 - visited_ratio)
        if random.random() < exploration_prob:
            next_node = random.choice(unvisited_nodes)

    return next_node
