import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_weight = 0.0
    weights = []
    base_weight = 0.5

    # Dynamic weight adjustment using sigmoid function
    sigmoid_input = (remaining_nodes - 5) / 5  # Adjust midpoint and steepness as needed
    dynamic_weight = 1 / (1 + math.exp(-sigmoid_input))

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Weighted combination of distances
        combined_distance = (base_weight * distance_to_current) + ((1 - base_weight) * distance_to_destination)
        combined_distance = combined_distance * (1 + dynamic_weight)  # Adjust based on remaining nodes

        # Inverse weight for selection probability
        weight = 1.0 / (combined_distance + 1e-6)  # Small epsilon to avoid division by zero
        weights.append(weight)
        total_weight += weight

    # Normalize weights to probabilities
    probabilities = [w / total_weight for w in weights]

    # Select node based on weighted probability
    import random
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]

    return next_node
