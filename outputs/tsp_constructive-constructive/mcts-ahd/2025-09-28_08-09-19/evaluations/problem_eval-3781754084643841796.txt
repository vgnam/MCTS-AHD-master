def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_score = float('inf')
    remaining_count = len(unvisited_nodes)

    # Track historical variance (simplified for example)
    history_window = min(4, remaining_count // 3) if remaining_count > 3 else 1
    historical_distances = [distance_matrix[current_node][n] for n in unvisited_nodes if n in unvisited_nodes]
    avg_historical = sum(historical_distances) / len(historical_distances) if historical_distances else 0
    variance_historical = sum((d - avg_historical) ** 2 for d in historical_distances) / len(historical_distances) if historical_distances else 0

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        # Dynamic penalty based on variance from historical average
        deviation_penalty = 1.0 + (immediate_distance / (avg_historical + 1e-6) - 1.0) * 0.6

        # Connectivity bonus: favor nodes with many nearby neighbors
        avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0
        connectivity_bonus = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.2 * avg_distance) / remaining_count

        # Symmetry penalty: penalize nodes that disrupt path symmetry
        symmetry_penalty = 1.0
        if remaining_count > 1:
            symmetry_penalty = 1.0 + (max(distance_matrix[node][n] for n in remaining_nodes) - min(distance_matrix[node][n] for n in remaining_nodes)) / (avg_distance + 1e-6)

        # Combined score with adjusted weights
        score = (immediate_distance * deviation_penalty) + (1.0 - connectivity_bonus) * 0.4 + symmetry_penalty * 0.3

        if score < min_score:
            min_score = score
            next_node = node

    return next_node
