def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    total_nodes = remaining_count + 1
    exploration_progress = 1.0 - (remaining_count / total_nodes)
    temperature = max(0.1, 1.0 - exploration_progress * 1.5)

    potential_fields = []
    max_potential = -float('inf')

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]

        # Potential field calculation
        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * immediate_distance)
        potential = immediate_distance * (1.0 - connectivity / total_nodes)

        # Dynamic weight adjustment
        exploration_factor = 0.5 + 0.5 * exploration_progress
        exploitation_factor = 1.0 - exploration_factor

        # Temperature-adjusted selection
        adjusted_potential = potential * (exploration_factor + exploitation_factor * (1.0 / (1.0 + math.exp(-potential / temperature))))

        potential_fields.append((node, adjusted_potential))
        if adjusted_potential > max_potential:
            max_potential = adjusted_potential

    # Probabilistic selection with softmax
    exp_potentials = [math.exp(p / temperature) for (_, p) in potential_fields]
    sum_exp = sum(exp_potentials)
    probabilities = [e / sum_exp for e in exp_potentials]

    next_node = random.choices([n for (n, _) in potential_fields], weights=probabilities, k=1)[0]

    return next_node
