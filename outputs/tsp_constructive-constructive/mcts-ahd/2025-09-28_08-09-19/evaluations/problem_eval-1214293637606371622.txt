def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    total_nodes = remaining_count + 1
    visited_ratio = 1 - (remaining_count / total_nodes)

    node_scores = []
    base_weights = {
        'immediate': max(0.3, 0.7 - 0.4 * visited_ratio),
        'connectivity': min(0.5, 0.2 + 0.3 * visited_ratio),
        'centrality': min(0.4, 0.1 + 0.25 * visited_ratio),
        'penalty': max(0.1, 0.25 * (1 - visited_ratio))
    }

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if remaining_nodes:
            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)
            connectivity = sum(1 for n in remaining_nodes if distance_matrix[node][n] < 1.3 * avg_distance)
            node_centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)
            lookahead_depth = max(2, min(5, remaining_count // 3))
            nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth]
            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0
            path_history_penalty = sum(distance_matrix[current_node][n] for n in remaining_nodes) / len(remaining_nodes)
        else:
            avg_distance = immediate_distance
            connectivity = 0
            node_centrality = 0
            avg_neighbor_distance = 0
            path_history_penalty = 0

        connectivity_factor = 1.0 + (connectivity / (remaining_count + 1e-6)) * 0.5
        centrality_factor = 1.0 + (1.0 / (1.0 + node_centrality)) * 0.3

        score = (base_weights['immediate'] * immediate_distance +
                base_weights['connectivity'] * (immediate_distance * connectivity_factor) +
                base_weights['centrality'] * (immediate_distance * centrality_factor))
        penalty = 1 + (base_weights['penalty'] * (0.4 * avg_neighbor_distance +
                                                 0.6 * path_history_penalty) / (immediate_distance + 1e-6))
        adjusted_score = score * penalty

        node_scores.append((adjusted_score, node))

    if node_scores:
        probabilities = [1.0 / (score + 1e-6) for score, _ in node_scores]
        total_prob = sum(probabilities)
        normalized_probs = [p / total_prob for p in probabilities]
        next_node = random.choices([node for _, node in node_scores], weights=normalized_probs, k=1)[0]
        return next_node
    return next_node
