def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = -float('inf')
    total_nodes = len(unvisited_nodes) + 1
    visited_history = set()

    # Calculate dynamic weights based on path progress
    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes
    proximity_weight = 1.0 - 0.3 * progress_ratio
    connectivity_weight = 0.5 + 0.5 * progress_ratio
    efficiency_weight = 0.3 + 0.2 * progress_ratio

    for node in unvisited_nodes:
        # Proximity score: inverse distance with dynamic adjustment
        distance_to_current = distance_matrix[current_node][node]
        proximity_score = 1.0 / (distance_to_current + 1e-6) * proximity_weight

        # Connectivity score: number of nearby unvisited nodes
        local_connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * distance_to_current)
        connectivity_score = local_connectivity / (total_nodes - 1) * connectivity_weight

        # Efficiency score: reduction in average remaining distances
        remaining_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        avg_remaining_distance = sum(remaining_distances) / (len(remaining_distances) + 1e-6)
        efficiency_score = (1.0 - avg_remaining_distance / (distance_to_current + 1e-6)) * efficiency_weight

        # Novelty factor: penalize frequently visited nodes
        novelty_factor = 1.0 if node not in visited_history else 0.7

        # Combined score with adaptive weights
        total_score = (proximity_score + connectivity_score + efficiency_score) * novelty_factor

        if total_score > best_score:
            best_score = total_score
            next_node = node

    # Update visited history for novelty factor
    if next_node:
        visited_history.add(next_node)

    return next_node
