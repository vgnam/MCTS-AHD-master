def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    candidates = []
    scores = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]

        # Dynamic lookahead depth based on remaining nodes (up to 4 or 1/3 of remaining count)
        lookahead_depth = min(4, remaining_count // 3) if remaining_count > 3 else 1
        remaining_nodes = unvisited_nodes - {node}

        if remaining_nodes:
            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)
            # Additional lookahead: average distance to remaining nodes after one step
            if lookahead_depth > 1:
                second_level_avg = sum(
                    sum(distance_matrix[n][m] for m in remaining_nodes - {n}) / (len(remaining_nodes) - 1)
                    for n in remaining_nodes
                ) / len(remaining_nodes)
                avg_distance = 0.6 * avg_distance + 0.4 * second_level_avg
        else:
            avg_distance = 0

        # Novel scoring: exponential decay of immediate distance and inverse of avg distance
        score = (immediate_distance ** 0.7) * (1 / (1 + avg_distance))
        scores.append(score)
        candidates.append(node)

    # Probabilistic selection with softmax-like weights
    if scores:
        # Normalize scores to probabilities
        exp_scores = [math.exp(-s) for s in scores]
        total = sum(exp_scores)
        probs = [s / total for s in exp_scores]
        next_node = random.choices(candidates, weights=probs, k=1)[0]
    else:
        next_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])

    return next_node
