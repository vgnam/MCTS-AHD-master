def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)

    # Calculate path history diversity factor
    if hasattr(select_next_node, 'path_history'):
        select_next_node.path_history.append(current_node)
    else:
        select_next_node.path_history = [current_node]

    history_diversity = len(set(select_next_node.path_history)) / len(select_next_node.path_history) if select_next_node.path_history else 1.0

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        if remaining_nodes == 1:
            score = -distance_to_current - distance_to_destination
        else:
            # Calculate node diversity (inverse of distance variance)
            distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
            mean_distance = sum(distances) / len(distances) if distances else 0
            variance = sum((d - mean_distance) ** 2 for d in distances) / len(distances) if distances else 0
            diversity = 1.0 / (1.0 + variance) if variance > 0 else 1.0

            # Calculate connectivity with adaptive threshold
            avg_distance = sum(distances) / len(distances) if distances else 0
            connectivity = sum(1 for d in distances if d < 1.1 * avg_distance) / len(distances) if distances else 0

            # Dynamic weights with reinforcement learning-inspired adaptation
            diversity_weight = 0.3 * (1.0 - history_diversity)
            immediate_weight = 0.4 + 0.2 * (1.0 - history_diversity)
            connectivity_weight = 0.3 * history_diversity

            # Path history penalty
            history_penalty = 0.2 * (1.0 - connectivity_weight) * (1.0 - diversity) if node in select_next_node.path_history else 0

            # Score combines weighted components with penalties
            score = (immediate_weight * (-distance_to_current) +
                     diversity_weight * diversity +
                     connectivity_weight * connectivity) - history_penalty

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
