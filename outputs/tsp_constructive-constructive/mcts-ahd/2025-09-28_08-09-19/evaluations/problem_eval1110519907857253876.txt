def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_score = float('inf')
    remaining_nodes = len(unvisited_nodes)
    total_nodes = remaining_nodes + 1

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]

        # Calculate proximity diversity: reward nodes with balanced distances to others
        sorted_distances = sorted(distance_matrix[node][n] for n in unvisited_nodes if n != node)
        diversity = sum(abs(sorted_distances[i] - sorted_distances[i-1]) for i in range(1, len(sorted_distances))) if len(sorted_distances) > 1 else 0

        # Dynamic connectivity weight: increases with problem progress
        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * distance_to_current)
        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * (1.0 - remaining_nodes / total_nodes)

        # Hub impact: penalize nodes that are too central to avoid bottlenecks
        hub_penalty = 1.0 + (sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 0.8 * distance_to_current) / (total_nodes - 1)) * 0.5

        # Combined score with dynamic weight
        weight = 1.0 + (remaining_nodes / total_nodes) * connectivity_factor * hub_penalty
        score = (distance_to_current + diversity) * weight

        if score < min_score:
            min_score = score
            next_node = node

    return next_node
