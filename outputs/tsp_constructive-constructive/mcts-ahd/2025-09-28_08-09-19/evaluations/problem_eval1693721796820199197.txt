def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_score = float('inf')
    remaining_count = len(unvisited_nodes)

    # Path momentum: favor nodes that align with recent direction changes
    momentum_weight = 0.4 if remaining_count > 2 else 0.1
    recent_nodes = list(unvisited_nodes)[:2] if len(unvisited_nodes) > 2 else [current_node]

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        # Centrality metric: average distance to remaining unvisited nodes
        centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0

        # Path momentum: cosine similarity between current path and potential path
        if len(recent_nodes) > 1:
            vec_current = (distance_matrix[current_node][recent_nodes[0]], distance_matrix[recent_nodes[0]][recent_nodes[1]])
            vec_potential = (distance_matrix[current_node][node], distance_matrix[node][recent_nodes[0]])
            dot_product = vec_current[0] * vec_potential[0] + vec_current[1] * vec_potential[1]
            norm_current = (vec_current[0]**2 + vec_current[1]**2)**0.5
            norm_potential = (vec_potential[0]**2 + vec_potential[1]**2)**0.5
            momentum_score = dot_product / (norm_current * norm_potential + 1e-6) if norm_current > 0 and norm_potential > 0 else 0
        else:
            momentum_score = 0

        # Symmetry penalty: penalize nodes that disrupt path symmetry
        symmetry_penalty = 1.0
        if remaining_count > 1:
            symmetry_penalty = 1.0 + (max(distance_matrix[node][n] for n in remaining_nodes) - min(distance_matrix[node][n] for n in remaining_nodes)) / (centrality + 1e-6)

        # Combined score
        score = (immediate_distance * (1.0 - momentum_weight)) + (centrality * momentum_weight) + symmetry_penalty * 0.3

        if score < min_score:
            min_score = score
            next_node = node

    return next_node
