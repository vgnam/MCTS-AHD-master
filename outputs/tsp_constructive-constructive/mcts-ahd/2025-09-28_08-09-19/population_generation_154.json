[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node (60% weight) with future average distances to unvisited nodes (30% weight, dynamically adjusted by remaining nodes) while penalizing nodes close to the destination to encourage exploration. The weight increases as remaining nodes decrease, prioritizing strategic choices later, and the penalty term discourages early visits to nodes near the destination. The score combines these factors to select the next node with the lowest cost.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate and future distance balancing from No.2, using a weight that increases as remaining nodes decrease to prioritize strategic choices later, while penalizing nodes close to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment, normalization, and decay factors to balance immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination. Immediate distance is prioritized (0.5 weight), followed by future average distance (0.3 weight with decay), and penalizes nodes close to the destination to avoid premature convergence. The weights adapt based on remaining nodes, with higher penalties for nodes near the destination to encourage exploration.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the normalization and decay factor from No.2, using a weighted score of immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n    dynamic_weight = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        max_distance = max(distance_to_current, distance_to_destination, 1.0)\n        normalized_current = distance_to_current / max_distance\n        normalized_future = avg_future_distance / max_distance if avg_future_distance > 0 else 0\n\n        decay_factor = 0.7 * (1.0 - dynamic_weight)\n        score = immediate_weight * normalized_current + future_weight * (normalized_future ** decay_factor) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50058,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with weighted score balancing, prioritizing closer nodes early by scaling weights inversely with the number of remaining nodes. It computes a score for each unvisited node based on the current distance to the node and the node's distance to the destination, using a power-weighted formula that balances proximity and strategic connections. The weight factor dynamically adjusts to favor proximity early and strategic connections later, with closer nodes receiving higher priority when few nodes remain.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the weighted score balancing from No.2, using a power-weighted score that prioritizes closer nodes early and strategic connections later, with the weight factor scaling inversely with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * weight_factor\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a ratio-based scoring mechanism (prioritizing nodes with better current-to-destination distance ratios) with a predicted path cost (balancing immediate distance, average future distances, and destination proximity), dynamically adjusting weights with `local_weight` (higher priority for future efficiency as nodes remain unvisited). The `predicted_path_cost` (60% future, 40% destination) and ratio (weighted by `local_weight`) are linearly combined to select the next node, ensuring a balance between short-term and long-term efficiency.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (balancing immediate distance, future average distance, and destination proximity) with the ratio-based scoring from No.2, using a local_weight to prioritize future efficiency as nodes remain unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / remaining_nodes if remaining_nodes > 0 else 0\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        predicted_path_cost = distance_to_current + 0.6 * avg_future_distance + 0.4 * distance_to_destination\n        score = local_weight * ratio + (1 - local_weight) * predicted_path_cost\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68362,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (distance to current node) and future efficiency (average future distances and distance to destination) by dynamically adjusting weights based on remaining nodes. It prioritizes minimizing the ratio of immediate distance to destination distance early on, while later focusing more on predicted path costs, with a weighted combination of these factors. The weight of these components is adjusted by `local_weight`, which increases as more nodes remain unvisited, favoring future efficiency in later stages.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring mechanism of No.2, dynamically balancing immediate proximity and future efficiency by adjusting weights based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            predicted_path_cost = distance_to_current + 0.7 * avg_future_distance + 0.3 * distance_to_destination\n\n            if distance_to_destination == 0:\n                ratio = float('inf')\n            else:\n                ratio = distance_to_current / distance_to_destination\n\n            local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n            score = local_weight * ratio + (1 - local_weight) * predicted_path_cost\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69376,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, node centrality (degree of connections to unvisited nodes), and destination proximity, with dynamic weights that prioritize centrality as the tour progresses while penalizing nodes too close to the destination. Immediate distance is weighted higher early in the tour, while centrality and destination proximity become more significant later, and nodes near the destination are penalized to avoid premature convergence. The score combines these factors multiplicatively, favoring nodes that minimize distance while maximizing connectivity and avoiding proximity to the destination.",
          "thought": "The new algorithm prioritizes nodes based on a combination of immediate distance, node centrality, and destination proximity, with dynamic weights that emphasize centrality as the tour progresses while penalizing nodes too close to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n    weight_factor = 1.0 - (1.0 / (1.0 + remaining_nodes))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate node degree (number of connections to unvisited nodes)\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n        degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.8\n\n        # Dynamic weights based on remaining nodes and degree\n        immediate_weight = (1.0 - weight_factor) * 0.7\n        centrality_weight = 0.3 + weight_factor * degree_factor\n        proximity_weight = 0.5 * (1.0 - weight_factor)\n\n        # Penalize nodes too close to destination\n        penalty = proximity_weight * (1.0 / (1.0 + distance_to_destination)) if degree > 0 else 0\n\n        # Calculate total score\n        score = -distance_to_current * immediate_weight + degree_factor * centrality_weight - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.78754,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local proximity** (distance from current node) with **global optimization** (average distance to remaining nodes), dynamically adjusting weights based on tour progress. It prioritizes immediate closeness (`immediate_weight`) while balancing long-term efficiency (`global_weight`), with a penalty for nodes too close to the destination (`penalty_weight`). The score calculation (`immediate_weight * distance_to_current - global_weight * avg_distance + penalty`) ensures a trade-off between short-term and long-term goals.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.2 with the balanced local-global proximity scoring from No.1, prioritizing nodes that are close to the current node while also maximizing average distances to remaining unvisited nodes, with weights adjusted based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n\n        # Dynamic weights based on remaining nodes\n        immediate_weight = (1.0 - weight_factor)\n        global_weight = 0.5 + weight_factor\n        penalty_weight = 0.3 * (1.0 - weight_factor)\n\n        # Penalize nodes too close to destination\n        penalty = penalty_weight * distance_to_destination if remaining_nodes > 1 else 0\n\n        # Calculate total score\n        score = immediate_weight * distance_to_current - global_weight * avg_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.7982,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing immediate distance from the current node, distance to the destination, and node centrality (degree), using a score that prioritizes central nodes early (higher degree_factor) and closer nodes later (lower weight). The scoring mechanism combines these factors to favor strategic early selections while optimizing for shorter paths as the tour progresses. The degree_factor adjusts weights based on node connectivity, while the weight dynamically shifts priority between immediate and long-term path considerations.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on node centrality and path history, using a novel scoring mechanism that combines immediate distance, destination distance, and node degree to prioritize strategic nodes early while favoring closer nodes later, with a score calculated as `(distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))`.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # Including current node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            # Calculate node degree (number of connections to unvisited nodes)\n            degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n            degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.5  # Normalize by max possible degree\n\n            # Dynamic weight based on remaining nodes and degree\n            weight = 1.0 + (remaining_nodes / total_nodes) * (1.0 / (1.0 + degree_factor))\n\n            # Novel scoring mechanism\n            score = (distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86761,
          "other_inf": null
     }
]