[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
          "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with shorter immediate distances while balancing them with higher average distances to remaining unvisited nodes, using a dynamic lookahead depth (up to 3 or half of remaining nodes) to avoid excessive computation. The score is a weighted combination (70% for the distance-average difference, 30% for immediate distance), ensuring a trade-off between immediate and long-term benefits. The code efficiently handles edge cases (empty unvisited nodes) and dynamically adjusts lookahead depth based on remaining nodes.",
          "thought": "The new algorithm combines the balanced scoring of No.1 (distance_to_current - avg_distance) with the weighted immediate/lookahead approach of No.2, using a dynamic lookahead depth (up to 3 or half of remaining nodes) and a score that prioritizes nodes with lower immediate distance and higher average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        # Dynamic lookahead depth based on remaining nodes (up to 3 or half the remaining count)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n\n        # Weighted score: 70% of (distance_to_current - avg_distance), 30% of immediate_distance\n        score = 0.7 * (immediate_distance - avg_distance) + 0.3 * immediate_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, lookahead connectivity, and node popularity with adaptive weights, prioritizing immediate distance (60-90%) and lookahead (10-40%) based on exploration progress, while penalizing distant nodes and less central nodes (20-50% weight). It dynamically adjusts lookahead depth (up to 3) and balances exploration/exploitation via exploration_factor. The score is minimized to select the next node, ensuring a trade-off between short-term and long-term optimality.",
          "thought": "This new algorithm combines the weighted scoring from No.1 and No.2 with dynamic lookahead depth and popularity-based selection from No.3, while adding adaptive weights based on exploration progress and a penalty for distant nodes, ensuring a balance between immediate distance, future connectivity, and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.5 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.5 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40888,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60% weight) with dynamic lookahead (25% weight, depth proportional to remaining nodes) and node popularity (15% weight, based on centrality), while penalizing nodes far from the destination (30% weight) and adjusting weights based on exploration progress. It balances short-term and long-term considerations, with exploration factor modulating the importance of lookahead and popularity. The lookahead depth scales with remaining nodes (max 5), and centrality is calculated as average distance to unvisited nodes.",
          "thought": "The new algorithm prioritizes immediate distance with a fixed weight, emphasizes dynamic lookahead with depth proportional to remaining nodes, and incorporates node popularity based on average distance to unvisited nodes, while penalizing nodes far from the destination and adjusting weights based on exploration progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + 2 * node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        lookahead_weight = 0.25 * (1.0 - exploration_factor)\n        popularity_weight = 0.15 * exploration_factor\n        penalty_weight = 0.3 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.3 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.42886,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance to current node) and long-term connectivity (node's connections to unvisited nodes), with connectivity weighted more heavily as the number of remaining nodes decreases. It prioritizes nodes that are closer to the current node but also have strong connections to other unvisited nodes, adjusting the balance dynamically. The score calculation combines distance and connectivity, favoring nodes with lower scores.",
          "thought": "The new algorithm combines the score calculation from No.1 (distance_to_current - avg_distance) with the dynamic connectivity weighting from No.2, creating a hybrid approach that balances immediate proximity and long-term connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance_to_unvisited)\n        connectivity_weight = 1.0 + (1.0 - (remaining_nodes / total_nodes)) * (connectivity / (total_nodes - 1)) * 0.5\n\n        score = (distance_to_current - avg_distance_to_unvisited) * connectivity_weight\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both locally close to the current node and globally well-connected to unvisited nodes, dynamically adjusting its focus based on the visited ratio. It balances proximity (distance_to_current) and connectivity (avg_distance) with a weighted score, while penalizing high-connectivity nodes (avg_neighbor_distance > 1.5x distance_to_current) to avoid clustering. The weight factor (0.5 + 0.5*(1-visited_ratio)) shifts emphasis from local proximity early (high weight) to global connectivity later (lower weight).",
          "thought": "The new algorithm combines the No.1's balance between local proximity and global connectivity with No.2's dynamic weighting and penalty for high-connectivity nodes, using a score that prioritizes closer nodes with high average distances to unvisited nodes, while dynamically adjusting weights based on visited ratio and penalizing nodes with significantly higher neighbor distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            if avg_neighbor_distance > 1.5 * distance_to_current:\n                score *= 1.1\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45911,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local proximity (immediate distance) and global connectivity (average distance to remaining nodes) with a fixed-depth lookahead strategy (2 steps ahead), dynamically adjusting their weights based on the visited ratio to prioritize nodes that are both nearby and well-connected. The score calculation balances immediate distance (weighted more when fewer nodes are visited) with lookahead distance (weighted more when more nodes are visited) while subtracting the average distance to remaining nodes to favor globally connected nodes.",
          "thought": "The new algorithm combines the No.1 algorithm's balanced focus on local proximity and global connectivity with the No.2 algorithm's fixed-depth lookahead strategy, dynamically adjusting the balance between immediate and lookahead distances based on the visited ratio to prioritize nodes that are both locally close and globally well-connected.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n\n        # Fixed lookahead depth of 2\n        lookahead_depth = 2\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        # Calculate average distance to remaining nodes (global connectivity)\n        if len(unvisited_nodes) > 1:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_distance = 0\n\n        # Dynamic weight based on visited ratio\n        weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n\n        # Combine immediate distance, lookahead distance, and global connectivity\n        score = (weight_factor * immediate_distance +\n                 (1 - weight_factor) * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) -\n                 avg_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46964,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node (60% weight) with future average distances to unvisited nodes (30% weight, dynamically adjusted by remaining nodes) while penalizing nodes close to the destination to encourage exploration. The weight increases as remaining nodes decrease, prioritizing strategic choices later, and the penalty term discourages early visits to nodes near the destination. The score combines these factors to select the next node with the lowest cost.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate and future distance balancing from No.2, using a weight that increases as remaining nodes decrease to prioritize strategic choices later, while penalizing nodes close to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47116,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines nearest-neighbor with dynamic lookahead, balancing immediate distance, future exploration, and node popularity while penalizing distant nodes. It prioritizes immediate distance early (higher weight) and increases lookahead and popularity influence as the tour progresses, with penalties scaling inversely with exploration. The weights (`immediate_weight`, `lookahead_weight`, `popularity_weight`, `penalty_weight`) adjust dynamically based on remaining nodes, favoring local choices early but gradually incorporating global factors.",
          "thought": "The new algorithm combines nearest neighbor with dynamic lookahead, similar to No.2, but incorporates exploration/exploitation balance, popularity, and penalty terms inspired by No.1, adjusting weights dynamically based on remaining nodes and favoring immediate distance early while balancing lookahead and global factors later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.4 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.5 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47232,
          "other_inf": null
     }
]