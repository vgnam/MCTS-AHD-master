[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with weighted score balancing, prioritizing closer nodes early by scaling weights inversely with the number of remaining nodes. It computes a score for each unvisited node based on the current distance to the node and the node's distance to the destination, using a power-weighted formula that balances proximity and strategic connections. The weight factor dynamically adjusts to favor proximity early and strategic connections later, with closer nodes receiving higher priority when few nodes remain.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the weighted score balancing from No.2, using a power-weighted score that prioritizes closer nodes early and strategic connections later, with the weight factor scaling inversely with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * weight_factor\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing immediate distance from the current node, distance to the destination, and node centrality (degree), using a score that prioritizes central nodes early (higher degree_factor) and closer nodes later (lower weight). The scoring mechanism combines these factors to favor strategic early selections while optimizing for shorter paths as the tour progresses. The degree_factor adjusts weights based on node connectivity, while the weight dynamically shifts priority between immediate and long-term path considerations.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on node centrality and path history, using a novel scoring mechanism that combines immediate distance, destination distance, and node degree to prioritize strategic nodes early while favoring closer nodes later, with a score calculated as `(distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))`.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # Including current node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            # Calculate node degree (number of connections to unvisited nodes)\n            degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n            degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.5  # Normalize by max possible degree\n\n            # Dynamic weight based on remaining nodes and degree\n            weight = 1.0 + (remaining_nodes / total_nodes) * (1.0 / (1.0 + degree_factor))\n\n            # Novel scoring mechanism\n            score = (distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86761,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This ensures a balance between immediate proximity (lower numerator) and long-term efficiency (lower denominator), dynamically adjusting the path based on the remaining unvisited nodes. The code explicitly checks for and avoids division by zero when a node is the destination, ensuring robustness.",
          "thought": "The new algorithm prioritizes nodes that minimize the ratio of the distance to the current node divided by the distance to the destination, ensuring a balance between immediate proximity and long-term path efficiency while dynamically adjusting the selection based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local proximity (distance from the current node) and global coverage (average distance to remaining nodes), using a dynamically adjusted weight that prioritizes global coverage early (when few nodes remain) and local proximity later (as the tour progresses). The score metric combines these factors, favoring nodes that minimize the weighted sum of distance to the current node and the average distance to unvisited nodes.",
          "thought": "This new algorithm modifies the original by incorporating a dynamic weight factor that adjusts based on the number of remaining unvisited nodes, scaling the average distance contribution to prioritize global coverage in early stages and local proximity in later stages, while still using a combined score metric to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if total_unvisited == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (total_unvisited - 1)\n\n        weight = 1.0 / (1.0 + total_unvisited)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * distance_to_current - weight * avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.95321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node and strategic coverage, where the latter is measured by the node's normalized average distance to remaining unvisited nodes. The balance is dynamically adjusted through a density weight that reduces the influence of coverage as the number of remaining nodes decreases, prioritizing proximity in the final stages. The score combines these factors to choose the node with the lowest cost, ensuring both efficiency and adaptability to the problem's constraints.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of distance to the current node and a normalized global connectivity measure, where the weights are dynamically adjusted based on the remaining unvisited nodes' density, favoring both proximity and strategic coverage in a more adaptive manner.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if total_unvisited == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (total_unvisited - 1)\n\n        # Normalize avg_distance by the maximum possible distance in the matrix\n        max_possible_distance = max(max(row) for row in distance_matrix)\n        normalized_avg = avg_distance / max_possible_distance if max_possible_distance != 0 else 0\n\n        # Adjust weights based on remaining nodes density\n        density_weight = 1 / (1 + total_unvisited)  # Higher density reduces weight of avg_distance\n        score = (1 - density_weight) * distance_to_current + density_weight * (1 - normalized_avg)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96076,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts its priority between immediate distance (70% weight) and global optimization (30% weight), with the weight shifting aggressively toward immediate distance early on (via `weight_factor = 1.0 / (1.0 + remaining_nodes ** 2)`). The balance between local and global factors is managed by the `total_score` calculation, where immediate distance dominates early due to the `1 - weight_factor` term.",
          "thought": "The new algorithm introduces a dynamic weight factor that prioritizes immediate distance more aggressively early on, then shifts toward global optimization by balancing the current node's distance with the average distance to unvisited nodes, but with a different weight adjustment formula to emphasize long-term planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_total_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes ** 2)  # More aggressive decrease in weight\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        total_score = (0.7 * (1 - weight_factor) * distance_to_current) + (0.3 * weight_factor * avg_distance_to_unvisited)  # Different weight balance\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with connectivity-aware scoring, dynamically adjusting weights based on remaining nodes. It balances short-term distance (70% weight) with long-term average distance (30% weight), while incorporating connectivity as a multiplicative factor (up to 30% boost). The weight factor decreases as nodes are visited, giving more emphasis to immediate distance early on.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (prioritizing immediate distance early) with the connectivity-aware scoring of No.2. It balances distance to the current node with average distance to remaining nodes, while dynamically adjusting weights based on remaining nodes and incorporating connectivity as a multiplicative factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n    weight_factor = 1.0 / (1.0 + remaining_nodes ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_all = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance_to_all)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        weighted_distance = (0.7 * (1 - weight_factor) * distance_to_current) + (0.3 * weight_factor * avg_distance_to_all)\n        score = weighted_distance * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.02523,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances short-term (current distance) and long-term (destination proximity) priorities using a non-linear weight factor based on visited-to-unvisited node ratio, while penalizing nodes too close to the destination early to prevent premature convergence. It prioritizes immediate distance early in the process (low `visited_ratio`) but gradually shifts focus to destination proximity (high `visited_ratio`), with an added penalty for nodes that become too close to the destination when many nodes remain unvisited.",
          "thought": "This new algorithm introduces a dynamic weighting mechanism that considers both immediate distance and long-term connectivity, but it incorporates a non-linear weight adjustment based on the ratio of visited to unvisited nodes, and also penalizes nodes that are too close to the destination prematurely to encourage better path diversification.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 to include current node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_factor = visited_ratio ** 2  # Non-linear adjustment for better balance\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Penalize nodes too close to destination early\n        early_penalty = 1.0 if (len(unvisited_nodes) > total_nodes / 2 and distance_to_destination < 2 * distance_matrix[current_node][destination_node]) else 1.0\n\n        weighted_score = (1 - weight_factor) * distance_to_current + weight_factor * distance_to_destination * early_penalty\n\n        if weighted_score < min_score:\n            min_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.02907,
          "other_inf": null
     }
]