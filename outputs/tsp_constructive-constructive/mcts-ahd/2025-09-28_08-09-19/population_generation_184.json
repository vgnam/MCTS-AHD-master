[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node (60% weight) with future average distances to unvisited nodes (30% weight, dynamically adjusted by remaining nodes) while penalizing nodes close to the destination to encourage exploration. The weight increases as remaining nodes decrease, prioritizing strategic choices later, and the penalty term discourages early visits to nodes near the destination. The score combines these factors to select the next node with the lowest cost.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate and future distance balancing from No.2, using a weight that increases as remaining nodes decrease to prioritize strategic choices later, while penalizing nodes close to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment, normalization, and decay factors to balance immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination. Immediate distance is prioritized (0.5 weight), followed by future average distance (0.3 weight with decay), and penalizes nodes close to the destination to avoid premature convergence. The weights adapt based on remaining nodes, with higher penalties for nodes near the destination to encourage exploration.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the normalization and decay factor from No.2, using a weighted score of immediate distance, future average distance, and destination proximity, while penalizing nodes near the destination to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n    dynamic_weight = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.5\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        max_distance = max(distance_to_current, distance_to_destination, 1.0)\n        normalized_current = distance_to_current / max_distance\n        normalized_future = avg_future_distance / max_distance if avg_future_distance > 0 else 0\n\n        decay_factor = 0.7 * (1.0 - dynamic_weight)\n        score = immediate_weight * normalized_current + future_weight * (normalized_future ** decay_factor) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50058,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, node centrality (higher priority early on), and future connectivity (lower priority), with adaptive weights and a penalty for nodes too close to the destination. It prioritizes centrality and connectivity early (higher weights) but shifts focus to immediate distance as nodes remain. The score combines weighted components (immediate distance: 50%, centrality: 30%, connectivity: 20%) minus a penalty for nodes near the destination.",
          "thought": "The new algorithm introduces a dynamic priority system that combines immediate distance with probabilistic selection based on node centrality and future connectivity, using a novel scoring mechanism that balances exploration and exploitation through adaptive weights and a connectivity penalty term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            # Calculate node centrality (inverse of average distance to other nodes)\n            centrality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)) if remaining_nodes > 1 else 0\n\n            # Calculate future connectivity (number of nearby nodes)\n            connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * distance_to_current) / remaining_nodes\n\n            # Dynamic weights based on remaining nodes\n            weight_factor = 0.4 + 0.6 * (remaining_nodes / (remaining_nodes + 3))\n            immediate_weight = 0.5 * weight_factor\n            centrality_weight = 0.3 * (1 - weight_factor)\n            connectivity_weight = 0.2 * (1 - weight_factor)\n\n            # Penalty for nodes that are too close to destination\n            penalty_weight = 0.3 * (1.0 - connectivity_weight)\n            penalty = penalty_weight * (distance_to_destination / (1.0 + distance_to_current)) if distance_to_current > 0 else 0\n\n            # Score combines weighted components with penalty\n            score = (immediate_weight * distance_to_current +\n                     centrality_weight * centrality +\n                     connectivity_weight * connectivity) - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51679,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with weighted score balancing, prioritizing closer nodes early by scaling weights inversely with the number of remaining nodes. It computes a score for each unvisited node based on the current distance to the node and the node's distance to the destination, using a power-weighted formula that balances proximity and strategic connections. The weight factor dynamically adjusts to favor proximity early and strategic connections later, with closer nodes receiving higher priority when few nodes remain.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the weighted score balancing from No.2, using a power-weighted score that prioritizes closer nodes early and strategic connections later, with the weight factor scaling inversely with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * weight_factor\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a ratio-based scoring mechanism (prioritizing nodes with better current-to-destination distance ratios) with a predicted path cost (balancing immediate distance, average future distances, and destination proximity), dynamically adjusting weights with `local_weight` (higher priority for future efficiency as nodes remain unvisited). The `predicted_path_cost` (60% future, 40% destination) and ratio (weighted by `local_weight`) are linearly combined to select the next node, ensuring a balance between short-term and long-term efficiency.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (balancing immediate distance, future average distance, and destination proximity) with the ratio-based scoring from No.2, using a local_weight to prioritize future efficiency as nodes remain unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / remaining_nodes if remaining_nodes > 0 else 0\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        predicted_path_cost = distance_to_current + 0.6 * avg_future_distance + 0.4 * distance_to_destination\n        score = local_weight * ratio + (1 - local_weight) * predicted_path_cost\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68362,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate, neighbor, and future distances with dynamic weights adjusted based on remaining nodes, prioritizing exploitation early (higher immediate and neighbor weights) and balancing exploration later (higher future weight). It includes a penalty mechanism to avoid prematurely favoring nodes near the destination, using average nearest-neighbor distances for local exploration and refining scores with a weighted combination of these factors. The weights (`immediate_weight`, `neighbor_weight`, `future_weight`) are dynamically adjusted to favor immediate and neighbor distances early, while increasing future distance consideration as nodes are visited.",
          "thought": "The new algorithm combines the weighted balancing of immediate and future distances with dynamic weight adjustment, incorporates a penalty mechanism to avoid premature convergence to the destination, and enhances exploration through average nearest-neighbor distances while using a more refined scoring system that prioritizes exploitation early and balances exploration later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(3, remaining_nodes)]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n\n            weight_factor = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 2))\n            immediate_weight = 0.5 * weight_factor\n            neighbor_weight = 0.3 * (1 - weight_factor)\n            future_weight = 0.2 * (1 - weight_factor)\n\n            penalty_weight = 0.5 * (1.0 - future_weight)\n            penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n            score = immediate_weight * distance_to_current + neighbor_weight * avg_neighbor_distance + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69226,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (distance to current node) and future efficiency (average future distances and distance to destination) by dynamically adjusting weights based on remaining nodes. It prioritizes minimizing the ratio of immediate distance to destination distance early on, while later focusing more on predicted path costs, with a weighted combination of these factors. The weight of these components is adjusted by `local_weight`, which increases as more nodes remain unvisited, favoring future efficiency in later stages.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring mechanism of No.2, dynamically balancing immediate proximity and future efficiency by adjusting weights based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            score = distance_to_current + distance_to_destination\n        else:\n            avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            predicted_path_cost = distance_to_current + 0.7 * avg_future_distance + 0.3 * distance_to_destination\n\n            if distance_to_destination == 0:\n                ratio = float('inf')\n            else:\n                ratio = distance_to_current / distance_to_destination\n\n            local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n            score = local_weight * ratio + (1 - local_weight) * predicted_path_cost\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69376,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, node centrality (degree of connections to unvisited nodes), and destination proximity, with dynamic weights that prioritize centrality as the tour progresses while penalizing nodes too close to the destination. Immediate distance is weighted higher early in the tour, while centrality and destination proximity become more significant later, and nodes near the destination are penalized to avoid premature convergence. The score combines these factors multiplicatively, favoring nodes that minimize distance while maximizing connectivity and avoiding proximity to the destination.",
          "thought": "The new algorithm prioritizes nodes based on a combination of immediate distance, node centrality, and destination proximity, with dynamic weights that emphasize centrality as the tour progresses while penalizing nodes too close to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n    weight_factor = 1.0 - (1.0 / (1.0 + remaining_nodes))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate node degree (number of connections to unvisited nodes)\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n        degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.8\n\n        # Dynamic weights based on remaining nodes and degree\n        immediate_weight = (1.0 - weight_factor) * 0.7\n        centrality_weight = 0.3 + weight_factor * degree_factor\n        proximity_weight = 0.5 * (1.0 - weight_factor)\n\n        # Penalize nodes too close to destination\n        penalty = proximity_weight * (1.0 / (1.0 + distance_to_destination)) if degree > 0 else 0\n\n        # Calculate total score\n        score = -distance_to_current * immediate_weight + degree_factor * centrality_weight - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.78754,
          "other_inf": null
     }
]