[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This ensures a balance between immediate proximity (lower numerator) and long-term efficiency (lower denominator), dynamically adjusting the path based on the remaining unvisited nodes. The code explicitly checks for and avoids division by zero when a node is the destination, ensuring robustness.",
          "thought": "The new algorithm prioritizes nodes that minimize the ratio of the distance to the current node divided by the distance to the destination, ensuring a balance between immediate proximity and long-term path efficiency while dynamically adjusting the selection based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local proximity (distance from the current node) and global coverage (average distance to remaining nodes), using a dynamically adjusted weight that prioritizes global coverage early (when few nodes remain) and local proximity later (as the tour progresses). The score metric combines these factors, favoring nodes that minimize the weighted sum of distance to the current node and the average distance to unvisited nodes.",
          "thought": "This new algorithm modifies the original by incorporating a dynamic weight factor that adjusts based on the number of remaining unvisited nodes, scaling the average distance contribution to prioritize global coverage in early stages and local proximity in later stages, while still using a combined score metric to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if total_unvisited == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (total_unvisited - 1)\n\n        weight = 1.0 / (1.0 + total_unvisited)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * distance_to_current - weight * avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.95321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node and strategic coverage, where the latter is measured by the node's normalized average distance to remaining unvisited nodes. The balance is dynamically adjusted through a density weight that reduces the influence of coverage as the number of remaining nodes decreases, prioritizing proximity in the final stages. The score combines these factors to choose the node with the lowest cost, ensuring both efficiency and adaptability to the problem's constraints.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of distance to the current node and a normalized global connectivity measure, where the weights are dynamically adjusted based on the remaining unvisited nodes' density, favoring both proximity and strategic coverage in a more adaptive manner.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if total_unvisited == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (total_unvisited - 1)\n\n        # Normalize avg_distance by the maximum possible distance in the matrix\n        max_possible_distance = max(max(row) for row in distance_matrix)\n        normalized_avg = avg_distance / max_possible_distance if max_possible_distance != 0 else 0\n\n        # Adjust weights based on remaining nodes density\n        density_weight = 1 / (1 + total_unvisited)  # Higher density reduces weight of avg_distance\n        score = (1 - density_weight) * distance_to_current + density_weight * (1 - normalized_avg)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96076,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance to the current node with long-term guidance by averaging distances to remaining unvisited nodes, weighted by a dynamic factor that prioritizes immediate distance as the number of remaining nodes decreases. It selects the next node by minimizing a score that balances direct proximity and average connectivity, ensuring efficiency without exhaustive search. The weight factor adjusts dynamically, giving higher priority to immediate distance early in the search and more balanced consideration as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm combines the dynamic weight factor from No.1 to balance immediate distance and long-term guidance, with the score calculation from No.2 that prioritizes nodes close to the current node while considering their average distance to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = (1 - weight_factor) * distance_to_current + weight_factor * avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically balances immediate distance and long-term path guidance by adjusting a weight factor based on remaining unvisited nodes. Early in the search, it prioritizes closer nodes (lower `distance_to_current`), while later it favors nodes that better connect to the destination (higher `distance_to_destination`). The weight factor (`weight_factor = 1.0 / (1.0 + remaining_nodes)`) ensures the balance shifts toward long-term planning as the number of unvisited nodes decreases.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating a dynamic weighting factor to balance immediate distance and long-term path guidance, where the weight adjusts based on the remaining unvisited nodes, favoring closer nodes early and more strategic choices later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Decreases as more nodes are visited\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_score = (1 - weight_factor) * distance_to_current + weight_factor * distance_to_destination\n\n        if weighted_score < min_score:\n            min_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a ratio of the product of distances (current to node and node to destination, with a decay factor applied to the latter) to their sum, balancing closeness to both the current node and destination while prioritizing nodes that are closer to the destination (due to the decay factor). The decay factor (0.7) reduces the influence of the destination distance, favoring nodes that are both close to the current node and the destination, but with the destination's influence dampened. The code efficiently iterates through unvisited nodes to find the optimal next node.",
          "thought": "The new algorithm combines the balanced approach of No.1 (minimizing product of distances with decay) and No.2 (minimizing ratio of distances) by using a ratio of the product of distances (with decay) to the sum of distances, favoring nodes that are both close to the current node and the destination, while dynamically adjusting the balance based on the remaining tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n    decay_factor = 0.7\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            product = distance_to_current * (distance_to_destination ** decay_factor)\n            sum_distances = distance_to_current + distance_to_destination\n            ratio = product / sum_distances\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 7.29549,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance to current node) and global alignment (distance to destination), while also considering the average distance to other unvisited nodes to avoid isolation. The score calculation prioritizes minimizing the sum of current and destination distances while slightly favoring nodes with better connections to other unvisited nodes. The function dynamically adjusts its selection based on the remaining nodes, ensuring a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm modifies the selection criteria by prioritizing nodes that are closer to the current node while also considering the minimum distance to the destination, creating a balance between local proximity and global alignment with the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current + distance_to_destination - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.30366,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances near-term and long-term optimization by combining normalized distances to the current node and destination, with a decay factor that prioritizes the destination distance as more nodes are visited. It uses a dynamic weight based on remaining unvisited nodes to adjust the influence of these distances, favoring closer current nodes early and closer destination nodes later. The score calculation ensures a smooth transition between these priorities.",
          "thought": "This new algorithm introduces a dynamic weighting mechanism that adjusts the influence of both current and destination distances based on the remaining number of unvisited nodes, using a heuristic score that combines normalized distances and a progressive decay factor to balance near-term and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_decay_factor = 0.7\n    dynamic_weight = 1.0 / (1.0 + remaining_nodes)  # Decreases as more nodes are visited\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Normalize distances\n        max_distance = max(distance_to_current, distance_to_destination, 1.0)  # Avoid division by zero\n        normalized_current = distance_to_current / max_distance\n        normalized_destination = distance_to_destination / max_distance\n\n        # Dynamic decay factor\n        decay_factor = base_decay_factor * (1.0 - dynamic_weight)\n        score = normalized_current * (normalized_destination ** decay_factor)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.39562,
          "other_inf": null
     }
]