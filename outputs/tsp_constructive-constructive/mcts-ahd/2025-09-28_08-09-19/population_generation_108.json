[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing local proximity (minimizing distance from the current node) and global connectivity (maximizing average distance to remaining unvisited nodes), using a score that combines these factors. It selects the node with the smallest score, which is calculated as `distance_to_current - avg_distance`, favoring closer nodes with higher average distances to unvisited nodes. The heuristic ensures a trade-off between immediate proximity and broader solution coverage.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current position while also considering the global connectivity by favoring nodes with higher average distances to the remaining unvisited nodes, balancing local proximity with broader solution coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node (60% weight) with future average distances to unvisited nodes (30% weight, dynamically adjusted by remaining nodes) while penalizing nodes close to the destination to encourage exploration. The weight increases as remaining nodes decrease, prioritizing strategic choices later, and the penalty term discourages early visits to nodes near the destination. The score combines these factors to select the next node with the lowest cost.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate and future distance balancing from No.2, using a weight that increases as remaining nodes decrease to prioritize strategic choices later, while penalizing nodes close to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        future_weight = 0.3 * (1.0 - weight)\n\n        penalty_weight = 0.4 * (1.0 - future_weight)\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with weighted score balancing, prioritizing closer nodes early by scaling weights inversely with the number of remaining nodes. It computes a score for each unvisited node based on the current distance to the node and the node's distance to the destination, using a power-weighted formula that balances proximity and strategic connections. The weight factor dynamically adjusts to favor proximity early and strategic connections later, with closer nodes receiving higher priority when few nodes remain.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the weighted score balancing from No.2, using a power-weighted score that prioritizes closer nodes early and strategic connections later, with the weight factor scaling inversely with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * weight_factor\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, node centrality (degree of connections to unvisited nodes), and destination proximity, with dynamic weights that prioritize centrality as the tour progresses while penalizing nodes too close to the destination. Immediate distance is weighted higher early in the tour, while centrality and destination proximity become more significant later, and nodes near the destination are penalized to avoid premature convergence. The score combines these factors multiplicatively, favoring nodes that minimize distance while maximizing connectivity and avoiding proximity to the destination.",
          "thought": "The new algorithm prioritizes nodes based on a combination of immediate distance, node centrality, and destination proximity, with dynamic weights that emphasize centrality as the tour progresses while penalizing nodes too close to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n    weight_factor = 1.0 - (1.0 / (1.0 + remaining_nodes))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate node degree (number of connections to unvisited nodes)\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n        degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.8\n\n        # Dynamic weights based on remaining nodes and degree\n        immediate_weight = (1.0 - weight_factor) * 0.7\n        centrality_weight = 0.3 + weight_factor * degree_factor\n        proximity_weight = 0.5 * (1.0 - weight_factor)\n\n        # Penalize nodes too close to destination\n        penalty = proximity_weight * (1.0 / (1.0 + distance_to_destination)) if degree > 0 else 0\n\n        # Calculate total score\n        score = -distance_to_current * immediate_weight + degree_factor * centrality_weight - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.78754,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local proximity** (distance from current node) with **global optimization** (average distance to remaining nodes), dynamically adjusting weights based on tour progress. It prioritizes immediate closeness (`immediate_weight`) while balancing long-term efficiency (`global_weight`), with a penalty for nodes too close to the destination (`penalty_weight`). The score calculation (`immediate_weight * distance_to_current - global_weight * avg_distance + penalty`) ensures a trade-off between short-term and long-term goals.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.2 with the balanced local-global proximity scoring from No.1, prioritizing nodes that are close to the current node while also maximizing average distances to remaining unvisited nodes, with weights adjusted based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n\n        # Dynamic weights based on remaining nodes\n        immediate_weight = (1.0 - weight_factor)\n        global_weight = 0.5 + weight_factor\n        penalty_weight = 0.3 * (1.0 - weight_factor)\n\n        # Penalize nodes too close to destination\n        penalty = penalty_weight * distance_to_destination if remaining_nodes > 1 else 0\n\n        # Calculate total score\n        score = immediate_weight * distance_to_current - global_weight * avg_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.7982,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing immediate distance from the current node, distance to the destination, and node centrality (degree), using a score that prioritizes central nodes early (higher degree_factor) and closer nodes later (lower weight). The scoring mechanism combines these factors to favor strategic early selections while optimizing for shorter paths as the tour progresses. The degree_factor adjusts weights based on node connectivity, while the weight dynamically shifts priority between immediate and long-term path considerations.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on node centrality and path history, using a novel scoring mechanism that combines immediate distance, destination distance, and node degree to prioritize strategic nodes early while favoring closer nodes later, with a score calculated as `(distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))`.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # Including current node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            # Calculate node degree (number of connections to unvisited nodes)\n            degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)\n            degree_factor = 1.0 + (degree / (total_nodes - 1)) * 0.5  # Normalize by max possible degree\n\n            # Dynamic weight based on remaining nodes and degree\n            weight = 1.0 + (remaining_nodes / total_nodes) * (1.0 / (1.0 + degree_factor))\n\n            # Novel scoring mechanism\n            score = (distance_to_current * degree_factor) / (distance_to_destination * (1 + remaining_nodes / total_nodes))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86761,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This ensures a balance between immediate proximity (lower numerator) and long-term efficiency (lower denominator), dynamically adjusting the path based on the remaining unvisited nodes. The code explicitly checks for and avoids division by zero when a node is the destination, ensuring robustness.",
          "thought": "The new algorithm prioritizes nodes that minimize the ratio of the distance to the current node divided by the distance to the destination, ensuring a balance between immediate proximity and long-term path efficiency while dynamically adjusting the selection based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60% weight) over future distances, with future distance importance dynamically decreasing as unvisited nodes decrease (weight = 0.7 / (1 + remaining_nodes)). It penalizes nodes close to the destination (40% of remaining weight) to encourage exploration, balancing short-term and long-term path optimization.",
          "thought": "The new algorithm prioritizes immediate distance with a fixed weight, balances future distance with a dynamic weight based on remaining nodes, and penalizes nodes close to the destination with a linear scaling factor to encourage exploration while avoiding premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    future_weight = 0.7 / (1.0 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6\n        penalty_weight = 0.4 * (1.0 - future_weight)\n\n        penalty = penalty_weight * (distance_to_destination / (1.0 + avg_future_distance)) if avg_future_distance > 0 else 0\n\n        score = immediate_weight * distance_to_current + future_weight * avg_future_distance - penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.92882,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection (prioritizing nodes that minimize the ratio of current-to-destination distance) with connectivity scoring (favoring nodes with many nearby neighbors), dynamically balancing these factors using a weight factor that decreases as remaining nodes decrease. The weighted score (60% ratio, 40% average distance) is further multiplied by a connectivity factor (1.3x for highly connected nodes), making connectivity a multiplicative rather than additive factor. The algorithm prioritizes immediate distance savings while gradually shifting focus to long-term connectivity as the tour progresses.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted distance and connectivity scoring from No.2, using a dynamic weight factor that balances immediate and long-term distance considerations, while incorporating connectivity as a multiplicative factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n    weight_factor = 1.0 / (1.0 + remaining_nodes ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        avg_distance_to_all = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance_to_all)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        weighted_score = (0.6 * (1 - weight_factor) * ratio) + (0.4 * weight_factor * avg_distance_to_all)\n        score = weighted_score * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.93477,
          "other_inf": null
     }
]