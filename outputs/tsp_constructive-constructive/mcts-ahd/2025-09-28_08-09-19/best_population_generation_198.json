{
     "algorithm": "The algorithm prioritizes nodes that are both locally close to the current node and globally well-connected to unvisited nodes, dynamically adjusting its focus based on the visited ratio. It balances proximity (distance_to_current) and connectivity (avg_distance) with a weighted score, while penalizing high-connectivity nodes (avg_neighbor_distance > 1.5x distance_to_current) to avoid clustering. The weight factor (0.5 + 0.5*(1-visited_ratio)) shifts emphasis from local proximity early (high weight) to global connectivity later (lower weight).",
     "thought": "The new algorithm combines the No.1's balance between local proximity and global connectivity with No.2's dynamic weighting and penalty for high-connectivity nodes, using a score that prioritizes closer nodes with high average distances to unvisited nodes, while dynamically adjusting weights based on visited ratio and penalizing nodes with significantly higher neighbor distances.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            if avg_neighbor_distance > 1.5 * distance_to_current:\n                score *= 1.1\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.45911,
     "other_inf": null
}