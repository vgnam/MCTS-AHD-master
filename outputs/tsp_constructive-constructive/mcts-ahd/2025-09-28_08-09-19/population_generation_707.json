[
     {
          "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
          "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.31125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with connectivity penalties and exploration factors, prioritizing immediate distance early while adaptively incorporating lookahead and centrality, with penalties for highly connected nodes to prevent clustering. It balances immediate distance (weighted higher early) with lookahead and centrality (weighted lower initially) and adjusts penalties based on visited ratio. Key variables: `immediate_weight` (prioritized early), `lookahead_weight` and `centrality_weight` (lower priority initially), `penalty_weight` (scales with visited ratio).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity penalty and exploration factor refinement of No.1, using a balanced scoring mechanism that prioritizes immediate distance early while incorporating lookahead and centrality adaptively, with penalties for highly connected nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32084,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local proximity (distance_to_current) with global connectivity (avg_distance and avg_neighbor_distance), using a time-decaying weight (time_decay) to prioritize exploration early and exploitation later. It penalizes overly central nodes (high avg_neighbor_distance) and adjusts selection with nearest-neighbor refinements (second_nearest), emphasizing shorter-term gains (distance_to_current) while accounting for long-term connectivity (avg_distance and avg_neighbor_distance). The score calculation prioritizes distance_to_current and avg_neighbor_distance early, while the penalty and second_nearest adjustments refine choices later.",
          "thought": "The new algorithm introduces a dynamic connectivity-aware scoring mechanism that combines local proximity with global connectivity, using a penalty factor for nodes that are too central (high avg_neighbor_distance) and a time-decaying weight to balance exploration and exploitation, while also incorporating a nearest-neighbor adjustment to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n    time_decay = 1 - (visited_ratio ** 2)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current - avg_distance\n\n        if len(unvisited_nodes) > 1:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda n: distance_matrix[node][n])[:min(4, len(unvisited_nodes))]\n            avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n            weight_factor = 0.5 + 0.5 * (1 - visited_ratio)\n            score = weight_factor * score + (1 - weight_factor) * avg_neighbor_distance\n\n            penalty = 1 + (avg_neighbor_distance / (distance_to_current + 1e-6)) * time_decay\n            score *= penalty\n\n            if len(nearest_neighbors) >= 2:\n                second_nearest = nearest_neighbors[1]\n                score += 0.2 * distance_matrix[node][second_nearest]\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with multi-factor scoring, prioritizing immediate distance (60-90% weight early) and lookahead depth (reduced as nodes remain), while penalizing high-connectivity nodes to balance local coverage and global connectivity. It dynamically adjusts weights based on remaining nodes and applies penalties to avoid clustering, with centrality and connectivity given progressively lower emphasis as the search progresses. The exploration factor and visited ratio further refine node selection by favoring local exploration early and global optimization later.",
          "thought": "The new algorithm combines dynamic weight adjustment with multi-factor scoring, balancing immediate distance (60-90% weight early), lookahead depth (reduced as nodes remain), centrality (lower weight), connectivity (penalized for high connectivity), and progressive exploration factor to favor local coverage early and global connectivity later, while dynamically adjusting weights based on remaining nodes and applying penalties for high-connectivity nodes to avoid clustering.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.8\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.4\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.6 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3461,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with dynamic connectivity adjustment, using a weighted score that balances proximity (higher weight early), lookahead depth (reduced weight as nodes remain), and node centrality (lower weight), while dynamically penalizing highly connected nodes and adjusting weights based on remaining nodes to favor local coverage early and global connectivity later. The algorithm prioritizes immediate distance with a weight of 0.6\u20130.9 early on, while reducing lookahead depth and centrality importance as the tour progresses, and applies penalties for high-connectivity nodes to avoid clustering.",
          "thought": "The new algorithm combines immediate distance prioritization with dynamic connectivity adjustment, using a weighted score that balances proximity (higher weight early), lookahead depth (reduced weight as nodes remain), and node centrality (lower weight), while also incorporating dynamic penalties for highly connected nodes and adjusting weights based on remaining nodes to favor local coverage early and balance global connectivity later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n        penalty_weight = 0.3 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.5 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.35065,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with shorter immediate distances while balancing them with higher average distances to remaining unvisited nodes, using a dynamic lookahead depth (up to 3 or half of remaining nodes) to avoid excessive computation. The score is a weighted combination (70% for the distance-average difference, 30% for immediate distance), ensuring a trade-off between immediate and long-term benefits. The code efficiently handles edge cases (empty unvisited nodes) and dynamically adjusts lookahead depth based on remaining nodes.",
          "thought": "The new algorithm combines the balanced scoring of No.1 (distance_to_current - avg_distance) with the weighted immediate/lookahead approach of No.2, using a dynamic lookahead depth (up to 3 or half of remaining nodes) and a score that prioritizes nodes with lower immediate distance and higher average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        # Dynamic lookahead depth based on remaining nodes (up to 3 or half the remaining count)\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            avg_distance = 0\n\n        # Weighted score: 70% of (distance_to_current - avg_distance), 30% of immediate_distance\n        score = 0.7 * (immediate_distance - avg_distance) + 0.3 * immediate_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, connectivity, and centrality by adjusting weights based on remaining nodes. It prioritizes local optimization early (higher immediate distance weight) and global connectivity later (higher lookahead and centrality weights), using a lookahead mechanism to anticipate future connections. The score combines immediate distance, lookahead distance differences, and node centrality, with adaptive weights scaling connectivity and exploration factors.",
          "thought": "This new algorithm combines the strengths of both previous approaches by dynamically balancing immediate distance, connectivity, and centrality, with adaptive weights that prioritize local optimization early and global connectivity later, while incorporating a lookahead mechanism to anticipate future connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.3\n\n        weight = 1.0 + (remaining_count / total_nodes) * connectivity_factor\n        immediate_weight = 0.7 - 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        score *= weight\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.37303,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, lookahead depth, and node centrality. Immediate distance is prioritized (60% weight) with exploration/exploitation tradeoff, while lookahead (40% weight) and centrality (50% weight) refine choices based on remaining nodes. The lookahead depth dynamically adjusts (up to 3 levels) to estimate future costs, and centrality penalizes nodes far from unvisited nodes, ensuring a tradeoff between proximity and global coverage.",
          "thought": "The new algorithm combines the dynamic lookahead depth and exploration/exploitation balance from No.1 with the distance-average difference and immediate distance weighting from No.2, while adding node centrality as a penalty to prioritize nodes that are central to the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        centrality_weight = 0.5 * (1.0 - lookahead_weight)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.39988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted higher early) while dynamically reducing lookahead depth and incorporating node centrality (weighted more heavily later) to balance local optimization and global connectivity, adjusting weights based on progress (progress_factor) to favor connectivity in later stages. It uses a non-linear scoring system combining immediate distance, lookahead potential, and centrality, with connectivity as a multiplicative modifier that grows in influence as progress advances.",
          "thought": "The new algorithm prioritizes immediate distance with a fixed weight, reduces lookahead depth dynamically, and incorporates node centrality with a non-linear weighting scheme, favoring global connectivity in later stages while maintaining local optimization early.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    progress_factor = 1.0 - (remaining_count / total_nodes) ** 2\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n\n        lookahead_depth = max(1, remaining_count // 3)\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_nodes\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_weight = 0.5 + 0.5 * progress_factor\n\n        immediate_weight = 0.7 - 0.2 * progress_factor\n        lookahead_weight = 0.3 * progress_factor\n        centrality_weight = 0.5 * (1.0 - progress_factor)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        score *= (1.0 + connectivity_weight * connectivity / (total_nodes - 1))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40133,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, lookahead connectivity, and node popularity with adaptive weights, prioritizing immediate distance (60-90%) and lookahead (10-40%) based on exploration progress, while penalizing distant nodes and less central nodes (20-50% weight). It dynamically adjusts lookahead depth (up to 3) and balances exploration/exploitation via exploration_factor. The score is minimized to select the next node, ensuring a trade-off between short-term and long-term optimality.",
          "thought": "This new algorithm combines the weighted scoring from No.1 and No.2 with dynamic lookahead depth and popularity-based selection from No.3, while adding adaptive weights based on exploration progress and a penalty for distant nodes, ensuring a balance between immediate distance, future connectivity, and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    exploration_factor = 1.0 - (remaining_count / (remaining_count + 1)) * 0.7\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = 0\n        lookahead_depth = min(3, remaining_count // 2) if remaining_count > 2 else 1\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            current = node\n            for _ in range(lookahead_depth):\n                if not remaining_nodes:\n                    break\n                next_candidate = min(remaining_nodes, key=lambda x: distance_matrix[current][x])\n                lookahead_distance += distance_matrix[current][next_candidate]\n                current = next_candidate\n                remaining_nodes -= {next_candidate}\n\n        node_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        popularity = 1.0 / (1.0 + node_centrality)\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        immediate_weight = 0.6 + 0.3 * exploration_factor\n        lookahead_weight = 0.4 * (1.0 - exploration_factor)\n        popularity_weight = 0.2 * exploration_factor\n        penalty_weight = 0.5 * (1.0 - lookahead_weight)\n\n        penalty = penalty_weight * (distance_to_destination + 0.5 * node_centrality)\n        score = immediate_weight * immediate_distance + lookahead_weight * (lookahead_distance / lookahead_depth if lookahead_depth > 0 else 0) + popularity_weight * popularity - penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40888,
          "other_inf": null
     }
]