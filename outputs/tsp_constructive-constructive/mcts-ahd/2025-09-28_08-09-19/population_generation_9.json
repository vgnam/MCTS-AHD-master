[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and long-term distance to the destination, using a dynamic weight factor that prioritizes the latter as the number of remaining unvisited nodes decreases. The weight adjusts the ratio-based selection, favoring closer nodes early and more strategic choices later, with the score calculated as `(distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))`. The weight increases as remaining nodes decrease, ensuring adaptive path optimization.",
          "thought": "The new algorithm modifies the ratio-based selection by incorporating a dynamic weight factor that balances immediate distance and long-term efficiency, using a novel equation that adjusts the ratio based on the number of remaining unvisited nodes, ensuring adaptive path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            score = float('inf')\n        else:\n            weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n            score = (distance_to_current ** weight) / (distance_to_destination ** (1.0 / weight))\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.76774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This ensures a balance between immediate proximity (lower numerator) and long-term efficiency (lower denominator), dynamically adjusting the path based on the remaining unvisited nodes. The code explicitly checks for and avoids division by zero when a node is the destination, ensuring robustness.",
          "thought": "The new algorithm prioritizes nodes that minimize the ratio of the distance to the current node divided by the distance to the destination, ensuring a balance between immediate proximity and long-term path efficiency while dynamically adjusting the selection based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a ratio of the product of distances (current to node and node to destination, with a decay factor applied to the latter) to their sum, balancing closeness to both the current node and destination while prioritizing nodes that are closer to the destination (due to the decay factor). The decay factor (0.7) reduces the influence of the destination distance, favoring nodes that are both close to the current node and the destination, but with the destination's influence dampened. The code efficiently iterates through unvisited nodes to find the optimal next node.",
          "thought": "The new algorithm combines the balanced approach of No.1 (minimizing product of distances with decay) and No.2 (minimizing ratio of distances) by using a ratio of the product of distances (with decay) to the sum of distances, favoring nodes that are both close to the current node and the destination, while dynamically adjusting the balance based on the remaining tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n    decay_factor = 0.7\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            product = distance_to_current * (distance_to_destination ** decay_factor)\n            sum_distances = distance_to_current + distance_to_destination\n            ratio = product / sum_distances\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 7.29549,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the distance to the current node and the distance to the destination, with the destination distance weighted by a decay factor (0.7) to balance immediate and long-term path considerations. The score is computed as `distance_to_current * (distance_to_destination ** decay_factor)`, favoring nodes closer to both the current and destination nodes, while the decay factor reduces the influence of the destination distance as the tour progresses. The algorithm ensures the tour returns to the destination node when all other nodes are visited.",
          "thought": "This algorithm prioritizes nodes that minimize the product of the distance to the current node and the distance to the destination, balancing both immediate and long-term path considerations, and uses a decay factor to adjust the influence of the destination distance based on remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    decay_factor = 0.7  # Adjusts influence of destination distance\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current * (distance_to_destination ** decay_factor)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.4284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the product of distances from the current node to the candidate and from the candidate to the destination, balancing immediate proximity and long-term efficiency. It avoids division by zero and checks for invalid nodes, ensuring robustness. The code dynamically evaluates unvisited nodes based on this ratio and returns the optimal candidate, defaulting to the destination if no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node multiplied by the distance from the candidate node to the destination, ensuring a balance between immediate proximity and long-term efficiency while dynamically adjusting the path based on the remaining unvisited nodes. The code avoids division by zero and checks for invalid nodes, ensuring robustness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0 or distance_to_current == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current * distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm selects the next node by prioritizing the unvisited node closest to the current node while also considering its proximity to the destination, balancing immediate distance and long-term path guidance. The `total_distance` combines the distance from the current node and the distance to the destination, ensuring the path moves towards the goal efficiently. The function returns the destination if no unvisited nodes remain, otherwise it chooses the node minimizing this combined distance.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination node to guide the path towards the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_current + distance_to_destination\n\n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the immediate distance from the current node with the average distance to all remaining unvisited nodes, prioritizing nodes that are closer to the current position while also ensuring global connectivity by favoring those with lower average distances to the rest of the unvisited nodes. The `score` is computed as the sum of these two distances, and the node with the lowest score is chosen as the next node. The `distance_to_current` is given higher priority in the selection process, while the `avg_distance` ensures the algorithm considers the broader connectivity of the solution. The function handles edge cases (e.g., only one unvisited node) separately to avoid division by zero.",
          "thought": "The new algorithm prioritizes nodes by balancing the distance to the current node with the average distance to all remaining unvisited nodes, favoring nodes that are closer to the current node but also have lower average distances to the rest of the unvisited nodes to ensure global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) == 1:\n            avg_distance = 0\n        else:\n            avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n\n        score = distance_to_current + avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the product of the distance from the current node to the candidate and the distance from the candidate to the destination, balancing immediate proximity and long-term efficiency. It prioritizes nodes that are both relatively close to the current position and far from the destination, ensuring dynamic path adjustment based on unvisited nodes. The code iterates through unvisited nodes, computes the product of these distances, and selects the node with the highest product.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the product of the distance from the current node to the candidate node and the distance from the candidate node to the destination, ensuring a balance between immediate proximity and long-term efficiency, dynamically adjusting the path based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_product = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        product = distance_to_current * distance_to_destination\n\n        if product > max_product:\n            max_product = product\n            next_node = node\n\n    return next_node",
          "objective": 31.32683,
          "other_inf": null
     }
]