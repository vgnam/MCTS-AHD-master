{
     "algorithm": "The algorithm prioritizes immediate distance and centrality (weighted higher early) while dynamically adjusting lookahead depth and connectivity penalties to balance global connectivity (early) and local optimization (later) via exploration_factor and visited_ratio. It uses weighted scores combining immediate distance, lookahead averages, centrality, and connectivity penalties, with weights shifting based on remaining nodes. Key variables: immediate_distance (high early weight), node_centrality (high early weight), and connectivity_factor (boosts well-connected nodes). The algorithm balances exploration (lookahead) and exploitation (immediate distance) via exploration_factor, while penalties and weights adapt to visited_ratio.",
     "thought": "The new algorithm prioritizes local density with a higher weight on immediate distance and centrality, while dynamically adjusting lookahead depth and connectivity penalties based on remaining nodes to favor global connectivity early and local optimization later.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_count = len(unvisited_nodes)\n    total_nodes = remaining_count + 1\n    exploration_factor = 1.0 - (remaining_count / total_nodes) * 0.5\n    visited_ratio = 1 - (remaining_count / total_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            node_centrality = avg_distance\n        else:\n            avg_distance = 0\n            node_centrality = 0\n\n        connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * avg_distance)\n        connectivity_factor = 1.0 + (connectivity / (total_nodes - 1)) * 0.5\n\n        lookahead_depth = min(5, remaining_count // 3) if remaining_count > 3 else 1\n        nearest_neighbors = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:lookahead_depth] if remaining_nodes else []\n        avg_neighbor_distance = sum(distance_matrix[node][n] for n in nearest_neighbors) / len(nearest_neighbors) if nearest_neighbors else 0\n\n        immediate_weight = 0.7 + 0.2 * exploration_factor\n        lookahead_weight = 0.3 * (1.0 - exploration_factor)\n        centrality_weight = 0.8 * (1.0 - lookahead_weight)\n        penalty_weight = 0.4 * (1 - visited_ratio)\n\n        score = immediate_weight * immediate_distance + lookahead_weight * (immediate_distance - avg_distance) - centrality_weight * node_centrality\n        penalty = 1 + (0.7 * avg_neighbor_distance / (immediate_distance + 1e-6)) * (1 - visited_ratio)\n        score *= penalty * connectivity_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
     "objective": 6.31125,
     "other_inf": null
}