[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to unvisited nodes and focus on the destination by adjusting a threshold based on the remaining distance to the destination and the number of unvisited nodes. It prioritizes the destination if it's close enough (below the threshold) or selects the next node based on a weighted combination of current distance and future distance to the destination, ensuring a trade-off between local and global optimization. The dynamic threshold (`dynamic_threshold`) and the weighted selection criterion (`key=lambda...`) are the critical design elements.",
          "thought": "This new algorithm introduces a dynamic threshold mechanism that adjusts based on the remaining distance to the destination and the number of unvisited nodes, prioritizing either the closest node or the destination based on a calculated threshold, ensuring a balance between proximity and destination focus.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_threshold = max(1, (distance_matrix[current_node][destination_node] / (len(unvisited_nodes) + 1)) * 0.75)\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= dynamic_threshold:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.1 * (distance_matrix[node][destination_node] / sum(distance_matrix[node]))))\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic that prioritizes both the distance from the current node and the distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. It balances local optimization (proximity to the current node) and global optimization (proximity to the destination) by scaling the weight between 0.5 and 1, favoring the destination when fewer nodes remain. The heuristic function multiplies the distance to the destination by the distance to the current node, ensuring both factors influence the selection.",
          "thought": "The new algorithm combines multiplicative prioritization of distances with a weighted sum heuristic, dynamically adjusting weights based on the remaining unvisited nodes' proximity to the destination, to balance local and global optimization while minimizing the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        return weight * to_current + (1 - weight) * to_destination * to_current\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.02736,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically balances exploration and exploitation by adjusting the exploration factor based on progress, scaling detours proportionally to remaining nodes, and penalizing revisits based on node centrality. It prioritizes immediate costs early but increasingly weights strategic detours toward the end, with a time-decaying normalization to smooth transitions. The heuristic combines normalized immediate and detour costs, adjusted by progress-dependent scaling and penalties, to select the next node.",
          "thought": "The new algorithm introduces a dynamic exploration/exploitation trade-off using a progress-dependent exploration factor, adaptive detour scaling with remaining nodes, and a penalty mechanism that increases for revisits based on node centrality, while normalizing costs with a time-decaying factor to prioritize strategic detours in later stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0\n\n    max_distance = max(max(row) for row in distance_matrix)\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes if unvisited_nodes else 0\n\n    exploration_factor = 0.2 + 0.6 * (1 - progress_ratio) ** 2\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node] / max_distance\n        detour_cost = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / max_distance\n\n        detour_scaling = (remaining_nodes / total_nodes) ** 2 * (1 - progress_ratio)\n        adjusted_detour = detour_cost * detour_scaling\n\n        revisit_penalty = 0.0\n        if node != destination_node and node in unvisited_nodes:\n            node_degree = sum(1 for d in distance_matrix[node] if d < avg_unvisited_distance)\n            revisit_penalty = 0.1 * (1 - progress_ratio) * (node_degree / total_nodes)\n\n        time_decay = 0.5 ** progress_ratio\n        normalized_cost = (exploration_factor * immediate_cost + (1 - exploration_factor) * adjusted_detour) * time_decay\n\n        return normalized_cost + revisit_penalty\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.0438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity to the current node, detour penalties (adjusted by node centrality and remaining nodes), and centrality factors, prioritizing nodes with lower detour costs and higher centrality (reduced penalties) to encourage exploration of less central nodes while adapting weights based on remaining nodes. The heuristic function combines these factors to evaluate node suitability, with detour_weight adjusting penalties inversely with remaining nodes and centrality_factor emphasizing less central nodes. The code structure integrates these components into a single selection criterion, dynamically adjusting priorities as the algorithm progresses.",
          "thought": "The new algorithm modifies the heuristic by incorporating dynamic detour penalties based on node centrality, where nodes with higher centrality (measured by average distance to all unvisited nodes) receive reduced detour penalties to encourage exploration of less central nodes, while maintaining a balance between local and global optimization through adaptive weights that increase as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    proximity_factor = 1 - (distance_matrix[current_node][destination_node] / max(distance_matrix[current_node][i] for i in unvisited_nodes))\n    detour_weight = 0.1 + 0.7 * (remaining_nodes / (remaining_nodes + 1)) * proximity_factor\n\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes\n    centrality = {node: sum(distance_matrix[node][j] for j in unvisited_nodes) / remaining_nodes for node in unvisited_nodes}\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        centrality_factor = 1 - (centrality[node] / max(centrality.values()))\n        balance_factor = (avg_unvisited_distance - to_current) / avg_unvisited_distance\n        return to_current + detour_weight * detour_cost * balance_factor * centrality_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.0957,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic with a dynamic progress factor to balance local (distance to current node) and global (distance to destination) optimization. It prioritizes nodes that minimize a weighted combination of these distances, adjusting weights based on remaining unvisited nodes and progress toward the destination. The heuristic dynamically shifts focus from local to global optimization as the algorithm progresses.",
          "thought": "The new algorithm combines the weighted sum heuristic from No.1 with the progress factor from No.2, dynamically adjusting weights based on the number of unvisited nodes and progress towards the destination, to balance local and global optimization while prioritizing nodes that reduce path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return weight * to_current + (1 - weight) * to_destination * (1 - progress_factor)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, potential detour costs to the destination, and node centrality, while dynamically adjusting weights based on progress (prioritizing proximity early) and path diversity (favoring less central nodes later). Detour costs are weighted inversely with remaining nodes, and diversity is emphasized as the tour progresses. The heuristic combines these factors to prioritize nodes that minimize immediate distance, detour risk, and centrality while encouraging exploration early.",
          "thought": "The new algorithm combines the dynamic balancing of proximity, detour potential, and centrality from No.1 with the progress-based weighting and diversity considerations from No.2, adjusting detour weights inversely with remaining nodes and emphasizing less central nodes for better exploration while maintaining path diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    detour_weight = 0.1 + 0.7 * (remaining_nodes / (remaining_nodes + 1)) * (1 - progress_factor)\n    path_diversity = 0.3 * (len(distance_matrix) - remaining_nodes) / len(distance_matrix)\n\n    centrality = {node: sum(distance_matrix[node][j] for j in unvisited_nodes) / remaining_nodes for node in unvisited_nodes}\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        centrality_factor = 1 - (centrality[node] / max(centrality.values()))\n        diversity_cost = to_current - distance_matrix[current_node][destination_node]\n        balance_factor = (avg_unvisited_distance - to_current) / avg_unvisited_distance\n        return to_current + detour_weight * detour_cost * balance_factor * centrality_factor + path_diversity * diversity_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.13851,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **proximity-aware selection** with **detour weighting** to balance immediate distance, potential future detours, and global optimization. It prioritizes nodes closer to the current node while dynamically adjusting the detour weight based on remaining nodes and proximity to the destination, ensuring efficient path planning as unvisited nodes decrease. The heuristic function (`to_current + detour_weight * detour_cost * balance_factor`) ensures a trade-off between minimizing immediate distance and optimizing long-term path efficiency.",
          "thought": "This new algorithm combines the adaptive detour weighting from Algorithm 1 and 2 with a proximity-aware heuristic that balances immediate distance, detour costs, and global optimization by incorporating both the average unvisited distance and a dynamic proximity factor to ensure efficient path planning as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    proximity_factor = 1 - (distance_matrix[current_node][destination_node] / max(distance_matrix[current_node][i] for i in unvisited_nodes))\n    detour_weight = 0.2 + 0.5 * (remaining_nodes / (remaining_nodes + 1)) * proximity_factor\n\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        balance_factor = (avg_unvisited_distance - to_current) / avg_unvisited_distance\n        return to_current + detour_weight * detour_cost * balance_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.14907,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local (distance to current node) and global (proximity to destination) factors, using a detour weight that adapts based on remaining nodes and current proximity to the destination. It prioritizes nodes closer to the current position while considering detour costs relative to the average distance to unvisited nodes, with higher weights given to global optimization as the number of remaining nodes decreases. The heuristic function combines these factors to guide the selection toward nodes that minimize immediate distance while maintaining overall path efficiency.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating a dynamic detour weight that adapts based on both the number of remaining nodes and the current position's proximity to the destination, while also considering the average distance to unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    proximity_factor = 1 - (distance_matrix[current_node][destination_node] / max(distance_matrix[current_node][i] for i in unvisited_nodes))\n    detour_weight = 0.1 + 0.7 * (remaining_nodes / (remaining_nodes + 1)) * proximity_factor\n\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        balance_factor = (avg_unvisited_distance - to_current) / avg_unvisited_distance\n        return to_current + detour_weight * detour_cost * balance_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.20078,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between minimizing immediate distance (70% early, 30% late) and reducing detours (30% early, 70% late) by adjusting weights based on progress, while penalizing revisits to non-destination nodes and scaling detour costs with remaining nodes. It prioritizes proximity early but increasingly values strategic detours later, using normalized costs and penalties to guide node selection. The heuristic combines immediate and detour costs with dynamic weights, penalties, and progress-based adjustments.",
          "thought": "The new algorithm combines dynamic weighting between immediate distance minimization and detour reduction, with weights shifting from 70% proximity to 30% detour reduction as progress increases, while incorporating a penalty for revisiting non-destination nodes and adjusting detour costs based on remaining nodes and proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0\n\n    max_distance = max(max(row) for row in distance_matrix)\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes if unvisited_nodes else 0\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node] / max_distance\n        detour_cost = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / max_distance\n\n        weight_proximity = 0.7 if progress_ratio < 0.5 else 0.3\n        weight_detour = 1 - weight_proximity\n\n        penalty = 0.2 if node in unvisited_nodes and node != destination_node else 0.0\n\n        adjusted_detour = detour_cost * (remaining_nodes / total_nodes) * (1 - progress_ratio)\n\n        return weight_proximity * immediate_cost + weight_detour * adjusted_detour + penalty\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.22886,
          "other_inf": null
     }
]