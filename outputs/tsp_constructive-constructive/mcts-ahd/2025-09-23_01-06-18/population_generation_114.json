[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to unvisited nodes and focus on the destination by adjusting a threshold based on the remaining distance to the destination and the number of unvisited nodes. It prioritizes the destination if it's close enough (below the threshold) or selects the next node based on a weighted combination of current distance and future distance to the destination, ensuring a trade-off between local and global optimization. The dynamic threshold (`dynamic_threshold`) and the weighted selection criterion (`key=lambda...`) are the critical design elements.",
          "thought": "This new algorithm introduces a dynamic threshold mechanism that adjusts based on the remaining distance to the destination and the number of unvisited nodes, prioritizing either the closest node or the destination based on a calculated threshold, ensuring a balance between proximity and destination focus.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_threshold = max(1, (distance_matrix[current_node][destination_node] / (len(unvisited_nodes) + 1)) * 0.75)\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= dynamic_threshold:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.1 * (distance_matrix[node][destination_node] / sum(distance_matrix[node]))))\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic that prioritizes both the distance from the current node and the distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. It balances local optimization (proximity to the current node) and global optimization (proximity to the destination) by scaling the weight between 0.5 and 1, favoring the destination when fewer nodes remain. The heuristic function multiplies the distance to the destination by the distance to the current node, ensuring both factors influence the selection.",
          "thought": "The new algorithm combines multiplicative prioritization of distances with a weighted sum heuristic, dynamically adjusting weights based on the remaining unvisited nodes' proximity to the destination, to balance local and global optimization while minimizing the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        return weight * to_current + (1 - weight) * to_destination * to_current\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.02736,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic with a dynamic progress factor to balance local (distance to current node) and global (distance to destination) optimization. It prioritizes nodes that minimize a weighted combination of these distances, adjusting weights based on remaining unvisited nodes and progress toward the destination. The heuristic dynamically shifts focus from local to global optimization as the algorithm progresses.",
          "thought": "The new algorithm combines the weighted sum heuristic from No.1 with the progress factor from No.2, dynamically adjusting weights based on the number of unvisited nodes and progress towards the destination, to balance local and global optimization while prioritizing nodes that reduce path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return weight * to_current + (1 - weight) * to_destination * (1 - progress_factor)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local (distance to current node) and global (proximity to destination) factors, using a detour weight that adapts based on remaining nodes and current proximity to the destination. It prioritizes nodes closer to the current position while considering detour costs relative to the average distance to unvisited nodes, with higher weights given to global optimization as the number of remaining nodes decreases. The heuristic function combines these factors to guide the selection toward nodes that minimize immediate distance while maintaining overall path efficiency.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating a dynamic detour weight that adapts based on both the number of remaining nodes and the current position's proximity to the destination, while also considering the average distance to unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    proximity_factor = 1 - (distance_matrix[current_node][destination_node] / max(distance_matrix[current_node][i] for i in unvisited_nodes))\n    detour_weight = 0.1 + 0.7 * (remaining_nodes / (remaining_nodes + 1)) * proximity_factor\n\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        balance_factor = (avg_unvisited_distance - to_current) / avg_unvisited_distance\n        return to_current + detour_weight * detour_cost * balance_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.20078,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity, detour potential, and path diversity by adjusting weights based on progress (progress_factor) and remaining nodes (detour_weight, path_diversity). It prioritizes direct paths early (lower detour_weight) but increasingly considers longer-term gains (higher detour_weight) as the tour progresses, while path_diversity encourages exploration of less direct routes. The heuristic function combines these factors to select the next node, favoring nodes that minimize immediate distance but also account for their potential to reduce future detours.",
          "thought": "The new algorithm integrates a dynamic detour weight that adapts to both the number of remaining nodes and the current path progress, incorporating a path diversity factor to encourage exploration of less direct paths while balancing immediate and long-term costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    detour_weight = 0.2 + 0.6 * (remaining_nodes / (remaining_nodes + 1)) * (1 - progress_factor)\n\n    path_diversity = 0.3 * (len(distance_matrix) - remaining_nodes) / len(distance_matrix)\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        diversity_cost = distance_matrix[current_node][node] - distance_matrix[current_node][destination_node]\n        return to_current + detour_weight * detour_cost + path_diversity * diversity_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.30788,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a 2-step lookahead mechanism with a weighted heuristic, prioritizing immediate proximity (80%) and future cost estimation (20%) to select the next node. It evaluates the top 2 nearest neighbors recursively to estimate future travel costs, balancing short-term and long-term considerations. The heuristic function ensures that immediate distance is weighted more heavily than future cost, guiding the path toward the destination efficiently.",
          "thought": "The new algorithm combines the lookahead mechanism from No.1 with the proximity and progress balancing from No.2, using a 2-step lookahead over the top 2 nearest neighbors to estimate future cost while maintaining the weighted heuristic (80% proximity, 20% progress).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=2):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:2]\n        return min(\n            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1)\n            for candidate in next_candidates\n        )\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = evaluate_path(node)\n        return 0.8 * immediate_cost + 0.2 * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.32518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both close to the current node and the destination while balancing proximity and local density, with a decay factor reducing the influence of density as fewer nodes remain unvisited. It normalizes distances to ensure fairness and uses a heuristic combining proximity, destination progress, and neighborhood density to guide the selection. The decay factor and density term dynamically adjust priorities, favoring closer nodes later in the search.",
          "thought": "The new algorithm dynamically balances proximity to the current node, progress toward the destination, and local density of unvisited nodes, using a heuristic that combines normalized distances with a decay factor and a density term to prioritize nodes that are both close to the current position and surrounded by many unvisited neighbors, while gradually favoring closer nodes as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        max_distance = max(max(row) for row in distance_matrix)\n\n        normalized_to_current = to_current / max_distance\n        normalized_to_destination = to_destination / max_distance\n\n        decay_factor = 0.1 * (len(unvisited_nodes) / len(distance_matrix))\n\n        density = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < max_distance * 0.3)\n        density_term = density / len(unvisited_nodes) if unvisited_nodes else 0\n\n        return (normalized_to_current * normalized_to_destination) * (1 - decay_factor) * (1 + density_term)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.32569,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance to the next node while adaptively adjusting the influence of potential detours based on remaining unvisited nodes. It balances local efficiency (direct distance to the current node) with global efficiency (detour cost relative to the direct path to the destination) using a dynamic detour weight that increases as the number of unvisited nodes decreases. The heuristic function combines these factors, giving higher priority to immediate distance early on but gradually emphasizing detour costs as the tour nears completion.",
          "thought": "The new algorithm prioritizes minimizing immediate distance while adaptively increasing the influence of detour costs as the number of unvisited nodes decreases, using a different detour weight calculation and heuristic function to balance local and global path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    detour_weight = 0.3 + 0.5 * (1 / (remaining_nodes + 1))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        return to_current + detour_weight * detour_cost * (remaining_nodes / (remaining_nodes + 2))\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.36327,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future costs by adjusting weights based on node density, using a 4-step lookahead to prioritize nodes with both short-term proximity and long-term potential, while penalizing revisits to avoid cycles. It assigns higher priority to immediate costs when few nodes remain (via dynamic_weight) and lower priority to future costs in dense graphs, with a greedy selection strategy favoring the top 3 candidates at each step. The heuristic function combines these factors to guide node selection.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances immediate and future costs based on the remaining unvisited nodes' density, using a 4-step lookahead with a greedy selection strategy that prioritizes nodes with both short-term proximity and long-term potential, while incorporating a penalty for revisiting nodes in the lookahead to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=4, visited=None):\n        if visited is None:\n            visited = set()\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node and n not in visited]\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:3]\n        visited.add(node)\n        return min(\n            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1, visited.copy())\n            for candidate in next_candidates\n        )\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = evaluate_path(node)\n        density_factor = len(unvisited_nodes) / len(distance_matrix)\n        dynamic_weight = 0.6 + 0.2 * density_factor\n        return dynamic_weight * immediate_cost + (1 - dynamic_weight) * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.37869,
          "other_inf": null
     }
]