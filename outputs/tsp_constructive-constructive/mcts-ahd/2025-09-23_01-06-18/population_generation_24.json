[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) considerations, weighted dynamically by the number of remaining unvisited nodes, while also incorporating the average distance to unvisited nodes. The heuristic prioritizes minimizing the sum of current distance and a weighted destination distance, with the dynamic weight adjusting for global progress. The average distance factor adds a secondary influence, ensuring a mix of local and global optimization.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between local optimization and global progress, while also considering the average distance to unvisited nodes to guide the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Adjusts based on remaining nodes\n        return to_current + dynamic_weight * to_destination + 0.3 * avg_distance_to_unvisited  # Adds average distance factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing the sum of the direct distance to the current node and half the distance to the destination. This ensures a trade-off between local optimization (short-term gains) and global progress (long-term goals). The heuristic function `heuristic(node)` combines these two factors, with the distance to the destination weighted lower (0.5x) than the distance to the current node. The algorithm efficiently handles edge cases (empty unvisited nodes or destination in unvisited nodes) and iteratively chooses the optimal next step.",
          "thought": "The new algorithm prioritizes nodes based on a combination of distance to the current node and distance to the destination node, ensuring a balance between proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + 0.5 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of its distance to the current node and its distance to the destination, balancing proximity and progress while avoiding local optima. It ensures the multiplicative effect of distances is considered, giving higher priority to nodes that are closer to both the current and destination nodes. The heuristic function (`to_current * to_destination`) explicitly encodes this multiplicative prioritization, while the `min` operation selects the optimal node based on this criterion.",
          "thought": "The new algorithm selects the next node by prioritizing the node that minimizes the product of the distance to the current node and the distance to the destination, ensuring a balance between proximity and progress while avoiding local optima by considering the multiplicative effect of distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node and progress toward the destination, combining the distance to the current node with the square root of the distance to the destination. This emphasizes global progress more than local proximity, as the square root of the distance to the destination is added to the direct distance from the current node. The heuristic function ensures the algorithm makes informed decisions by minimizing the combined metric, guiding the path toward the destination efficiently.",
          "thought": "The new algorithm prioritizes balancing proximity to the current node and progress toward the destination by combining the distance to the current node with the square root of the distance to the destination, emphasizing global progress more significantly than the provided algorithm.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (to_destination ** 0.5)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.65711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance to the destination by adjusting a `progress_factor` that scales with the ratio of the current-to-destination distance to the average distance to unvisited nodes. Closer nodes are prioritized when progress is slow (`progress_factor` decreases), while a steady balance is maintained otherwise, ensuring efficient path selection while handling edge cases (empty/unvisited sets). The heuristic prioritizes minimizing the sum of the current distance and a weighted destination distance, with the weight dynamically adjusted for optimal progress.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the current progress toward the destination, favoring closer nodes when progress is slow and balancing proximity and destination distance when progress is steady, while maintaining edge case handling for efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (1 - progress_factor) * to_destination\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.95665,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing both proximity to the current node and progress toward the destination, with the latter weighted 1.5 times more strongly (using `to_current + 1.5 * to_destination`). It ensures the destination is visited last if it remains unvisited, and handles edge cases where no nodes are left to visit. The code balances local and global considerations, favoring global progress while still accounting for immediate proximity.",
          "thought": "The new algorithm prioritizes balancing proximity to the current node and progress toward the destination by combining their distances with a different weighting scheme, favoring global progress (distance to destination) more strongly (1.5x) while still considering local proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + 1.5 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 8.454,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, direct distance to the destination, and a weighted sum of distances to remaining unvisited nodes. The heuristic prioritizes local efficiency (distance to current node) and global efficiency (distance to destination and unvisited nodes, weighted at 0.5 and 0.3 respectively), ensuring a trade-off between immediate and long-term optimization. The code structure uses a nested `heuristic` function to compute the weighted sum and selects the node with the minimum heuristic value.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted balance of the distance to the destination and the sum of distances to remaining unvisited nodes, prioritizing local optimization while maintaining global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        cumulative_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)\n        return to_current + 0.5 * (to_destination + 0.3 * cumulative_to_unvisited)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 11.07692,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing immediate proximity (distance from the current node) and long-term efficiency (estimated cumulative distance to the destination and remaining unvisited nodes), with the former given higher weight (1.0) and the latter given lower weight (0.3). It selects the next node by minimizing a heuristic that combines these two factors, ensuring the path is both locally optimal and globally efficient. The function handles edge cases (empty unvisited nodes or destination in unvisited) and uses the distance matrix for all calculations.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current node but also considers the cumulative distance from the current node to the destination, balancing immediate proximity with long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        cumulative_to_destination = distance_matrix[node][destination_node] + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)\n        return to_current + 0.3 * cumulative_to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 13.76293,
          "other_inf": null
     }
]