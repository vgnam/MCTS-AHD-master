[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing proximity to the current node (70%) and progress toward the destination (30%), minimizing a weighted sum of these distances. It prioritizes closer nodes while still making progress, avoiding local optima by dynamically choosing the best unvisited node based on the weighted heuristic. The weights (0.7 and 0.3) are tunable to adjust the trade-off between local and global optimization.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance to the current node and their distance to the destination, using a tunable parameter to balance proximity and progress, while still avoiding local optima by selecting the node that minimizes this weighted sum.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return 0.7 * to_current + 0.3 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) considerations, weighted dynamically by the number of remaining unvisited nodes, while also incorporating the average distance to unvisited nodes. The heuristic prioritizes minimizing the sum of current distance and a weighted destination distance, with the dynamic weight adjusting for global progress. The average distance factor adds a secondary influence, ensuring a mix of local and global optimization.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between local optimization and global progress, while also considering the average distance to unvisited nodes to guide the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Adjusts based on remaining nodes\n        return to_current + dynamic_weight * to_destination + 0.3 * avg_distance_to_unvisited  # Adds average distance factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing the sum of the direct distance to the current node and half the distance to the destination. This ensures a trade-off between local optimization (short-term gains) and global progress (long-term goals). The heuristic function `heuristic(node)` combines these two factors, with the distance to the destination weighted lower (0.5x) than the distance to the current node. The algorithm efficiently handles edge cases (empty unvisited nodes or destination in unvisited nodes) and iteratively chooses the optimal next step.",
          "thought": "The new algorithm prioritizes nodes based on a combination of distance to the current node and distance to the destination node, ensuring a balance between proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + 0.5 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of its distance to the current node and its distance to the destination, balancing proximity and progress while avoiding local optima. It ensures the multiplicative effect of distances is considered, giving higher priority to nodes that are closer to both the current and destination nodes. The heuristic function (`to_current * to_destination`) explicitly encodes this multiplicative prioritization, while the `min` operation selects the optimal node based on this criterion.",
          "thought": "The new algorithm selects the next node by prioritizing the node that minimizes the product of the distance to the current node and the distance to the destination, ensuring a balance between proximity and progress while avoiding local optima by considering the multiplicative effect of distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing the product of distances from the current node to the candidate and from the candidate to the destination, scaled by a progress factor that adjusts dynamically based on the ratio of the current-to-destination distance to the average distance to unvisited nodes. The progress factor balances exploration (lower factor) and exploitation (higher factor), prioritizing nodes that reduce the path length while considering remaining progress. The heuristic prioritizes nodes closer to both the current and destination nodes, with the progress factor modulating this trade-off.",
          "thought": "The new algorithm combines the multiplicative prioritization of No.2 with the dynamic progress factor of No.1, selecting the next node by minimizing the product of distances to current and destination nodes, scaled by a progress factor that adjusts based on the ratio of current-to-destination distance to the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return (to_current * to_destination) * (1 - progress_factor)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.4922,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node and progress toward the destination, combining the distance to the current node with the square root of the distance to the destination. This emphasizes global progress more than local proximity, as the square root of the distance to the destination is added to the direct distance from the current node. The heuristic function ensures the algorithm makes informed decisions by minimizing the combined metric, guiding the path toward the destination efficiently.",
          "thought": "The new algorithm prioritizes balancing proximity to the current node and progress toward the destination by combining the distance to the current node with the square root of the distance to the destination, emphasizing global progress more significantly than the provided algorithm.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (to_destination ** 0.5)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.65711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance to the destination by adjusting a `progress_factor` that scales with the ratio of the current-to-destination distance to the average distance to unvisited nodes. Closer nodes are prioritized when progress is slow (`progress_factor` decreases), while a steady balance is maintained otherwise, ensuring efficient path selection while handling edge cases (empty/unvisited sets). The heuristic prioritizes minimizing the sum of the current distance and a weighted destination distance, with the weight dynamically adjusted for optimal progress.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the current progress toward the destination, favoring closer nodes when progress is slow and balancing proximity and destination distance when progress is steady, while maintaining edge case handling for efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (1 - progress_factor) * to_destination\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.95665,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, using a tunable parameter `alpha` to weigh their importance. When `alpha` is high, it prioritizes nearby nodes; when low, it favors nodes closer to the destination. The heuristic function computes a weighted sum of these distances, and the node with the minimum value is chosen.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance to the current node and their distance to the destination, using a tunable parameter to balance proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.5):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return alpha * to_current + (1 - alpha) * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance to the current node (60% weight) and the distance to the destination (40% weight), while dynamically adjusting the latter with a factor that penalizes nodes farther from the destination. This ensures a trade-off between local progress and global direction, avoiding premature convergence by scaling the destination distance based on the current node's proximity to the destination. The heuristic function dynamically modifies the weights to guide the selection toward nodes that are closer to the destination while still considering the immediate path.",
          "thought": "The new algorithm modifies the heuristic by incorporating a weighted sum of the distances to the current node and destination, adjusted by a dynamic factor that penalizes nodes farther from the destination to balance exploration and progress while avoiding premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_factor = 1.0 + (to_destination / (distance_matrix[current_node][destination_node] + 1e-10))\n        return (0.6 * to_current + 0.4 * to_destination) * dynamic_factor\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 8.30767,
          "other_inf": null
     }
]