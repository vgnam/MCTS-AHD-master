[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to unvisited nodes and focus on the destination by adjusting a threshold based on the remaining distance to the destination and the number of unvisited nodes. It prioritizes the destination if it's close enough (below the threshold) or selects the next node based on a weighted combination of current distance and future distance to the destination, ensuring a trade-off between local and global optimization. The dynamic threshold (`dynamic_threshold`) and the weighted selection criterion (`key=lambda...`) are the critical design elements.",
          "thought": "This new algorithm introduces a dynamic threshold mechanism that adjusts based on the remaining distance to the destination and the number of unvisited nodes, prioritizing either the closest node or the destination based on a calculated threshold, ensuring a balance between proximity and destination focus.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_threshold = max(1, (distance_matrix[current_node][destination_node] / (len(unvisited_nodes) + 1)) * 0.75)\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= dynamic_threshold:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.1 * (distance_matrix[node][destination_node] / sum(distance_matrix[node]))))\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic that prioritizes both the distance from the current node and the distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. It balances local optimization (proximity to the current node) and global optimization (proximity to the destination) by scaling the weight between 0.5 and 1, favoring the destination when fewer nodes remain. The heuristic function multiplies the distance to the destination by the distance to the current node, ensuring both factors influence the selection.",
          "thought": "The new algorithm combines multiplicative prioritization of distances with a weighted sum heuristic, dynamically adjusting weights based on the remaining unvisited nodes' proximity to the destination, to balance local and global optimization while minimizing the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        return weight * to_current + (1 - weight) * to_destination * to_current\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.02736,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a 2-step lookahead mechanism with a weighted heuristic, prioritizing immediate proximity (80%) and future cost estimation (20%) to select the next node. It evaluates the top 2 nearest neighbors recursively to estimate future travel costs, balancing short-term and long-term considerations. The heuristic function ensures that immediate distance is weighted more heavily than future cost, guiding the path toward the destination efficiently.",
          "thought": "The new algorithm combines the lookahead mechanism from No.1 with the proximity and progress balancing from No.2, using a 2-step lookahead over the top 2 nearest neighbors to estimate future cost while maintaining the weighted heuristic (80% proximity, 20% progress).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=2):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:2]\n        return min(\n            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1)\n            for candidate in next_candidates\n        )\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = evaluate_path(node)\n        return 0.8 * immediate_cost + 0.2 * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.32518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both close to the current node and the destination while balancing proximity and local density, with a decay factor reducing the influence of density as fewer nodes remain unvisited. It normalizes distances to ensure fairness and uses a heuristic combining proximity, destination progress, and neighborhood density to guide the selection. The decay factor and density term dynamically adjust priorities, favoring closer nodes later in the search.",
          "thought": "The new algorithm dynamically balances proximity to the current node, progress toward the destination, and local density of unvisited nodes, using a heuristic that combines normalized distances with a decay factor and a density term to prioritize nodes that are both close to the current position and surrounded by many unvisited neighbors, while gradually favoring closer nodes as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        max_distance = max(max(row) for row in distance_matrix)\n\n        normalized_to_current = to_current / max_distance\n        normalized_to_destination = to_destination / max_distance\n\n        decay_factor = 0.1 * (len(unvisited_nodes) / len(distance_matrix))\n\n        density = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < max_distance * 0.3)\n        density_term = density / len(unvisited_nodes) if unvisited_nodes else 0\n\n        return (normalized_to_current * normalized_to_destination) * (1 - decay_factor) * (1 + density_term)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.32569,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future costs by adjusting weights based on node density, using a 4-step lookahead to prioritize nodes with both short-term proximity and long-term potential, while penalizing revisits to avoid cycles. It assigns higher priority to immediate costs when few nodes remain (via dynamic_weight) and lower priority to future costs in dense graphs, with a greedy selection strategy favoring the top 3 candidates at each step. The heuristic function combines these factors to guide node selection.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances immediate and future costs based on the remaining unvisited nodes' density, using a 4-step lookahead with a greedy selection strategy that prioritizes nodes with both short-term proximity and long-term potential, while incorporating a penalty for revisiting nodes in the lookahead to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=4, visited=None):\n        if visited is None:\n            visited = set()\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node and n not in visited]\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:3]\n        visited.add(node)\n        return min(\n            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1, visited.copy())\n            for candidate in next_candidates\n        )\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = evaluate_path(node)\n        density_factor = len(unvisited_nodes) / len(distance_matrix)\n        dynamic_weight = 0.6 + 0.2 * density_factor\n        return dynamic_weight * immediate_cost + (1 - dynamic_weight) * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.37869,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing proximity to the current node (70%) and progress toward the destination (30%), minimizing a weighted sum of these distances. It prioritizes closer nodes while still making progress, avoiding local optima by dynamically choosing the best unvisited node based on the weighted heuristic. The weights (0.7 and 0.3) are tunable to adjust the trade-off between local and global optimization.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance to the current node and their distance to the destination, using a tunable parameter to balance proximity and progress, while still avoiding local optima by selecting the node that minimizes this weighted sum.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return 0.7 * to_current + 0.3 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) considerations, weighted dynamically by the number of remaining unvisited nodes, while also incorporating the average distance to unvisited nodes. The heuristic prioritizes minimizing the sum of current distance and a weighted destination distance, with the dynamic weight adjusting for global progress. The average distance factor adds a secondary influence, ensuring a mix of local and global optimization.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between local optimization and global progress, while also considering the average distance to unvisited nodes to guide the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Adjusts based on remaining nodes\n        return to_current + dynamic_weight * to_destination + 0.3 * avg_distance_to_unvisited  # Adds average distance factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing the sum of the direct distance to the current node and half the distance to the destination. This ensures a trade-off between local optimization (short-term gains) and global progress (long-term goals). The heuristic function `heuristic(node)` combines these two factors, with the distance to the destination weighted lower (0.5x) than the distance to the current node. The algorithm efficiently handles edge cases (empty unvisited nodes or destination in unvisited nodes) and iteratively chooses the optimal next step.",
          "thought": "The new algorithm prioritizes nodes based on a combination of distance to the current node and distance to the destination node, ensuring a balance between proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + 0.5 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of its distance to the current node and its distance to the destination, balancing proximity and progress while avoiding local optima. It ensures the multiplicative effect of distances is considered, giving higher priority to nodes that are closer to both the current and destination nodes. The heuristic function (`to_current * to_destination`) explicitly encodes this multiplicative prioritization, while the `min` operation selects the optimal node based on this criterion.",
          "thought": "The new algorithm selects the next node by prioritizing the node that minimizes the product of the distance to the current node and the distance to the destination, ensuring a balance between proximity and progress while avoiding local optima by considering the multiplicative effect of distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     }
]