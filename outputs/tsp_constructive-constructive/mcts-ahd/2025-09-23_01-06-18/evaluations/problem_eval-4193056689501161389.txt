def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    num_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)

    def calculate_centrality(node):
        if remaining_nodes == 1:
            return 0.0
        total_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)
        return total_distance / (remaining_nodes - 1)

    def calculate_time_decay():
        progress_ratio = (num_nodes - remaining_nodes) / num_nodes
        return 1.0 - (progress_ratio ** 2)

    def heuristic(node):
        direct_distance = distance_matrix[current_node][node]
        centrality = calculate_centrality(node)
        time_decay = calculate_time_decay()

        exploration_weight = 1.0 - (remaining_nodes / num_nodes)
        distance_weight = 1.0 + (remaining_nodes / num_nodes)

        hybrid_score = (direct_distance * distance_weight) + (centrality * exploration_weight)
        decay_factor = 1.0 / (1.0 + time_decay * (distance_matrix[node][destination_node] / num_nodes))

        return hybrid_score * decay_factor

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
