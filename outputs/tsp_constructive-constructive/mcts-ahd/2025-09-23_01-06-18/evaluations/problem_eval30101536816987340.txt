def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate centrality scores for each node
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node])  # Simple centrality measure (sum of distances to all other nodes)

    if destination_node in unvisited_nodes:
        if len(unvisited_nodes) == 1:
            return destination_node

        # Calculate proximity and centrality factors
        proximity_factor = 1 / (1 + distance_matrix[current_node][destination_node])
        centrality_factor = centrality[destination_node] / sum(centrality.values())

        # Temperature-dependent probability
        temperature = 1.0 + len(unvisited_nodes) / len(distance_matrix)  # Dynamic temperature adjustment
        prob = 0.5 + 0.5 * (1 - 1 / (1 + math.exp(-temperature * (proximity_factor + centrality_factor))))

        # Random selection with dynamic probability
        if random.random() < prob:
            return destination_node
        else:
            # Select node with highest combined score (proximity + centrality)
            return max(unvisited_nodes, key=lambda node: (1 / (1 + distance_matrix[current_node][node])) * centrality[node])
    else:
        # Select node with highest centrality if destination is visited
        return next_node
