def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = 1 - (remaining_nodes / total_nodes)

    # Phase 1: Early-stage local optimization with regret awareness
    if progress < 0.3:
        local_costs = [distance_matrix[current_node][node] for node in unvisited_nodes]
        regret_values = [max(local_costs) - cost for cost in local_costs]
        weights = [0.7 + 0.3 * (regret / (max(regret_values) + 1e-6)) for regret in regret_values]
        weighted_scores = [cost * weight for cost, weight in zip(local_costs, weights)]
        next_node = unvisited_nodes[weighted_scores.index(min(weighted_scores))]

    # Phase 2: Mid-stage hybrid optimization
    elif progress < 0.7:
        def hybrid_heuristic(node):
            local = distance_matrix[current_node][node]
            global_ = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)
            regret = max(distance_matrix[current_node][other] - local for other in unvisited_nodes) if unvisited_nodes else 0
            diversity = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)
            return (0.4 * local + 0.3 * global_ + 0.2 * regret - 0.1 * diversity)

        next_node = min(unvisited_nodes, key=hybrid_heuristic)

    # Phase 3: Late-stage global optimization with destination bias
    else:
        def final_heuristic(node):
            local = distance_matrix[current_node][node]
            to_dest = distance_matrix[node][destination_node]
            global_ = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)
            return (0.5 * local + 0.3 * to_dest + 0.2 * global_)

        next_node = min(unvisited_nodes, key=final_heuristic)

    # Special case: direct path to destination if within threshold
    if destination_node in unvisited_nodes:
        remaining_distance = distance_matrix[current_node][destination_node]
        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
        if avg_distance > 0 and remaining_distance / avg_distance <= 1.2:
            next_node = destination_node

    return next_node
