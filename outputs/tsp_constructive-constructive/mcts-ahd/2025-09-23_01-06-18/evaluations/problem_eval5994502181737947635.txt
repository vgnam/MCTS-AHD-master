def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)
    progress_factor = 1 - (remaining_nodes / total_nodes)

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]

        novelty_factor = progress_factor * 0.5 + 0.5
        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0

        weighted_score = (to_current * (1 - novelty_factor) + to_destination * novelty_factor) + 0.4 * regret_term
        return weighted_score

    candidates = sorted(unvisited_nodes, key=heuristic)[:3]
    weights = [0.6, 0.3, 0.1] if len(candidates) == 3 else [0.7, 0.3]

    if destination_node in unvisited_nodes:
        remaining_distance = distance_matrix[current_node][destination_node]
        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
        if avg_distance == 0 or (remaining_distance / avg_distance) <= 1.2:
            candidates = [destination_node] + candidates[:2]

    next_node = candidates[0] if len(candidates) == 1 else random.choices(candidates, weights=weights, k=1)[0]
    return next_node
