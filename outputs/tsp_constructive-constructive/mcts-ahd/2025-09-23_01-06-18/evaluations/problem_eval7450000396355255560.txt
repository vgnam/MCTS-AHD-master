import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    weight_factor = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))  # Dynamic weight adjustment

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]
        detour_cost = to_destination - distance_matrix[current_node][destination_node]

        # Compute angular deviation penalty
        if current_node == destination_node:
            angle_penalty = 0
        else:
            vec_current = (node - current_node, destination_node - current_node)
            vec_node = (destination_node - node, current_node - node)
            dot_product = vec_current[0] * vec_node[0] + vec_current[1] * vec_node[1]
            mag_current = math.sqrt(vec_current[0]**2 + vec_current[1]**2)
            mag_node = math.sqrt(vec_node[0]**2 + vec_node[1]**2)
            if mag_current * mag_node == 0:
                angle_penalty = 0
            else:
                angle_penalty = 1 - (dot_product / (mag_current * mag_node))

        weighted_detour = weight_factor * to_current + (1 - weight_factor) * detour_cost
        return weighted_detour + 0.2 * angle_penalty  # Incorporate angular penalty

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
