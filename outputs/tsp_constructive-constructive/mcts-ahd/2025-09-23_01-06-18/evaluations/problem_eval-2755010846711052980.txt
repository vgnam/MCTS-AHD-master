def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    def cluster_nodes(nodes, threshold=1.5):
        clusters = []
        nodes = list(nodes)
        while nodes:
            cluster = [nodes.pop(0)]
            for node in list(nodes):
                if any(distance_matrix[cluster[0]][node] <= threshold * distance_matrix[cluster[0]][c] for c in cluster):
                    cluster.append(node)
                    nodes.remove(node)
            clusters.append(cluster)
        return clusters

    clusters = cluster_nodes(unvisited_nodes)
    cluster_scores = []

    for cluster in clusters:
        cluster_score = 0
        for node in cluster:
            immediate_cost = distance_matrix[current_node][node]
            future_cost = distance_matrix[node][destination_node]
            remaining_ratio = len(unvisited_nodes) / len(distance_matrix)
            progress_factor = 1 - remaining_ratio
            weight = 0.5 + 0.5 * progress_factor
            cluster_score += immediate_cost * weight + future_cost * (1.0 - weight)
        cluster_score /= len(cluster)
        cluster_scores.append(cluster_score)

    selected_cluster = clusters[cluster_scores.index(min(cluster_scores))]

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]
        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)
        progress_factor = 1 - remaining_ratio
        weight = 1.5 - 0.5 * progress_factor
        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)
        global_potential = (to_destination + predictive_factor) / 2
        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0
        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)
        return (to_current * weight + global_potential * (1.0 - weight) + 0.3 * regret_term) - 0.5 * diversity_bonus

    next_node = min(selected_cluster, key=heuristic)
    return next_node
