def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = (total_nodes - remaining_nodes) / total_nodes

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]

        # Calculate node centrality (average distance to all unvisited nodes)
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)

        # Calculate path diversity (angular deviation from straight-line path)
        vec_current = (current_node % 10, current_node // 10)  # Simplified 2D coordinates
        vec_destination = (destination_node % 10, destination_node // 10)
        vec_node = (node % 10, node // 10)

        def dot_product(a, b):
            return a[0]*b[0] + a[1]*b[1]

        def magnitude(v):
            return (v[0]**2 + v[1]**2)**0.5

        vec_path = (vec_destination[0] - vec_current[0], vec_destination[1] - vec_current[1])
        vec_to_node = (vec_node[0] - vec_current[0], vec_node[1] - vec_current[1])

        if magnitude(vec_path) == 0 or magnitude(vec_to_node) == 0:
            angle_dev = 0
        else:
            cos_theta = dot_product(vec_path, vec_to_node) / (magnitude(vec_path) * magnitude(vec_to_node))
            cos_theta = max(-1, min(1, cos_theta))  # Clamp to avoid numerical errors
            angle_dev = (1 - cos_theta) / 2  # Normalized to [0,1]

        # Dynamic weighting with sigmoid transition
        sigmoid = 1 / (1 + math.exp(-10 * (progress - 0.5)))
        exploitation_weight = 1 - sigmoid
        exploration_weight = sigmoid

        return (exploitation_weight * to_current +
                exploration_weight * (0.6 * centrality + 0.4 * angle_dev))

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
