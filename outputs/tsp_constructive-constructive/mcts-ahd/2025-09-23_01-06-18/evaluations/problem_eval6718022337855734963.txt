def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]

        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)
        decay_factor = 0.7 ** (1 - remaining_ratio)

        neighborhood_radius = 1.2 * (1 + 0.5 * remaining_ratio)
        neighborhood_count = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < neighborhood_radius * to_current)
        neighborhood_weight = 0.3 * (1 + 0.2 * neighborhood_count / len(unvisited_nodes))

        regret_sorted = sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)
        regret_weight = 0.4 * (1 - remaining_ratio) * (regret_sorted[0] + regret_sorted[1]) / 2

        diversity_entropy = -sum((distance_matrix[node][other] / sum(distance_matrix[node][n] for n in unvisited_nodes)) *
                                np.log(distance_matrix[node][other] / sum(distance_matrix[node][n] for n in unvisited_nodes) + 1e-6)
                                for other in unvisited_nodes if sum(distance_matrix[node][n] for n in unvisited_nodes) > 0)
        diversity_bonus = 0.15 * diversity_entropy

        harmonic_weight = 2 / (1/to_current + 1/to_destination + 1e-6)
        selection_temp = 1.0 + 0.3 * (1 - remaining_ratio)

        local_factor = to_current * (1 + neighborhood_weight + regret_weight)
        global_factor = to_destination * (1 - neighborhood_weight - regret_weight)

        return (local_factor + global_factor) * harmonic_weight * decay_factor - diversity_bonus

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
