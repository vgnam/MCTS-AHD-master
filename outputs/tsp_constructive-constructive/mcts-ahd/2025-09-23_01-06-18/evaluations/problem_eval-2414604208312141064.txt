def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress_ratio = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0
    exploration_factor = 1 - (progress_ratio ** 1.5)  # Faster decay for exploration

    def anticipation_factor(node):
        # Measures how well the node bridges to the destination
        direct = distance_matrix[node][destination_node]
        indirect = min(distance_matrix[node][n] + distance_matrix[n][destination_node]
                      for n in unvisited_nodes if n != node) if unvisited_nodes else 0
        return 1 / (1 + min(direct, indirect))

    def node_connectivity(node):
        # Measures how well-connected the node is in the remaining graph
        connections = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 2 * min(distance_matrix[node]))
        return connections / max(1, remaining_nodes - 1)

    def heuristic(node):
        immediate_cost = distance_matrix[current_node][node]
        ant_factor = anticipation_factor(node)
        connectivity = node_connectivity(node)

        # Dynamic weights with exploration factor
        weight_immediate = 0.4 + 0.3 * (1 - progress_ratio) + 0.3 * connectivity
        weight_anticipation = 0.6 - 0.2 * progress_ratio

        # Penalty for non-destination nodes
        penalty = 0.2 if node in unvisited_nodes and node != destination_node else 0.0

        return (weight_immediate * immediate_cost +
                weight_anticipation * (1 - ant_factor) +
                penalty)

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
