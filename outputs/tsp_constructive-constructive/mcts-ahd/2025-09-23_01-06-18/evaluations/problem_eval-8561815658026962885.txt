importance based on local topology (clustering coefficient) and global path length, replacing the linear progress-based weighting. It combines nearest-neighbor selection with cluster-aware detour analysis, hub connectivity with betweenness centrality, and diversity encouragement using angular dispersion metrics.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = 1 - remaining_nodes / total_nodes

    # Calculate local clustering coefficient for current node
    neighbors = [n for n in unvisited_nodes if distance_matrix[current_node][n] < 1.5 * min(distance_matrix[current_node][m] for m in unvisited_nodes if m != n)]
    if len(neighbors) >= 2:
        triangles = sum(1 for i in range(len(neighbors)) for j in range(i+1, len(neighbors))
                        if distance_matrix[neighbors[i]][neighbors[j]] < 1.3 * min(distance_matrix[current_node][m] for m in unvisited_nodes))
        clustering_coeff = 2 * triangles / (len(neighbors) * (len(neighbors) - 1)) if len(neighbors) > 1 else 0
    else:
        clustering_coeff = 0

    # Calculate global path length metric
    avg_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / remaining_nodes

    def heuristic(node):
        immediate_cost = distance_matrix[current_node][node]
        detour_cost = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / max(1, avg_path_length)
        regret = immediate_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)

        # Cluster-aware hub score
        hub_score = (sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * min(distance_matrix[node][m] for m in unvisited_nodes if m != n))
                    * (1 + 0.5 * clustering_coeff)) if remaining_nodes > 1 else 0

        # Angular dispersion metric
        if remaining_nodes > 2:
            vectors = [(distance_matrix[node][n] - distance_matrix[current_node][n],
                      distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node])
                     for n in unvisited_nodes if n != node and n != destination_node]
            if vectors:
                avg_vector = (sum(v[0] for v in vectors)/len(vectors), sum(v[1] for v in vectors)/len(vectors))
                diversity_bonus = sum((v[0]-avg_vector[0])**2 + (v[1]-avg_vector[1])**2 for v in vectors) / len(vectors)
            else:
                diversity_bonus = 0
        else:
            diversity_bonus = 0

        # Adaptive weight scaling
        immediate_weight = 0.5 - 0.3 * clustering_coeff + 0.2 * progress
        regret_weight = 0.3 + 0.4 * progress * (1 - clustering_coeff)
        detour_weight = 0.2 * (1 - progress) * (1 + 0.5 * clustering_coeff)
        hub_weight = 0.1 * progress * (1 - clustering_coeff)
        diversity_weight = -0.15 * (1 - 0.5 * clustering_coeff)

        return (immediate_weight * immediate_cost +
                regret_weight * regret +
                detour_weight * detour_cost +
                hub_weight * hub_score +
                diversity_weight * diversity_bonus)

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
