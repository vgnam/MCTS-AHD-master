def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    density_factor = (total_nodes - remaining_nodes) / (total_nodes * 2) if total_nodes > 1 else 0
    exploration_weight = 0.7 - 0.4 * density_factor

    def calculate_potential(node):
        immediate_cost = distance_matrix[current_node][node]
        detour_potential = distance_matrix[node][destination_node] - immediate_cost
        future_diversity = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0
        centrality = sum(distance_matrix[node][n] for n in range(len(distance_matrix))) / len(distance_matrix)
        revisit_penalty = centrality * 0.5 if node not in unvisited_nodes else 0

        return (exploration_weight * immediate_cost +
                (1 - exploration_weight) * detour_potential +
                0.2 * future_diversity +
                0.1 * centrality +
                revisit_penalty)

    next_node = min(unvisited_nodes, key=calculate_potential)
    return next_node
