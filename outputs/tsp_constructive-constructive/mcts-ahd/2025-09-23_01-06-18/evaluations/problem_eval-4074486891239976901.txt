def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if destination_node in unvisited_nodes:
        return destination_node

    def calculate_centrality(node):
        if not unvisited_nodes:
            return 0
        return sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)

    def evaluate_path(node, depth=3, step=0):
        if depth == 0 or not unvisited_nodes:
            return distance_matrix[node][destination_node]
        remaining_nodes = [n for n in unvisited_nodes if n != node]
        if not remaining_nodes:
            return distance_matrix[node][destination_node]

        k = min(4, len(remaining_nodes))
        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n] + 0.3 * calculate_centrality(n))[:k]

        return min(
            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1, step+1)
            for candidate in next_candidates
        )

    def heuristic(node, step):
        immediate_weight = max(0.4, 0.6 - 0.05 * step)
        future_weight = 1 - immediate_weight
        immediate_cost = distance_matrix[current_node][node]
        future_cost = evaluate_path(node, step=step)
        return immediate_weight * immediate_cost + future_weight * future_cost

    step = len(unvisited_nodes) - len(unvisited_nodes.intersection(set([current_node, destination_node])))
    next_node = min(unvisited_nodes, key=lambda n: heuristic(n, step))
    return next_node
