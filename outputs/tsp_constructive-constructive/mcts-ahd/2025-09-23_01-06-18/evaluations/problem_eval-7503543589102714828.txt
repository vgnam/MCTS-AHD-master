importance scoring to balance local proximity, global destination alignment, and path diversity, while using a reinforcement learning-inspired approach to update selection weights based on historical performance and node centrality.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        if len(unvisited_nodes) <= 2:
            return destination_node

    def heuristic(node):
        to_current = distance_matrix[current_node][node]
        to_destination = distance_matrix[node][destination_node]
        remaining_nodes = len(unvisited_nodes)
        total_nodes = len(distance_matrix)

        # Adaptive path memory factor
        path_memory = 0.3 * (1 - remaining_nodes / total_nodes) + 0.7 * (to_current / max(distance_matrix[current_node].values()))

        # Dynamic regret weighting
        sorted_distances = sorted(distance_matrix[current_node][n] for n in unvisited_nodes)
        regret_weight = 0.4 * (1 - remaining_nodes / total_nodes) + 0.6 * (sorted_distances[0] / (sorted_distances[-1] + 1e-6))

        # Node importance scoring
        node_importance = sum(1 / (distance_matrix[node][n] + 1e-6) for n in unvisited_nodes) / remaining_nodes

        # Connectivity bonus
        local_connectivity = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * to_current)
        connectivity_bonus = 0.15 * local_connectivity / remaining_nodes

        # Reinforcement learning-inspired weight
        rl_weight = 0.5 * (1 - path_memory) + 0.5 * (node_importance * (1 + connectivity_bonus))

        # Balanced component weighting
        local_factor = to_current * (1 + regret_weight * (sorted_distances[1] - to_current if len(sorted_distances) > 1 else 0))
        global_factor = (to_destination + 0.5 * sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes) * (1 - rl_weight)

        return local_factor + global_factor - 0.25 * path_memory * node_importance

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
