[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (current node) and global (predictive factors) considerations, prioritizing local choices early (higher weight) and global considerations later (lower weight), while incorporating regret penalties (higher priority) and diversity bonuses (lower priority) to balance immediate distance, predictive factors, and exploration. The heuristic function evaluates each unvisited node based on a weighted sum of local distance, global potential, regret, and diversity, with weights dynamically adjusted based on remaining unvisited nodes. The algorithm ensures flexibility by balancing exploration (diversity) and exploitation (distance/regret) through the weight and penalty terms.",
          "thought": "The new algorithm combines No.2's dynamic weight adjustment between local and predictive factors with No.1's regret penalties and diversity bonuses, prioritizing local choices early and incorporating global considerations later while balancing immediate distance, predictive factors, regret, and diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.15 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2649,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing between proximity to the current node (weighted by connectivity and adaptively scaled by visited ratio), global potential (considering distance to destination and nearby unvisited nodes), regret (penalizing poor choices), and diversity (favoring less explored regions). It prioritizes direct paths to the destination when within a dynamic threshold, otherwise it minimizes a weighted combination of these factors, with connectivity and regret terms given moderate emphasis. The heuristic dynamically adjusts weights based on the number of unvisited nodes, favoring exploration early and exploitation later.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating adaptive weight scaling based on node connectivity, dynamic regret penalties that consider multiple unvisited nodes, and a path diversity bonus that favors nodes connecting to less explored regions, while maintaining the original threshold logic for direct destination selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 - (0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        visited_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.5 - 0.5 * visited_ratio\n\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.2 * to_current)\n        connectivity_factor = 1 + (0.1 * connectivity / len(unvisited_nodes))\n\n        global_potential = (to_destination + sum(sorted(distance_matrix[node][other] for other in unvisited_nodes if other != node)[:2])) / 3\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_bonus *= 1 - (0.2 * (connectivity / len(unvisited_nodes)))\n\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.7 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.29556,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (distance to current node) and global (predictive factors, regret penalties, and diversity bonuses) considerations, with weights balancing immediate and future decisions based on remaining problem size. It prioritizes minimizing immediate distance (weighted by `2.5 - remaining_ratio`) while incorporating regret (penalizing poor choices) and diversity (exploring alternatives) in the heuristic. The threshold for returning to the destination is adaptively adjusted based on the remaining nodes, favoring local choices early and global considerations later.",
          "thought": "This new algorithm combines dynamic weight adjustment between local and global factors, incorporates regret penalties to avoid poor choices, and uses diversity bonuses to explore alternatives, while also adaptively balancing predictive factors with immediate distances and adjusting thresholds based on the remaining problem size.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 + (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.5 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.6 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.30438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic weight adjustment, prioritizing local costs early in the search and shifting to global potential as progress advances, while incorporating regret terms to avoid costly alternatives and diversity bonuses to prevent clustering. The weight shifts from local (1.0) to global (1.6) as progress increases, and temperature balances exploration (0.8) and exploitation (0.1) similarly. The regret term prioritizes high-cost alternatives, and the diversity bonus discourages clustering, with the destination being prioritized if it is nearby relative to average distances.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic weight adjustment, global potential estimation, regret consideration, diversity encouragement, and temperature scaling, where the weight shifts from local to global focus, the regret term prioritizes high-cost alternatives, diversity bonus prevents clustering, and temperature balances exploration and exploitation, all while prioritizing the destination if it is nearby relative to the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        priority = remaining_distance / avg_distance\n        if priority <= 1.1:\n            return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    weight = 1 + 0.6 * progress_factor\n    temperature = 0.8 - 0.7 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (local_cost * weight + global_potential * (1 - weight) + 0.4 * regret_term) * temperature - 0.2 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.34249,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing local (current node distance) and global (destination proximity) considerations with adaptive weights, using regret minimization to avoid poor local choices, and encourages diversity to explore alternatives. It aggressively prioritizes the destination when near the end (via the threshold check) and adjusts weights dynamically based on remaining nodes, shifting from stronger global focus early to local focus later. The heuristic function combines weighted local/global distances, regret terms, and diversity bonuses, with parameters like `weight` (1.8-0.8) and `progress_factor` controlling priority shifts.",
          "thought": "The new algorithm combines dynamic weight adjustment (balancing local and global considerations with adaptive progress factors), regret minimization (prioritizing potential improvements), and diversity encouragement (exploring alternatives), while aggressively prioritizing the destination when near the end and adjusting weights based on remaining nodes (stronger global focus initially, shifting to local focus later).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 1.8 - 0.8 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.4 * regret_term) - 0.4 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.34792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (current node distance) and global (destination potential) considerations, adaptive thresholding for prioritizing the destination when it's close relative to average distances, and regret minimization to avoid poor choices. It balances these factors with a progress-dependent weight, predictive future impact, and diversity bonuses to explore alternatives, while scaling thresholds based on problem progress. The code prioritizes immediate distance early in the process but increasingly values global potential and diversity as progress continues.",
          "thought": "This new algorithm combines dynamic weight adjustment between local and global considerations, adaptive thresholding for destination prioritization, regret minimization to avoid poor choices, diversity bonuses to explore alternatives, and predictive factors that balance immediate distance with future path impact, all while scaling weights and thresholds based on problem progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 + (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 2.0 - 1.0 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.35695,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local proximity (prioritized early) with global potential, dynamically adjusting weights based on progress (1.6 to 1.0) and incorporating regret penalties (0.4x) and diversity bonuses (-0.5x) to balance exploration and exploitation. It prioritizes local cost and global potential with weights shifting from local to global as the tour progresses, while also considering regret (opportunity cost) and penalizing nodes that increase diversity.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (prioritizing local proximity early with global potential) with the refined heuristic structure of No.2 (balancing local and global optimization, incorporating regret penalties and diversity bonuses), while adjusting the weight shift and coefficients to further improve performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    weight = 1.6 - 0.6 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - local_cost for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (local_cost * weight + global_potential * (1.0 - weight) + 0.4 * regret_term) - 0.5 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.35977,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local proximity**, **global potential**, and **exploration** by dynamically adjusting weights based on progress (via `progress_factor` and `weight`), incorporating **regret minimization** (via `regret_term`), and encouraging **diversity** (via `diversity_bonus`). It prioritizes **local proximity** early in the search (higher `weight`) and shifts toward **global potential** as progress increases, while penalizing high regret and rewarding diverse node selections. The heuristic dynamically balances these factors using adaptive thresholds and predictive estimates.",
          "thought": "The new algorithm combines the dynamic weight adjustment and regret penalties from No.1 with the adaptive thresholding and predictive factors from No.2, creating a heuristic that balances local proximity, global potential, and exploration while dynamically adjusting weights based on progress and incorporating regret minimization and diversity encouragement.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.2 + (0.8 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 1.6 - 0.6 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.4 * regret_term) - 0.4 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.36399,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines local cost, global potential, regret, and diversity considerations, with weights dynamically adjusted based on progress (progress_factor). Early stages prioritize local cost and regret (weighted higher), while later stages emphasize global potential and diversity (lower weights). The temperature parameter introduces stochasticity, and the diversity_bonus discourages clustering. The heuristic function balances these factors multiplicatively, with regret_term scaled by regret_weight.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 and No.4, the global potential and regret consideration from No.3, the diversity bonus from No.4, and the early destination prioritization from No.2, while introducing adaptive regret weighting and a more aggressive weight shift to balance local and global considerations more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        priority = remaining_distance / avg_distance\n        if priority <= 1.15:\n            return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    weight = 1 + 0.5 * progress_factor\n    temperature = 0.8 - 0.7 * progress_factor\n    regret_weight = 0.3 * (1 - progress_factor)\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (local_cost * weight + global_potential * (1 - weight) + regret_weight * regret_term) * temperature - 0.2 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.36425,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing local proximity (weighted by progress) and global potential (predictive factors and destination proximity), with adaptive weights shifting toward local proximity as progress advances. It incorporates regret minimization and diversity encouragement, while dynamically adjusting a threshold for destination proximity based on remaining nodes. The heuristic function combines distance to current node, global potential (averaged with destination distance and predictive factors), regret terms, and diversity bonuses, with weights favoring local proximity early in the process.",
          "thought": "The new algorithm combines dynamic weight adjustment between local proximity and global potential, incorporating adaptive thresholding for destination proximity, predictive factors, regret minimization, and diversity encouragement, with weights shifting toward local proximity as progress advances and global potential as remaining nodes increase, while prioritizing the destination when it's nearby relative to average distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 1.5 - 0.5 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.4 * regret_term) - 0.6 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.37111,
          "other_inf": null
     }
]