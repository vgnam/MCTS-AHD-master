[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (current node) and global (predictive factors) considerations, prioritizing local choices early (higher weight) and global considerations later (lower weight), while incorporating regret penalties (higher priority) and diversity bonuses (lower priority) to balance immediate distance, predictive factors, and exploration. The heuristic function evaluates each unvisited node based on a weighted sum of local distance, global potential, regret, and diversity, with weights dynamically adjusted based on remaining unvisited nodes. The algorithm ensures flexibility by balancing exploration (diversity) and exploitation (distance/regret) through the weight and penalty terms.",
          "thought": "The new algorithm combines No.2's dynamic weight adjustment between local and predictive factors with No.1's regret penalties and diversity bonuses, prioritizing local choices early and incorporating global considerations later while balancing immediate distance, predictive factors, regret, and diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.15 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2649,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nearby destination returns when possible, balances local and global distances with dynamic weights (higher local weight early, higher global weight later), and incorporates regret penalties (avoiding high-cost alternatives) and diversity bonuses (exploring varied paths) to optimize the TSP path. The heuristic function combines distance to current node (weighted by dynamic weight and connectivity), distance to destination (weighted inversely), regret term (second-best option penalty), and diversity bonus (path variation reward).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity, regret, and diversity considerations of No.1. It prioritizes nearby destination returns when possible, balances local and global distances with dynamic weights, and incorporates regret penalties and diversity bonuses to improve path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        if remaining_distance / avg_distance <= 1.2:\n            return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        connectivity_factor = 1 + (0.2 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + to_destination * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global choices by adjusting weights (higher local early, lower global later) while incorporating regret penalties and diversity bonuses. It prioritizes immediate distance (weighted by remaining nodes) and predictive global potential (average distance to unvisited nodes) but penalizes high regret (missing better local options) and rewards diversity (spreading visits). A threshold-based direct routing checks if the destination is nearby, optimizing when few nodes remain. The heuristic function combines these factors to select the next node, ensuring a trade-off between exploitation (short-term gains) and exploration (future potential).",
          "thought": "The new algorithm integrates dynamic weight adjustment between local and global considerations, prioritizes local choices early with higher weights and global considerations later with lower weights, incorporates regret penalties and diversity bonuses to balance immediate distance, predictive factors, exploration, and exploitation, while dynamically adjusting the balance based on remaining unvisited nodes and using a threshold-based direct routing when the destination is nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.5 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27575,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic local-global balancing with regret penalties and diversity bonuses, prioritizing local connectivity and global potential while penalizing diversity. It adaptively weights local (distance to current node, connectivity) and global (predictive factor, destination distance) factors, with regret terms and diversity bonuses refining the selection. The heuristic function prioritizes local distance, global potential, and regret, while diversity bonuses are subtracted, balancing exploration and exploitation.",
          "thought": "The new algorithm combines dynamic local-global balancing with regret penalties and diversity bonuses, incorporating adaptive weights, predictive global potential, connectivity-based local selection, and enhanced regret terms from both algorithms to optimize path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.5 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        connectivity_factor = 1 + (0.2 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing between proximity to the current node (weighted by connectivity and adaptively scaled by visited ratio), global potential (considering distance to destination and nearby unvisited nodes), regret (penalizing poor choices), and diversity (favoring less explored regions). It prioritizes direct paths to the destination when within a dynamic threshold, otherwise it minimizes a weighted combination of these factors, with connectivity and regret terms given moderate emphasis. The heuristic dynamically adjusts weights based on the number of unvisited nodes, favoring exploration early and exploitation later.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating adaptive weight scaling based on node connectivity, dynamic regret penalties that consider multiple unvisited nodes, and a path diversity bonus that favors nodes connecting to less explored regions, while maintaining the original threshold logic for direct destination selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 - (0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        visited_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.5 - 0.5 * visited_ratio\n\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.2 * to_current)\n        connectivity_factor = 1 + (0.1 * connectivity / len(unvisited_nodes))\n\n        global_potential = (to_destination + sum(sorted(distance_matrix[node][other] for other in unvisited_nodes if other != node)[:2])) / 3\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_bonus *= 1 - (0.2 * (connectivity / len(unvisited_nodes)))\n\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.7 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.29556,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global considerations by adjusting weights (higher early, lower later) while incorporating regret penalties (top 2 alternatives) and diversity bonuses (spread of distances) to prioritize connectivity and predictive factors. It first checks for direct returns to the destination if the remaining distance is below a threshold, otherwise evaluates nodes based on a weighted combination of local distance, global potential (to destination + predictive factor), regret, and diversity. The weight shifts from local to global as nodes are visited, with connectivity and regret terms enhancing performance.",
          "thought": "The new algorithm combines dynamic weight adjustment between local and global considerations, incorporating regret penalties and diversity bonuses, while prioritizing local choices early and global considerations later, with connectivity and predictive factors enhancing performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.8 - (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.8 - remaining_ratio\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        connectivity_factor = 1 + (0.2 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.6 * regret_term) - 0.25 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.30152,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (distance to current node) and global (predictive factors, regret penalties, and diversity bonuses) considerations, with weights balancing immediate and future decisions based on remaining problem size. It prioritizes minimizing immediate distance (weighted by `2.5 - remaining_ratio`) while incorporating regret (penalizing poor choices) and diversity (exploring alternatives) in the heuristic. The threshold for returning to the destination is adaptively adjusted based on the remaining nodes, favoring local choices early and global considerations later.",
          "thought": "This new algorithm combines dynamic weight adjustment between local and global factors, incorporates regret penalties to avoid poor choices, and uses diversity bonuses to explore alternatives, while also adaptively balancing predictive factors with immediate distances and adjusting thresholds based on the remaining problem size.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 + (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.5 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.6 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.30438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic weight adjustment, prioritizing local costs early in the search and shifting to global potential as progress advances, while incorporating regret terms to avoid costly alternatives and diversity bonuses to prevent clustering. The weight shifts from local (1.0) to global (1.6) as progress increases, and temperature balances exploration (0.8) and exploitation (0.1) similarly. The regret term prioritizes high-cost alternatives, and the diversity bonus discourages clustering, with the destination being prioritized if it is nearby relative to average distances.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic weight adjustment, global potential estimation, regret consideration, diversity encouragement, and temperature scaling, where the weight shifts from local to global focus, the regret term prioritizes high-cost alternatives, diversity bonus prevents clustering, and temperature balances exploration and exploitation, all while prioritizing the destination if it is nearby relative to the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        priority = remaining_distance / avg_distance\n        if priority <= 1.1:\n            return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    weight = 1 + 0.6 * progress_factor\n    temperature = 0.8 - 0.7 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (local_cost * weight + global_potential * (1 - weight) + 0.4 * regret_term) * temperature - 0.2 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.34249,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing local (current node distance) and global (destination proximity) considerations with adaptive weights, using regret minimization to avoid poor local choices, and encourages diversity to explore alternatives. It aggressively prioritizes the destination when near the end (via the threshold check) and adjusts weights dynamically based on remaining nodes, shifting from stronger global focus early to local focus later. The heuristic function combines weighted local/global distances, regret terms, and diversity bonuses, with parameters like `weight` (1.8-0.8) and `progress_factor` controlling priority shifts.",
          "thought": "The new algorithm combines dynamic weight adjustment (balancing local and global considerations with adaptive progress factors), regret minimization (prioritizing potential improvements), and diversity encouragement (exploring alternatives), while aggressively prioritizing the destination when near the end and adjusting weights based on remaining nodes (stronger global focus initially, shifting to local focus later).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 1.8 - 0.8 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.4 * regret_term) - 0.4 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.34792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (current node distance) and global (destination potential) considerations, adaptive thresholding for prioritizing the destination when it's close relative to average distances, and regret minimization to avoid poor choices. It balances these factors with a progress-dependent weight, predictive future impact, and diversity bonuses to explore alternatives, while scaling thresholds based on problem progress. The code prioritizes immediate distance early in the process but increasingly values global potential and diversity as progress continues.",
          "thought": "This new algorithm combines dynamic weight adjustment between local and global considerations, adaptive thresholding for destination prioritization, regret minimization to avoid poor choices, diversity bonuses to explore alternatives, and predictive factors that balance immediate distance with future path impact, all while scaling weights and thresholds based on problem progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 + (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        progress_factor = 1 - remaining_ratio\n        weight = 2.0 - 1.0 * progress_factor\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        global_potential = (to_destination + predictive_factor) / 2\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.35695,
          "other_inf": null
     }
]