[
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting selection pressure and temperature based on progress, prioritizing local cost early and global potential later. It incorporates regret and diversity terms to avoid suboptimal choices, with regret weighted lower (0.1) and diversity penalized heavily (-0.3). The heuristic score is temperature-adjusted to refine selections as the problem progresses, ensuring a hybrid of greedy and global-aware node selection.",
          "thought": "This algorithm combines adaptive selection pressure, dynamic temperature scaling, regret-based global potential, diversity bonus, and progress-aware weighting to balance local and global optimization, while incorporating a hybrid heuristic that integrates local cost, global potential, regret, and diversity into a temperature-adjusted score to dynamically prioritize nodes based on problem progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n    temperature = 1.0 - 0.8 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (selection_pressure * local_cost + (1 - selection_pressure) * global_potential + 0.1 * regret_term) * temperature - 0.3 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.64995,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines regret-based optimization (60% weight) and global potential evaluation (35%) while dynamically adjusting selection pressure based on progress, penalizing high-centrality nodes (-0.2 weight) and rewarding diversity (-0.3 weight). The weighted score balances immediate cost savings with long-term efficiency, using parameters (0.6, 0.35, -0.2, -0.3) to prioritize local optimization early and global optimization later, while avoiding bottlenecks and local optima.",
          "thought": "The new algorithm combines dynamic selection pressure adjustment, regret-based optimization, global potential evaluation, centrality penalty, and diversity bonus, while balancing immediate cost savings (60%) with long-term path efficiency (35%) and diversity (5%), using parameters (0.6, 0.35, -0.2, -0.3) to prioritize both local and global optimization while avoiding bottlenecks and local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        regret = (local_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)) / (max(distance_matrix[current_node][n] for n in unvisited_nodes) - min(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (1 - selection_pressure) * regret + selection_pressure * (0.6 * local_cost + 0.35 * global_potential) - 0.2 * centrality - 0.3 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.66924,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines proximity and detour cost with dynamic weighting, adaptive temperature, and regret-based selection, prioritizing local cost (50%), detour impact (30%), and diversity penalty (20%) while adjusting weights based on progress and node distances. The algorithm balances exploration (temperature) and exploitation (regret) to select the next node efficiently.",
          "thought": "The new algorithm combines No.1's dynamic weight balancing proximity and detour cost with No.2's adaptive temperature and weighted heuristic, introducing a regret-based detour adjustment and diversity penalty to enhance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    temperature = 1.0 - 0.7 * progress_factor\n\n    remaining_distance = distance_matrix[current_node][destination_node]\n    dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance / sum(distance_matrix[current_node]))\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - remaining_distance\n        weighted_detour = dynamic_weight * local_cost + (1 - dynamic_weight) * detour_cost\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (0.5 * weighted_detour + 0.3 * regret_term) * temperature - 0.2 * diversity_penalty\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.67157,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local optimization (prioritizing nearby nodes) and global path potential (considering future steps) using adaptive weights that shift with progress. It emphasizes regret minimization early (to avoid poor choices) and destination bias later (to ensure efficient returns), while centrality is downweighted to prevent premature clustering. The heuristic combines these factors with a weighted score, where selection pressure adjusts between exploration and exploitation.",
          "thought": "The new algorithm integrates dynamic selection pressure with adaptive regret weighting, incorporating node centrality and destination bias to balance local optimization with global path potential, using a novel scoring mechanism that dynamically adjusts weights based on tour progress and node characteristics.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (1 - progress_factor) * distance_matrix[node][destination_node] + progress_factor * sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node) / (remaining_nodes)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        regret_factor = (1 - progress_factor) * 0.8 + progress_factor * 0.3\n        regret = (local_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)) / (max(distance_matrix[current_node][n] for n in unvisited_nodes) - min(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        destination_bias = 1 / (1 + distance_matrix[node][destination_node])\n        weighted_score = (1 - selection_pressure) * regret_factor * regret + selection_pressure * (0.6 * local_cost + 0.3 * global_potential + 0.1 * destination_bias) - 0.3 * centrality\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.76429,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, detour risk, and centrality to select the next node, adjusting weights based on progress (prioritizing detour minimization early) while penalizing high-centrality nodes (favoring peripheral nodes). It uses a heuristic combining current distance, a dynamic detour cost, average distance to unvisited nodes, and centrality factor (weighted lower), ensuring exploration and efficiency. The `dynamic_weight` and `centrality_factor` variables are key in balancing exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustments based on progress and remaining nodes, detour cost consideration, and centrality balance to prioritize nodes that minimize immediate distance, detour risk, and centrality while encouraging exploration early.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1)) * (1 - progress_factor)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n    centrality = {node: sum(distance_matrix[node][j] for j in unvisited_nodes) / remaining_nodes for node in unvisited_nodes}\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        centrality_factor = 1 - (centrality[node] / max(centrality.values()))\n        return to_current + dynamic_weight * detour_cost + 0.2 * avg_distance_to_unvisited + 0.3 * centrality_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.77965,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting selection pressure based on tour progress, prioritizing local cost (60%), global potential (25%), and proximity bias (15%) with a penalty for central nodes (30%), while regret is given lower weight initially but increases as the tour progresses. The heuristic combines immediate regret, local cost, global potential, centrality, and proximity bias in a weighted sum, with adaptive weights shifting from exploration to exploitation.",
          "thought": "The new algorithm incorporates dynamic selection pressure based on tour progress, integrates a hybrid cost metric that combines immediate regret, local cost, global potential, and centrality, with a novel \"proximity bias\" term that favors nodes closer to the current node while penalizing highly central nodes to prevent bottlenecks, and uses adaptive weights that shift from exploration to exploitation as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        regret = (local_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)) / (max(distance_matrix[current_node][n] for n in unvisited_nodes) - min(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n        proximity_bias = 1 / (1 + local_cost)\n        weighted_score = (1 - selection_pressure) * regret + selection_pressure * (0.6 * local_cost + 0.25 * global_potential + 0.15 * proximity_bias) - 0.3 * centrality\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.80877,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic progress-based selection pressure with adaptive weighted scoring, prioritizing regret-based local optimization (60%), global potential (30%), and diversity penalty (10%) while balancing exploration/exploitation through temperature scaling and centrality consideration. Selection pressure increases as progress advances, and node selection is weighted by regret, cost, and potential, with centrality acting as a penalty. The algorithm dynamically adjusts priorities based on progress, temperature, and node centrality.",
          "thought": "The new algorithm combines dynamic progress-based selection pressure with adaptive weighted scoring, incorporating regret-based local optimization, global potential, and diversity penalty, while increasing selection pressure and balancing exploration/exploitation through temperature scaling and centrality consideration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n    temperature = 1.0 - 0.8 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret = (local_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)) / (\n            max(distance_matrix[current_node][n] for n in unvisited_nodes) - min(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (1 - selection_pressure) * regret + selection_pressure * (0.6 * local_cost + 0.3 * global_potential + 0.1 * regret) * temperature - 0.2 * centrality\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.87046,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a weighted heuristic to select the next node, prioritizing local cost (60%), global potential (30%), and regret (10%), while dynamically adjusting temperature based on progress and applying a diversity penalty (20%) to avoid premature convergence. The selection pressure increases as progress advances, balancing exploration and exploitation through adaptive temperature scaling and regret-based global potential.",
          "thought": "The new algorithm incorporates probabilistic node selection with adaptive temperature scaling, where selection pressure dynamically adjusts based on remaining nodes and incorporates a regret-based global potential term to balance exploration and exploitation, while a novel diversity penalty term prevents premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    temperature = 1.0 - 0.8 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (0.6 * local_cost + 0.3 * global_potential + 0.1 * regret_term) * temperature - 0.2 * diversity_penalty\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.92468,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance optimization with global path diversity by prioritizing nodes based on their immediate cost (weighted by `selection_pressure`) and their potential to improve overall tour efficiency (weighted by `1 - selection_pressure`), while dynamically adjusting selection pressure as the problem progresses. It also incorporates a diversity bonus to avoid local optima, with higher priority given to minimizing immediate costs early in the search and balancing global efficiency as more nodes are visited. The heuristic function dynamically adjusts weights based on progress, ensuring a balance between short-term gains and long-term tour optimization.",
          "thought": "This algorithm prioritizes node selection by combining local distance optimization with global path diversity, using a probabilistic approach that weights nodes based on their immediate cost and potential to improve overall tour efficiency, while dynamically adjusting selection pressure as the problem progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = selection_pressure * local_cost + (1 - selection_pressure) * global_potential - 0.3 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.00131,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global costs dynamically, with selection pressure increasing as progress advances (higher priority to global costs later). It balances detour-based global potential with normalized local costs, while incorporating a diversity bonus to avoid suboptimal paths. The heuristic prioritizes minimizing immediate detours and maintaining global connectivity, with diversity bonuses reducing clustering.",
          "thought": "The new algorithm combines the dynamic balancing of local and global costs from No.2 with the diversity bonus and progress-dependent selection pressure from No.1, while incorporating a detour-based global potential and normalized local costs for improved efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    max_distance = max(max(row) for row in distance_matrix)\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes if unvisited_nodes else 0\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node] / max_distance\n        detour_cost = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / max_distance\n        global_potential = (detour_cost + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = selection_pressure * local_cost + (1 - selection_pressure) * global_potential - 0.3 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.00292,
          "other_inf": null
     }
]