[
     {
          "algorithm": "The algorithm dynamically balances immediate distance, detour risk, and centrality to select the next node, adjusting weights based on progress (prioritizing detour minimization early) while penalizing high-centrality nodes (favoring peripheral nodes). It uses a heuristic combining current distance, a dynamic detour cost, average distance to unvisited nodes, and centrality factor (weighted lower), ensuring exploration and efficiency. The `dynamic_weight` and `centrality_factor` variables are key in balancing exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustments based on progress and remaining nodes, detour cost consideration, and centrality balance to prioritize nodes that minimize immediate distance, detour risk, and centrality while encouraging exploration early.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1)) * (1 - progress_factor)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n    centrality = {node: sum(distance_matrix[node][j] for j in unvisited_nodes) / remaining_nodes for node in unvisited_nodes}\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - distance_matrix[current_node][destination_node]\n        centrality_factor = 1 - (centrality[node] / max(centrality.values()))\n        return to_current + dynamic_weight * detour_cost + 0.2 * avg_distance_to_unvisited + 0.3 * centrality_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.77965,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a weighted heuristic to select the next node, prioritizing local cost (60%), global potential (30%), and regret (10%), while dynamically adjusting temperature based on progress and applying a diversity penalty (20%) to avoid premature convergence. The selection pressure increases as progress advances, balancing exploration and exploitation through adaptive temperature scaling and regret-based global potential.",
          "thought": "The new algorithm incorporates probabilistic node selection with adaptive temperature scaling, where selection pressure dynamically adjusts based on remaining nodes and incorporates a regret-based global potential term to balance exploration and exploitation, while a novel diversity penalty term prevents premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_factor = 1 - (remaining_nodes / total_nodes)\n    temperature = 1.0 - 0.8 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] +\n                           sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        regret_term = max(distance_matrix[current_node][n] - distance_matrix[current_node][node] for n in unvisited_nodes) if unvisited_nodes else 0\n        diversity_penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = (0.6 * local_cost + 0.3 * global_potential + 0.1 * regret_term) * temperature - 0.2 * diversity_penalty\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.92468,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance optimization with global path diversity by prioritizing nodes based on their immediate cost (weighted by `selection_pressure`) and their potential to improve overall tour efficiency (weighted by `1 - selection_pressure`), while dynamically adjusting selection pressure as the problem progresses. It also incorporates a diversity bonus to avoid local optima, with higher priority given to minimizing immediate costs early in the search and balancing global efficiency as more nodes are visited. The heuristic function dynamically adjusts weights based on progress, ensuring a balance between short-term gains and long-term tour optimization.",
          "thought": "This algorithm prioritizes node selection by combining local distance optimization with global path diversity, using a probabilistic approach that weights nodes based on their immediate cost and potential to improve overall tour efficiency, while dynamically adjusting selection pressure as the problem progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = 1 - (remaining_nodes / len(distance_matrix))\n    selection_pressure = 0.5 + 0.5 * progress_factor\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = (distance_matrix[node][destination_node] + sum(distance_matrix[node][n] for n in unvisited_nodes if n != destination_node)) / (remaining_nodes + 1)\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        weighted_score = selection_pressure * local_cost + (1 - selection_pressure) * global_potential - 0.3 * diversity_bonus\n        return weighted_score\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.00131,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to unvisited nodes and focus on the destination by adjusting a threshold based on the remaining distance to the destination and the number of unvisited nodes. It prioritizes the destination if it's close enough (below the threshold) or selects the next node based on a weighted combination of current distance and future distance to the destination, ensuring a trade-off between local and global optimization. The dynamic threshold (`dynamic_threshold`) and the weighted selection criterion (`key=lambda...`) are the critical design elements.",
          "thought": "This new algorithm introduces a dynamic threshold mechanism that adjusts based on the remaining distance to the destination and the number of unvisited nodes, prioritizing either the closest node or the destination based on a calculated threshold, ensuring a balance between proximity and destination focus.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_threshold = max(1, (distance_matrix[current_node][destination_node] / (len(unvisited_nodes) + 1)) * 0.75)\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= dynamic_threshold:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.1 * (distance_matrix[node][destination_node] / sum(distance_matrix[node]))))\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the square root of the distance to the destination, adjusting the weight based on the remaining distance to the destination. It prioritizes minimizing the weighted sum of these two factors to select the next node, with the dynamic weight favoring proximity as the destination nears. The heuristic ensures a trade-off between local and global progress, with the square root of the distance to the destination providing a smoother global influence.",
          "thought": "The new algorithm combines the dynamic weighting of detour cost and proximity from No.1 with the global progress emphasis of No.2 by using a heuristic that balances the distance to the current node and the square root of the distance to the destination, while adjusting the weight dynamically based on the remaining distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_distance = distance_matrix[current_node][destination_node]\n    dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance / sum(distance_matrix[current_node]))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        weighted_heuristic = dynamic_weight * to_current + (1 - dynamic_weight) * (to_destination ** 0.5)\n        return weighted_heuristic\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.01462,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted sum heuristic that prioritizes both the distance from the current node and the distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. It balances local optimization (proximity to the current node) and global optimization (proximity to the destination) by scaling the weight between 0.5 and 1, favoring the destination when fewer nodes remain. The heuristic function multiplies the distance to the destination by the distance to the current node, ensuring both factors influence the selection.",
          "thought": "The new algorithm combines multiplicative prioritization of distances with a weighted sum heuristic, dynamically adjusting weights based on the remaining unvisited nodes' proximity to the destination, to balance local and global optimization while minimizing the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        return weight * to_current + (1 - weight) * to_destination * to_current\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.02736,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and long-term alignment (distance to destination), using a dynamic weight that adjusts based on remaining distance. It prioritizes detour cost and normalizes decisions by the number of unvisited nodes, ensuring a trade-off between proximity and goal alignment. The heuristic dynamically weights detour cost and distance to the current node, while the normalization factor scales decisions based on remaining nodes.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adapts based on the remaining distance to the destination, ensuring a balance between immediate proximity and long-term goal alignment, while also considering the potential detour cost and the number of unvisited nodes to influence the decision.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_distance = distance_matrix[current_node][destination_node]\n    dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance / sum(distance_matrix[current_node]))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        detour_cost = to_destination - remaining_distance\n        weighted_detour = dynamic_weight * to_current + (1 - dynamic_weight) * detour_cost\n        normalization_factor = 1 + 0.1 * (len(unvisited_nodes) / len(distance_matrix))\n        return weighted_detour * normalization_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.04278,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically balances exploration and exploitation by adjusting the exploration factor based on progress, scaling detours proportionally to remaining nodes, and penalizing revisits based on node centrality. It prioritizes immediate costs early but increasingly weights strategic detours toward the end, with a time-decaying normalization to smooth transitions. The heuristic combines normalized immediate and detour costs, adjusted by progress-dependent scaling and penalties, to select the next node.",
          "thought": "The new algorithm introduces a dynamic exploration/exploitation trade-off using a progress-dependent exploration factor, adaptive detour scaling with remaining nodes, and a penalty mechanism that increases for revisits based on node centrality, while normalizing costs with a time-decaying factor to prioritize strategic detours in later stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0\n\n    max_distance = max(max(row) for row in distance_matrix)\n    avg_unvisited_distance = sum(distance_matrix[current_node][i] for i in unvisited_nodes) / remaining_nodes if unvisited_nodes else 0\n\n    exploration_factor = 0.2 + 0.6 * (1 - progress_ratio) ** 2\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node] / max_distance\n        detour_cost = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / max_distance\n\n        detour_scaling = (remaining_nodes / total_nodes) ** 2 * (1 - progress_ratio)\n        adjusted_detour = detour_cost * detour_scaling\n\n        revisit_penalty = 0.0\n        if node != destination_node and node in unvisited_nodes:\n            node_degree = sum(1 for d in distance_matrix[node] if d < avg_unvisited_distance)\n            revisit_penalty = 0.1 * (1 - progress_ratio) * (node_degree / total_nodes)\n\n        time_decay = 0.5 ** progress_ratio\n        normalized_cost = (exploration_factor * immediate_cost + (1 - exploration_factor) * adjusted_detour) * time_decay\n\n        return normalized_cost + revisit_penalty\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.0438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with a 2-step lookahead evaluation, prioritizing immediate distance over future cost as the number of unvisited nodes increases. The heuristic function balances immediate cost (weighted more heavily) and future cost (estimated by evaluating the best 2 candidate paths 2 steps ahead), with weights adjusted based on remaining nodes. The `evaluate_path` function recursively estimates future costs, while `heuristic` computes a weighted sum to guide node selection.",
          "thought": "The new algorithm will combine dynamic weight adjustment with a 2-step lookahead evaluation, using a weighted sum of immediate distance and future cost, where weights are adjusted based on remaining nodes, and future cost is estimated by evaluating the best 2 candidate paths 2 steps ahead.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=2):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_candidates = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:2]\n        return min(\n            distance_matrix[node][candidate] + evaluate_path(candidate, depth-1)\n            for candidate in next_candidates\n        )\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = evaluate_path(node)\n        weight = 0.5 + 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        return weight * immediate_cost + (1 - weight) * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.05491,
          "other_inf": null
     }
]