{
     "algorithm": "The algorithm combines dynamic weight adjustment between local (distance to current node) and global (predictive factors, regret penalties, and diversity bonuses) considerations, with weights balancing immediate and future decisions based on remaining problem size. It prioritizes minimizing immediate distance (weighted by `2.5 - remaining_ratio`) while incorporating regret (penalizing poor choices) and diversity (exploring alternatives) in the heuristic. The threshold for returning to the destination is adaptively adjusted based on the remaining nodes, favoring local choices early and global considerations later.",
     "thought": "This new algorithm combines dynamic weight adjustment between local and global factors, incorporates regret penalties to avoid poor choices, and uses diversity bonuses to explore alternatives, while also adaptively balancing predictive factors with immediate distances and adjusting thresholds based on the remaining problem size.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 + (0.3 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.5 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.6 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
     "objective": 6.30438,
     "other_inf": null
}