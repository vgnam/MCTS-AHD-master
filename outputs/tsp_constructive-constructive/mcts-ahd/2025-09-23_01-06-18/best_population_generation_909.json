{
     "algorithm": "The algorithm combines dynamic weight adjustment between local (current node) and global (predictive factors) considerations, prioritizing local choices early (higher weight) and global considerations later (lower weight), while incorporating regret penalties (higher priority) and diversity bonuses (lower priority) to balance immediate distance, predictive factors, and exploration. The heuristic function evaluates each unvisited node based on a weighted sum of local distance, global potential, regret, and diversity, with weights dynamically adjusted based on remaining unvisited nodes. The algorithm ensures flexibility by balancing exploration (diversity) and exploitation (distance/regret) through the weight and penalty terms.",
     "thought": "The new algorithm combines No.2's dynamic weight adjustment between local and predictive factors with No.1's regret penalties and diversity bonuses, prioritizing local choices early and incorporating global considerations later while balancing immediate distance, predictive factors, regret, and diversity.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.15 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
     "objective": 6.2649,
     "other_inf": null
}