{
     "algorithm": "The algorithm combines regret-based local optimization with global potential evaluation, dynamically adjusting weights based on progress (favoring local costs early, global potential later) while penalizing centrality and diversity to avoid clustering. The heuristic prioritizes regret (weighted by progress) and local/global costs (70%/30%), with secondary penalties for centrality and diversity. The weight smoothly transitions from local to global focus as progress increases, ensuring a balance between short-term and long-term optimization.",
     "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the regret-based optimization and global potential evaluation of No.1, while incorporating centrality and diversity penalties to avoid clustering, and uses a nonlinear progress-based weight to balance local and global optimization.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = (total_nodes - remaining_nodes) / total_nodes\n    weight = (1 - progress) ** 2\n\n    def heuristic(node):\n        local_cost = distance_matrix[current_node][node]\n        global_potential = distance_matrix[node][destination_node]\n        regret = (local_cost - min(distance_matrix[current_node][n] for n in unvisited_nodes)) / (max(distance_matrix[current_node][n] for n in unvisited_nodes) - min(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        diversity_bonus = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes + 1e-6)\n        return (1 - weight) * regret + weight * (0.7 * local_cost + 0.3 * global_potential) - 0.2 * centrality - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
     "objective": 6.59768,
     "other_inf": null
}