{
     "algorithm": "The algorithm selects the next node by balancing between proximity to the current node (weighted by connectivity and adaptively scaled by visited ratio), global potential (considering distance to destination and nearby unvisited nodes), regret (penalizing poor choices), and diversity (favoring less explored regions). It prioritizes direct paths to the destination when within a dynamic threshold, otherwise it minimizes a weighted combination of these factors, with connectivity and regret terms given moderate emphasis. The heuristic dynamically adjusts weights based on the number of unvisited nodes, favoring exploration early and exploitation later.",
     "thought": "The new algorithm modifies the provided heuristic by incorporating adaptive weight scaling based on node connectivity, dynamic regret penalties that consider multiple unvisited nodes, and a path diversity bonus that favors nodes connecting to less explored regions, while maintaining the original threshold logic for direct destination selection.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 - (0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        visited_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.5 - 0.5 * visited_ratio\n\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.2 * to_current)\n        connectivity_factor = 1 + (0.1 * connectivity / len(unvisited_nodes))\n\n        global_potential = (to_destination + sum(sorted(distance_matrix[node][other] for other in unvisited_nodes if other != node)[:2])) / 3\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_bonus *= 1 - (0.2 * (connectivity / len(unvisited_nodes)))\n\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.7 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
     "objective": 6.29556,
     "other_inf": null
}