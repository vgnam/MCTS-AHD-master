{
     "algorithm": "The algorithm combines dynamic weight balancing, regret penalties, and diversity bonuses to select the next node in TSP, prioritizing local distance (weighted by remaining nodes) and global factors (destination proximity and predictive distances), while penalizing high regret and rewarding diverse, well-connected nodes. Weights adapt based on remaining nodes, with regret and diversity factors given moderate influence, and connectivity factors slightly boosting node selection. The heuristic balances local and global considerations while accounting for path diversity and connectivity.",
     "thought": "The new algorithm combines dynamic weight balancing, regret penalties, diversity bonuses, and predictive factors from No.2, while incorporating the connectivity-aware heuristic and regret term from No.1 to create a more balanced and adaptive approach.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n\n        # Regret term combining No.1 and No.2 approaches\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        regret_weight = 0.5 * (1.0 - remaining_ratio)\n\n        # Diversity bonus considering connectivity\n        local_connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_factor = 0.2 * (1 + 0.1 * local_connectivity / len(unvisited_nodes)) * diversity_bonus\n\n        # Predictive factor from No.2 and connectivity from No.1\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        connectivity_factor = 1 + (0.2 * local_connectivity / len(unvisited_nodes))\n\n        # Balanced component weighting\n        local_factor = to_current * weight * connectivity_factor * (1.0 + regret_weight * regret_term)\n        global_factor = (to_destination + predictive_factor) * (1.0 - weight)\n\n        return (local_factor + global_factor) - diversity_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
     "objective": 6.26409,
     "other_inf": null
}