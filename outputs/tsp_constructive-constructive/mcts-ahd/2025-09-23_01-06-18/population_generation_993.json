[
     {
          "algorithm": "The algorithm combines dynamic weight balancing, regret penalties, and diversity bonuses to select the next node in TSP, prioritizing local distance (weighted by remaining nodes) and global factors (destination proximity and predictive distances), while penalizing high regret and rewarding diverse, well-connected nodes. Weights adapt based on remaining nodes, with regret and diversity factors given moderate influence, and connectivity factors slightly boosting node selection. The heuristic balances local and global considerations while accounting for path diversity and connectivity.",
          "thought": "The new algorithm combines dynamic weight balancing, regret penalties, diversity bonuses, and predictive factors from No.2, while incorporating the connectivity-aware heuristic and regret term from No.1 to create a more balanced and adaptive approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n\n        # Regret term combining No.1 and No.2 approaches\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        regret_weight = 0.5 * (1.0 - remaining_ratio)\n\n        # Diversity bonus considering connectivity\n        local_connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_factor = 0.2 * (1 + 0.1 * local_connectivity / len(unvisited_nodes)) * diversity_bonus\n\n        # Predictive factor from No.2 and connectivity from No.1\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        connectivity_factor = 1 + (0.2 * local_connectivity / len(unvisited_nodes))\n\n        # Balanced component weighting\n        local_factor = to_current * weight * connectivity_factor * (1.0 + regret_weight * regret_term)\n        global_factor = (to_destination + predictive_factor) * (1.0 - weight)\n\n        return (local_factor + global_factor) - diversity_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.26409,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (current node) and global (predictive factors) considerations, prioritizing local choices early (higher weight) and global considerations later (lower weight), while incorporating regret penalties (higher priority) and diversity bonuses (lower priority) to balance immediate distance, predictive factors, and exploration. The heuristic function evaluates each unvisited node based on a weighted sum of local distance, global potential, regret, and diversity, with weights dynamically adjusted based on remaining unvisited nodes. The algorithm ensures flexibility by balancing exploration (diversity) and exploitation (distance/regret) through the weight and penalty terms.",
          "thought": "The new algorithm combines No.2's dynamic weight adjustment between local and predictive factors with No.1's regret penalties and diversity bonuses, prioritizing local choices early and incorporating global considerations later while balancing immediate distance, predictive factors, regret, and diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.15 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2649,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment between local (distance from current node) and global (distance to destination and predictive factors) choices, while incorporating regret penalties (avoiding poor local decisions) and diversity bonuses (encouraging exploration of unvisited nodes). It prioritizes global potential early in the search (high weight on global terms) but gradually shifts to local decisions (lower weight on global terms) as fewer nodes remain unvisited. The heuristic function balances these factors with a weight (`2.5 - remaining_ratio`) that adapts to the remaining nodes, while regret penalties and diversity bonuses fine-tune the selection.",
          "thought": "The new algorithm combines dynamic weight adjustment between local and global choices, regret penalties, and diversity bonuses, while incorporating a stricter threshold for direct routing and enhanced predictive global potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.6 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.5 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.6 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2718,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (distance to current node) and global (distance to destination) factors, with adaptive weights that prioritize local choices early and global choices later. It incorporates a regret term to avoid poor historical choices and a diversity bonus to encourage exploration of well-connected nodes, all while using probabilistic selection to avoid deterministic traps. The heuristic dynamically adjusts weights based on remaining unvisited nodes, giving higher priority to local distances early and global distances later.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism with adaptive weights, incorporating a dynamic regret term based on historical path choices and a diversity bonus that considers both local and global connectivity, while maintaining the original algorithm's core balance between local and global factors.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.3 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n\n        # Adaptive regret term based on historical choices\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:3]) / 3\n        regret_weight = 0.4 * (1.0 - remaining_ratio)\n\n        # Dynamic diversity bonus considering both local and global connectivity\n        local_diversity = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_diversity = sum(distance_matrix[other][destination_node] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_bonus = 0.3 * (local_diversity + global_diversity)\n\n        # Probabilistic selection factor\n        selection_prob = 1.0 / (1.0 + to_current + 0.5 * to_destination)\n\n        # Adaptive weighting of components\n        local_factor = to_current * weight * (1.0 + regret_weight * regret_term)\n        global_factor = (to_destination + sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)) * (1.0 - weight)\n\n        return (local_factor + global_factor) * selection_prob - diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2736,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nearby destination returns when possible, balances local and global distances with dynamic weights (higher local weight early, higher global weight later), and incorporates regret penalties (avoiding high-cost alternatives) and diversity bonuses (exploring varied paths) to optimize the TSP path. The heuristic function combines distance to current node (weighted by dynamic weight and connectivity), distance to destination (weighted inversely), regret term (second-best option penalty), and diversity bonus (path variation reward).",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the connectivity, regret, and diversity considerations of No.1. It prioritizes nearby destination returns when possible, balances local and global distances with dynamic weights, and incorporates regret penalties and diversity bonuses to improve path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        if remaining_distance / avg_distance <= 1.2:\n            return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        connectivity_factor = 1 + (0.2 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + to_destination * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global choices by adjusting weights (higher local early, lower global later) while incorporating regret penalties and diversity bonuses. It prioritizes immediate distance (weighted by remaining nodes) and predictive global potential (average distance to unvisited nodes) but penalizes high regret (missing better local options) and rewards diversity (spreading visits). A threshold-based direct routing checks if the destination is nearby, optimizing when few nodes remain. The heuristic function combines these factors to select the next node, ensuring a trade-off between exploitation (short-term gains) and exploration (future potential).",
          "thought": "The new algorithm integrates dynamic weight adjustment between local and global considerations, prioritizes local choices early with higher weights and global considerations later with lower weights, incorporates regret penalties and diversity bonuses to balance immediate distance, predictive factors, exploration, and exploitation, while dynamically adjusting the balance based on remaining unvisited nodes and using a threshold-based direct routing when the destination is nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.5 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = max(distance_matrix[current_node][other] - to_current for other in unvisited_nodes) if unvisited_nodes else 0\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        return (to_current * weight + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27575,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic local-global balancing with regret penalties and diversity bonuses, prioritizing local connectivity and global potential while penalizing diversity. It adaptively weights local (distance to current node, connectivity) and global (predictive factor, destination distance) factors, with regret terms and diversity bonuses refining the selection. The heuristic function prioritizes local distance, global potential, and regret, while diversity bonuses are subtracted, balancing exploration and exploitation.",
          "thought": "The new algorithm combines dynamic local-global balancing with regret penalties and diversity bonuses, incorporating adaptive weights, predictive global potential, connectivity-based local selection, and enhanced regret terms from both algorithms to optimize path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.5 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 2\n        connectivity_factor = 1 + (0.2 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.2 * diversity_bonus\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.27829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight balancing (prioritizing local exploration early and global optimization later) with regret penalties (encouraging better choices by comparing alternatives) and diversity bonuses (favoring nodes that improve path variety), while using probabilistic selection with adaptive temperature to balance exploration and exploitation. It dynamically adjusts weights based on remaining nodes, incorporates regret terms to avoid poor choices, and uses diversity bonuses to encourage path diversity, with local factors (distance to current node) given higher priority early and global factors (distance to destination and connectivity) becoming more important later. The probabilistic selection with adaptive temperature ensures a balance between deterministic and random choices.",
          "thought": "The new algorithm combines the dynamic weight balancing, regret penalties, and diversity bonuses from No.1 with the adaptive regret term and probabilistic selection from No.2 to create a more balanced heuristic that prioritizes local exploration early and global optimization later while avoiding poor choices and encouraging path diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 1.0 + 0.2 * (1.0 - (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 2.0 - remaining_ratio\n\n        # Enhanced regret term combining No.1 and No.2 approaches\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n        regret_weight = 0.5 * (1.0 - remaining_ratio)\n\n        # Improved diversity bonus considering connectivity\n        local_connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.3 * to_current)\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_factor = 0.2 * (1 + 0.1 * local_connectivity / len(unvisited_nodes)) * diversity_bonus\n\n        # Probabilistic selection factor with adaptive temperature\n        selection_temp = 1.0 + 0.5 * (1.0 - remaining_ratio)\n        selection_prob = 1.0 / (1.0 + to_current**selection_temp + 0.3 * to_destination**selection_temp)\n\n        # Balanced component weighting\n        local_factor = to_current * weight * (1.0 + regret_weight * regret_term)\n        global_factor = (to_destination + sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)) * (1.0 - weight)\n\n        return (local_factor + global_factor) * selection_prob - diversity_factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.28662,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing between proximity to the current node (weighted by connectivity and adaptively scaled by visited ratio), global potential (considering distance to destination and nearby unvisited nodes), regret (penalizing poor choices), and diversity (favoring less explored regions). It prioritizes direct paths to the destination when within a dynamic threshold, otherwise it minimizes a weighted combination of these factors, with connectivity and regret terms given moderate emphasis. The heuristic dynamically adjusts weights based on the number of unvisited nodes, favoring exploration early and exploitation later.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating adaptive weight scaling based on node connectivity, dynamic regret penalties that consider multiple unvisited nodes, and a path diversity bonus that favors nodes connecting to less explored regions, while maintaining the original threshold logic for direct destination selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 - (0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        visited_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.5 - 0.5 * visited_ratio\n\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.2 * to_current)\n        connectivity_factor = 1 + (0.1 * connectivity / len(unvisited_nodes))\n\n        global_potential = (to_destination + sum(sorted(distance_matrix[node][other] for other in unvisited_nodes if other != node)[:2])) / 3\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:2]) / 2\n\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        diversity_bonus *= 1 - (0.2 * (connectivity / len(unvisited_nodes)))\n\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.7 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.29556,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with high local connectivity (via `connectivity_factor`) and immediate global potential (via `global_potential`), balancing them with a dynamic weight that shifts focus from local distances early to global factors later. It also incorporates regret penalties (`regret_term`) to avoid poor choices and diversity bonuses (`diversity_bonus`) to encourage exploration, while the `threshold` mechanism ensures the destination is reached when sufficiently close. The heuristic function combines these factors multiplicatively and additively, with local distances weighted more heavily early in the search.",
          "thought": "The new algorithm focuses on prioritizing nodes with high local connectivity and immediate global potential, using a dynamic weight that emphasizes local distances early and global factors later, while incorporating regret penalties and diversity bonuses to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        if avg_distance == 0:\n            return destination_node\n        threshold = 0.7 - (0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n        if remaining_distance / avg_distance <= threshold:\n            return destination_node\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        weight = 1.5 - remaining_ratio * 0.5\n        connectivity = sum(1 for other in unvisited_nodes if distance_matrix[node][other] < 1.2 * to_current)\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        regret_term = sum(sorted(distance_matrix[current_node][other] - to_current for other in unvisited_nodes)[:3]) / 3\n        diversity_bonus = sum(distance_matrix[node][other] for other in unvisited_nodes) / (len(unvisited_nodes) + 1e-6)\n        global_potential = (to_destination + predictive_factor) / 1.5\n        connectivity_factor = 1 + (0.3 * connectivity / len(unvisited_nodes))\n        return (to_current * weight * connectivity_factor + global_potential * (1.0 - weight) + 0.5 * regret_term) - 0.3 * diversity_bonus\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.2995,
          "other_inf": null
     }
]