[
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited, otherwise it selects the closest unvisited node to the current node based on the distance matrix. The destination node is given higher priority than other nodes, while the closest unvisited node is chosen when the destination is already visited. The function handles edge cases where no unvisited nodes remain by returning the destination node.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to unvisited nodes and focus on the destination by adjusting a threshold based on the remaining distance to the destination and the number of unvisited nodes. It prioritizes the destination if it's close enough (below the threshold) or selects the next node based on a weighted combination of current distance and future distance to the destination, ensuring a trade-off between local and global optimization. The dynamic threshold (`dynamic_threshold`) and the weighted selection criterion (`key=lambda...`) are the critical design elements.",
          "thought": "This new algorithm introduces a dynamic threshold mechanism that adjusts based on the remaining distance to the destination and the number of unvisited nodes, prioritizing either the closest node or the destination based on a calculated threshold, ensuring a balance between proximity and destination focus.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_threshold = max(1, (distance_matrix[current_node][destination_node] / (len(unvisited_nodes) + 1)) * 0.75)\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= dynamic_threshold:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.1 * (distance_matrix[node][destination_node] / sum(distance_matrix[node]))))\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing proximity to the current node (70%) and progress toward the destination (30%), minimizing a weighted sum of these distances. It prioritizes closer nodes while still making progress, avoiding local optima by dynamically choosing the best unvisited node based on the weighted heuristic. The weights (0.7 and 0.3) are tunable to adjust the trade-off between local and global optimization.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance to the current node and their distance to the destination, using a tunable parameter to balance proximity and progress, while still avoiding local optima by selecting the node that minimizes this weighted sum.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return 0.7 * to_current + 0.3 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) considerations, weighted dynamically by the number of remaining unvisited nodes, while also incorporating the average distance to unvisited nodes. The heuristic prioritizes minimizing the sum of current distance and a weighted destination distance, with the dynamic weight adjusting for global progress. The average distance factor adds a secondary influence, ensuring a mix of local and global optimization.",
          "thought": "The new algorithm modifies the heuristic by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between local optimization and global progress, while also considering the average distance to unvisited nodes to guide the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Adjusts based on remaining nodes\n        return to_current + dynamic_weight * to_destination + 0.3 * avg_distance_to_unvisited  # Adds average distance factor\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing the sum of the direct distance to the current node and half the distance to the destination. This ensures a trade-off between local optimization (short-term gains) and global progress (long-term goals). The heuristic function `heuristic(node)` combines these two factors, with the distance to the destination weighted lower (0.5x) than the distance to the current node. The algorithm efficiently handles edge cases (empty unvisited nodes or destination in unvisited nodes) and iteratively chooses the optimal next step.",
          "thought": "The new algorithm prioritizes nodes based on a combination of distance to the current node and distance to the destination node, ensuring a balance between proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + 0.5 * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of its distance to the current node and its distance to the destination, balancing proximity and progress while avoiding local optima. It ensures the multiplicative effect of distances is considered, giving higher priority to nodes that are closer to both the current and destination nodes. The heuristic function (`to_current * to_destination`) explicitly encodes this multiplicative prioritization, while the `min` operation selects the optimal node based on this criterion.",
          "thought": "The new algorithm selects the next node by prioritizing the node that minimizes the product of the distance to the current node and the distance to the destination, ensuring a balance between proximity and progress while avoiding local optima by considering the multiplicative effect of distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current * to_destination\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing the product of distances from the current node to the candidate and from the candidate to the destination, scaled by a progress factor that adjusts dynamically based on the ratio of the current-to-destination distance to the average distance to unvisited nodes. The progress factor balances exploration (lower factor) and exploitation (higher factor), prioritizing nodes that reduce the path length while considering remaining progress. The heuristic prioritizes nodes closer to both the current and destination nodes, with the progress factor modulating this trade-off.",
          "thought": "The new algorithm combines the multiplicative prioritization of No.2 with the dynamic progress factor of No.1, selecting the next node by minimizing the product of distances to current and destination nodes, scaled by a progress factor that adjusts based on the ratio of current-to-destination distance to the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    progress_factor = 0.5 if current_to_dest == 0 else min(1.0, 0.5 * (current_to_dest / sum(distance_matrix[current_node][n] for n in unvisited_nodes)))\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return (to_current * to_destination) * (1 - progress_factor)\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.4922,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global distances by prioritizing the destination node when near it, while adjusting the weight between current-to-node and node-to-destination distances based on remaining nodes. It also incorporates an average distance factor (weighted at 0.2) to ensure exploration, with the dynamic weight (up to 0.7) favoring global paths as the number of remaining nodes increases. The heuristic prioritizes shorter current-to-node distances but balances them with destination proximity and average distances.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a dynamic weighting of local and global distances inspired by No.1, adjusting the weight based on remaining nodes and incorporating an average distance factor to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance_to_unvisited = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 0\n\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.7 * (remaining_nodes / (remaining_nodes + 1))\n        return to_current + dynamic_weight * to_destination + 0.2 * avg_distance_to_unvisited\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.61752,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node and progress toward the destination, combining the distance to the current node with the square root of the distance to the destination. This emphasizes global progress more than local proximity, as the square root of the distance to the destination is added to the direct distance from the current node. The heuristic function ensures the algorithm makes informed decisions by minimizing the combined metric, guiding the path toward the destination efficiently.",
          "thought": "The new algorithm prioritizes balancing proximity to the current node and progress toward the destination by combining the distance to the current node with the square root of the distance to the destination, emphasizing global progress more significantly than the provided algorithm.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (to_destination ** 0.5)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.65711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes moving toward the destination node if its distance is within 1.5 times the average distance to unvisited nodes, otherwise it selects the next node by minimizing a weighted sum of the distance from the current node and the square root of the distance to the destination, scaled by the remaining problem size. The heuristic balances local proximity (distance to current node) and global progress (distance to destination) using a dynamic weight based on the number of remaining nodes.",
          "thought": "The new algorithm combines the balanced proximity and global progress from No.1 by prioritizing the destination node when its distance is close to the average (\u22641.5), otherwise selecting the next node by minimizing a weighted sum of the distance to the current node and the square root of the distance to the destination, scaled by the remaining problem size.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if destination_node in unvisited_nodes:\n        remaining_distance = distance_matrix[current_node][destination_node]\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        priority = remaining_distance / avg_distance if avg_distance != 0 else 1.0\n        if priority <= 1.5:\n            return destination_node\n    def heuristic(node):\n        to_current = distance_matrix[current_node][node]\n        to_destination = distance_matrix[node][destination_node]\n        return to_current + (to_destination ** 0.5) * (1 + 0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.66208,
          "other_inf": null
     }
]