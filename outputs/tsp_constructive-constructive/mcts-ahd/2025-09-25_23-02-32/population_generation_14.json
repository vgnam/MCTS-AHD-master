[
     {
          "algorithm": "The algorithm selects the next node by minimizing the ratio of the distance from the current node to the candidate node over the distance from the candidate node to the destination. This prioritizes nodes that are both close to the current position and closer to the destination, balancing proximity and directionality. The function iterates through unvisited nodes, computes the ratio, and selects the node with the smallest ratio, ensuring efficient path progression toward the destination.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the ratio of the distance from the current node to the candidate node over the distance from the candidate node to the destination, ensuring a balance between proximity and direction toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n\n        if distance_node_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_node / distance_node_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the destination node if it's unvisited and closer than other nodes; otherwise, it chooses the nearest unvisited node from the current node. The destination node is given higher priority than other nodes, while unvisited nodes are evaluated based on their distance from the current node. The code structure ensures the destination is checked first, followed by a loop through remaining unvisited nodes.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the smallest distance from the current node, prioritizing the destination node if it is unvisited and closer than any other node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        min_distance = distance_matrix[current_node][destination_node]\n        next_node = destination_node\n    else:\n        min_distance = float('inf')\n        next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node by assigning it a higher weight (1.5) to guide the path toward it, while other nodes are selected based on a dynamic threshold (0.9x the best distance) to balance proximity and exploration. If the destination is unvisited, it is chosen first; otherwise, nearby nodes are selected if they meet the threshold. The dynamic threshold ensures a mix of local optimization and exploration of unvisited nodes.",
          "thought": "The new algorithm modifies the selection process by incorporating a weighted combination of distance and node priority, where the destination node is prioritized with a higher weight, and other nodes are selected based on a dynamic threshold that balances proximity and exploration of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_destination = 1.5\n    min_distance = float('inf')\n    next_node = None\n\n    if destination_node in unvisited_nodes:\n        candidate_distance = distance_matrix[current_node][destination_node]\n        weighted_distance = candidate_distance * weight_destination\n        min_distance = weighted_distance\n        next_node = destination_node\n\n    threshold = min_distance * 0.9 if next_node else float('inf')\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        if distance < threshold:\n            min_distance = distance\n            next_node = node\n            threshold = min_distance * 0.9\n\n    return next_node",
          "objective": 7.09035,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local efficiency (distance from current node) with global progress (distance to destination), using a weighted combination where the distance to the candidate node is prioritized (60%), followed by the distance from the candidate to the destination (30%), and a heuristic factor (10%) that adjusts based on relative positions to the destination. The heuristic factor helps guide the path toward the destination while avoiding detours.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the distance to the candidate node, the distance from the candidate node to the destination, and a heuristic factor that prioritizes nodes closer to the current node's position relative to the destination, balancing local efficiency with global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n\n        # Heuristic factor: prioritize nodes closer to the current node's position relative to destination\n        heuristic_factor = (distance_to_node - distance_node_to_destination) / max(distance_matrix[current_node][destination_node], 1)\n\n        # Weighted score combining distances and heuristic factor\n        score = 0.6 * distance_to_node + 0.3 * distance_node_to_destination + 0.1 * heuristic_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.41761,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the sum of the distance from the current node to the candidate node and the distance from the candidate node to the destination. This ensures the path progressively moves closer to the destination while considering local efficiency. The code checks all unvisited nodes, computes the combined distance for each, and selects the node with the smallest total distance. The destination node is returned if no unvisited nodes remain.",
          "thought": "This algorithm prioritizes nodes that are closest to the destination node, ensuring the path gradually converges toward the destination while maintaining efficiency by considering both distance to destination and distance from current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_node + distance_node_to_destination\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing both immediate proximity (distance from current node) and network centrality (average distance to unvisited nodes), with the latter weighted lower (0.7) to balance exploration and exploitation. The score is computed as the sum of the current distance and 70% of the average distance to other unvisited nodes, favoring nodes that are close to the current position and centrally located in the remaining unvisited set. The function returns the node with the minimum score, ensuring a path that avoids isolated nodes while minimizing immediate travel distance.",
          "thought": "The new algorithm selects the next node by prioritizing those that are closest to the current node and have the highest connectivity (minimum average distance to other unvisited nodes), aiming to create a path that balances immediate proximity and network centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n\n        if len(unvisited_nodes) > 1:\n            avg_distance_to_others = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_distance_to_others = 0\n\n        score = distance_to_node + 0.7 * avg_distance_to_others\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.12438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, direct distance to the destination, and average distance to remaining unvisited nodes, with the latter given lower weight (0.7). It prioritizes nodes that are close to the current position while also considering overall path efficiency. The score calculation ensures a trade-off between immediate and long-term path optimization.",
          "thought": "The new algorithm combines the proximity-based selection of No.2 with the centrality consideration of No.1, prioritizing nodes that are close to the current node while also minimizing the sum of distances to the destination and the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            avg_distance_to_others = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_distance_to_others = 0\n\n        score = distance_to_node + distance_node_to_destination + 0.7 * avg_distance_to_others\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.96554,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node, potential distance to the destination, and the node's centrality (sum of distances to all remaining unvisited nodes). It prioritizes immediate distance (1.0 weight) over centrality (0.3 weight) and destination distance (0.5 weight), with the centrality score being the least influential factor. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the minimum score. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The algorithm prioritizes selecting the next node by balancing immediate closeness to the current node and potential long-term efficiency, considering both direct distance and the node's centrality in the remaining unvisited nodes to optimize the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality score: sum of distances from current node to all other unvisited nodes\n        centrality_score = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)\n\n        # Combine immediate distance, distance to destination, and centrality\n        score = distance_to_node + 0.5 * distance_node_to_destination + 0.3 * centrality_score\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 14.0222,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local (current-to-candidate) and global (candidate-to-destination) distances, with weights inversely proportional to remaining unvisited nodes. Higher priority is given to global optimization (candidate-to-destination) as the problem progresses, while local efficiency (current-to-candidate) is emphasized early on. The code efficiently computes a weighted sum of distances and selects the node with the lowest combined score.",
          "thought": "The new algorithm introduces a weighted combination of the current-to-candidate distance and candidate-to-destination distance, where weights are inversely proportional to the number of remaining unvisited nodes, promoting global path optimization while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = 1.0 / remaining_nodes\n    weight_destination = 1.0 - weight_current\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = (weight_current * distance_to_node) + (weight_destination * distance_node_to_destination)\n\n        if weighted_distance < min_total_distance:\n            min_total_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 14.08142,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination. This prioritizes nodes that are close to the current node while also being far from the destination, balancing proximity and progress toward the goal. The code iterates through unvisited nodes, computes the ratio, and selects the node with the highest ratio, defaulting to the destination if no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the ratio of the distance from the current node to the candidate node divided by the distance from the candidate node to the destination, ensuring a balance between proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_node_to_destination = distance_matrix[node][destination_node]\n\n        if distance_node_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_node / distance_node_to_destination\n\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 28.21944,
          "other_inf": null
     }
]