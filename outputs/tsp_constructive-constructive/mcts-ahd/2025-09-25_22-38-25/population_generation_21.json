[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP, prioritizing the destination node if it's unvisited but otherwise selecting the closest unvisited node from the current node based on the distance matrix. The function checks if the destination is unvisited first (highest priority), otherwise it iterates through unvisited nodes to find the nearest neighbor (lower priority). The distance matrix and unvisited nodes set are key inputs, while the current and destination nodes guide the selection.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current node, with a preference for the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation. The destination node is given the highest priority, followed by the nearest neighbor, with occasional randomness to avoid local optima. The code uses a distance matrix for efficiency and a probability-based decision to explore nearby nodes.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.2:\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.03928,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node (if unvisited) with a 70% chance, otherwise it defaults to the nearest unvisited node, with a 30% chance of randomly choosing a nearby node (within 120% of the minimum distance) to introduce exploration. This balances exploitation (shortest paths) with controlled exploration (randomness) to avoid local optima.",
          "thought": "The algorithm uses a probabilistic selection approach where the destination node has a higher probability of being chosen if unvisited, otherwise it selects the nearest unvisited node with a bias towards shorter distances, incorporating randomness to explore different paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.7:  # Higher probability to choose the destination\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.3:  # Randomly choose a nearby node with lower probability\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.10914,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and within 70% of the maximum distance from the current node; otherwise, it selects the nearest unvisited node while incorporating a 30% bias towards nodes closer to the destination, balancing immediate proximity and progress toward the goal. The key design choices are the 0.7 threshold for destination prioritization and the 0.3 weight for destination proximity in the distance calculation.",
          "thought": "The new algorithm prioritizes the destination node only if it's unvisited and within a threshold distance from the current node; otherwise, it selects the nearest unvisited node, but with a bias towards nodes that are closer to the destination, balancing proximity and progress towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= max(distance_matrix[current_node][node] for node in unvisited_nodes) * 0.7:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node with a 50% chance, defaults to the nearest unvisited node with a 40% chance, and randomly selects a nearby node (within 150% of the minimum distance) with a 10% chance, balancing exploitation and exploration. The destination node is given the highest priority (50%), followed by the nearest node (40%), and then a nearby random node (10%), with the latter two phases only executed if the destination is not selected. The code uses probabilistic selection to dynamically choose the next node, ensuring a mix of greedy and exploratory steps.",
          "thought": "The new algorithm prioritizes the destination node with a 50% chance, defaults to the nearest unvisited node with a 40% chance, and randomly selects a nearby node (within 150% of the minimum distance) with a 10% chance, balancing exploitation and exploration more aggressively.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.5:\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None:\n        if random.random() < 0.4:\n            return next_node\n        elif random.random() < 0.5:\n            nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.5]\n            if nearby_nodes:\n                return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.33201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (60% chance) to minimize distance, defaults to the destination (35% chance) to ensure progress, and occasionally explores faraway nodes (5% chance) to avoid local optima. It uses a distance matrix for efficiency and randomness to balance exploitation and exploration. The structure checks conditions in order of priority, with later steps only executing if earlier ones fail.",
          "thought": "The new algorithm prioritizes selecting the nearest unvisited node with a 60% chance, defaults to the destination node if it's unvisited with a 35% chance, and randomly chooses a faraway node (within 150% of the minimum distance) with a 5% chance to encourage exploration and avoid local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.35:\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.6:\n        return next_node\n    if next_node is not None and random.random() < 0.05:\n        faraway_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] >= min_distance * 1.5]\n        if faraway_nodes:\n            return random.choice(faraway_nodes)\n    return next_node",
          "objective": 7.33407,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by linearly decreasing the probability of selecting the destination node as unvisited nodes decrease, while exponentially increasing the chance of choosing nearby nodes to encourage exploration. It also uses a cooling factor to scale randomness, prioritizing nearby nodes early and the destination later in the process. The key variables are `dest_prob` (high priority for destination) and `nearby_prob` (high priority for nearby nodes), with probabilities adjusted based on progress and temperature.",
          "thought": "The new algorithm introduces a dynamic probability mechanism where the chance of selecting the destination node decreases linearly with the number of unvisited nodes remaining, while the probability of choosing a nearby node increases exponentially to encourage exploration as the problem progresses. It also incorporates a temperature-based selection where randomness is scaled by a cooling factor to balance exploration and exploitation over iterations.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = (total_nodes - remaining_nodes) / total_nodes\n    temperature = 1.0 - progress\n\n    if destination_node in unvisited_nodes:\n        dest_prob = 0.7 * (remaining_nodes / total_nodes)\n        if random.random() < dest_prob:\n            return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if next_node is not None:\n        nearby_prob = 0.3 * (1 - math.exp(-temperature))\n        if random.random() < nearby_prob:\n            nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n            if nearby_nodes:\n                return random.choice(nearby_nodes)\n\n    return next_node",
          "objective": 7.60743,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node (70% chance) while also considering proximity to it (30% weight in distance calculation). It balances this with a 20% chance to explore nearby nodes (within 120% of the minimum distance) to avoid local optima, combining greedy selection with controlled randomness. The key variables are `distance_matrix` and `destination_node`, with the latter given higher priority (70% chance) but also influencing future selections (30% weight).",
          "thought": "The new algorithm combines destination prioritization (70% chance) with a biased nearest-neighbor selection that incorporates a 30% weight towards destination proximity, similar to No.1, but with controlled exploration by allowing a 20% chance to randomly choose a nearby node (within 120% of the minimum distance) to avoid local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.7:\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.2:\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 8.25757,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances exploitation and exploration by prioritizing the destination node (50% chance) when it's unvisited, otherwise randomly selecting from the top 30% farthest nodes (20% chance) for exploration, and defaulting to the nearest unvisited node (80% chance) for exploitation. The distance matrix is used to compute distances, and the unvisited nodes are filtered to ensure valid selections. Key variables: `current_node` (current position), `unvisited_nodes` (remaining nodes), and `distance_matrix` (node distances).",
          "thought": "The new algorithm prioritizes selecting the farthest unvisited node with a 50% chance, otherwise defaults to the nearest unvisited node, with a 20% chance of randomly choosing a node from the top 30% of the farthest distances to introduce exploration while balancing exploitation and controlled exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    distances = [(node, distance_matrix[current_node][node]) for node in unvisited_nodes]\n    distances.sort(key=lambda x: x[1])\n\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.5:\n            return destination_node\n\n    if random.random() < 0.2:\n        farthest_nodes = [node for node, dist in distances[int(0.7 * len(distances)):]]\n        if farthest_nodes:\n            return random.choice(farthest_nodes)\n\n    return next_node",
          "objective": 9.44315,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP path by first giving a 50% chance to choose the destination node if it's unvisited, otherwise it probabilistically selects nodes based on inverse distance weights (closer nodes are prioritized) using weighted random selection. If all weights are zero, it defaults to a random choice. The design balances exploitation (favoring nearby nodes) with exploration (allowing some randomness), using the distance matrix to guide decisions.",
          "thought": "This algorithm first checks if the destination node is unvisited and selects it with a 50% chance, otherwise it uses a probability-based selection where nodes are weighted by their inverse distance to the current node, favoring closer nodes while allowing some exploration.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and random.random() < 0.5:\n        return destination_node\n\n    weights = []\n    total_weight = 0.0\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance == 0:\n            weight = 0\n        else:\n            weight = 1.0 / distance\n        weights.append((node, weight))\n        total_weight += weight\n\n    if total_weight == 0:\n        return random.choice(unvisited_nodes)\n\n    rand_val = random.uniform(0, total_weight)\n    cumulative_weight = 0.0\n    for node, weight in weights:\n        cumulative_weight += weight\n        if rand_val <= cumulative_weight:\n            return node\n\n    return next_node",
          "objective": 19.72962,
          "other_inf": null
     }
]