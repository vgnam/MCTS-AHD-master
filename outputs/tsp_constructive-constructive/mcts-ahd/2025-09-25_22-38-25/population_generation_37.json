[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP, prioritizing the destination node if it's unvisited but otherwise selecting the closest unvisited node from the current node based on the distance matrix. The function checks if the destination is unvisited first (highest priority), otherwise it iterates through unvisited nodes to find the nearest neighbor (lower priority). The distance matrix and unvisited nodes set are key inputs, while the current and destination nodes guide the selection.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current node, with a preference for the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation. The destination node is given the highest priority, followed by the nearest neighbor, with occasional randomness to avoid local optima. The code uses a distance matrix for efficiency and a probability-based decision to explore nearby nodes.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.2:\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.03928,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm enhances the nearest-neighbor heuristic by dynamically balancing exploration and exploitation using a decaying temperature parameter, prioritizing the destination node probabilistically early on, and introducing a weighted random selection among nearby nodes when the temperature is high. It balances distance minimization (exploitation) with exploration of nearby nodes (exploration) through temperature-driven probabilistic decisions. The temperature decays linearly from 0.7 to 0.1, and the selection prioritizes the destination node early but gradually shifts to the nearest neighbor, with occasional random selections among nearby nodes when the temperature is high.",
          "thought": "The new algorithm enhances the nearest-neighbor heuristic by introducing a dynamic temperature parameter that decays over iterations to gradually shift from exploration to exploitation, combined with a probabilistic selection weighted by node priorities derived from distance and destination alignment.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    iterations = len(distance_matrix) - len(unvisited_nodes)\n    max_iterations = len(distance_matrix)\n    temperature = max(0.1, 0.7 * (1 - iterations / max_iterations))\n\n    if destination_node in unvisited_nodes:\n        if random.random() < temperature:\n            return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if random.random() < temperature * (1 - min_distance / max(distance_matrix[current_node])):\n        candidate_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if candidate_nodes:\n            next_node = random.choice(candidate_nodes)\n\n    return next_node",
          "objective": 7.08424,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node (if unvisited) with a 70% chance, otherwise it defaults to the nearest unvisited node, with a 30% chance of randomly choosing a nearby node (within 120% of the minimum distance) to introduce exploration. This balances exploitation (shortest paths) with controlled exploration (randomness) to avoid local optima.",
          "thought": "The algorithm uses a probabilistic selection approach where the destination node has a higher probability of being chosen if unvisited, otherwise it selects the nearest unvisited node with a bias towards shorter distances, incorporating randomness to explore different paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.7:  # Higher probability to choose the destination\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.3:  # Randomly choose a nearby node with lower probability\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.10914,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines probabilistic destination selection with adaptive exploration-exploitation balance, using a temperature parameter that decreases linearly with progress to prioritize nearby nodes early while increasing the chance of selecting the destination later. It first checks if the destination is unvisited and selects it with probability proportional to the remaining temperature, otherwise it selects the nearest unvisited node. If multiple nearby nodes are within 20% of the minimum distance, it randomly picks one with probability based on temperature. The algorithm balances greediness (prioritizing nearby nodes) and exploration (considering destination and nearby nodes probabilistically) dynamically.",
          "thought": "The new algorithm combines the probabilistic destination selection of No.2 with the adaptive exploration-exploitation balance from No.1, using a temperature parameter that decreases linearly with progress and prioritizes nearby nodes early while increasing the chance of selecting the destination later.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = (total_nodes - remaining_nodes) / total_nodes\n    temperature = 1.0 - progress\n\n    if destination_node in unvisited_nodes:\n        if random.random() < temperature:\n            return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if next_node is not None and remaining_nodes > 1:\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes and random.random() < temperature:\n            return random.choice(nearby_nodes)\n\n    return next_node",
          "objective": 7.1939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by combining distance-based proximity and a dynamic \"attraction factor\" that considers both direct distance to the current node and alignment with the destination path, while using a temperature-based probabilistic selection to balance exploration of nearby nodes and exploitation of the most attractive options. The attraction factor weights nodes inversely with distance but boosts those closer to the destination, while the temperature parameter controls exploration intensity, decreasing as the number of unvisited nodes shrinks. The code structure first computes attraction factors, then probabilistically selects nearby nodes for exploration, and defaults to the highest-attraction node for exploitation.",
          "thought": "The new algorithm introduces a dynamic priority system that combines distance-based proximity with a novel \"attraction factor\" derived from the node's position relative to the destination and its local neighborhood, using a probabilistic selection mechanism that adapts to the remaining unvisited nodes. It prioritizes nodes that are both close to the current node and aligned with the destination path, while maintaining controlled randomness through a temperature-based exploration parameter.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 0.9 * (total_unvisited / (total_unvisited + 1)))\n\n    # Calculate attraction factors for each node\n    attraction_factors = {}\n    for node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][node]\n        if destination_node in unvisited_nodes:\n            dest_distance = distance_matrix[node][destination_node]\n            attraction = (1 / (direct_distance + 1e-6)) * (1 + 0.3 * (1 - dest_distance / (distance_matrix[current_node][destination_node] + 1e-6)))\n        else:\n            attraction = 1 / (direct_distance + 1e-6)\n        attraction_factors[node] = attraction\n\n    # Temperature-based probabilistic selection\n    if random.random() < temperature:\n        # Explore nearby nodes with higher probability\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min(distance_matrix[current_node][n] for n in unvisited_nodes) * 1.2]\n        if nearby_nodes:\n            weights = [attraction_factors[node] for node in nearby_nodes]\n            return random.choices(nearby_nodes, weights=weights, k=1)[0]\n\n    # Exploit the most attractive node\n    next_node = max(attraction_factors.items(), key=lambda x: x[1])[0]\n    return next_node",
          "objective": 7.19823,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and within 70% of the maximum distance from the current node; otherwise, it selects the nearest unvisited node while incorporating a 30% bias towards nodes closer to the destination, balancing immediate proximity and progress toward the goal. The key design choices are the 0.7 threshold for destination prioritization and the 0.3 weight for destination proximity in the distance calculation.",
          "thought": "The new algorithm prioritizes the destination node only if it's unvisited and within a threshold distance from the current node; otherwise, it selects the nearest unvisited node, but with a bias towards nodes that are closer to the destination, balancing proximity and progress towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= max(distance_matrix[current_node][node] for node in unvisited_nodes) * 0.7:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node with a 50% chance, defaults to the nearest unvisited node with a 40% chance, and randomly selects a nearby node (within 150% of the minimum distance) with a 10% chance, balancing exploitation and exploration. The destination node is given the highest priority (50%), followed by the nearest node (40%), and then a nearby random node (10%), with the latter two phases only executed if the destination is not selected. The code uses probabilistic selection to dynamically choose the next node, ensuring a mix of greedy and exploratory steps.",
          "thought": "The new algorithm prioritizes the destination node with a 50% chance, defaults to the nearest unvisited node with a 40% chance, and randomly selects a nearby node (within 150% of the minimum distance) with a 10% chance, balancing exploitation and exploration more aggressively.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.5:\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None:\n        if random.random() < 0.4:\n            return next_node\n        elif random.random() < 0.5:\n            nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.5]\n            if nearby_nodes:\n                return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.33201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (60% chance) to minimize distance, defaults to the destination (35% chance) to ensure progress, and occasionally explores faraway nodes (5% chance) to avoid local optima. It uses a distance matrix for efficiency and randomness to balance exploitation and exploration. The structure checks conditions in order of priority, with later steps only executing if earlier ones fail.",
          "thought": "The new algorithm prioritizes selecting the nearest unvisited node with a 60% chance, defaults to the destination node if it's unvisited with a 35% chance, and randomly chooses a faraway node (within 150% of the minimum distance) with a 5% chance to encourage exploration and avoid local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.35:\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.6:\n        return next_node\n    if next_node is not None and random.random() < 0.05:\n        faraway_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] >= min_distance * 1.5]\n        if faraway_nodes:\n            return random.choice(faraway_nodes)\n    return next_node",
          "objective": 7.33407,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by linearly decreasing the probability of selecting the destination node as unvisited nodes decrease, while exponentially increasing the chance of choosing nearby nodes to encourage exploration. It also uses a cooling factor to scale randomness, prioritizing nearby nodes early and the destination later in the process. The key variables are `dest_prob` (high priority for destination) and `nearby_prob` (high priority for nearby nodes), with probabilities adjusted based on progress and temperature.",
          "thought": "The new algorithm introduces a dynamic probability mechanism where the chance of selecting the destination node decreases linearly with the number of unvisited nodes remaining, while the probability of choosing a nearby node increases exponentially to encourage exploration as the problem progresses. It also incorporates a temperature-based selection where randomness is scaled by a cooling factor to balance exploration and exploitation over iterations.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = (total_nodes - remaining_nodes) / total_nodes\n    temperature = 1.0 - progress\n\n    if destination_node in unvisited_nodes:\n        dest_prob = 0.7 * (remaining_nodes / total_nodes)\n        if random.random() < dest_prob:\n            return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if next_node is not None:\n        nearby_prob = 0.3 * (1 - math.exp(-temperature))\n        if random.random() < nearby_prob:\n            nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n            if nearby_nodes:\n                return random.choice(nearby_nodes)\n\n    return next_node",
          "objective": 7.60743,
          "other_inf": null
     }
]