[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP, prioritizing the destination node if it's unvisited but otherwise selecting the closest unvisited node from the current node based on the distance matrix. The function checks if the destination is unvisited first (highest priority), otherwise it iterates through unvisited nodes to find the nearest neighbor (lower priority). The distance matrix and unvisited nodes set are key inputs, while the current and destination nodes guide the selection.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current node, with a preference for the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation. The destination node is given the highest priority, followed by the nearest neighbor, with occasional randomness to avoid local optima. The code uses a distance matrix for efficiency and a probability-based decision to explore nearby nodes.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the nearest neighbor, but introduces controlled randomness by choosing a nearby node (within 120% of the minimum distance) with a 20% probability to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.2:\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.03928,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node (if unvisited) with a 70% chance, otherwise it defaults to the nearest unvisited node, with a 30% chance of randomly choosing a nearby node (within 120% of the minimum distance) to introduce exploration. This balances exploitation (shortest paths) with controlled exploration (randomness) to avoid local optima.",
          "thought": "The algorithm uses a probabilistic selection approach where the destination node has a higher probability of being chosen if unvisited, otherwise it selects the nearest unvisited node with a bias towards shorter distances, incorporating randomness to explore different paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.7:  # Higher probability to choose the destination\n            return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is not None and random.random() < 0.3:  # Randomly choose a nearby node with lower probability\n        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= min_distance * 1.2]\n        if nearby_nodes:\n            return random.choice(nearby_nodes)\n    return next_node",
          "objective": 7.10914,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited and within 70% of the maximum distance from the current node; otherwise, it selects the nearest unvisited node while incorporating a 30% bias towards nodes closer to the destination, balancing immediate proximity and progress toward the goal. The key design choices are the 0.7 threshold for destination prioritization and the 0.3 weight for destination proximity in the distance calculation.",
          "thought": "The new algorithm prioritizes the destination node only if it's unvisited and within a threshold distance from the current node; otherwise, it selects the nearest unvisited node, but with a bias towards nodes that are closer to the destination, balancing proximity and progress towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] <= max(distance_matrix[current_node][node] for node in unvisited_nodes) * 0.7:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances exploitation and exploration by prioritizing the destination node (50% chance) when it's unvisited, otherwise randomly selecting from the top 30% farthest nodes (20% chance) for exploration, and defaulting to the nearest unvisited node (80% chance) for exploitation. The distance matrix is used to compute distances, and the unvisited nodes are filtered to ensure valid selections. Key variables: `current_node` (current position), `unvisited_nodes` (remaining nodes), and `distance_matrix` (node distances).",
          "thought": "The new algorithm prioritizes selecting the farthest unvisited node with a 50% chance, otherwise defaults to the nearest unvisited node, with a 20% chance of randomly choosing a node from the top 30% of the farthest distances to introduce exploration while balancing exploitation and controlled exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    distances = [(node, distance_matrix[current_node][node]) for node in unvisited_nodes]\n    distances.sort(key=lambda x: x[1])\n\n    if destination_node in unvisited_nodes:\n        if random.random() < 0.5:\n            return destination_node\n\n    if random.random() < 0.2:\n        farthest_nodes = [node for node, dist in distances[int(0.7 * len(distances)):]]\n        if farthest_nodes:\n            return random.choice(farthest_nodes)\n\n    return next_node",
          "objective": 9.44315,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP path by first giving a 50% chance to choose the destination node if it's unvisited, otherwise it probabilistically selects nodes based on inverse distance weights (closer nodes are prioritized) using weighted random selection. If all weights are zero, it defaults to a random choice. The design balances exploitation (favoring nearby nodes) with exploration (allowing some randomness), using the distance matrix to guide decisions.",
          "thought": "This algorithm first checks if the destination node is unvisited and selects it with a 50% chance, otherwise it uses a probability-based selection where nodes are weighted by their inverse distance to the current node, favoring closer nodes while allowing some exploration.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes and random.random() < 0.5:\n        return destination_node\n\n    weights = []\n    total_weight = 0.0\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance == 0:\n            weight = 0\n        else:\n            weight = 1.0 / distance\n        weights.append((node, weight))\n        total_weight += weight\n\n    if total_weight == 0:\n        return random.choice(unvisited_nodes)\n\n    rand_val = random.uniform(0, total_weight)\n    cumulative_weight = 0.0\n    for node, weight in weights:\n        cumulative_weight += weight\n        if rand_val <= cumulative_weight:\n            return node\n\n    return next_node",
          "objective": 19.72962,
          "other_inf": null
     }
]