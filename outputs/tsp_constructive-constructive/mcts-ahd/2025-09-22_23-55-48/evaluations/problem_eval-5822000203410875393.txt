def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_max_subtour = float('inf')
    next_node = None

    for candidate in unvisited_nodes:
        distance_to_candidate = distance_matrix[current_node][candidate]
        remaining_nodes = unvisited_nodes - {candidate}

        if not remaining_nodes:
            total_distance = distance_to_candidate + distance_matrix[candidate][destination_node]
            max_subtour = total_distance
        else:
            subtour_lengths = []
            visited = set()
            for node in remaining_nodes:
                if node not in visited:
                    stack = [node]
                    visited.add(node)
                    current_subtour = 0
                    while stack:
                        current = stack.pop()
                        for neighbor in remaining_nodes:
                            if neighbor not in visited and distance_matrix[current][neighbor] > 0:
                                visited.add(neighbor)
                                stack.append(neighbor)
                                current_subtour += distance_matrix[current][neighbor]
                    if current_subtour > 0:
                        subtour_lengths.append(current_subtour)

            if subtour_lengths:
                max_subtour = max(subtour_lengths)
            else:
                max_subtour = distance_to_candidate + distance_matrix[candidate][destination_node]

        if max_subtour < min_max_subtour:
            min_max_subtour = max_subtour
            next_node = candidate

    return next_node
