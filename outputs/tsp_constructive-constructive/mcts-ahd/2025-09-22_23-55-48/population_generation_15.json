[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the destination node if it's unvisited and closest to the current node, otherwise choosing the nearest unvisited node from the distance matrix. It ensures the destination is visited last if it's the closest, otherwise proceeds greedily. The code handles edge cases (empty unvisited nodes) and efficiently checks distances using the distance matrix.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node to the current node, prioritizing the destination node if it is the closest and unvisited, otherwise selecting the nearest unvisited node from the distance matrix.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        min_distance = distance_matrix[current_node][destination_node]\n        next_node = destination_node\n    else:\n        min_distance = float('inf')\n        next_node = None\n\n    for node in unvisited_nodes:\n        if node != destination_node and distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by evaluating both the immediate distance to unvisited nodes and the potential to reach the destination efficiently, prioritizing candidates that minimize the total path length while considering remaining unvisited nodes. It balances local proximity (distance to candidate) and global efficiency (distance to destination or next closest nodes), dynamically adjusting the selection based on the remaining unvisited set. The function iterates through unvisited nodes, calculates a heuristic total distance, and chooses the node that minimizes this metric.",
          "thought": "This algorithm selects the next node by considering both the closest unvisited node and the destination node, prioritizing the one that minimizes the total path length when combined with the remaining unvisited nodes, ensuring a more globally optimal path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for candidate in unvisited_nodes:\n        distance_to_candidate = distance_matrix[current_node][candidate]\n        remaining_nodes = unvisited_nodes - {candidate}\n\n        if candidate == destination_node:\n            total_distance = distance_to_candidate + distance_matrix[candidate][destination_node]\n        else:\n            if not remaining_nodes:\n                total_distance = distance_to_candidate + distance_matrix[candidate][destination_node]\n            else:\n                min_next_distance = min(distance_matrix[candidate][node] for node in remaining_nodes)\n                total_distance = distance_to_candidate + min_next_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = candidate\n\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance from the current node with the average distance to remaining unvisited nodes, ensuring a more globally optimized path by combining local and global considerations. It selects the next node by minimizing a heuristic that sums the direct distance to the candidate and the average distance to all other unvisited nodes, effectively trading off short-term and long-term optimality. The heuristic ensures the path avoids isolated nodes by favoring candidates that are central to nearby unvisited nodes.",
          "thought": "The new algorithm prioritizes nodes that balance immediate distance with potential to form a cluster of nearby nodes, using a heuristic that combines the distance to the candidate and the average distance to remaining unvisited nodes, ensuring a more globally optimized path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_heuristic = float('inf')\n    next_node = None\n\n    for candidate in unvisited_nodes:\n        distance_to_candidate = distance_matrix[current_node][candidate]\n        remaining_nodes = unvisited_nodes - {candidate}\n\n        if not remaining_nodes:\n            heuristic = distance_to_candidate + distance_matrix[candidate][destination_node]\n        else:\n            avg_remaining_distance = sum(distance_matrix[candidate][node] for node in remaining_nodes) / len(remaining_nodes)\n            heuristic = distance_to_candidate + avg_remaining_distance\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = candidate\n\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in the TSP path by prioritizing candidates that minimize the maximum subtour length among unvisited nodes, balancing immediate distance and potential cluster formation. It evaluates each candidate by simulating subtour lengths of remaining nodes (using DFS) and choosing the one that most evenly distributes the remaining path, with the `distance_matrix` guiding edge weights and `unvisited_nodes` determining remaining candidates. The `destination_node` ensures the path eventually returns to the start.",
          "thought": "This algorithm prioritizes nodes that create the most balanced subtours by considering both immediate distance and the potential to form compact clusters of unvisited nodes, aiming to minimize the maximum subtour length in the remaining path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_max_subtour = float('inf')\n    next_node = None\n\n    for candidate in unvisited_nodes:\n        distance_to_candidate = distance_matrix[current_node][candidate]\n        remaining_nodes = unvisited_nodes - {candidate}\n\n        if not remaining_nodes:\n            total_distance = distance_to_candidate + distance_matrix[candidate][destination_node]\n            max_subtour = total_distance\n        else:\n            subtour_lengths = []\n            visited = set()\n            for node in remaining_nodes:\n                if node not in visited:\n                    stack = [node]\n                    visited.add(node)\n                    current_subtour = 0\n                    while stack:\n                        current = stack.pop()\n                        for neighbor in remaining_nodes:\n                            if neighbor not in visited and distance_matrix[current][neighbor] > 0:\n                                visited.add(neighbor)\n                                stack.append(neighbor)\n                                current_subtour += distance_matrix[current][neighbor]\n                    if current_subtour > 0:\n                        subtour_lengths.append(current_subtour)\n\n            if subtour_lengths:\n                max_subtour = max(subtour_lengths)\n            else:\n                max_subtour = distance_to_candidate + distance_matrix[candidate][destination_node]\n\n        if max_subtour < min_max_subtour:\n            min_max_subtour = max_subtour\n            next_node = candidate\n\n    return next_node",
          "objective": 19.64282,
          "other_inf": null
     }
]