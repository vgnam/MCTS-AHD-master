[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm attempts to go directly to the destination node if possible; otherwise, it selects the next node based on a combination of distance and pheromone-inspired desirability. A probabilistic component introduces exploration, balancing exploitation of known good paths with the discovery of potentially better ones. The algorithm prioritizes exploitation (using `q0`) with a probability of 0.9, and exploration with a probability of 0.1.\n",
          "thought": "This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # {This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.}\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    \n    pheromone_levels = {node: 1.0 for node in unvisited_nodes} \n\n    def desirability(node):\n        alpha = 1.0  \n        beta = 2.0   \n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in unvisited_nodes}\n    \n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in unvisited_nodes}\n    \n    # Exploration vs Exploitation\n    q = random.random()\n    q0 = 0.9  \n    \n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        # Probabilistic selection\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(unvisited_nodes)) \n\n    return next_node",
          "objective": 7.80112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by balancing immediate proximity (distance from current node) with global connectivity (average distance to other unvisited nodes), minimizing their sum to ensure a trade-off between short-term and long-term path efficiency. The destination node has the highest priority, followed by nodes that minimize the combined score of current distance and average distance to others.",
          "thought": "The new algorithm first checks if the destination node is unvisited, prioritizing it if possible. For the remaining nodes, it selects the one that minimizes the sum of distances to the current node and the average distance to all other unvisited nodes, balancing immediate proximity with global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        score = current_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically prioritizes the destination node with a time-decaying probability (starting at 90% when most nodes are unvisited, decreasing to 10%), while otherwise selecting the nearest unvisited node with stochasticity controlled by a temperature parameter (higher when more nodes remain). It balances exploration (via exponential decay in neighbor selection) and exploitation (greedy nearest-neighbor choice) to avoid local optima.",
          "thought": "The new algorithm introduces a dynamic bias towards the destination node when it's unvisited, using a probabilistic selection mechanism that combines distance-based proximity with a time-decaying preference for the destination, while maintaining stochasticity to avoid local optima.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    if destination_node in unvisited_nodes:\n        # Dynamic probability of selecting destination, decaying with time\n        prob_destination = max(0.1, 0.9 * (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))))\n        if random.random() < prob_destination:\n            return destination_node\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Temperature-based stochasticity: higher temperature leads to more exploration\n    temperature = len(unvisited_nodes) / len(distance_matrix)\n    if random.random() < temperature:\n        # Exponential decay for candidate selection\n        weights = [math.exp(-i * 0.5) for i in range(len(nearest_neighbors))]\n        next_node = random.choices(nearest_neighbors, weights=weights, k=1)[0]\n    else:\n        next_node = nearest_neighbors[0]\n\n    return next_node",
          "objective": 9.07523,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach that balances immediate distance from the current node with potential future efficiency by considering the nearest unvisited node and the average distance to all other unvisited nodes, combining these metrics to select the next node with the lowest total score. The function uses the `distance_matrix` to compute distances, with `current_distance` given the highest priority, followed by `nearest_distance`, and `avg_distance` given the lowest priority in the scoring mechanism.",
          "thought": "This algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach combining nearest neighbor selection with a greedy optimization that considers both immediate distance and potential future path efficiency by evaluating the sum of distances to the nearest unvisited nodes and the average distance to all other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n\n        # Find the nearest unvisited node from this candidate\n        nearest_unvisited = min(unvisited_nodes, key=lambda n: distance_matrix[node][n] if n != node else float('inf'))\n        nearest_distance = distance_matrix[node][nearest_unvisited] if nearest_unvisited != node else 0\n\n        # Average distance to all other unvisited nodes\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        # Combine metrics for a balanced score\n        score = current_distance + nearest_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 10.1896,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise combines nearest-neighbor selection with adaptive stochasticity based on node centrality. It balances proximity (70% weight) and centrality (30% weight) in scoring, then selects from top candidates with higher probability (70% from top 2, 30% from top 5). The centrality score is calculated as the inverse of average distance to other unvisited nodes, favoring nodes that are more central in the graph.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise it combines nearest-neighbor selection with adaptive stochasticity based on node centrality, favoring nodes that are both close and more central in the graph to balance proximity and potential for better routes.",
          "code": "import random\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    # Calculate centrality score for each node (inverse of average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        avg_distance = np.mean([distance_matrix[node][other] for other in unvisited_nodes if other != node])\n        centrality[node] = 1.0 / (avg_distance + 1e-6)  # Avoid division by zero\n\n    # Get nearest neighbors sorted by distance\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Combine distance and centrality to score nodes\n    scored_nodes = []\n    for node in nearest_neighbors:\n        distance_score = 1.0 / (distance_matrix[current_node][node] + 1e-6)\n        total_score = 0.7 * distance_score + 0.3 * centrality[node]\n        scored_nodes.append((node, total_score))\n\n    # Sort by combined score\n    scored_nodes.sort(key=lambda x: x[1], reverse=True)\n\n    # Adaptive stochasticity: higher probability for top nodes, but still some randomness\n    if random.random() < 0.7:  # 70% chance to pick from top 2 nodes\n        candidates = [node for node, _ in scored_nodes[:min(2, len(scored_nodes))]]\n        next_node = random.choice(candidates)\n    else:  # 30% chance to pick from top 5 nodes\n        candidates = [node for node, _ in scored_nodes[:min(5, len(scored_nodes))]]\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 11.06655,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between prioritizing the nearest unvisited nodes (via a stochastic nearest-neighbor approach with exponential decay weights) and occasionally exploring random nodes (controlled by a temperature parameter that decreases as nodes are visited). It also includes a probabilistic bias toward the destination node early in the search, with a probability that decays as more nodes are visited. The nearest neighbors are further refined by either selecting from the top 3 nearest or using weighted random selection based on proximity.",
          "thought": "The new algorithm combines the dynamic probability of selecting the destination node from No.1 with the stochastic nearest neighbor approach of No.2, while introducing a time-decaying exploration component that prioritizes the nearest nodes but allows occasional random selection to diversify the search.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    if destination_node in unvisited_nodes:\n        prob_destination = max(0.1, 0.9 * (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))))\n        if random.random() < prob_destination:\n            return destination_node\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    temperature = len(unvisited_nodes) / len(distance_matrix)\n    if random.random() < temperature:\n        weights = [math.exp(-i * 0.5) for i in range(len(nearest_neighbors))]\n        next_node = random.choices(nearest_neighbors, weights=weights, k=1)[0]\n    else:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 11.55381,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by favoring the nearest 3 neighbors 80% of the time, while occasionally (20%) selecting a node with lower average distance to remaining unvisited nodes to balance exploration. The destination node is always prioritized if unvisited. The code efficiently combines deterministic nearest-neighbor selection with stochastic exploration to optimize path efficiency.",
          "thought": "The new algorithm combines the destination priority of No.1 with a stochastic nearest neighbor approach of No.2, balancing immediate proximity with occasional random exploration to improve path efficiency.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    if random.random() < 0.8:  # 80% chance to pick from top 3 nearest\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        next_node = random.choice(candidates)\n    else:  # 20% chance to pick a node with lower average distance to others\n        candidates = nearest_neighbors[:min(5, len(nearest_neighbors))]\n        next_node = min(candidates, key=lambda node: sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0)\n\n    return next_node",
          "objective": 12.45256,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node if unvisited, otherwise it employs a stochastic nearest neighbor approach. It primarily chooses from the three nearest unvisited nodes but occasionally selects a random node to diversify the search. This balances exploitation of proximity with exploration of potentially better, less obvious routes.\n",
          "thought": "This algorithm uses a nearest neighbor approach with a stochastic element, favoring closer nodes but occasionally selecting a more distant one to potentially escape local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    \n    # Introduce stochasticity:  sometimes pick a node that's not the absolute nearest\n    if random.random() < 0.9: # 90% chance to pick from top 3 nearest\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        next_node = random.choice(candidates)\n    else: # 10% chance to pick a random node\n        next_node = random.choice(nearest_neighbors)\n    \n    return next_node",
          "objective": 12.53987,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited; otherwise, it selects the nearest neighbor with a 70% chance and a random neighbor with 30% chance to balance exploitation (favoring the closest node) and exploration (allowing some randomness). The `current_node`, `destination_node`, and `unvisited_nodes` are key inputs, while the `distance_matrix` determines proximity. The code structure ensures the destination is always chosen first if still unvisited, otherwise, it uses a probabilistic rule for neighbor selection.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects from the nearest neighbors with a higher probability of choosing the absolute nearest node (70% chance) and a lower probability of random selection (30%) to increase exploitation of local optima while maintaining some exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    if random.random() < 0.7:  # 70% chance to pick the absolute nearest\n        next_node = nearest_neighbors[0]\n    else:  # 30% chance to pick a random node\n        next_node = random.choice(nearest_neighbors)\n\n    return next_node",
          "objective": 12.71066,
          "other_inf": null
     }
]