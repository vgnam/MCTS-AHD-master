[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm attempts to go directly to the destination node if possible; otherwise, it selects the next node based on a combination of distance and pheromone-inspired desirability. A probabilistic component introduces exploration, balancing exploitation of known good paths with the discovery of potentially better ones. The algorithm prioritizes exploitation (using `q0`) with a probability of 0.9, and exploration with a probability of 0.1.\n",
          "thought": "This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # {This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.}\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    \n    pheromone_levels = {node: 1.0 for node in unvisited_nodes} \n\n    def desirability(node):\n        alpha = 1.0  \n        beta = 2.0   \n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in unvisited_nodes}\n    \n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in unvisited_nodes}\n    \n    # Exploration vs Exploitation\n    q = random.random()\n    q0 = 0.9  \n    \n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        # Probabilistic selection\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(unvisited_nodes)) \n\n    return next_node",
          "objective": 7.80112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by balancing immediate proximity (distance from current node) with global connectivity (average distance to other unvisited nodes), minimizing their sum to ensure a trade-off between short-term and long-term path efficiency. The destination node has the highest priority, followed by nodes that minimize the combined score of current distance and average distance to others.",
          "thought": "The new algorithm first checks if the destination node is unvisited, prioritizing it if possible. For the remaining nodes, it selects the one that minimizes the sum of distances to the current node and the average distance to all other unvisited nodes, balancing immediate proximity with global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        score = current_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach that balances immediate distance from the current node with potential future efficiency by considering the nearest unvisited node and the average distance to all other unvisited nodes, combining these metrics to select the next node with the lowest total score. The function uses the `distance_matrix` to compute distances, with `current_distance` given the highest priority, followed by `nearest_distance`, and `avg_distance` given the lowest priority in the scoring mechanism.",
          "thought": "This algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach combining nearest neighbor selection with a greedy optimization that considers both immediate distance and potential future path efficiency by evaluating the sum of distances to the nearest unvisited nodes and the average distance to all other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n\n        # Find the nearest unvisited node from this candidate\n        nearest_unvisited = min(unvisited_nodes, key=lambda n: distance_matrix[node][n] if n != node else float('inf'))\n        nearest_distance = distance_matrix[node][nearest_unvisited] if nearest_unvisited != node else 0\n\n        # Average distance to all other unvisited nodes\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        # Combine metrics for a balanced score\n        score = current_distance + nearest_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 10.1896,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node if unvisited, otherwise it employs a stochastic nearest neighbor approach. It primarily chooses from the three nearest unvisited nodes but occasionally selects a random node to diversify the search. This balances exploitation of proximity with exploration of potentially better, less obvious routes.\n",
          "thought": "This algorithm uses a nearest neighbor approach with a stochastic element, favoring closer nodes but occasionally selecting a more distant one to potentially escape local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    \n    # Introduce stochasticity:  sometimes pick a node that's not the absolute nearest\n    if random.random() < 0.9: # 90% chance to pick from top 3 nearest\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        next_node = random.choice(candidates)\n    else: # 10% chance to pick a random node\n        next_node = random.choice(nearest_neighbors)\n    \n    return next_node",
          "objective": 12.53987,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if it's unvisited. Otherwise, it primarily selects the nearest neighbor, but with a probability of 0.3, it explores one of the next 5 nearest neighbors to potentially escape local optima. If there are no neighbors available, the algorithm defaults back to the nearest neighbor.\n",
          "thought": "The new algorithm prioritizes the destination if unvisited, otherwise combines deterministic selection of the nearest neighbor with infrequent, focused exploration of nodes beyond the immediate vicinity based on a different probability distribution.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    \n    # Introduce stochasticity:  sometimes pick a node that's not the absolute nearest\n    if random.random() < 0.9: # 90% chance to pick from top 3 nearest\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        next_node = random.choice(candidates)\n    else: # 10% chance to pick a random node\n        next_node = random.choice(nearest_neighbors)\n    \n    return next_node\n\n#{The new algorithm prioritizes the destination if unvisited, otherwise combines deterministic selection of the nearest neighbor with infrequent, focused exploration of nodes beyond the immediate vicinity based on a different probability distribution.}\ndef select_next_node_new(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    \n    if random.random() < 0.7: # 70% chance to pick the absolute nearest\n        next_node = nearest_neighbors[0]\n    else: # 30% chance to pick from the next 5 nearest\n        candidates = nearest_neighbors[1:min(6, len(nearest_neighbors))]\n        if candidates:\n            next_node = random.choice(candidates)\n        else:\n            next_node = nearest_neighbors[0]\n    \n    return next_node",
          "objective": 12.91157,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes visiting the destination node if unvisited; otherwise, it selects the next node stochastically from the nearest neighbors. The selection probability is weighted by a score that combines the immediate distance to the neighbor and its average distance to other unvisited nodes, favoring nodes with lower combined distances. If all scores become zero, then the algorithm returns None.\n",
          "thought": "Similar to No.2, the algorithm prioritizes the destination; otherwise, it stochastically selects from the nearest neighbors, weighting the selection probability by a score combining immediate distance and average distance to unvisited nodes, inspired by Algorithm No.1.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    \n    # Calculate scores based on distance and connectivity\n    scores = []\n    for node in nearest_neighbors:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        score = current_distance + avg_distance\n        scores.append(score)\n    \n    # Convert scores to probabilities using inverse proportionality\n    if scores:\n        inverse_scores = [1 / (score + 1e-9) for score in scores]  # Add a small value to avoid division by zero\n        total_inverse_score = sum(inverse_scores)\n        probabilities = [score / total_inverse_score for score in inverse_scores]\n\n        # Stochastic selection based on probabilities\n        next_node = random.choices(nearest_neighbors, weights=probabilities, k=1)[0]\n    else:\n        next_node = None\n    \n    return next_node",
          "objective": 24.19653,
          "other_inf": null
     }
]