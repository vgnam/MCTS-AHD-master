[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination prioritization** with a **probabilistic selection** from the top 3 nearest neighbors, where the best candidate is chosen with **95% probability** (prioritizing pheromone and distance with \u03b1=1.0 and \u03b2=2.0, respectively), and a **random candidate** is selected with **5% probability** to avoid local optima. The **destination node is always prioritized** if still unvisited, while the **distance matrix** and **pheromone levels** (initially uniform) influence the probabilistic selection.",
          "thought": "The new algorithm will combine the prioritization of the destination node from No.2 with a probabilistic selection from the top 3 nearest neighbors based on desirability (\u03b1=1.0 for pheromone, \u03b2=2.0 for distance) as in No.1, but with a 95% probability to exploit the best candidate and 5% to explore randomly among the top 3.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.95:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.09496,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines destination prioritization with stochastic nearest-neighbor selection, using a pheromone-inspired desirability metric (higher weight on pheromone levels) to guide choices among the top 3 nearest neighbors, while occasionally exploring less obvious routes via random selection. The desirability function prioritizes nodes with higher pheromone levels (\u03b1=1.0) and shorter distances (\u03b2=2.0), with a 90% chance of selecting the highest-probability candidate (q0=0.9) and a 10% chance of random exploration.",
          "thought": "The new algorithm combines the destination prioritization of No.1 with the stochastic nearest-neighbor approach of No.2, but introduces pheromone-inspired desirability to guide selection among the top nearest neighbors, while still allowing occasional exploration of less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.11573,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **90% nearest-neighbor heuristic** (exploitation) with a **pheromone-inspired desirability-based selection** (exploration), where **distance** is prioritized more (\u03b2=2.0) than **pheromone levels** (\u03b1=1.0). It first checks if the destination node is unvisited, otherwise selects from the top 3 nearest neighbors, computes weighted probabilities, and chooses deterministically (90%) or probabilistically (10%) to balance exploration and exploitation.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest-neighbor approach, where it primarily selects from the top 3 nearest neighbors (90% chance) but also considers pheromone-inspired desirability (weighted by distance) to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n    alpha = 1.0\n    beta = 2.0\n\n    def desirability(node):\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.18019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes exploitation by favoring the most desirable node (based on pheromone and distance) with a 90% chance, while allowing exploration with a 10% chance to select from the top 3 nearest neighbors. Pheromone levels (uniformly initialized) and distance are weighted by parameters `alpha` (1.0) and `beta` (2.0), respectively, giving higher priority to distance than pheromone. The selection process involves sorting unvisited nodes by distance, computing desirability scores, and using a probabilistic approach to balance exploitation and exploration.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a stochastic nearest-neighbor approach from No.1, using desirability scores based on distance and pheromone levels (uniformly initialized) to balance exploitation and exploration, with a 90% chance of selecting the most desirable node among the top 3 nearest neighbors and a 10% chance of exploring alternatives.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.19874,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it combines a nearest-neighbor approach with probabilistic selection: it considers the top 3 nearest unvisited nodes, calculates their desirability (inverse squared distance), and selects the most desirable node 90% of the time, while exploring other candidates 10% of the time via weighted random selection. This balances exploitation (favoring closer nodes) and exploration (randomness) to guide the path toward the destination while maintaining diversity.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest-neighbor approach, using desirability based on distance and probabilistic selection to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node] ** 2.0)\n\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.19894,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise it balances exploitation (selecting the nearest neighbors) and exploration (probabilistically choosing nodes based on pheromone-inspired desirability, weighted by distance). It uses a stochastic nearest-neighbor approach with a 90% chance of selecting the most desirable node (based on desirability = pheromone^\u03b1 / distance^\u03b2) and a 10% chance of exploring alternatives, where \u03b1 (1.0) and \u03b2 (2.0) control the influence of pheromones and distance, respectively. Pheromone levels are uniform (1.0) initially, and the top 3 nearest neighbors are considered as candidates.",
          "thought": "The new algorithm will prioritize the destination node if unvisited, otherwise it will combine the stochastic nearest neighbor approach with a probabilistic selection based on distance and pheromone-inspired desirability, balancing exploitation of proximity with exploration of potentially better routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.2208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the nearest unvisited node (90% chance) while occasionally exploring a randomly chosen node from the top 3 nearest neighbors (10% chance). It ensures the destination node is always selected if unvisited, balances exploitation (proximity) and exploration (randomness), and uses a distance matrix to evaluate node distances. The key design choices are the 90-10 split, the top-3 candidate selection, and the conditional handling of the destination node.",
          "thought": "The new algorithm combines the exploitation of the No.1 algorithm by prioritizing the most desirable node (based on distance) with a 90% chance, while allowing exploration with a 10% chance to select from the top 3 nearest neighbors, similar to No.2. It balances proximity and randomness to find better solutions.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    if random.random() < 0.9:\n        next_node = min(candidates, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.383,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node probabilistically: 90% of the time it chooses from the top 3 nearest unvisited nodes weighted by inverse squared distance (higher desirability for closer nodes), and 10% of the time it explores randomly among these candidates. The destination node is always prioritized, and the selection balances exploitation (focusing on nearby nodes) with exploration (random selection).",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a probabilistic selection inspired by No.1's desirability-based approach, using a 90% chance to choose from the top 3 nearest nodes weighted by distance, and a 10% chance for exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node]**2)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.39859,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest nodes (\u03b2=2.0) with 90% probability, selecting the most desirable node based on inverse distance weighting, while allowing random selection from the top 3 nearest nodes with 10% probability to introduce diversity. The desirability function (\u03b1=1.0) emphasizes closeness, while the probabilistic choice balances exploitation (90%) and exploration (10%). The destination node is always prioritized if unvisited.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the weighted desirability selection of No.1, favoring closer nodes (\u03b2=2.0) with 90% probability and allowing random selection from top 3 with 10% probability.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (1.0**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.4028,
          "other_inf": null
     }
]