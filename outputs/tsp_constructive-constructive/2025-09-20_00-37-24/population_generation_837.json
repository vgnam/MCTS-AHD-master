[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination prioritization** with a **probabilistic selection** from the top 3 nearest neighbors, where the best candidate is chosen with **95% probability** (prioritizing pheromone and distance with \u03b1=1.0 and \u03b2=2.0, respectively), and a **random candidate** is selected with **5% probability** to avoid local optima. The **destination node is always prioritized** if still unvisited, while the **distance matrix** and **pheromone levels** (initially uniform) influence the probabilistic selection.",
          "thought": "The new algorithm will combine the prioritization of the destination node from No.2 with a probabilistic selection from the top 3 nearest neighbors based on desirability (\u03b1=1.0 for pheromone, \u03b2=2.0 for distance) as in No.1, but with a 95% probability to exploit the best candidate and 5% to explore randomly among the top 3.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.95:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.09496,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines destination prioritization with stochastic nearest-neighbor selection, using a pheromone-inspired desirability metric (higher weight on pheromone levels) to guide choices among the top 3 nearest neighbors, while occasionally exploring less obvious routes via random selection. The desirability function prioritizes nodes with higher pheromone levels (\u03b1=1.0) and shorter distances (\u03b2=2.0), with a 90% chance of selecting the highest-probability candidate (q0=0.9) and a 10% chance of random exploration.",
          "thought": "The new algorithm combines the destination prioritization of No.1 with the stochastic nearest-neighbor approach of No.2, but introduces pheromone-inspired desirability to guide selection among the top nearest neighbors, while still allowing occasional exploration of less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.11573,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node either deterministically (90% chance) or probabilistically (10% chance) from the top 3 nearest neighbors, with desirability weighted by pheromone levels (alpha=1.0) and inversely by distance (beta=2.0), giving distance a higher priority than pheromone. The probabilistic selection uses roulette wheel sampling based on normalized desirability scores.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the probabilistic desirability-based selection of No.1, where it first checks if the destination is unvisited, then selects among the top 3 nearest neighbors with a 90% chance, and otherwise probabilistically chooses based on desirability weighted by pheromone and distance.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.1278,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the next node with a 90% chance from the top 3 nearest neighbors weighted by desirability (pheromone and distance), and a 10% chance to explore less obvious routes. Desirability is calculated as (pheromone^1.0)/(distance^2.0), giving higher priority to closer nodes with higher pheromone levels.",
          "thought": "The new algorithm combines the exploitation of nearest neighbors from No.2 with the probabilistic selection based on desirability (pheromone and distance) from No.1, while prioritizing the destination node if unvisited. It uses a 90% chance to select from the top 3 nearest neighbors, weighted by desirability, and a 10% chance to explore less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(nearest_neighbors)\n\n    return next_node",
          "objective": 7.17176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (90% chance) with random exploration (10%) among the top 3 nearest unvisited nodes, prioritizing nodes with higher desirability (inversely proportional to distance) while maintaining exploration through probabilistic selection. The `beta` parameter (set to 2.0) sharpens the desirability weighting, favoring closer nodes, while the 90-10 split balances exploitation and exploration.",
          "thought": "The new algorithm combines the probabilistic selection of No.1 with the nearest neighbor exploration of No.2, using a 90% chance to pick the highest desirability node (weighted by distance) from the top 3 nearest neighbors and a 10% chance to explore randomly among the top 3.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        beta = 2.0\n        return 1.0 / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.17733,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **90% nearest-neighbor heuristic** (exploitation) with a **pheromone-inspired desirability-based selection** (exploration), where **distance** is prioritized more (\u03b2=2.0) than **pheromone levels** (\u03b1=1.0). It first checks if the destination node is unvisited, otherwise selects from the top 3 nearest neighbors, computes weighted probabilities, and chooses deterministically (90%) or probabilistically (10%) to balance exploration and exploitation.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest-neighbor approach, where it primarily selects from the top 3 nearest neighbors (90% chance) but also considers pheromone-inspired desirability (weighted by distance) to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n    alpha = 1.0\n    beta = 2.0\n\n    def desirability(node):\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.18019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes exploitation by favoring the most desirable node (based on pheromone and distance) with a 90% chance, while allowing exploration with a 10% chance to select from the top 3 nearest neighbors. Pheromone levels (uniformly initialized) and distance are weighted by parameters `alpha` (1.0) and `beta` (2.0), respectively, giving higher priority to distance than pheromone. The selection process involves sorting unvisited nodes by distance, computing desirability scores, and using a probabilistic approach to balance exploitation and exploration.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a stochastic nearest-neighbor approach from No.1, using desirability scores based on distance and pheromone levels (uniformly initialized) to balance exploitation and exploration, with a 90% chance of selecting the most desirable node among the top 3 nearest neighbors and a 10% chance of exploring alternatives.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.19874,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it combines a nearest-neighbor approach with probabilistic selection: it considers the top 3 nearest unvisited nodes, calculates their desirability (inverse squared distance), and selects the most desirable node 90% of the time, while exploring other candidates 10% of the time via weighted random selection. This balances exploitation (favoring closer nodes) and exploration (randomness) to guide the path toward the destination while maintaining diversity.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest-neighbor approach, using desirability based on distance and probabilistic selection to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node] ** 2.0)\n\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.19894,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **nearest-neighbor approach** with **probabilistic selection**, prioritizing the most desirable node (based on distance and pheromone influence) with a **90% chance** (using `q0 = 0.9`). If this condition fails, it explores the **top 3 nearest neighbors** with a **10% chance**, using weighted probabilities where distance (`distance_matrix`) has a higher priority (`beta = 1.5`) than pheromone levels (`alpha = 0.5`). The desirability function ensures closer nodes are favored, while pheromone influence (initially uniform) can be adjusted for future enhancements.",
          "thought": "The new algorithm combines the probabilistic selection of No.1 with the nearest neighbor approach of No.2, favoring the most desirable node (based on distance and a small pheromone influence) with a 90% chance, while allowing exploration with a 10% chance to select from the top 3 nearest neighbors.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        alpha = 0.5\n        beta = 1.5\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.21962,
          "other_inf": null
     }
]