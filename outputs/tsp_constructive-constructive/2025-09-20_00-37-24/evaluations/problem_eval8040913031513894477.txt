import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    if destination_node in unvisited_nodes:
        return destination_node

    # Calculate dynamic stochasticity factor based on destination proximity
    dest_distance = distance_matrix[current_node][destination_node]
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    stochasticity_factor = min(0.9, max(0.1, 0.5 + (avg_distance - dest_distance) / (avg_distance + 1e-6)))

    # Weight nodes by a combination of distance and destination alignment
    weighted_nodes = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        dest_alignment = 1.0 / (1.0 + distance_matrix[node][destination_node])
        weight = (1 - stochasticity_factor) * (1 / (1 + distance)) + stochasticity_factor * dest_alignment
        weighted_nodes.append((node, weight))

    # Select node based on weighted probabilities
    nodes, weights = zip(*weighted_nodes)
    next_node = random.choices(nodes, weights=weights, k=1)[0]

    return next_node
