import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node

    if not unvisited_nodes:
        return None

    # Calculate temperature-based bias (increases as fewer nodes remain)
    remaining_nodes = len(unvisited_nodes)
    temperature = max(0.1, 1.0 / remaining_nodes)

    # Evaluate potential candidates
    candidates = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Combine distance with destination bias
        if node == destination_node:
            score = 0  # Always prioritize destination if available
        else:
            # Score combines distance and potential path length
            dist_to_dest = distance_matrix[node][destination_node] if destination_node in unvisited_nodes else 0
            score = distance + temperature * dist_to_dest
        candidates.append((node, score))

    # Select based on temperature
    if random.random() < temperature:
        # Exploration phase: pick based on potential
        candidates.sort(key=lambda x: x[1])
        selected = candidates[0][0] if candidates else None
    else:
        # Exploitation phase: pick nearest neighbor
        selected = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    return next_node
