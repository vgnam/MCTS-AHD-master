import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate weights: inverse distance and novelty factor
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    novelty = [1.0 / (1 + np.log(len(unvisited_nodes) - i)) for i in range(len(unvisited_nodes))]  # Higher novelty for less visited nodes

    # Combine weights (distance preference with novelty)
    weights = [1.0 / (d + 1e-6) * n for d, n in zip(distances, novelty)]

    # Normalize weights
    total_weight = sum(weights)
    probabilities = [w / total_weight for w in weights]

    # 90% chance to pick from top 3 weighted nodes, 10% chance to pick randomly
    if random.random() < 0.9:
        sorted_indices = np.argsort(probabilities)[::-1]  # Descending order
        top_candidates = [unvisited_nodes[i] for i in sorted_indices[:min(3, len(unvisited_nodes))]]
        next_node = random.choices(top_candidates, weights=probabilities[:min(3, len(unvisited_nodes))])[0]
    else:
        next_node = random.choices(unvisited_nodes, weights=probabilities)[0]

    return next_node
