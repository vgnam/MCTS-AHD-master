def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate potential gain for each unvisited node
    potential_gains = []
    for node in unvisited_nodes:
        # Gain is inversely proportional to distance (higher gain for closer nodes)
        # and proportional to the number of remaining unvisited nodes (more exploration when few nodes left)
        gain = (1 / distance_matrix[current_node][node]) * (len(unvisited_nodes) ** 0.5)
        potential_gains.append((node, gain))

    # Sort nodes by potential gain
    potential_gains.sort(key=lambda x: -x[1])
    top_candidates = [node for node, gain in potential_gains[:min(3, len(potential_gains))]]

    # Probabilistic selection: higher chance to pick from top candidates
    if random.random() < 0.8:  # 80% chance to pick from top candidates
        next_node = random.choice(top_candidates)
    else:  # 20% chance to pick from all unvisited nodes with probability proportional to gain
        nodes, gains = zip(*potential_gains)
        next_node = random.choices(nodes, weights=gains, k=1)[0]

    return next_node
