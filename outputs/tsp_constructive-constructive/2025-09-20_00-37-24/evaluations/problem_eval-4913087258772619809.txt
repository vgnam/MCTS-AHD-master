import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate nearest neighbors with dynamic weights
    nearest_neighbors = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Weight by inverse distance and a historical factor (simulated here as random)
        weight = (1 / (distance + 1e-6)) * (1 + random.random() * 0.5)  # Add stochasticity
        nearest_neighbors.append((node, weight))

    # Sort by weight in descending order
    nearest_neighbors.sort(key=lambda x: -x[1])

    # Select with probability based on rank
    total_weight = sum(w for _, w in nearest_neighbors)
    probabilities = [w / total_weight for _, w in nearest_neighbors]

    # Introduce stochasticity: 70% chance to pick from top 3, 20% chance to pick from next 3, 10% random
    rand_val = random.random()
    if rand_val < 0.7:
        candidates = [node for node, _ in nearest_neighbors[:min(3, len(nearest_neighbors))]]
    elif rand_val < 0.9:
        candidates = [node for node, _ in nearest_neighbors[min(3, len(nearest_neighbors)):min(6, len(nearest_neighbors))]]
    else:
        candidates = [node for node, _ in nearest_neighbors]

    next_node = random.choice(candidates)
    return next_node
