import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Temperature parameter (can be adjusted or made dynamic)
    temperature = 0.3

    # Calculate probabilities based on inverse distance and temperature
    distances = [distance_matrix[current_node][node] for node in nearest_neighbors]
    min_dist = min(distances)
    max_dist = max(distances)

    # Normalize distances to [0, 1] range
    normalized_distances = [(max_dist - d) / (max_dist - min_dist) for d in distances]

    # Apply softmax with temperature
    exp_probs = [math.exp(normalized_dist / temperature) for normalized_dist in normalized_distances]
    total_exp = sum(exp_probs)
    probabilities = [exp_prob / total_exp for exp_prob in exp_probs]

    # 90% chance to pick from top 3 with softmax probabilities, 10% random
    if random.random() < 0.9:
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]
        probs = probabilities[:min(3, len(probabilities))]
        next_node = random.choices(candidates, weights=probs, k=1)[0]
    else:
        next_node = random.choice(nearest_neighbors)

    return next_node
