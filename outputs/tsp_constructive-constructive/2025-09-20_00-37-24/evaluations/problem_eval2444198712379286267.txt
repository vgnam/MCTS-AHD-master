import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate a score for each unvisited node: distance + heuristic for path reduction
    node_scores = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Heuristic: prefer nodes that are closer to the destination (if known)
        if destination_node is not None and destination_node in unvisited_nodes:
            heuristic = distance_matrix[node][destination_node]
        else:
            heuristic = 0
        # Combine distance and heuristic (weighted sum)
        score = distance + 0.5 * heuristic
        node_scores.append((node, score))

    # Sort nodes by score (lower is better)
    node_scores.sort(key=lambda x: x[1])
    sorted_nodes = [node for node, score in node_scores]

    # Introduce stochasticity: 80% chance to pick from top 20% of nodes, 20% chance to pick randomly
    if random.random() < 0.8:
        top_k = max(1, len(sorted_nodes) // 5)  # Top 20% or at least 1
        candidates = sorted_nodes[:top_k]
        next_node = random.choice(candidates)
    else:
        next_node = random.choice(sorted_nodes)

    return next_node
