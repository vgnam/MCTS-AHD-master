import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate centrality scores (lower average distance = more central)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = np.mean([distance_matrix[node][other] for other in unvisited_nodes])

    # Normalize centrality scores to [0, 1]
    min_centrality = min(centrality.values())
    max_centrality = max(centrality.values())
    if max_centrality - min_centrality > 0:
        normalized_centrality = {node: (centrality[node] - min_centrality) / (max_centrality - min_centrality)
                               for node in unvisited_nodes}
    else:
        normalized_centrality = {node: 0.5 for node in unvisited_nodes}  # Default if all equal

    # Calculate combined scores: 70% distance, 30% centrality
    combined_scores = {}
    for node in unvisited_nodes:
        distance_score = distance_matrix[current_node][node]
        if max(distance_matrix[current_node].values()) > 0:
            distance_score = 1 - (distance_score / max(distance_matrix[current_node].values()))
        combined_scores[node] = 0.7 * distance_score + 0.3 * (1 - normalized_centrality[node])

    # Select based on probability distribution
    probabilities = np.array([combined_scores[node] for node in unvisited_nodes])
    probabilities = probabilities / np.sum(probabilities)  # Normalize to sum to 1
    next_node = np.random.choice(unvisited_nodes, p=probabilities)

    return next_node
