import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate inverse distances and weights
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    inv_distances = [1.0 / d if d > 0 else 1.0 for d in distances]  # Avoid division by zero

    # Assign weights: prioritize less frequently visited nodes
    visit_counts = {node: 0 for node in unvisited_nodes}
    for node in unvisited_nodes:
        visit_counts[node] = random.random()  # Simulate frequency (higher = more frequent)

    weights = []
    for i, node in enumerate(unvisited_nodes):
        # Weight combines inverse distance and inverse frequency
        weight = inv_distances[i] * (1.0 / (1.0 + visit_counts[node]))
        weights.append(weight)

    # Normalize weights
    total_weight = sum(weights)
    if total_weight > 0:
        normalized_weights = [w / total_weight for w in weights]
    else:
        normalized_weights = [1.0 / len(unvisited_nodes)] * len(unvisited_nodes)

    # Select node based on weighted probabilities
    next_node = random.choices(unvisited_nodes, weights=normalized_weights, k=1)[0]

    return next_node
