import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate destination bias: stronger when closer to destination
    if destination_node in unvisited_nodes:
        dest_dist = distance_matrix[current_node][destination_node]
        max_dist = max(distance_matrix[current_node][node] for node in unvisited_nodes)
        bias_prob = 0.5 + 0.4 * (1 - dest_dist/max_dist) if max_dist > 0 else 0.5
        if random.random() < bias_prob:
            return destination_node

    # Calculate adaptive neighborhood size based on local distance variance
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    mean_dist = np.mean(distances)
    std_dev = np.std(distances) if len(distances) > 1 else 1.0
    neighborhood_size = max(1, min(5, int(3 + 2 * (std_dev / mean_dist)))) if mean_dist > 0 else 3

    # Select from adaptive neighborhood with stochasticity
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    candidates = nearest_neighbors[:min(neighborhood_size, len(nearest_neighbors))]

    if random.random() < 0.8:  # 80% chance to pick from candidates
        next_node = random.choice(candidates)
    else:  # 20% chance to pick from slightly farther nodes
        farther_nodes = nearest_neighbors[neighborhood_size:min(2*neighborhood_size, len(nearest_neighbors))]
        if farther_nodes:
            next_node = random.choice(farther_nodes)
        else:
            next_node = random.choice(candidates)

    return next_node
