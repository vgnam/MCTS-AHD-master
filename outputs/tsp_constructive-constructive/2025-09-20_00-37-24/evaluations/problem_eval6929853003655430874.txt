import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, visitation_counts=None):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    if visitation_counts is None:
        visitation_counts = {node: 1 for node in unvisited_nodes}

    # Calculate adaptive selection probabilities
    distances = np.array([distance_matrix[current_node][node] for node in unvisited_nodes])
    frequencies = np.array([visitation_counts[node] for node in unvisited_nodes])

    # Normalize to create probability weights
    distance_weights = 1 / (1 + distances)  # Inverse distance weighting
    frequency_weights = 1 / (1 + frequencies)  # Inverse frequency weighting
    combined_weights = distance_weights * frequency_weights

    # Normalize weights to probabilities
    probabilities = combined_weights / combined_weights.sum()

    # Select based on adaptive probabilities
    if random.random() < 0.9:  # 90% chance to pick from top 3 weighted
        top_indices = np.argsort(probabilities)[-3:][::-1]
        selected_index = random.choices(top_indices, weights=probabilities[top_indices])[0]
    else:  # 10% chance to pick a random node
        selected_index = random.choices(range(len(unvisited_nodes)), weights=probabilities)[0]

    next_node = unvisited_nodes[selected_index]
    return next_node
