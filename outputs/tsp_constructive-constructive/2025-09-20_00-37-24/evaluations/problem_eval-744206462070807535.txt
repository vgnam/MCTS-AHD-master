import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, temperature=1.0, cooling_rate=0.99):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Dynamic probability based on temperature
    exploitation_prob = max(0.1, 0.9 * (temperature ** 2))
    if random.random() < exploitation_prob:
        # Penalize nodes that would create short cycles
        candidates = []
        for node in nearest_neighbors[:min(3, len(nearest_neighbors))]:
            penalty = 0
            if len(nearest_neighbors) > 1 and node in nearest_neighbors[1:]:
                penalty = distance_matrix[current_node][node] * 0.1
            candidates.append((node, distance_matrix[current_node][node] + penalty))
        candidates.sort(key=lambda x: x[1])
        next_node = candidates[0][0]
    else:
        next_node = random.choice(nearest_neighbors)

    # Cool the temperature
    temperature *= cooling_rate

    return next_node
