import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate proximity scores: combination of distance to current node and distance to destination
    proximity_scores = []
    for node in unvisited_nodes:
        dist_to_current = distance_matrix[current_node][node]
        dist_to_dest = distance_matrix[node][destination_node]
        # Weighted score: prioritize nodes closer to destination but still consider local proximity
        score = 0.7 * dist_to_dest + 0.3 * dist_to_current
        proximity_scores.append((node, score))

    # Sort by score (lower is better)
    sorted_nodes = sorted(proximity_scores, key=lambda x: x[1])

    # Probabilistic selection: higher probability for nodes with lower scores
    candidates = [node for node, _ in sorted_nodes[:min(5, len(sorted_nodes))]]
    if random.random() < 0.8:  # 80% chance to pick from top candidates
        next_node = random.choice(candidates)
    else:  # 20% chance to pick a random node from remaining
        remaining = [node for node in unvisited_nodes if node not in candidates]
        if remaining:
            next_node = random.choice(remaining)
        else:
            next_node = random.choice(candidates)

    return next_node
