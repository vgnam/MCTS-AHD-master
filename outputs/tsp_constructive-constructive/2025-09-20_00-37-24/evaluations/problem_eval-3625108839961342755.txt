import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate potential scores for each unvisited node
    potential_scores = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Node degree approximation (number of nearby nodes)
        node_degree = sum(1 for neighbor in unvisited_nodes if distance_matrix[node][neighbor] < distance * 1.5)
        # Weighted score combining distance and local connectivity
        score = -distance + 0.3 * node_degree  # Negative distance to minimize it
        potential_scores.append((node, score))

    # Sort by potential score (descending)
    potential_scores.sort(key=lambda x: x[1], reverse=True)

    # Selection strategy: prioritize top 3 by score, but with probability based on rank
    if random.random() < 0.8:  # 80% chance to pick from top candidates
        top_nodes = [node for node, _ in potential_scores[:min(3, len(potential_scores))]]
        # Probability proportional to rank (higher rank = higher chance)
        weights = [1.0 / (i + 1) for i in range(len(top_nodes))]
        next_node = random.choices(top_nodes, weights=weights, k=1)[0]
    else:  # 20% chance to pick from all unvisited nodes with inverse distance bias
        all_nodes = [node for node, _ in potential_scores]
        weights = [1.0 / (distance_matrix[current_node][node] + 1) for node in all_nodes]
        next_node = random.choices(all_nodes, weights=weights, k=1)[0]

    return next_node
