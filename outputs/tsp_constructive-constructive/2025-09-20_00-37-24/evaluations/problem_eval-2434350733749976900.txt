import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Calculate adaptive stochasticity based on node density
    num_neighbors = len(nearest_neighbors)
    density_factor = min(1.0, num_neighbors / 10)  # Normalize to a small range

    # Historical performance: favor nodes that were better choices in previous steps (simulated)
    # In a real implementation, this would track actual performance
    historical_weights = [1.0 - (i / num_neighbors) for i in range(num_neighbors)]

    # Combine factors: proximity (70%), randomness (20%), historical performance (10%)
    weights = [
        0.7 * (1.0 - (distance_matrix[current_node][node] / max(distance_matrix[current_node].values()))) +
        0.2 * density_factor +
        0.1 * historical_weights[i]
        for i, node in enumerate(nearest_neighbors)
    ]

    # Normalize weights
    total_weight = sum(weights)
    normalized_weights = [w / total_weight for w in weights]

    # Select node based on weighted random choice
    next_node = random.choices(nearest_neighbors, weights=normalized_weights, k=1)[0]

    return next_node
