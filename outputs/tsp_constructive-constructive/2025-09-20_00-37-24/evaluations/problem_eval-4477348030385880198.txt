import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate exploration probability based on remaining unvisited nodes
    exploration_prob = 0.5 * (len(unvisited_nodes) / len(distance_matrix))

    # Calculate centrality scores for unvisited nodes (simplified betweenness centrality)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(1 for n in unvisited_nodes if n != node and distance_matrix[node][n] < float('inf'))

    # Sort by distance and centrality
    distance_sorted = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    centrality_sorted = sorted(unvisited_nodes, key=lambda node: centrality[node], reverse=True)

    # Combine distance and centrality with exploration probability
    if random.random() < exploration_prob:
        # Exploitation: prioritize high centrality nodes
        candidates = centrality_sorted[:min(3, len(centrality_sorted))]
        next_node = random.choice(candidates)
    else:
        # Exploration: balance distance and randomness
        distance_weight = 0.7
        random_weight = 0.3
        weighted_scores = [
            (distance_weight * distance_matrix[current_node][node] +
             random_weight * (1 / (centrality[node] + 1)))
            for node in unvisited_nodes
        ]
        next_node = unvisited_nodes[weighted_scores.index(min(weighted_scores))]

    return next_node
