import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    if destination_node in unvisited_nodes:
        # Dynamic bias towards destination as unvisited nodes decrease
        bias_prob = 1 - (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix)))
        if random.random() < bias_prob:
            return destination_node

    # Calculate weighted nearest neighbors (inverse distance weighting)
    weights = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if distance == 0:
            weights.append(float('inf'))  # Avoid division by zero
        else:
            weights.append(1.0 / distance)

    # Select node based on weighted probability
    selected_node = random.choices(
        unvisited_nodes,
        weights=weights,
        k=1
    )[0]

    return next_node
