import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    candidates = nearest_neighbors[:min(5, len(nearest_neighbors))] #Increased candidates to 5

    #Pheromone-inspired component (initialized to 1, but could be learned)
    pheromone_levels = {node: 1.0 for node in candidates}

    def desirability(node):
        alpha = 0.8 #Adjusted alpha
        beta = 2.2 #Adjusted beta
        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)

    desirabilities = {node: desirability(node) for node in candidates}
    total_desirability = sum(desirabilities.values())

    if total_desirability == 0:
        probabilities = {node: 1/len(candidates) for node in candidates}
    else:
        probabilities = {node: desirabilities[node] / total_desirability for node in candidates}

    #Probabilistic selection based on desirability
    if random.random() < 0.97: #Increased chance of using desirability
        next_node = random.choices(list(probabilities.keys()), weights=list(probabilities.values()), k=1)[0]
    else:
        next_node = random.choice(candidates)
    
    return next_node
