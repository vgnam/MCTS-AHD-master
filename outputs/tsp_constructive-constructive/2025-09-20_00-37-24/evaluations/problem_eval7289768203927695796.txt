import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate exploration potential for each unvisited node
    exploration_potentials = []
    for node in unvisited_nodes:
        # Distance component
        dist = distance_matrix[current_node][node]
        # Exploration component: higher if more unvisited nodes are nearby
        nearby_unvisited = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < dist * 1.5)
        exploration_potential = nearby_unvisited / (dist + 1e-6)  # Avoid division by zero
        exploration_potentials.append(exploration_potential)

    # Normalize to get probabilities
    total_potential = sum(exploration_potentials)
    if total_potential == 0:
        probabilities = [1/len(unvisited_nodes)] * len(unvisited_nodes)
    else:
        probabilities = [p/total_potential for p in exploration_potentials]

    # Occasionally choose the farthest node to escape local optima
    if random.random() < 0.1:  # 10% chance
        farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
        return farthest_node

    # Select based on weighted probabilities
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]
    return next_node
