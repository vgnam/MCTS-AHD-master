import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Temperature-based stochasticity: higher temperature increases chance of picking distant nodes
    temperature = len(unvisited_nodes) / (len(distance_matrix) * 2)
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Penalty for revisiting nodes (simulated by reducing selection probability)
    revisit_penalty = 0.2 if len(unvisited_nodes) < len(distance_matrix) / 2 else 0.0

    # Dynamic selection probability
    selection_prob = min(0.9, 0.7 + temperature - revisit_penalty)

    if random.random() < selection_prob:  # Use dynamic probability
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]
        next_node = random.choice(candidates)
    else:
        # Choose a node with a bias towards medium-distance nodes
        weights = [math.exp(-d / (temperature * 10)) for d in [distance_matrix[current_node][n] for n in nearest_neighbors]]
        next_node = random.choices(nearest_neighbors, weights=weights, k=1)[0]

    return next_node
