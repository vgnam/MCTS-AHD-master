import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate distance to destination if it's unvisited
    dest_distance = distance_matrix[current_node][destination_node] if destination_node in unvisited_nodes else float('inf')

    # Dynamic bias towards destination based on remaining distance
    bias_prob = 1 / (1 + math.exp(-0.1 * (dest_distance - 5)))  # Sigmoid function

    if destination_node in unvisited_nodes and random.random() < bias_prob:
        return destination_node

    # Get nearest neighbors and their distances
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    nearest_distance = distance_matrix[current_node][nearest_neighbors[0]] if nearest_neighbors else float('inf')

    # Determine exploration threshold (adaptive based on nearest distance)
    threshold = nearest_distance * (1.5 + 0.5 * random.random())

    # Candidates within threshold
    candidates = [node for node in unvisited_nodes
                 if distance_matrix[current_node][node] <= threshold]

    if not candidates:
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]

    # Weighted random selection based on inverse distance
    weights = [1 / (1 + distance_matrix[current_node][node]) for node in candidates]
    next_node = random.choices(candidates, weights=weights, k=1)[0]

    return next_node
