import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate average distance to other unvisited nodes for each candidate
    def average_distance_to_unvisited(node):
        if not unvisited_nodes:
            return 0
        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        return np.mean(distances) if distances else float('inf')

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    candidate_nodes = nearest_neighbors[:min(5, len(nearest_neighbors))]

    # Assign probabilities based on inverse distance and average distance
    distances = [distance_matrix[current_node][n] for n in candidate_nodes]
    avg_distances = [average_distance_to_unvisited(n) for n in candidate_nodes]

    # Normalize probabilities
    total_weight = sum(1/(d + 1e-6) * (1/(avg_d + 1e-6)) for d, avg_d in zip(distances, avg_distances))
    probabilities = [(1/(d + 1e-6) * (1/(avg_d + 1e-6))) / total_weight for d, avg_d in zip(distances, avg_distances)]

    # Select node based on calculated probabilities
    next_node = random.choices(candidate_nodes, weights=probabilities, k=1)[0]
    return next_node
