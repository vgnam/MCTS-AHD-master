import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate node centrality (inverse of average distance to other nodes)
    centrality = {}
    for node in unvisited_nodes:
        avg_distance = np.mean(distance_matrix[node])
        centrality[node] = 1.0 / avg_distance if avg_distance != 0 else float('inf')

    # Normalize centrality and distance scores
    max_centrality = max(centrality.values()) if centrality else 1.0
    max_distance = max(distance_matrix[current_node][node] for node in unvisited_nodes) if unvisited_nodes else 1.0

    # Calculate weighted score (70% distance, 30% centrality)
    scores = {}
    for node in unvisited_nodes:
        distance_score = (max_distance - distance_matrix[current_node][node]) / max_distance if max_distance != 0 else 0
        centrality_score = centrality[node] / max_centrality if max_centrality != 0 else 0
        scores[node] = 0.7 * distance_score + 0.3 * centrality_score

    # Select top 3 nodes by score
    top_nodes = sorted(unvisited_nodes, key=lambda node: -scores[node])[:3]

    # Stochastic selection: 80% chance to pick from top 3, 20% chance to pick randomly
    if random.random() < 0.8:
        next_node = random.choice(top_nodes)
    else:
        next_node = random.choice(unvisited_nodes)

    return next_node
