import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate weighted scores for each unvisited node
    scores = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Base score is inverse of distance (closer nodes get higher score)
        base_score = 1.0 / (distance + 1e-10)  # Small epsilon to avoid division by zero

        # Additional score boost if node is the destination
        if node == destination_node:
            base_score *= 2.0  # Double the score for destination

        # Add randomness to avoid deterministic behavior
        random_factor = random.uniform(0.9, 1.1)
        scores.append(base_score * random_factor)

    # Select node based on weighted probability
    total_score = sum(scores)
    if total_score <= 0:
        return random.choice(unvisited_nodes)  # Fallback if all scores are zero

    probabilities = [score / total_score for score in scores]
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]

    # With 10% probability, override selection with a random node
    if random.random() < 0.1:
        next_node = random.choice(unvisited_nodes)

    return next_node
