import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate base probabilities based on distance (inverse relationship)
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    max_distance = max(distances) if distances else 1.0
    base_probs = [(max_distance / (d + 1e-6)) for d in distances]  # Avoid division by zero

    # Normalize base probabilities
    total_base = sum(base_probs)
    base_probs = [p / total_base for p in base_probs]

    # Introduce popularity factor (inverse of selection frequency)
    popularity_weights = [1.0 / (1.0 + unvisited_nodes.count(node)) for node in unvisited_nodes]

    # Combine base probabilities with popularity weights
    combined_probs = [base * pop for base, pop in zip(base_probs, popularity_weights)]
    total_combined = sum(combined_probs)
    combined_probs = [p / total_combined for p in combined_probs]

    # Select node based on combined probabilities
    next_node = random.choices(unvisited_nodes, weights=combined_probs, k=1)[0]

    # 10% chance to override with a random node to maintain exploration
    if random.random() < 0.1:
        next_node = random.choice(unvisited_nodes)

    return next_node
