import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate nearest neighbors and their distances
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    nearest_distances = [distance_matrix[current_node][node] for node in nearest_neighbors]

    # Calculate a score combining proximity and potential for long-term optimization
    def node_score(node):
        distance = distance_matrix[current_node][node]
        # Bias towards nodes that are both close and potentially part of a longer-term optimal path
        return distance * (1 + 0.2 * np.mean([distance_matrix[node][other] for other in unvisited_nodes]))

    scored_nodes = sorted(unvisited_nodes, key=node_score)
    scored_distances = [node_score(node) for node in scored_nodes]

    # 70% chance to pick from top 3 nearest, 20% from top 3 scored, 10% random
    selection_prob = random.random()
    if selection_prob < 0.7:
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]
    elif selection_prob < 0.9:
        candidates = scored_nodes[:min(3, len(scored_nodes))]
    else:
        candidates = unvisited_nodes

    next_node = random.choice(candidates)
    return next_node
