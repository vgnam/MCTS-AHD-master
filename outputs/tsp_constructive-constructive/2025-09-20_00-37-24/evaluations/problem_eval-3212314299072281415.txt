import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate centrality: nodes with more connections are more likely to be selected
    centrality = {node: sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0) for node in unvisited_nodes}

    # Calculate dynamic probabilities: inverse distance weighted by centrality
    total_weight = 0.0
    weights = {}
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if distance == 0:
            weight = 0
        else:
            weight = (centrality[node] / distance)
        weights[node] = weight
        total_weight += weight

    # Normalize weights to probabilities
    probabilities = {node: weight / total_weight for node, weight in weights.items()}

    # Introduce stochasticity: 80% chance to pick based on probability, 20% chance to pick random
    if random.random() < 0.8:
        next_node = random.choices(list(probabilities.keys()), weights=list(probabilities.values()), k=1)[0]
    else:
        next_node = random.choice(list(unvisited_nodes))

    return next_node
