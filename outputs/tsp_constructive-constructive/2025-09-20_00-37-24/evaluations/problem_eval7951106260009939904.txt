import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate a weighted score combining distance and visit frequency
    visit_counts = {node: len(unvisited_nodes) - len([n for n in unvisited_nodes if n == node]) for node in unvisited_nodes}
    temperature = max(1, len(unvisited_nodes) / 10)  # Higher temperature for more exploration

    def node_score(node):
        distance = distance_matrix[current_node][node]
        frequency = visit_counts[node] / len(unvisited_nodes)
        return distance + temperature * (1 - frequency)

    scored_nodes = [(node, node_score(node)) for node in unvisited_nodes]
    scored_nodes.sort(key=lambda x: x[1])

    # Probabilistic selection: higher probability for lower scores
    probabilities = [math.exp(-score) for _, score in scored_nodes]
    total = sum(probabilities)
    probabilities = [p / total for p in probabilities]

    next_node = random.choices([node for node, _ in scored_nodes], weights=probabilities, k=1)[0]
    return next_node
