import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate nearest neighbors and their distances
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    nearest_distance = distance_matrix[current_node][nearest_neighbors[0]] if nearest_neighbors else float('inf')

    # Calculate weighted scores: distance + inverse visit frequency (simulated)
    visit_frequency = {node: random.uniform(0.1, 1.0) for node in unvisited_nodes}  # Simulated visit frequency
    weighted_scores = {
        node: distance_matrix[current_node][node] / visit_frequency[node]
        for node in unvisited_nodes
    }

    # Determine candidates: 70% nearest neighbors, 30% weighted by distance and frequency
    if random.random() < 0.7:
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]
    else:
        candidates = sorted(unvisited_nodes, key=lambda node: weighted_scores[node])[:min(3, len(unvisited_nodes))]

    # Select next node with probability proportional to inverse score
    if candidates:
        inverse_scores = [1.0 / (weighted_scores[node] + 1e-6) for node in candidates]
        total = sum(inverse_scores)
        probabilities = [score / total for score in inverse_scores]
        next_node = random.choices(candidates, weights=probabilities, k=1)[0]
    else:
        next_node = random.choice(unvisited_nodes)

    return next_node
