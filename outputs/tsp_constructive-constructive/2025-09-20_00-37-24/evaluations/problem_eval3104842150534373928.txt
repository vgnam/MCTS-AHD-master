import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate centrality scores for unvisited nodes
    centrality_scores = {}
    for node in unvisited_nodes:
        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])
        centrality_scores[node] = 1 / (1 + avg_distance)  # Higher score for more central nodes

    # Normalize centrality scores to use as probabilities
    total_score = sum(centrality_scores.values())
    probabilities = {node: score / total_score for node, score in centrality_scores.items()}

    # Select node based on centrality probability, but with a 20% chance to pick from nearest neighbors
    if random.random() < 0.8:  # 80% chance to use centrality-based selection
        next_node = random.choices(list(probabilities.keys()), weights=probabilities.values(), k=1)[0]
    else:  # 20% chance to pick from nearest 3 neighbors
        nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]
        next_node = random.choice(candidates)

    return next_node
