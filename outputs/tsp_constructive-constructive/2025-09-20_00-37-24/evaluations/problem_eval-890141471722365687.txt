import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate dynamic probabilities based on inverse distance and node degree
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    degrees = [sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0) for node in unvisited_nodes]

    # Avoid division by zero and normalize probabilities
    inv_distances = [1.0 / (d + 1e-6) for d in distances]
    inv_degrees = [1.0 / (deg + 1e-6) for deg in degrees]

    # Combine inverse distance and inverse degree for dynamic weights
    weights = [inv_dist * inv_deg for inv_dist, inv_deg in zip(inv_distances, inv_degrees)]
    total_weight = sum(weights)
    probabilities = [w / total_weight for w in weights]

    # Introduce stochasticity: 80% chance to pick from top 3 weighted nodes, 20% random
    if random.random() < 0.8:
        sorted_indices = np.argsort(probabilities)[::-1]
        top_candidates = [unvisited_nodes[i] for i in sorted_indices[:min(3, len(unvisited_nodes))]]
        next_node = random.choices(top_candidates, weights=probabilities[:len(top_candidates)])[0]
    else:
        next_node = random.choices(unvisited_nodes, weights=probabilities)[0]

    return next_node
