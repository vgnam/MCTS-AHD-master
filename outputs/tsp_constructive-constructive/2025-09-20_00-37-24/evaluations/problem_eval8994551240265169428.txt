import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    if destination_node in unvisited_nodes:
        # Dynamic bias towards destination based on distance
        distance_to_dest = distance_matrix[current_node][destination_node]
        bias_probability = 1 / (1 + math.exp(-distance_to_dest / 10))  # Sigmoid function
        if random.random() < bias_probability:
            return destination_node

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Distance-based stochastic selection: closer nodes have higher probability
    distances = [distance_matrix[current_node][node] for node in nearest_neighbors]
    max_distance = max(distances) if distances else 1
    probabilities = [(max_distance / (d + 0.01)) for d in distances]  # Avoid division by zero
    total = sum(probabilities)
    normalized_probs = [p / total for p in probabilities]

    # Add memory component: favor nodes that were recently visited (simulated here)
    # In a real implementation, this would track recent nodes
    if random.random() < 0.3:  # 30% chance to consider memory
        if len(nearest_neighbors) > 1:
            # Randomly pick a node that's not the nearest to introduce diversity
            candidates = nearest_neighbors[1:]
            next_node = random.choice(candidates)
        else:
            next_node = nearest_neighbors[0]
    else:
        next_node = random.choices(nearest_neighbors, weights=normalized_probs, k=1)[0]

    return next_node
