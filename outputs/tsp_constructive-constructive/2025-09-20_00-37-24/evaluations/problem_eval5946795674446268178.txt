import random
import math

def calculate_path_potential(node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return 0.0
    avg_distances = [sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)
                    for n in unvisited_nodes]
    return sum(1 / (d + 1e-6) for d in avg_distances) / len(unvisited_nodes)

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    top_k = min(5, len(nearest_neighbors))
    candidates = nearest_neighbors[:top_k]

    # Calculate selection probabilities based on inverse distance and path potential
    inv_distances = [1 / (distance_matrix[current_node][n] + 1e-6) for n in candidates]
    path_potentials = [calculate_path_potential(n, unvisited_nodes, distance_matrix) for n in candidates]

    # Combine metrics with weights (70% distance, 30% potential)
    weights = [0.7 * inv_dist + 0.3 * pot for inv_dist, pot in zip(inv_distances, path_potentials)]
    total_weight = sum(weights)

    if total_weight > 0:
        probabilities = [w / total_weight for w in weights]
        next_node = random.choices(candidates, weights=probabilities, k=1)[0]
    else:
        next_node = random.choice(candidates)

    return next_node
