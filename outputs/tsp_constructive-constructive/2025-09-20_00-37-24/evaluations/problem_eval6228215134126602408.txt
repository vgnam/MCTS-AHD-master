import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate base probabilities based on inverse distance
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    inv_distances = [1.0 / (d + 1e-10) for d in distances]  # Avoid division by zero
    inv_dist_sum = sum(inv_distances)
    base_probs = [d / inv_dist_sum for d in inv_distances]

    # Introduce attractiveness scores (simplified for this example)
    attractiveness = [1.0 / (i + 1) for i in range(len(unvisited_nodes))]  # Placeholder for dynamic scores
    attr_sum = sum(attractiveness)
    attr_probs = [a / attr_sum for a in attractiveness]

    # Combine probabilities with a dynamic weight
    weight = 0.7 if len(unvisited_nodes) > 3 else 0.3  # Higher weight for distance when few nodes left
    combined_probs = [weight * base_probs[i] + (1 - weight) * attr_probs[i] for i in range(len(unvisited_nodes))]

    # Normalize probabilities
    prob_sum = sum(combined_probs)
    norm_probs = [p / prob_sum for p in combined_probs]

    # Select node based on combined probabilities
    next_node = np.random.choice(unvisited_nodes, p=norm_probs)

    return next_node
