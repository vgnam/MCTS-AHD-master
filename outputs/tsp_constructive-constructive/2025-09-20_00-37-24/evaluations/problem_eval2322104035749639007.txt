import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate centrality scores (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = np.mean(distance_matrix[node])

    # Normalize centrality scores to [0, 1] range
    max_centrality = max(centrality.values()) if centrality else 1
    min_centrality = min(centrality.values()) if centrality else 0
    if max_centrality != min_centrality:
        normalized_centrality = {node: (centrality[node] - min_centrality) / (max_centrality - min_centrality)
                                for node in unvisited_nodes}
    else:
        normalized_centrality = {node: 0.5 for node in unvisited_nodes}

    # Calculate combined scores: inverse distance (exploitation) and normalized centrality (exploration)
    scores = {}
    for node in unvisited_nodes:
        distance_score = 1 / (1 + distance_matrix[current_node][node])  # Inverse distance
        centrality_score = normalized_centrality[node]
        scores[node] = 0.7 * distance_score + 0.3 * centrality_score  # Weighted combination

    # Select based on probability proportional to scores
    nodes = list(scores.keys())
    probabilities = [scores[node] for node in nodes]
    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize to probabilities
    next_node = random.choices(nodes, weights=probabilities, k=1)[0]

    return next_node
