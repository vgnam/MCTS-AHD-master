import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node
    if not unvisited_nodes:
        return None

    # Calculate cumulative path distance from start (assuming start is index 0)
    start_node = 0
    cumulative_distances = {
        node: distance_matrix[start_node][node] + distance_matrix[node][current_node]
        for node in unvisited_nodes
    }

    # Sort by cumulative distance (exploitation) and original distance (exploration)
    sorted_by_cumulative = sorted(unvisited_nodes, key=lambda node: cumulative_distances[node])
    sorted_by_distance = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    # Combine scores: 70% weight to cumulative distance, 30% to original distance
    combined_scores = {
        node: 0.7 * cumulative_distances[node] + 0.3 * distance_matrix[current_node][node]
        for node in unvisited_nodes
    }
    sorted_by_combined = sorted(unvisited_nodes, key=lambda node: combined_scores[node])

    # Select with probability based on rank
    if random.random() < 0.8:  # 80% chance to pick from top 3 by combined score
        candidates = sorted_by_combined[:min(3, len(unvisited_nodes))]
    else:  # 20% chance to pick from top 3 by distance
        candidates = sorted_by_distance[:min(3, len(unvisited_nodes))]

    next_node = random.choice(candidates)
    return next_node
