[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a stochastic nearest-neighbor approach with pheromone-inspired desirability, prioritizing the destination node when possible. It balances exploitation (selecting the highest-desirability node with probability *q0*) and exploration (randomly choosing a node via roulette wheel selection). Desirability is computed as *(pheromone_levels[node]^\u03b1) / (distance^\u03b2)*, where \u03b1 (1.0) and \u03b2 (2.0) emphasize pheromone influence over distance, favoring closer nodes with higher pheromones.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest neighbor approach, introducing a probabilistic selection between the nearest nodes and a random node, while incorporating a pheromone-inspired desirability component to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.48804,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines deterministic selection of the nearest nodes (90% of the time) with stochastic exploration (10% of the time), prioritizing the top 3 nearest neighbors while considering pheromone influence. It balances exploitation (closer nodes with higher pheromone) and exploration (less obvious routes) through a desirability function weighted by \u03b1=1.0 (pheromone) and \u03b2=2.0 (distance), ensuring efficient path construction in TSP. The destination is prioritized if still unvisited.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the pheromone-aware stochastic selection of No.1, favoring closer nodes with pheromone influence while maintaining 90% exploitation of top 3 nearest neighbors and 10% exploration of less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        candidates_prob = {node: probabilities[node] for node in candidates}\n        next_node = max(candidates_prob, key=candidates_prob.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.65688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination priority** (always selecting the destination node if unvisited) with a **probabilistic selection** based on node desirability (weighted by pheromone levels and distance). It prioritizes exploitation (90% chance to choose the highest-probability node) but includes stochasticity (10% chance for random selection) to balance exploration. The desirability function uses `alpha=1.0` (pheromone emphasis) and `beta=2.0` (distance de-emphasis), favoring shorter paths while allowing some randomness.",
          "thought": "The new algorithm combines the destination priority of No.2 with the probabilistic selection based on desirability (pheromone and distance) from No.1, while introducing stochasticity to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.67592,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination prioritization** (always choosing the destination if unvisited) with a **stochastic selection** that favors closer nodes (based on distance) and those with higher pheromone levels, using weighted probabilities. It prioritizes **distance** (\u03b2=2.0) over pheromones (\u03b1=1.0) but allows **90% of the time** to select from the top 3 nearest neighbors with pheromone influence, while the remaining 10% enables exploration of less obvious routes. The desirability function balances these factors, and the selection is either deterministic (top 3) or probabilistic (remaining nodes).",
          "thought": "The new algorithm combines the destination prioritization from No.2 with the pheromone-inspired desirability and stochastic selection from No.1, favoring closer nodes with higher pheromones while occasionally exploring less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    # 90% chance to pick from top 3 nearest with pheromone consideration\n    if random.random() < 0.9:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        candidates_prob = {node: probabilities[node] for node in candidates}\n        next_node = max(candidates_prob, key=candidates_prob.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.68236,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm attempts to go directly to the destination node if possible; otherwise, it selects the next node based on a combination of distance and pheromone-inspired desirability. A probabilistic component introduces exploration, balancing exploitation of known good paths with the discovery of potentially better ones. The algorithm prioritizes exploitation (using `q0`) with a probability of 0.9, and exploration with a probability of 0.1.\n",
          "thought": "This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    # {This algorithm prioritizes the destination node, and if unavailable, selects the next node by combining distance, pheromone-inspired desirability, and a probabilistic exploration component.}\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    \n    pheromone_levels = {node: 1.0 for node in unvisited_nodes} \n\n    def desirability(node):\n        alpha = 1.0  \n        beta = 2.0   \n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in unvisited_nodes}\n    \n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in unvisited_nodes}\n    \n    # Exploration vs Exploitation\n    q = random.random()\n    q0 = 0.9  \n    \n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        # Probabilistic selection\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(unvisited_nodes)) \n\n    return next_node",
          "objective": 7.80112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by balancing immediate proximity (distance from current node) with global connectivity (average distance to other unvisited nodes), minimizing their sum to ensure a trade-off between short-term and long-term path efficiency. The destination node has the highest priority, followed by nodes that minimize the combined score of current distance and average distance to others.",
          "thought": "The new algorithm first checks if the destination node is unvisited, prioritizing it if possible. For the remaining nodes, it selects the one that minimizes the sum of distances to the current node and the average distance to all other unvisited nodes, balancing immediate proximity with global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        score = current_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically prioritizes the destination node with a time-decaying probability (starting at 90% when most nodes are unvisited, decreasing to 10%), while otherwise selecting the nearest unvisited node with stochasticity controlled by a temperature parameter (higher when more nodes remain). It balances exploration (via exponential decay in neighbor selection) and exploitation (greedy nearest-neighbor choice) to avoid local optima.",
          "thought": "The new algorithm introduces a dynamic bias towards the destination node when it's unvisited, using a probabilistic selection mechanism that combines distance-based proximity with a time-decaying preference for the destination, while maintaining stochasticity to avoid local optima.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    if destination_node in unvisited_nodes:\n        # Dynamic probability of selecting destination, decaying with time\n        prob_destination = max(0.1, 0.9 * (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))))\n        if random.random() < prob_destination:\n            return destination_node\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Temperature-based stochasticity: higher temperature leads to more exploration\n    temperature = len(unvisited_nodes) / len(distance_matrix)\n    if random.random() < temperature:\n        # Exponential decay for candidate selection\n        weights = [math.exp(-i * 0.5) for i in range(len(nearest_neighbors))]\n        next_node = random.choices(nearest_neighbors, weights=weights, k=1)[0]\n    else:\n        next_node = nearest_neighbors[0]\n\n    return next_node",
          "objective": 9.07523,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic nearest-neighbor selection with centrality-based scoring, prioritizing the destination node. It balances proximity (80% weight) and centrality (20% weight) in scoring, then selects from top 3 candidates with 90% probability from the top 2 and 10% from the top 3. The code ensures the destination is visited first if unvisited, and uses adaptive randomness for exploration.",
          "thought": "The new algorithm combines the stochastic nearest-neighbor approach from No.2 with centrality-based scoring from No.1, prioritizing the destination node, and balances proximity (80% weight) and centrality (20% weight) in scoring, selecting from top 3 candidates with higher probability (90% from top 2, 10% from top 3).",
          "code": "import random\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    # Calculate centrality score for each node (inverse of average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        avg_distance = np.mean([distance_matrix[node][other] for other in unvisited_nodes if other != node])\n        centrality[node] = 1.0 / (avg_distance + 1e-6)  # Avoid division by zero\n\n    # Get nearest neighbors sorted by distance\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Combine distance and centrality to score nodes\n    scored_nodes = []\n    for node in nearest_neighbors:\n        distance_score = 1.0 / (distance_matrix[current_node][node] + 1e-6)\n        total_score = 0.8 * distance_score + 0.2 * centrality[node]\n        scored_nodes.append((node, total_score))\n\n    # Sort by combined score\n    scored_nodes.sort(key=lambda x: x[1], reverse=True)\n\n    # Adaptive stochasticity: higher probability for top nodes, but still some randomness\n    if random.random() < 0.9:  # 90% chance to pick from top 2 nodes\n        candidates = [node for node, _ in scored_nodes[:min(2, len(scored_nodes))]]\n        next_node = random.choice(candidates)\n    else:  # 10% chance to pick from top 3 nodes\n        candidates = [node for node, _ in scored_nodes[:min(3, len(scored_nodes))]]\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 9.71281,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach that balances immediate distance from the current node with potential future efficiency by considering the nearest unvisited node and the average distance to all other unvisited nodes, combining these metrics to select the next node with the lowest total score. The function uses the `distance_matrix` to compute distances, with `current_distance` given the highest priority, followed by `nearest_distance`, and `avg_distance` given the lowest priority in the scoring mechanism.",
          "thought": "This algorithm prioritizes selecting the destination node if it's unvisited, otherwise it uses a hybrid approach combining nearest neighbor selection with a greedy optimization that considers both immediate distance and potential future path efficiency by evaluating the sum of distances to the nearest unvisited nodes and the average distance to all other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n\n        # Find the nearest unvisited node from this candidate\n        nearest_unvisited = min(unvisited_nodes, key=lambda n: distance_matrix[node][n] if n != node else float('inf'))\n        nearest_distance = distance_matrix[node][nearest_unvisited] if nearest_unvisited != node else 0\n\n        # Average distance to all other unvisited nodes\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n        # Combine metrics for a balanced score\n        score = current_distance + nearest_distance + avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 10.1896,
          "other_inf": null
     }
]