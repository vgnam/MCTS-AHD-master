[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise it balances exploitation (selecting the nearest neighbors) and exploration (probabilistically choosing nodes based on pheromone-inspired desirability, weighted by distance). It uses a stochastic nearest-neighbor approach with a 90% chance of selecting the most desirable node (based on desirability = pheromone^\u03b1 / distance^\u03b2) and a 10% chance of exploring alternatives, where \u03b1 (1.0) and \u03b2 (2.0) control the influence of pheromones and distance, respectively. Pheromone levels are uniform (1.0) initially, and the top 3 nearest neighbors are considered as candidates.",
          "thought": "The new algorithm will prioritize the destination node if unvisited, otherwise it will combine the stochastic nearest neighbor approach with a probabilistic selection based on distance and pheromone-inspired desirability, balancing exploitation of proximity with exploration of potentially better routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.2208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a stochastic nearest-neighbor approach with pheromone-inspired desirability, prioritizing the destination node when possible. It balances exploitation (selecting the highest-desirability node with probability *q0*) and exploration (randomly choosing a node via roulette wheel selection). Desirability is computed as *(pheromone_levels[node]^\u03b1) / (distance^\u03b2)*, where \u03b1 (1.0) and \u03b2 (2.0) emphasize pheromone influence over distance, favoring closer nodes with higher pheromones.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest neighbor approach, introducing a probabilistic selection between the nearest nodes and a random node, while incorporating a pheromone-inspired desirability component to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.48804,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination prioritization** (always choosing the destination if it's unvisited) with a **pheromone-inspired desirability metric** (balancing pheromone levels and distance). It restricts selection to the **top 3 nearest neighbors**, where the most desirable node is chosen with **90% probability** and a random alternative with **10%**. The parameters **\u03b1=1.0** and **\u03b2=2.0** emphasize **distance more than pheromone levels**, while the **90-10 split** balances exploitation and exploration.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a pheromone-inspired desirability metric from No.1, where desirability is calculated as pheromone^\u03b1 / distance^\u03b2 (\u03b1=1.0, \u03b2=2.0), and the top 3 nearest neighbors are considered as candidates. With 90% probability, it selects the most desirable node among these candidates, and with 10% probability, it explores alternatives by randomly choosing from the candidates.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.50579,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **proximity** (prioritizing nearby nodes) with **stochastic exploration** (randomly selecting from top 3 neighbors) while balancing **pheromone influence** (weighted by `alpha=1.0`) and **distance penalization** (weighted by `beta=2.0`). It favors shorter paths (higher `beta`) but occasionally explores alternatives (90% chance to pick the best candidate, 10% random selection). The destination node is always prioritized if unvisited.",
          "thought": "The new algorithm combines destination priority with a stochastic selection from the top 3 nearest neighbors, weighted by pheromone levels, to balance proximity and exploration while favoring shorter paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.52399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **greedy nearest-neighbor selection** with **stochastic exploration** to balance proximity (prioritized via desirability function) and randomness. It first checks if the destination is unvisited; otherwise, it sorts unvisited nodes by distance, computes a desirability score (inverse-distance weighted by \u03b1=1.0 and \u03b2=2.0), and selects the nearest node 90% of the time or a probabilistic choice otherwise. The desirability function and probabilistic selection ensure a trade-off between short-term optimality and exploration.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a desirability-based selection inspired by No.1, using a weighted balance between proximity and stochastic exploration to improve path quality.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (1.0**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        candidates_prob = {node: probabilities[node] for node in candidates}\n        next_node = max(candidates_prob, key=candidates_prob.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.53524,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances nearest-neighbor focus (prioritizing closer nodes) and probabilistic selection (using weighted desirability with \u03b1=1.0 and \u03b2=2.0, favoring higher pheromone levels and shorter distances) while ensuring the destination node is always chosen if unvisited. It defaults to the top 3 nearest neighbors with 90% probability but allows exploration of less obvious paths 10% of the time via random selection.",
          "thought": "The new algorithm combines the probabilistic selection of No.1 with the nearest neighbor focus of No.2, using a weighted desirability function (\u03b1=1.0, \u03b2=2.0) to balance pheromone levels and distance, while prioritizing the destination node and occasionally exploring less obvious paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    pheromone_levels = {node: 1.0 for node in nearest_neighbors}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        candidate_probabilities = {node: probabilities[node] for node in candidates}\n        next_node = max(candidate_probabilities, key=candidate_probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.60087,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines deterministic selection of the nearest nodes (90% of the time) with stochastic exploration (10% of the time), prioritizing the top 3 nearest neighbors while considering pheromone influence. It balances exploitation (closer nodes with higher pheromone) and exploration (less obvious routes) through a desirability function weighted by \u03b1=1.0 (pheromone) and \u03b2=2.0 (distance), ensuring efficient path construction in TSP. The destination is prioritized if still unvisited.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the pheromone-aware stochastic selection of No.1, favoring closer nodes with pheromone influence while maintaining 90% exploitation of top 3 nearest neighbors and 10% exploration of less obvious routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n        candidates_prob = {node: probabilities[node] for node in candidates}\n        next_node = max(candidates_prob, key=candidates_prob.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.65688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **destination priority** (always selecting the destination node if unvisited) with a **probabilistic selection** based on node desirability (weighted by pheromone levels and distance). It prioritizes exploitation (90% chance to choose the highest-probability node) but includes stochasticity (10% chance for random selection) to balance exploration. The desirability function uses `alpha=1.0` (pheromone emphasis) and `beta=2.0` (distance de-emphasis), favoring shorter paths while allowing some randomness.",
          "thought": "The new algorithm combines the destination priority of No.2 with the probabilistic selection based on desirability (pheromone and distance) from No.1, while introducing stochasticity to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.67592,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes exploitation (90% chance) by selecting the highest-probability node from nearest neighbors, balancing it with exploration (10% chance) via random selection. Desirability is weighted by pheromone levels (\u03b1=1.0) and inversely by distance (\u03b2=2.0), giving distance higher priority in node selection. The code structures decisions probabilistically, ensuring diversity in exploration while favoring the most promising paths.",
          "thought": "The new algorithm combines the destination priority of No.2 with probabilistic selection based on desirability (weighted by pheromone levels and distance) from No.1, prioritizing exploitation (90% chance to choose the highest-probability node from the nearest neighbors) but including stochasticity (10% chance for random selection) to balance exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    pheromone_levels = {node: 1.0 for node in nearest_neighbors}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.68179,
          "other_inf": null
     }
]