[
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node based on the distance matrix. The design ensures efficiency by checking the destination first, followed by a greedy nearest-neighbor approach for the remaining nodes. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, returning the next node to visit.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it's among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise it balances exploitation (selecting the nearest neighbors) and exploration (probabilistically choosing nodes based on pheromone-inspired desirability, weighted by distance). It uses a stochastic nearest-neighbor approach with a 90% chance of selecting the most desirable node (based on desirability = pheromone^\u03b1 / distance^\u03b2) and a 10% chance of exploring alternatives, where \u03b1 (1.0) and \u03b2 (2.0) control the influence of pheromones and distance, respectively. Pheromone levels are uniform (1.0) initially, and the top 3 nearest neighbors are considered as candidates.",
          "thought": "The new algorithm will prioritize the destination node if unvisited, otherwise it will combine the stochastic nearest neighbor approach with a probabilistic selection based on distance and pheromone-inspired desirability, balancing exploitation of proximity with exploration of potentially better routes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.2208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node probabilistically: 90% of the time it chooses from the top 3 nearest unvisited nodes weighted by inverse squared distance (higher desirability for closer nodes), and 10% of the time it explores randomly among these candidates. The destination node is always prioritized, and the selection balances exploitation (focusing on nearby nodes) with exploration (random selection).",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a probabilistic selection inspired by No.1's desirability-based approach, using a 90% chance to choose from the top 3 nearest nodes weighted by distance, and a 10% chance for exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node]**2)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.39859,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node from the 3 nearest neighbors using inverse squared distance weighting (higher priority for closer nodes) with a 90% probability, or random selection from the same set with 10% probability. The distance matrix determines neighbor proximity, and the heuristic balances exploration (randomness) with exploitation (distance-based preference).",
          "thought": "The new algorithm combines the destination prioritization from No.1 with the stochastic nearest neighbor approach of No.2, but uses inverse squared distance weighting (from No.1) to select among the nearest neighbors, ensuring closer nodes are more likely chosen while maintaining some randomness.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node]**2)\n\n    if random.random() < 0.9:\n        desirabilities = {node: desirability(node) for node in candidates}\n        total_desirability = sum(desirabilities.values())\n        probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.4118,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm prioritizes the destination node if unvisited, otherwise selects from the top 3 nearest neighbors with 90% probability based on desirability (\u03b1=1.0 for pheromone, \u03b2=2.0 for distance), and allows random selection from the top 3 with 10% probability. Distance is weighted more heavily (\u03b2=2.0) than pheromone (\u03b1=1.0) in desirability calculations, favoring closer nodes.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the desirability-based selection of No.1. It prioritizes the destination if unvisited, otherwise selects from the top 3 nearest neighbors with 90% probability, using desirability (\u03b1=1.0 for pheromone, \u03b2=2.0 for distance), and allows random selection from the top 3 with 10% probability.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    pheromone_levels = {node: 1.0 for node in candidates}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.41791,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest nodes (up to 3) based on desirability (inverse of squared distance) with a 90% probability, while allowing occasional random selection (10%) to escape local optima. It first checks if the destination is unvisited, otherwise selects the most desirable candidate from the nearest neighbors, balancing proximity and exploration. The `destination_node` is always prioritized if unvisited, ensuring progress toward the goal.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with a desirability-based selection from No.1, favoring closer nodes with higher probability and occasionally exploring random nodes to escape local optima.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    def desirability(node):\n        return 1.0 / (distance_matrix[current_node][node] ** 2.0)\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.45288,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines stochastic nearest-neighbor selection with pheromone-inspired desirability, prioritizing the top 3 nearest nodes (90% chance) while allowing 10% exploration, balancing exploitation and exploration. It uses desirability (weighted by \u03b1=1.0 for pheromone and \u03b2=2.0 for distance) to probabilistically select the next node, with uniform pheromone levels initially. The destination node is prioritized if still unvisited.",
          "thought": "The new algorithm combines the prioritization of destination nodes with a stochastic nearest-neighbor approach, using a 90% chance to select from the top 3 nearest nodes (weighted by pheromone-inspired desirability) and a 10% chance to explore alternatives, balancing exploitation and exploration while maintaining simplicity and efficiency.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.47203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a stochastic nearest-neighbor approach with pheromone-inspired desirability, prioritizing the destination node when possible. It balances exploitation (selecting the highest-desirability node with probability *q0*) and exploration (randomly choosing a node via roulette wheel selection). Desirability is computed as *(pheromone_levels[node]^\u03b1) / (distance^\u03b2)*, where \u03b1 (1.0) and \u03b2 (2.0) emphasize pheromone influence over distance, favoring closer nodes with higher pheromones.",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest neighbor approach, introducing a probabilistic selection between the nearest nodes and a random node, while incorporating a pheromone-inspired desirability component to balance exploitation and exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 2.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    desirabilities = {node: desirability(node) for node in nearest_neighbors}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in nearest_neighbors}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        cumulative_probability = 0.0\n        r = random.random()\n        for node, probability in probabilities.items():\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = node\n                break\n        else:\n            next_node = random.choice(list(nearest_neighbors))\n\n    return next_node",
          "objective": 7.48804,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a deterministic nearest-neighbor approach with probabilistic selection, prioritizing the 3 nearest neighbors (90% chance) while occasionally choosing randomly (10%) to escape local optima. It balances distance and pheromone (initially uniform) via desirability metrics (\u03b1=\u03b2=1.0) and always checks if the destination node should be visited next. The core trade-off is between exploitation (nearest neighbors) and exploration (randomness).",
          "thought": "The new algorithm combines the prioritization of the destination node with a stochastic nearest neighbor approach, but uses a desirability metric that balances distance and a simple pheromone-inspired heuristic, selecting from the top 3 nearest neighbors with 90% probability and a random alternative with 10%.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    pheromone_levels = {node: 1.0 for node in unvisited_nodes}\n\n    def desirability(node):\n        alpha = 1.0\n        beta = 1.0\n        return (pheromone_levels[node]**alpha) / (distance_matrix[current_node][node]**beta)\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    q = random.random()\n    q0 = 0.9\n\n    if q < q0:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.48879,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest nodes (90% of the time) while occasionally exploring randomly (10% of the time). It uses a desirability function (weighted by \u03b2=2.0) to favor closer nodes, selecting from the top 3 nearest neighbors. The destination node is always chosen if still unvisited, ensuring progress toward the goal.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with stochastic nearest neighbor selection (90% chance) and occasional random exploration (10% chance), but introduces desirability weighting based on distance (beta=2.0) to favor shorter paths more consistently.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    if not unvisited_nodes:\n        return None\n\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def desirability(node):\n        beta = 2.0\n        return 1.0 / (distance_matrix[current_node][node]**beta)\n\n    candidates = nearest_neighbors[:min(3, len(nearest_neighbors))]\n    desirabilities = {node: desirability(node) for node in candidates}\n    total_desirability = sum(desirabilities.values())\n    probabilities = {node: desirabilities[node] / total_desirability for node in candidates}\n\n    if random.random() < 0.9:\n        next_node = max(probabilities, key=probabilities.get)\n    else:\n        next_node = random.choice(candidates)\n\n    return next_node",
          "objective": 7.49608,
          "other_inf": null
     }
]