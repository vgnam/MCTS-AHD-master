import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    candidates = []
    total_entropy = 0.0
    max_distance = max(max(row) for row in distance_matrix if max(row) > 0)

    for node in unvisited_nodes:
        direct_dist = distance_matrix[current_node][node]
        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {node}
            degree = sum(1 for d in distance_matrix[node] if d > 0)
            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)
            locality = 1.0 / (avg_distance + 1e-6)
            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))
            penalty = 0.7 * (direct_dist / max_distance) ** 2 if max_distance > 0 else 0

            # Calculate entropy of node connectivity
            probs = [d / sum(distance_matrix[node]) for d in distance_matrix[node] if d > 0]
            entropy = -sum(p * math.log(p + 1e-6) for p in probs) if probs else 0
            total_entropy += entropy

            # Weighted score with entropy and memory bias
            score = (0.5 * direct_dist + 0.2 * degree + 0.2 * locality * dynamic_weight - 0.3 * penalty) * (1 + 0.1 * entropy)
        else:
            score = direct_dist

        candidates.append((node, score))

    # Probabilistic selection based on scores and entropy
    if total_entropy > 0:
        weights = [math.exp(-score / total_entropy) for _, score in candidates]
        total_weight = sum(weights)
        probabilities = [w / total_weight for w in weights]
        next_node = random.choices([node for node, _ in candidates], weights=probabilities, k=1)[0]
    else:
        next_node, _ = min(candidates, key=lambda x: x[1])

    return next_node
