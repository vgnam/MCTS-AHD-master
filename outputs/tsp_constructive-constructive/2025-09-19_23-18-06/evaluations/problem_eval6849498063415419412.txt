def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def score(node):
        distance = distance_matrix[current_node][node]
        degree = sum(1 for d in distance_matrix[node] if d > 0)

        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {node}
            distances_to_remaining = [distance_matrix[node][n] for n in remaining_nodes]
            mean_distance = sum(distances_to_remaining) / len(distances_to_remaining)
            variance = sum((d - mean_distance) ** 2 for d in distances_to_remaining) / len(distances_to_remaining)
            locality = 1.0 / (variance + 1e-6)

            # Adjust weights dynamically based on remaining nodes
            w_distance = 1.5 * (len(unvisited_nodes) / (len(distance_matrix) - 1))
            w_degree = 0.3 * (1 - len(unvisited_nodes) / (len(distance_matrix) - 1))
            w_locality = 0.2

            return w_distance * distance + w_degree * degree + w_locality * locality
        else:
            return distance

    next_node = min(unvisited_nodes, key=score)
    return next_node
