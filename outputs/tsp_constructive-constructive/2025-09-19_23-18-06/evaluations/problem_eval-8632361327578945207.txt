def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    candidates = []
    remaining_count = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = 1.0 - (remaining_count / total_nodes)

    for node in unvisited_nodes:
        next_distance = distance_matrix[current_node][node]
        degree = sum(1 for d in distance_matrix[node] if d > 0)

        if remaining_count > 1:
            remaining_nodes = unvisited_nodes - {node}
            distances = [distance_matrix[node][n] for n in remaining_nodes]
            avg_distance = sum(distances) / len(distances)
            min_distance = min(distances)
            max_distance = max(distances)
            variance = sum((d - avg_distance) ** 2 for d in distances) / len(distances)

            centrality = degree / (sum(distance_matrix[node]) + 1e-6)
            locality = len(distances) / (sum(1 / (d + 1e-6) for d in distances))
            detour_penalty = (variance ** 0.5) * (remaining_count ** 0.3) / (degree + 1)

            weight_centrality = 0.3 * (1.0 - progress)
            weight_locality = 0.4 * (0.7 + 0.3 * progress)
            weight_detour = 0.2 * (0.5 + 0.5 * progress)

            total_distance = next_distance * (1.0 + weight_centrality * centrality + weight_locality * locality) + weight_detour * detour_penalty
        else:
            total_distance = next_distance

        candidates.append((node, total_distance))

    next_node, _ = min(candidates, key=lambda x: x[1])
    return next_node
