def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1
    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes
    distance_weight = 0.9 - 0.6 * progress_ratio
    locality_weight = 1.0 - distance_weight

    candidates = []
    for node in unvisited_nodes:
        direct_dist = distance_matrix[current_node][node]

        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {node}
            direct_centrality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)

            future_centrality = 0
            for future_node in remaining_nodes:
                future_remaining = remaining_nodes - {future_node}
                if future_remaining:
                    future_centrality += 1.0 / (sum(distance_matrix[future_node][n] for n in future_remaining) / len(future_remaining) + 1e-6)
            future_centrality /= len(remaining_nodes)

            locality = 0.6 * direct_centrality + 0.4 * future_centrality
            score = distance_weight * direct_dist + locality_weight * locality
        else:
            score = direct_dist

        candidates.append((node, score))

    next_node, _ = min(candidates, key=lambda x: x[1])
    return next_node
