def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    candidates = []
    remaining_count = len(unvisited_nodes)
    for node in unvisited_nodes:
        next_distance = distance_matrix[current_node][node]
        if remaining_count > 1:
            remaining_nodes = unvisited_nodes - {node}
            distances_to_remaining = [distance_matrix[node][n] for n in remaining_nodes]
            avg_distance = sum(distances_to_remaining) / (remaining_count - 1)
            variance = sum((d - avg_distance) ** 2 for d in distances_to_remaining) / (remaining_count - 1)
            centrality = 1 / avg_distance if avg_distance > 0 else 0
            detour_penalty = variance * 0.4
            dynamic_weight = 0.6 + 0.3 * (remaining_count / (remaining_count + 1))
            score = next_distance + dynamic_weight * (1 - centrality) + detour_penalty
        else:
            score = next_distance
        candidates.append((node, score))
    # Softmax selection with temperature scaling
    scores = [s[1] for s in candidates]
    temperature = 0.5 + 0.5 * (remaining_count / (remaining_count + 1))
    exp_scores = [math.exp(-score / temperature) for score in scores]
    sum_exp = sum(exp_scores)
    probabilities = [e / sum_exp for e in exp_scores]
    next_node = random.choices([c[0] for c in candidates], weights=probabilities, k=1)[0]
    return next_node
