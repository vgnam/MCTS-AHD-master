{
     "algorithm": "The algorithm selects the next node by combining immediate distance, node centrality (inverse of average distance to all other nodes), and a detour penalty (maximum detour cost relative to remaining path length), with centrality and locality factors given higher weight (0.3 and 0.4, respectively) than immediate distance. The score prioritizes nodes that balance short-term efficiency with long-term path quality, while the degree of connectivity (number of reachable nodes) and detour penalty further refine the selection.",
     "thought": "The new algorithm introduces a hybrid scoring mechanism that combines immediate distance with a dynamic connectivity-aware locality factor, where the locality is adjusted by the node's centrality (inverse of average distance to all other nodes) and a novel \"detour penalty\" that accounts for the maximum detour cost relative to the remaining path length, emphasizing both immediate efficiency and long-term path quality.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    candidates = []\n    remaining_count = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n\n            centrality = 1.0 / (sum(distance_matrix[node]) / (total_nodes - 1) + 1e-6)\n            detour_penalty = max(distance_matrix[node][n] for n in remaining_nodes) / (remaining_count ** 0.5)\n\n            score = distance * (1.0 + 0.3 * degree * locality * centrality) + 0.2 * avg_distance + 0.4 * detour_penalty\n        else:\n            score = distance\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
     "objective": 6.44574,
     "other_inf": null
}