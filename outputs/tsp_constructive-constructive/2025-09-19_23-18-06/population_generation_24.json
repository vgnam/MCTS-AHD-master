[
     {
          "algorithm": "The algorithm enhances the greedy approach by dynamically weighting node selection based on **distance**, **degree** (connectivity), and **locality** (inverse of average distance to unvisited nodes). It prioritizes nodes that balance proximity, connectivity, and regional centrality, with degree and locality given lower priority than distance. The `adjusted_score` combines these factors multiplicatively, favoring nodes with lower distances, higher degrees, and better regional centrality.",
          "thought": "The new algorithm enhances the greedy approach by incorporating a dynamic weighting mechanism that combines distance, node degree, and a locality factor (inverse of the average distance to unvisited nodes), creating a more adaptive selection criterion that favors nodes balancing proximity, connectivity, and regional centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance * (1.0 + 0.5 * (1.0 / (degree + 1e-6))) * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP tour by balancing **distance, degree (connectivity), and locality (centrality of unvisited nodes)**, with weights adjusted based on remaining tour length. Distance is prioritized early (higher weight) and less so later, while degree and locality gain importance as the tour progresses. The score is computed as a weighted product of these factors, favoring nodes that are close, well-connected, and regionally central, with weights adapting to the remaining path length.",
          "thought": "The new algorithm modifies the original by incorporating a **dynamic weighted combination of distance, degree, and locality**, where weights are adjusted based on the remaining tour length and node centrality, favoring nodes that balance proximity, connectivity, and regional centrality with adaptive prioritization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n\n        remaining_nodes = len(unvisited_nodes)\n        tour_length_factor = 1.0 / (remaining_nodes + 1e-6)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1 + 1e-6)\n\n        weight_distance = 0.7 - 0.3 * tour_length_factor\n        weight_degree = 0.2 + 0.1 * tour_length_factor\n        weight_locality = 0.1 + 0.2 * tour_length_factor\n\n        return (distance ** weight_distance) * (degree ** weight_degree) * (locality ** weight_locality)\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.92587,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a greedy approach to select the next node by always choosing the closest unvisited node to the current node, prioritizing minimal incremental distance to minimize the total path length. If no unvisited nodes remain, it returns to the destination node. The function prioritizes `current_node` and `distance_matrix` for decision-making, while `destination_node` is only used as a fallback when all nodes are visited. The structure efficiently leverages Python's `min` and `lambda` for concise implementation.",
          "thought": "The algorithm design idea is to select the next node as the one closest to the current node from the unvisited nodes, ensuring a greedy approach to minimize the total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future potential, prioritizing short-term proximity (given weight 1.0) while also considering the average distance to remaining nodes (given weight 0.3). This hybrid approach avoids local optima by incorporating probabilistic elements while still optimizing for the shortest path. The code structure clearly separates candidate evaluation and selection, with the weighted sum determining the optimal choice.",
          "thought": "This algorithm combines nearest-neighbor selection with a probabilistic approach, where nodes are selected based on a weighted combination of immediate distance and the average distance to remaining nodes, introducing stochasticity to escape local optima while maintaining path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            total_distance = next_distance + 0.3 * avg_distance\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 7.44662,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach (minimizing immediate distance) with a lookahead heuristic (scaling the maximum remaining distance by 0.3) to balance short-term and long-term path choices. It prioritizes immediate distance (`next_distance`) but considers potential future detours by including a scaled version of the worst-case remaining distance (`0.3 * max_distance`). The scaling factor (0.3) downweights long-term considerations, making the algorithm more locally focused. The function iterates over unvisited nodes, computes a weighted score for each, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the greedy proximity of No.2 with a lookahead heuristic inspired by No.1, balancing immediate distance with potential future detours by scaling the maximum remaining distance by a factor of 0.3.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            max_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            total_distance = next_distance + 0.3 * max_distance\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 7.4691,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, potential detours (via `max_distance`), and connectivity (via `degree`) while dynamically weighting them, prioritizing immediate distance most heavily (1.0), followed by detour potential (0.4), and connectivity (0.3). Locality is calculated as the inverse of average remaining distances, further refined by node degree. The hybrid score balances these factors to select the next node, ensuring both short-term efficiency and long-term connectivity.",
          "thought": "The new algorithm combines the balanced approach of No.1 (prioritizing both immediate distance and potential detours) with the dynamic weighting of No.2 (using distance, degree, and locality), creating a hybrid heuristic that minimizes immediate steps while considering connectivity and regional centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def hybrid_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            remaining_nodes = unvisited_nodes - {node}\n            max_distance = max(distance_matrix[node][n] for n in remaining_nodes) if remaining_nodes else 0\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance + 0.4 * max_distance + 0.3 * (1.0 / (degree + 1e-6)) * locality\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 7.54868,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize both immediate distance from the current node and the maximum potential detour to remaining unvisited nodes (weighted by 0.4). It balances proximity and tour balance by combining the immediate step (`next_distance`) with a scaled lookahead (`max_distance`) to avoid long detours while still ensuring efficiency. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "This algorithm prioritizes nodes that minimize the maximum distance to any unvisited node, creating a more balanced tour by avoiding potential long detours while still considering immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            max_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            total_distance = next_distance + 0.4 * max_distance\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 7.62496,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing locality (0.3 weight), minimizing distance (0.4 weight), and inversely penalizing high-degree nodes (0.3 weight), with locality calculated as the average inverse distance to unvisited nodes. The weights emphasize proximity and connectivity while balancing exploration via locality.",
          "thought": "The new algorithm modifies the provided one by prioritizing nodes based on a weighted combination of distance, degree, and locality, where locality is given higher emphasis, and the score is computed additively rather than multiplicatively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return 0.4 * distance + 0.3 * (1.0 / (degree + 1e-6)) + 0.3 * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 7.93876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a 2-step lookahead mechanism: it prioritizes nodes that minimize the immediate distance to the next node and also anticipate the next step's distance to a subsequent node, balancing short-term and medium-term path optimization. The `total_distance` variable (sum of immediate and lookahead distances) is the primary optimization criterion, while the `destination_node` is only considered when no unvisited nodes remain. The algorithm prioritizes minimizing cumulative distance over raw proximity.",
          "thought": "This algorithm uses a hybrid approach that combines nearest-neighbor selection with a lookahead mechanism to anticipate the impact of future decisions, balancing immediate proximity with long-term path optimization by evaluating potential subpaths to minimize cumulative distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            lookahead_node = min(remaining_nodes, key=lambda n: distance_matrix[node][n])\n            lookahead_distance = distance_matrix[node][lookahead_node]\n            total_distance = next_distance + lookahead_distance\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance and node connectivity by selecting the next node based on a weighted score that prioritizes nearby nodes with lower degrees (fewer connections) while lightly considering the average distance to remaining nodes (weighted 0.1). The key trade-off is balancing proximity and connectivity, with connectivity given higher priority (via degree) and average distance given lower priority (via reduced weight). The structure iteratively evaluates unvisited nodes and chooses the one minimizing the weighted score.",
          "thought": "The new algorithm combines the hybrid approach of No.1 (balancing immediate distance and future potential) with the connectivity-aware selection of No.2, by prioritizing nodes that are both close and have lower degree, while also considering the average distance to remaining nodes with a reduced weight (0.1) to avoid overcomplicating the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_score(node):\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            return next_distance / (degree + 1e-6) + 0.1 * avg_distance\n        else:\n            return next_distance / (degree + 1e-6)\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 14.72773,
          "other_inf": null
     }
]