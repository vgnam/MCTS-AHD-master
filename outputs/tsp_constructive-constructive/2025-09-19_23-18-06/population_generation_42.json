[
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP tour by balancing distance, connectivity (degree), locality (average distance to remaining nodes), and a progress-driven \"proximity pressure\" term. It prioritizes shorter distances and nodes with higher connectivity while adapting weights based on remaining nodes. The score combines these factors with higher emphasis on distance and connectivity early in the tour, while proximity pressure increases later to encourage closer connections.",
          "thought": "This new algorithm modifies the selection criteria by incorporating a dynamic weighting factor that adapts based on the remaining unvisited nodes, combining distance, connectivity, locality, and a novel \"proximity pressure\" term that intensifies as the tour progresses to encourage closer connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    progress_ratio = 1.0 - (total_unvisited / (total_unvisited + len(distance_matrix)))\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if total_unvisited > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n\n        proximity_pressure = (1.0 - progress_ratio) ** 2\n        dynamic_weight = 0.7 + 0.3 * progress_ratio\n\n        score = (distance * (1.0 + 0.5 * (degree + 1e-6) * locality) +\n                0.3 * avg_distance * dynamic_weight +\n                0.2 * proximity_pressure * distance)\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.60702,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm enhances the greedy approach by dynamically weighting node selection based on **distance**, **degree** (connectivity), and **locality** (inverse of average distance to unvisited nodes). It prioritizes nodes that balance proximity, connectivity, and regional centrality, with degree and locality given lower priority than distance. The `adjusted_score` combines these factors multiplicatively, favoring nodes with lower distances, higher degrees, and better regional centrality.",
          "thought": "The new algorithm enhances the greedy approach by incorporating a dynamic weighting mechanism that combines distance, node degree, and a locality factor (inverse of the average distance to unvisited nodes), creating a more adaptive selection criterion that favors nodes balancing proximity, connectivity, and regional centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance * (1.0 + 0.5 * (1.0 / (degree + 1e-6))) * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP path by balancing immediate distance, node connectivity (degree), and locality (average distance to remaining unvisited nodes), using a weighted product of these factors. It prioritizes lower distances and higher connectivity/locality, while the 0.3 * avg_distance term slightly balances the score toward shorter future paths. The code avoids local optima by always evaluating all unvisited candidates.",
          "thought": "This new algorithm combines the hybrid distance-averaging approach with multiplicative scoring, incorporating both immediate distance and future potential through a weighted product of distance, degree (connectivity), and locality (average distance to remaining nodes), while avoiding local optima by considering probabilistic elements in the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n        score = distance * (1.0 + 0.5 * (degree + 1e-6) * locality) + 0.3 * avg_distance\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.61206,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing distance, node degree (connectivity), and locality (average distance to remaining unvisited nodes), prioritizing nodes with shorter distances, higher connectivity, and closer proximity to unvisited nodes. The score combines these factors multiplicatively, where distance is weighted by a term that includes degree and locality, with small constants (1e-6) to avoid division by zero. The node with the minimum score is chosen.",
          "thought": "The new algorithm combines No.1's balanced weighting of distance, degree, and locality with No.2's structured candidate evaluation. It evaluates nodes by multiplying distance with a weighted sum of degree and locality terms, then selects the node with the minimum combined score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n        else:\n            locality = 1.0\n        score = distance * (1.0 + 0.5 * (degree + 1e-6) * locality)\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.62239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts its selection strategy based on tour progress, prioritizing locality and connectivity early (using a weighted product of distance, degree, and locality) and focusing on minimizing immediate distance and balancing future paths later (using a weighted score combining distance and average remaining distance). The `progress_factor` balances these priorities, with early stages favoring connectivity-locality trade-offs and later stages emphasizing distance optimization. The weighted score formula `(1 - progress_factor) * (distance-weighted term) + progress_factor * (distance + 0.3 * avg_distance)` reflects this dynamic adjustment.",
          "thought": "The new algorithm combines dynamic progress_factor weighting with the weighted product of distance, degree, and locality from No.1, while using the balanced scoring approach of No.2. It dynamically adjusts factor weights based on tour progress to prioritize locality and connectivity early, then focus on minimizing immediate distance and balancing future paths later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n\n        weighted_score = (1 - progress_factor) * (distance * (1.0 + 0.5 * (degree + 1e-6) * locality)) + progress_factor * (distance + 0.3 * avg_distance)\n        candidates.append((node, weighted_score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.64353,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing distance, degree, locality, and progress, where distance and locality are prioritized early in the tour (low progress_factor), while degree and a balanced combination of factors dominate later (high progress_factor). The combined_score normalizes these metrics to ensure fair comparison, with progress_factor adjusting the weighting dynamically. The code efficiently handles edge cases (e.g., no unvisited nodes) and avoids division by zero with small constants.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting scheme that adjusts node selection based on the current state of the tour (e.g., remaining nodes and tour progress), using a normalized score that combines distance, degree, locality, and a novel \"progress\" factor to prioritize nodes that accelerate tour completion while maintaining balance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress_factor = (total_nodes - remaining_nodes) / total_nodes if total_nodes > 0 else 0.0\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited) + 1e-6)\n        else:\n            locality = 1.0\n\n        normalized_distance = distance / (max(distance_matrix[current_node]) + 1e-6)\n        normalized_degree = degree / (max(sum(1 for d in row if d > 0) for row in distance_matrix) + 1e-6)\n        combined_score = (1 - progress_factor) * (normalized_distance * (1 + normalized_degree * locality)) + progress_factor * (normalized_distance / (1 + normalized_degree * locality))\n\n        candidates.append((node, combined_score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.81576,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP tour by balancing **distance, degree (connectivity), and locality (centrality of unvisited nodes)**, with weights adjusted based on remaining tour length. Distance is prioritized early (higher weight) and less so later, while degree and locality gain importance as the tour progresses. The score is computed as a weighted product of these factors, favoring nodes that are close, well-connected, and regionally central, with weights adapting to the remaining path length.",
          "thought": "The new algorithm modifies the original by incorporating a **dynamic weighted combination of distance, degree, and locality**, where weights are adjusted based on the remaining tour length and node centrality, favoring nodes that balance proximity, connectivity, and regional centrality with adaptive prioritization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n\n        remaining_nodes = len(unvisited_nodes)\n        tour_length_factor = 1.0 / (remaining_nodes + 1e-6)\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1 + 1e-6)\n\n        weight_distance = 0.7 - 0.3 * tour_length_factor\n        weight_degree = 0.2 + 0.1 * tour_length_factor\n        weight_locality = 0.1 + 0.2 * tour_length_factor\n\n        return (distance ** weight_distance) * (degree ** weight_degree) * (locality ** weight_locality)\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.92587,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with additional heuristics to balance distance, connectivity (degree), and locality. It prioritizes minimal distance while adjusting the selection based on node connectivity (lower degree preferred) and proximity to remaining unvisited nodes (higher locality score preferred). The score is computed as `distance + (1/(degree+\u03b5)) * locality`, where locality is inversely proportional to the average distance to unvisited nodes. This ensures the algorithm considers both immediate proximity and global path efficiency.",
          "thought": "The new algorithm combines the greedy approach of always choosing the closest node with the No.2 algorithm's consideration of node degree and locality, creating a balanced score that prioritizes minimal distance while also accounting for connectivity and proximity to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n        else:\n            locality = 1.0\n        score = distance + (1.0 / (degree + 1e-6)) * locality\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.95173,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance to the current node, while also considering node degree (lower degree preferred) and locality (inverse of average distance to remaining nodes), with locality weighted by 0.4. The heuristic balances distance, degree, and locality, favoring nodes that minimize immediate travel while avoiding high-degree nodes and improving future path efficiency. The code iterates over unvisited nodes, computes a weighted score for each, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the No.1 algorithm's balance of distance, degree, and locality with the No.2 algorithm's structure, prioritizing nodes that minimize immediate distance while considering node degree (lower preferred) and locality (inverse of average distance to remaining nodes), scaled by 0.4.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = next_distance + 0.4 * (1.0 / (degree + 1e-6)) * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.97655,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing shorter distances while balancing connectivity (degree) and locality (average distance to remaining unvisited nodes). Nodes with lower distance, higher degree, and better locality receive higher scores, making them more likely to be chosen. The score is computed as distance divided by a weighted sum of degree and locality, with locality calculated dynamically for remaining nodes.",
          "thought": "The new algorithm prioritizes nodes with shorter distances, higher connectivity, and closer proximity to unvisited nodes, but uses a different scoring mechanism where distance is divided by a weighted sum of degree and locality, with locality calculated as the average distance to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        else:\n            locality = 1.0\n        score = distance / (1.0 + 0.5 * (degree + 1e-6) + locality)\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 7.00421,
          "other_inf": null
     }
]