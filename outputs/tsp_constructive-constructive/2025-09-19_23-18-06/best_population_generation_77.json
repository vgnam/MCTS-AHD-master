{
     "algorithm": "The algorithm selects the next node in TSP by balancing locality (prioritizing nearby nodes) with global considerations (avoiding nodes far from remaining unvisited nodes). It dynamically adjusts locality weight using a sigmoid-based function of remaining nodes and penalizes high-average-distance nodes, prioritizing shorter immediate distances, lower-degree nodes, and reduced penalties. The selection is made by minimizing a weighted sum of these factors.",
     "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight for locality based on the remaining unvisited nodes, using a sigmoid function to adjust the locality's influence, and adding a penalty term for nodes with high average distances to remaining nodes to further improve path efficiency.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))\n            penalty = 0.5 * avg_distance / max(distance_matrix[current_node]) if max(distance_matrix[current_node]) > 0 else 0\n            total_distance = next_distance + dynamic_weight * (1.0 / (degree + 1e-6)) * locality - penalty\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
     "objective": 6.45212,
     "other_inf": null
}