[
     {
          "algorithm": "The algorithm selects the next node by combining immediate distance, node centrality (inverse of average distance to all other nodes), and a detour penalty (maximum detour cost relative to remaining path length), with centrality and locality factors given higher weight (0.3 and 0.4, respectively) than immediate distance. The score prioritizes nodes that balance short-term efficiency with long-term path quality, while the degree of connectivity (number of reachable nodes) and detour penalty further refine the selection.",
          "thought": "The new algorithm introduces a hybrid scoring mechanism that combines immediate distance with a dynamic connectivity-aware locality factor, where the locality is adjusted by the node's centrality (inverse of average distance to all other nodes) and a novel \"detour penalty\" that accounts for the maximum detour cost relative to the remaining path length, emphasizing both immediate efficiency and long-term path quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    candidates = []\n    remaining_count = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n\n            centrality = 1.0 / (sum(distance_matrix[node]) / (total_nodes - 1) + 1e-6)\n            detour_penalty = max(distance_matrix[node][n] for n in remaining_nodes) / (remaining_count ** 0.5)\n\n            score = distance * (1.0 + 0.3 * degree * locality * centrality) + 0.2 * avg_distance + 0.4 * detour_penalty\n        else:\n            score = distance\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.44574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines progress-driven proximity pressure, centrality, and locality factors while dynamically adjusting detour penalties to balance short-term efficiency and long-term path quality. It prioritizes proximity early in the tour (via proximity_pressure) but gradually increases penalties for detours (dynamic_penalty) to ensure global optimality. Centrality (node connectivity) and locality (average distance to remaining nodes) are weighted higher than proximity late in the tour, while degree (node connections) has moderate influence. The score function balances these factors, with distance being the dominant term but modified by secondary factors.",
          "thought": "The new algorithm combines the progress-driven proximity pressure from No.1 with the centrality and locality factors from No.2, while adding a dynamic detour penalty that increases with tour progress to balance short-term efficiency with long-term path quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    progress_ratio = 1.0 - (total_unvisited / (total_unvisited + len(distance_matrix)))\n    proximity_pressure = (1.0 - progress_ratio) ** 2\n    dynamic_penalty = 0.5 * progress_ratio\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if total_unvisited > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n\n            centrality = 1.0 / (sum(distance_matrix[node]) / (len(distance_matrix) - 1) + 1e-6)\n            detour_penalty = max(distance_matrix[node][n] for n in remaining_nodes) / (total_unvisited ** 0.5) * dynamic_penalty\n\n            score = distance * (1.0 + 0.4 * degree * locality * centrality) + 0.3 * avg_distance + 0.5 * proximity_pressure * distance + 0.2 * detour_penalty\n        else:\n            score = distance\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.44825,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing distance, connectivity, locality, and centrality, with adaptive weights based on node degrees and remaining unvisited nodes. It prioritizes shorter distances, higher connectivity, and centrality, while dynamically adjusting weights to favor local optimization early and global optimization later. The score combines these factors with a weighted sum, where distance dominates but is moderated by connectivity, locality, and detour costs.",
          "thought": "The new algorithm integrates the dynamic detour cost scaling from No.1, the weighted combination of distance, connectivity, and locality from No.2, and the centrality and locality prioritization from No.3, while introducing a novel adaptive weight adjustment based on remaining nodes and node degrees to balance local and global optimization more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    candidates = []\n    remaining_count = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            min_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n            centrality = 1.0 / (sum(distance_matrix[node]) / (total_nodes - 1) + 1e-6)\n\n            detour_cost = (max_distance - min_distance) * (remaining_count / (remaining_count + 1))\n            adaptive_weight = (degree / total_nodes) * (remaining_count / (remaining_count + 1))\n\n            score = distance * (1.0 + 0.3 * (degree * locality * centrality) + adaptive_weight) + 0.2 * avg_distance + 0.4 * detour_cost\n        else:\n            score = distance\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.45208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing locality (prioritizing nearby nodes) with global considerations (avoiding nodes far from remaining unvisited nodes). It dynamically adjusts locality weight using a sigmoid-based function of remaining nodes and penalizes high-average-distance nodes, prioritizing shorter immediate distances, lower-degree nodes, and reduced penalties. The selection is made by minimizing a weighted sum of these factors.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight for locality based on the remaining unvisited nodes, using a sigmoid function to adjust the locality's influence, and adding a penalty term for nodes with high average distances to remaining nodes to further improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))\n            penalty = 0.5 * avg_distance / max(distance_matrix[current_node]) if max(distance_matrix[current_node]) > 0 else 0\n            total_distance = next_distance + dynamic_weight * (1.0 / (degree + 1e-6)) * locality - penalty\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.45212,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple metrics (distance, degree, locality, connectivity, and gap penalty) with dynamically weighted priorities, where early stages emphasize distance and degree (higher weights) while later stages shift to locality, connectivity, and gap penalty (lower weights). Exploration factors decay exponentially to balance exploration and exploitation, ensuring the solution adapts to the current state of the tour. The `select_next_node` function evaluates candidate nodes based on these weighted scores and selects the one with the minimal score, prioritizing immediate distance early and refining choices with additional metrics as the tour progresses.",
          "thought": "This new algorithm combines dynamic weighting of immediate distance, node degree, locality, connectivity, and tour gap metrics, with exploration factors that decay exponentially to balance exploration and exploitation, prioritizing distance and degree early and shifting toward locality, connectivity, and gap penalty as nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_degree(node):\n        return sum(1 for d in distance_matrix[node] if d > 0)\n\n    def node_locality(node, unvisited):\n        if len(unvisited) <= 1:\n            return 0.0\n        remaining = unvisited - {node}\n        return 1.0 / (sum(distance_matrix[node][n] for n in remaining) / len(remaining) + 1e-6)\n\n    def node_connectivity(node, unvisited):\n        if len(unvisited) <= 2:\n            return 1.0\n        remaining = unvisited - {node}\n        min_dist = min(distance_matrix[node][n] for n in remaining)\n        max_dist = max(distance_matrix[node][n] for n in remaining)\n        if max_dist == 0:\n            return 0.0\n        return min_dist / max_dist\n\n    def tour_gap_penalty(node, current, unvisited):\n        if len(unvisited) <= 2:\n            return 0.0\n        remaining = unvisited - {node}\n        avg_dist = sum(distance_matrix[current][n] for n in remaining) / len(remaining)\n        return (distance_matrix[current][node] - avg_dist) / avg_dist\n\n    exploration_factor = 0.7 ** (10 - len(unvisited_nodes))\n    candidates = []\n\n    for node in unvisited_nodes:\n        immediate_dist = distance_matrix[current_node][node]\n        degree = node_degree(node)\n        locality = node_locality(node, unvisited_nodes)\n        connectivity = node_connectivity(node, unvisited_nodes)\n        gap_penalty = tour_gap_penalty(node, current_node, unvisited_nodes)\n        weight_dist = 0.4 + 0.3 * exploration_factor\n        weight_degree = 0.2 * (1 - exploration_factor)\n        weight_locality = 0.1 * exploration_factor\n        weight_conn = 0.2 * (1 - exploration_factor)\n        weight_gap = 0.1 * exploration_factor\n        score = (weight_dist * immediate_dist +\n                 weight_degree * degree +\n                 weight_locality * locality +\n                 weight_conn * connectivity +\n                 weight_gap * gap_penalty)\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.47318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three criteria to select the next node: immediate distance (weight 1.5), node degree (weight 0.3), and locality (weight 0.2), balancing short-term and long-term optimization. Immediate distance is prioritized, while degree and locality play supporting roles. The code iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with the degree and locality considerations of No.1, using weights of 1.5 for immediate distance, 0.3 for degree, and 0.2 for locality to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            degree = sum(1 for d in distance_matrix[node] if d > 0)\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = 1.5 * next_distance + 0.3 * degree + 0.2 * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.5514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach (prioritizing the closest node) with a locality consideration (prioritizing nodes that are central to remaining unvisited nodes), weighted by a parameter (0.2) to balance short-term and long-term optimization. The locality term is calculated as the inverse of the average distance from the candidate node to all other unvisited nodes, ensuring nodes with better centrality contribute more to the decision. The code structure iterates through unvisited nodes, computes a weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the greedy approach of selecting the closest node with a locality consideration, inspired by No.1's weighted criteria, to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = next_distance + 0.2 * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.56571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with dynamic adjustments to balance immediate distance, average remaining distances, and penalties for far nodes. It prioritizes minimizing immediate distances (`next_distance`) while considering long-term connectivity through a weighted average of remaining distances (`dynamic_weight * 0.3 * avg_distance`), and penalizes high-penalty nodes (`-penalty`) to avoid suboptimal paths. The dynamic weight (`dynamic_weight`) scales with the number of remaining nodes, giving more emphasis to long-term planning as the tour progresses.",
          "thought": "The new algorithm combines the greedy approach of No.2 with the dynamic locality adjustment and penalty mechanism of No.1, where it balances immediate distance with a scaled average remaining distance and penalizes high-penalty nodes to improve path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))\n            penalty = 0.5 * avg_distance / max(distance_matrix[current_node]) if max(distance_matrix[current_node]) > 0 else 0\n            total_distance = next_distance + dynamic_weight * 0.3 * avg_distance - penalty\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.58705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP tour by balancing distance, connectivity (degree), locality (average distance to remaining nodes), and a progress-driven \"proximity pressure\" term. It prioritizes shorter distances and nodes with higher connectivity while adapting weights based on remaining nodes. The score combines these factors with higher emphasis on distance and connectivity early in the tour, while proximity pressure increases later to encourage closer connections.",
          "thought": "This new algorithm modifies the selection criteria by incorporating a dynamic weighting factor that adapts based on the remaining unvisited nodes, combining distance, connectivity, locality, and a novel \"proximity pressure\" term that intensifies as the tour progresses to encourage closer connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    progress_ratio = 1.0 - (total_unvisited / (total_unvisited + len(distance_matrix)))\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if total_unvisited > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n\n        proximity_pressure = (1.0 - progress_ratio) ** 2\n        dynamic_weight = 0.7 + 0.3 * progress_ratio\n\n        score = (distance * (1.0 + 0.5 * (degree + 1e-6) * locality) +\n                0.3 * avg_distance * dynamic_weight +\n                0.2 * proximity_pressure * distance)\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.60702,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm enhances the greedy approach by dynamically weighting node selection based on **distance**, **degree** (connectivity), and **locality** (inverse of average distance to unvisited nodes). It prioritizes nodes that balance proximity, connectivity, and regional centrality, with degree and locality given lower priority than distance. The `adjusted_score` combines these factors multiplicatively, favoring nodes with lower distances, higher degrees, and better regional centrality.",
          "thought": "The new algorithm enhances the greedy approach by incorporating a dynamic weighting mechanism that combines distance, node degree, and a locality factor (inverse of the average distance to unvisited nodes), creating a more adaptive selection criterion that favors nodes balancing proximity, connectivity, and regional centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance * (1.0 + 0.5 * (1.0 / (degree + 1e-6))) * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     }
]