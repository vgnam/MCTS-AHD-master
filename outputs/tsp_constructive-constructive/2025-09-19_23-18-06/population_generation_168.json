[
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing locality (prioritizing nearby nodes) with global considerations (avoiding nodes far from remaining unvisited nodes). It dynamically adjusts locality weight using a sigmoid-based function of remaining nodes and penalizes high-average-distance nodes, prioritizing shorter immediate distances, lower-degree nodes, and reduced penalties. The selection is made by minimizing a weighted sum of these factors.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight for locality based on the remaining unvisited nodes, using a sigmoid function to adjust the locality's influence, and adding a penalty term for nodes with high average distances to remaining nodes to further improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))\n            penalty = 0.5 * avg_distance / max(distance_matrix[current_node]) if max(distance_matrix[current_node]) > 0 else 0\n            total_distance = next_distance + dynamic_weight * (1.0 / (degree + 1e-6)) * locality - penalty\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.45212,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple metrics (distance, degree, locality, connectivity, and gap penalty) with dynamically weighted priorities, where early stages emphasize distance and degree (higher weights) while later stages shift to locality, connectivity, and gap penalty (lower weights). Exploration factors decay exponentially to balance exploration and exploitation, ensuring the solution adapts to the current state of the tour. The `select_next_node` function evaluates candidate nodes based on these weighted scores and selects the one with the minimal score, prioritizing immediate distance early and refining choices with additional metrics as the tour progresses.",
          "thought": "This new algorithm combines dynamic weighting of immediate distance, node degree, locality, connectivity, and tour gap metrics, with exploration factors that decay exponentially to balance exploration and exploitation, prioritizing distance and degree early and shifting toward locality, connectivity, and gap penalty as nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_degree(node):\n        return sum(1 for d in distance_matrix[node] if d > 0)\n\n    def node_locality(node, unvisited):\n        if len(unvisited) <= 1:\n            return 0.0\n        remaining = unvisited - {node}\n        return 1.0 / (sum(distance_matrix[node][n] for n in remaining) / len(remaining) + 1e-6)\n\n    def node_connectivity(node, unvisited):\n        if len(unvisited) <= 2:\n            return 1.0\n        remaining = unvisited - {node}\n        min_dist = min(distance_matrix[node][n] for n in remaining)\n        max_dist = max(distance_matrix[node][n] for n in remaining)\n        if max_dist == 0:\n            return 0.0\n        return min_dist / max_dist\n\n    def tour_gap_penalty(node, current, unvisited):\n        if len(unvisited) <= 2:\n            return 0.0\n        remaining = unvisited - {node}\n        avg_dist = sum(distance_matrix[current][n] for n in remaining) / len(remaining)\n        return (distance_matrix[current][node] - avg_dist) / avg_dist\n\n    exploration_factor = 0.7 ** (10 - len(unvisited_nodes))\n    candidates = []\n\n    for node in unvisited_nodes:\n        immediate_dist = distance_matrix[current_node][node]\n        degree = node_degree(node)\n        locality = node_locality(node, unvisited_nodes)\n        connectivity = node_connectivity(node, unvisited_nodes)\n        gap_penalty = tour_gap_penalty(node, current_node, unvisited_nodes)\n        weight_dist = 0.4 + 0.3 * exploration_factor\n        weight_degree = 0.2 * (1 - exploration_factor)\n        weight_locality = 0.1 * exploration_factor\n        weight_conn = 0.2 * (1 - exploration_factor)\n        weight_gap = 0.1 * exploration_factor\n        score = (weight_dist * immediate_dist +\n                 weight_degree * degree +\n                 weight_locality * locality +\n                 weight_conn * connectivity +\n                 weight_gap * gap_penalty)\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.47318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three criteria to select the next node: immediate distance (weight 1.5), node degree (weight 0.3), and locality (weight 0.2), balancing short-term and long-term optimization. Immediate distance is prioritized, while degree and locality play supporting roles. The code iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with the degree and locality considerations of No.1, using weights of 1.5 for immediate distance, 0.3 for degree, and 0.2 for locality to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            degree = sum(1 for d in distance_matrix[node] if d > 0)\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = 1.5 * next_distance + 0.3 * degree + 0.2 * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.5514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach (prioritizing the closest node) with a locality consideration (prioritizing nodes that are central to remaining unvisited nodes), weighted by a parameter (0.2) to balance short-term and long-term optimization. The locality term is calculated as the inverse of the average distance from the candidate node to all other unvisited nodes, ensuring nodes with better centrality contribute more to the decision. The code structure iterates through unvisited nodes, computes a weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the greedy approach of selecting the closest node with a locality consideration, inspired by No.1's weighted criteria, to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = next_distance + 0.2 * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.56571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with dynamic adjustments to balance immediate distance, average remaining distances, and penalties for far nodes. It prioritizes minimizing immediate distances (`next_distance`) while considering long-term connectivity through a weighted average of remaining distances (`dynamic_weight * 0.3 * avg_distance`), and penalizes high-penalty nodes (`-penalty`) to avoid suboptimal paths. The dynamic weight (`dynamic_weight`) scales with the number of remaining nodes, giving more emphasis to long-term planning as the tour progresses.",
          "thought": "The new algorithm combines the greedy approach of No.2 with the dynamic locality adjustment and penalty mechanism of No.1, where it balances immediate distance with a scaled average remaining distance and penalizes high-penalty nodes to improve path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_weight = 1.0 / (1.0 + 1.5 * (len(remaining_nodes) / len(unvisited_nodes)))\n            penalty = 0.5 * avg_distance / max(distance_matrix[current_node]) if max(distance_matrix[current_node]) > 0 else 0\n            total_distance = next_distance + dynamic_weight * 0.3 * avg_distance - penalty\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.58705,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP tour by balancing distance, connectivity (degree), locality (average distance to remaining nodes), and a progress-driven \"proximity pressure\" term. It prioritizes shorter distances and nodes with higher connectivity while adapting weights based on remaining nodes. The score combines these factors with higher emphasis on distance and connectivity early in the tour, while proximity pressure increases later to encourage closer connections.",
          "thought": "This new algorithm modifies the selection criteria by incorporating a dynamic weighting factor that adapts based on the remaining unvisited nodes, combining distance, connectivity, locality, and a novel \"proximity pressure\" term that intensifies as the tour progresses to encourage closer connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    progress_ratio = 1.0 - (total_unvisited / (total_unvisited + len(distance_matrix)))\n\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n\n        if total_unvisited > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n\n        proximity_pressure = (1.0 - progress_ratio) ** 2\n        dynamic_weight = 0.7 + 0.3 * progress_ratio\n\n        score = (distance * (1.0 + 0.5 * (degree + 1e-6) * locality) +\n                0.3 * avg_distance * dynamic_weight +\n                0.2 * proximity_pressure * distance)\n\n        candidates.append((node, score))\n\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.60702,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm enhances the greedy approach by dynamically weighting node selection based on **distance**, **degree** (connectivity), and **locality** (inverse of average distance to unvisited nodes). It prioritizes nodes that balance proximity, connectivity, and regional centrality, with degree and locality given lower priority than distance. The `adjusted_score` combines these factors multiplicatively, favoring nodes with lower distances, higher degrees, and better regional centrality.",
          "thought": "The new algorithm enhances the greedy approach by incorporating a dynamic weighting mechanism that combines distance, node degree, and a locality factor (inverse of the average distance to unvisited nodes), creating a more adaptive selection criterion that favors nodes balancing proximity, connectivity, and regional centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance * (1.0 + 0.5 * (1.0 / (degree + 1e-6))) * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (highest weight), heavily favors nodes with higher degrees (1.0 weight), and lightly considers locality (0.1 weight), balancing travel efficiency, connectivity, and future path potential. The code computes a weighted sum for each candidate node, selecting the one with the minimal total score, where the degree and locality are derived from the distance matrix.",
          "thought": "The new algorithm prioritizes immediate distance while heavily weighting node degree (higher degree preferred) and lightly considering locality (inverse of average distance to remaining nodes), with locality weighted by 0.1. The heuristic balances distance, degree, and locality, favoring nodes that minimize immediate travel while preferring high-degree nodes and slightly improving future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        next_distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n            total_distance = next_distance + 1.0 * degree + 0.1 * locality\n        else:\n            total_distance = next_distance\n        candidates.append((node, total_distance))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.61071,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP path by balancing immediate distance, node connectivity (degree), and locality (average distance to remaining unvisited nodes), using a weighted product of these factors. It prioritizes lower distances and higher connectivity/locality, while the 0.3 * avg_distance term slightly balances the score toward shorter future paths. The code avoids local optima by always evaluating all unvisited candidates.",
          "thought": "This new algorithm combines the hybrid distance-averaging approach with multiplicative scoring, incorporating both immediate distance and future potential through a weighted product of distance, degree (connectivity), and locality (average distance to remaining nodes), while avoiding local optima by considering probabilistic elements in the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            locality = 1.0 / (avg_distance + 1e-6)\n        else:\n            avg_distance = 0.0\n            locality = 1.0\n        score = distance * (1.0 + 0.5 * (degree + 1e-6) * locality) + 0.3 * avg_distance\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.61206,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing distance, node degree (connectivity), and locality (average distance to remaining unvisited nodes), prioritizing nodes with shorter distances, higher connectivity, and closer proximity to unvisited nodes. The score combines these factors multiplicatively, where distance is weighted by a term that includes degree and locality, with small constants (1e-6) to avoid division by zero. The node with the minimum score is chosen.",
          "thought": "The new algorithm combines No.1's balanced weighting of distance, degree, and locality with No.2's structured candidate evaluation. It evaluates nodes by multiplying distance with a weighted sum of degree and locality terms, then selects the node with the minimum combined score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    candidates = []\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) + 1e-6)\n        else:\n            locality = 1.0\n        score = distance * (1.0 + 0.5 * (degree + 1e-6) * locality)\n        candidates.append((node, score))\n    next_node, _ = min(candidates, key=lambda x: x[1])\n    return next_node",
          "objective": 6.62239,
          "other_inf": null
     }
]