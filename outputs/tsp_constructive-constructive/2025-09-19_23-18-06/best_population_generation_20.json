{
     "algorithm": "The algorithm enhances the greedy approach by dynamically weighting node selection based on **distance**, **degree** (connectivity), and **locality** (inverse of average distance to unvisited nodes). It prioritizes nodes that balance proximity, connectivity, and regional centrality, with degree and locality given lower priority than distance. The `adjusted_score` combines these factors multiplicatively, favoring nodes with lower distances, higher degrees, and better regional centrality.",
     "thought": "The new algorithm enhances the greedy approach by incorporating a dynamic weighting mechanism that combines distance, node degree, and a locality factor (inverse of the average distance to unvisited nodes), creating a more adaptive selection criterion that favors nodes balancing proximity, connectivity, and regional centrality.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def adjusted_score(node):\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        if not unvisited_nodes:\n            locality = 1.0\n        else:\n            locality = 1.0 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-6)\n        return distance * (1.0 + 0.5 * (1.0 / (degree + 1e-6))) * locality\n\n    next_node = min(unvisited_nodes, key=adjusted_score)\n    return next_node",
     "objective": 6.60833,
     "other_inf": null
}