[
     {
          "algorithm": "The algorithm combines the immediate distance to the current node with the average distance from all unvisited nodes to the destination, prioritizing local efficiency while considering global progress. It selects the next node by minimizing the sum of these two factors, balancing short-term and long-term objectives in the path construction. The distance to the current node is weighted equally with the average distance to the destination, making both factors critical in the decision-making process.",
          "thought": "The new algorithm combines the local optimality of the No.2 algorithm with a global consideration inspired by the No.1 algorithm, by selecting the next node that minimizes the sum of the immediate distance to the current node and the average distance to the destination from all unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_destination = sum(distance_matrix[n][destination_node] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        score = distance_to_node + avg_distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.85712,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance while moving toward the destination. If no unvisited nodes remain, it returns the destination. The code emphasizes local optimality by always choosing the nearest neighbor, ignoring the global path structure.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance from the current node, ensuring progress toward the destination by prioritizing nodes that reduce the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (immediate cost) and global considerations (average remaining distances to unvisited nodes and destination), with the weight for global factors decreasing as the number of unvisited nodes grows (prioritizing local decisions in dense scenarios). The score combines the current node's distance and the weighted average of remaining distances, favoring nodes that minimize this combined metric. The weight dynamically adjusts to the problem's density, ensuring adaptability.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the balance between local and global factors based on the remaining unvisited nodes' density, where the weight for the average remaining distance is inversely proportional to the number of unvisited nodes to prioritize global considerations in sparse scenarios.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_count = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = 1.0 / max(1, remaining_count) if remaining_count > 0 else 1.0\n        score = distance_to_node + weight * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.18439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing local and global optimality, using a weighted combination of the distance from the current node (high priority) and the distance to the destination (lower priority, weighted by 0.3). It selects the next node with the minimal combined score, ensuring proximity to the current node while still considering the path's overall efficiency. The function iterates through unvisited nodes, computes the score for each, and returns the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance to the current node and distance to the destination, balancing local and global optimality by allowing some flexibility in choosing the next node while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination  # Weighted combination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing proximity to the current node (weighted 0.7) and potential progress toward the destination (weighted 0.3), creating an adaptive selection mechanism that prioritizes local proximity while still considering global context. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the minimum score, ensuring a trade-off between immediate proximity and long-term efficiency.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weighting factor that balances proximity to the current node and potential progress toward the destination, introducing a more adaptive selection mechanism that considers both local and global context.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weight = 0.7\n        score = weight * distance_to_node + (1 - weight) * distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the immediate distance from the current node with a weighted consideration of the distance to the destination node. It prioritizes minimizing the sum of the current distance and half of the distance to the destination, favoring nodes that reduce both immediate and long-term path costs. The score calculation (`distance_to_node + 0.5 * distance_to_dest`) ensures a trade-off between local and global optimization, with the destination distance given half the weight of the immediate distance.",
          "thought": "The new algorithm prioritizes nodes that balance the immediate distance to the current node with the potential to reduce the overall path length by considering the distance to the destination, aiming to minimize the total tour length through a weighted selection criterion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = distance_to_node + 0.5 * distance_to_dest\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing local distance (weighted by `alpha=0.7`) and global centrality (average distance to remaining unvisited nodes). It prioritizes immediate proximity while accounting for a node's potential to improve the overall path, selecting the node with the lowest combined score. The weighting factor ensures a trade-off between short-term and long-term path optimization.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weighting factor that balances local distance and potential global path improvement, using a heuristic that considers both immediate proximity and the node's centrality in the remaining unvisited set.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    alpha = 0.7  # Weighting factor for local distance (0.7 gives more weight to distance)\n\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        global_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        score = alpha * local_distance + (1 - alpha) * global_centrality\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.71312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (70% weight) and the average distance to remaining unvisited nodes plus the destination (30% weight), prioritizing local proximity while maintaining global connectivity. The `score` calculation ensures a trade-off between minimizing immediate travel distance and reducing long-term travel costs, making it more robust than pure nearest-neighbor approaches. The weights (0.7 and 0.3) are fixed, giving higher priority to immediate distance but still considering global context.",
          "thought": "The new algorithm combines the local optimality of No.1 (prioritizing the nearest neighbor) with the global consideration of No.2 (balancing immediate distance and average remaining distances). It selects the next node by minimizing a weighted sum of the immediate distance and the average distance to remaining unvisited nodes (plus the destination), where the weights are tuned to prioritize local proximity while still considering global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        score = 0.7 * distance_to_node + 0.3 * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.77432,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of the immediate distance from the current node and the average distance to all remaining unvisited nodes (plus the destination). This balances short-term and long-term path costs, aiming for a more efficient tour by considering both local and global connectivity. The `distance_to_node` (local) and `avg_remaining_distance` (global) are weighted equally in the score calculation, with the node yielding the lowest total score chosen next.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the current distance and the average distance to all remaining unvisited nodes, balancing immediate and global path costs to achieve a more balanced tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        score = distance_to_node + avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.4729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of the current distance to the node and the maximum possible remaining distance from that node to the destination or other unvisited nodes, balancing immediate and worst-case path costs. The `distance_to_node` is prioritized over the `max_remaining_distance`, ensuring the algorithm favors closer nodes while considering potential future path lengths. The `select_next_node` function iterates through unvisited nodes, computes the total cost for each, and chooses the node with the lowest sum.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the sum of the current distance and the maximum possible remaining distance to the destination, ensuring a balance between immediate and worst-case path costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_total = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        max_remaining_distance = max([distance_matrix[node][n] for n in unvisited_nodes if n != node] + [distance_matrix[node][destination_node]])\n        total = distance_to_node + max_remaining_distance\n        if total < min_total:\n            min_total = total\n            next_node = node\n    return next_node",
          "objective": 8.62178,
          "other_inf": null
     }
]