[
     {
          "algorithm": "The algorithm combines the immediate distance to the current node with the average distance from all unvisited nodes to the destination, prioritizing local efficiency while considering global progress. It selects the next node by minimizing the sum of these two factors, balancing short-term and long-term objectives in the path construction. The distance to the current node is weighted equally with the average distance to the destination, making both factors critical in the decision-making process.",
          "thought": "The new algorithm combines the local optimality of the No.2 algorithm with a global consideration inspired by the No.1 algorithm, by selecting the next node that minimizes the sum of the immediate distance to the current node and the average distance to the destination from all unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_destination = sum(distance_matrix[n][destination_node] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        score = distance_to_node + avg_distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.85712,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance while moving toward the destination. If no unvisited nodes remain, it returns the destination. The code emphasizes local optimality by always choosing the nearest neighbor, ignoring the global path structure.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance from the current node, ensuring progress toward the destination by prioritizing nodes that reduce the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing exploration (distance to the current node) and exploitation (weighted distance to the destination), while penalizing nodes far from the destination. The dynamic weight (`1.0 / (1.0 + remaining_nodes)`) reduces the destination's influence as more nodes are visited, and a penalty (`max(0, distance_to_dest - 2 * distance_to_current_dest)`) discourages excessively distant nodes. The score combines these factors, prioritizing closer and more relevant nodes while adaptively adjusting for remaining steps.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for the destination distance, adjusting it based on the remaining number of unvisited nodes, and includes a penalty term for nodes that are too far from the destination, encouraging a more balanced exploration-exploitation trade-off.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        penalty = max(0, distance_to_dest - 2 * distance_matrix[current_node][destination_node])  # Penalty for distant nodes\n        score = distance_to_node + weight * distance_to_dest + penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.14314,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (immediate cost) and global considerations (average remaining distances to unvisited nodes and destination), with the weight for global factors decreasing as the number of unvisited nodes grows (prioritizing local decisions in dense scenarios). The score combines the current node's distance and the weighted average of remaining distances, favoring nodes that minimize this combined metric. The weight dynamically adjusts to the problem's density, ensuring adaptability.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the balance between local and global factors based on the remaining unvisited nodes' density, where the weight for the average remaining distance is inversely proportional to the number of unvisited nodes to prioritize global considerations in sparse scenarios.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_count = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = 1.0 / max(1, remaining_count) if remaining_count > 0 else 1.0\n        score = distance_to_node + weight * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.18439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the next node (doubled weight) while lightly considering the distance from that node to the destination (0.25 weight), balancing local optimization with global awareness. The scoring function sums these weighted distances to select the next node with the lowest total score, ensuring efficient path progression toward the destination.",
          "thought": "The new algorithm modifies the scoring function to prioritize the immediate distance more heavily by doubling its weight, while still considering the distance to the destination with a reduced weight of 0.25, creating a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = 2 * distance_to_node + 0.25 * distance_to_dest\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.21792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing local and global optimality, using a weighted combination of the distance from the current node (high priority) and the distance to the destination (lower priority, weighted by 0.3). It selects the next node with the minimal combined score, ensuring proximity to the current node while still considering the path's overall efficiency. The function iterates through unvisited nodes, computes the score for each, and returns the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance to the current node and distance to the destination, balancing local and global optimality by allowing some flexibility in choosing the next node while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination  # Weighted combination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing proximity to the current node (weighted 0.7) and potential progress toward the destination (weighted 0.3), creating an adaptive selection mechanism that prioritizes local proximity while still considering global context. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the minimum score, ensuring a trade-off between immediate proximity and long-term efficiency.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weighting factor that balances proximity to the current node and potential progress toward the destination, introducing a more adaptive selection mechanism that considers both local and global context.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weight = 0.7\n        score = weight * distance_to_node + (1 - weight) * distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the immediate distance from the current node with a weighted consideration of the distance to the destination node. It prioritizes minimizing the sum of the current distance and half of the distance to the destination, favoring nodes that reduce both immediate and long-term path costs. The score calculation (`distance_to_node + 0.5 * distance_to_dest`) ensures a trade-off between local and global optimization, with the destination distance given half the weight of the immediate distance.",
          "thought": "The new algorithm prioritizes nodes that balance the immediate distance to the current node with the potential to reduce the overall path length by considering the distance to the destination, aiming to minimize the total tour length through a weighted selection criterion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = distance_to_node + 0.5 * distance_to_dest\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing closer nodes early (via proximity bonus) while balancing destination proximity (weighted by a decreasing factor from 0.8 to 0.2) to ensure efficient path construction. It scores each unvisited node based on immediate distance, destination distance, and proximity, with the weighting factor reducing as the number of unvisited nodes decreases. The score combines these factors to select the next node, favoring immediate proximity early and gradually shifting focus toward the destination.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting factor that adjusts based on the remaining number of unvisited nodes, favoring closer nodes early and balancing distances to the destination as the path progresses. It calculates a weighted score combining immediate distance, destination distance, and a novel \"proximity bonus\" for nodes close to the current node, with the weighting factor decreasing linearly from 0.8 to 0.2 as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.2, 0.8 - 0.6 * (total_unvisited / (total_unvisited + 1)))\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_bonus = 1 / (1 + distance_to_node)\n        score = distance_to_node + weight_factor * distance_to_dest + 0.5 * proximity_bonus\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.45307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term efficiency (distance from current node) and long-term efficiency (distance to destination) by combining them with a fixed weight (0.6 for local, 0.4 for global) in a linear scoring function. It prioritizes local proximity over global proximity, selecting the next node with the lowest weighted sum of these distances. The structure iterates through unvisited nodes, computes the score, and updates the best candidate dynamically.",
          "thought": "The new algorithm combines the adaptive weighting from No.1 (balancing local and global proximity) with the simplified scoring approach of No.2. It dynamically adjusts the weight between immediate distance and destination proximity, prioritizing nodes that offer a balanced trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = 0.6\n        score = weight * distance_to_node + (1 - weight) * distance_to_dest\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     }
]