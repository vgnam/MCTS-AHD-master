[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance while moving toward the destination. If no unvisited nodes remain, it returns the destination. The code emphasizes local optimality by always choosing the nearest neighbor, ignoring the global path structure.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance from the current node, ensuring progress toward the destination by prioritizing nodes that reduce the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (immediate cost) and global considerations (average remaining distances to unvisited nodes and destination), with the weight for global factors decreasing as the number of unvisited nodes grows (prioritizing local decisions in dense scenarios). The score combines the current node's distance and the weighted average of remaining distances, favoring nodes that minimize this combined metric. The weight dynamically adjusts to the problem's density, ensuring adaptability.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the balance between local and global factors based on the remaining unvisited nodes' density, where the weight for the average remaining distance is inversely proportional to the number of unvisited nodes to prioritize global considerations in sparse scenarios.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_count = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = 1.0 / max(1, remaining_count) if remaining_count > 0 else 1.0\n        score = distance_to_node + weight * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.18439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the immediate distance from the current node with a weighted consideration of the distance to the destination node. It prioritizes minimizing the sum of the current distance and half of the distance to the destination, favoring nodes that reduce both immediate and long-term path costs. The score calculation (`distance_to_node + 0.5 * distance_to_dest`) ensures a trade-off between local and global optimization, with the destination distance given half the weight of the immediate distance.",
          "thought": "The new algorithm prioritizes nodes that balance the immediate distance to the current node with the potential to reduce the overall path length by considering the distance to the destination, aiming to minimize the total tour length through a weighted selection criterion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = distance_to_node + 0.5 * distance_to_dest\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (70% weight) and the average distance to remaining unvisited nodes plus the destination (30% weight), prioritizing local proximity while maintaining global connectivity. The `score` calculation ensures a trade-off between minimizing immediate travel distance and reducing long-term travel costs, making it more robust than pure nearest-neighbor approaches. The weights (0.7 and 0.3) are fixed, giving higher priority to immediate distance but still considering global context.",
          "thought": "The new algorithm combines the local optimality of No.1 (prioritizing the nearest neighbor) with the global consideration of No.2 (balancing immediate distance and average remaining distances). It selects the next node by minimizing a weighted sum of the immediate distance and the average distance to remaining unvisited nodes (plus the destination), where the weights are tuned to prioritize local proximity while still considering global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        score = 0.7 * distance_to_node + 0.3 * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.77432,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of the immediate distance from the current node and the average distance to all remaining unvisited nodes (plus the destination). This balances short-term and long-term path costs, aiming for a more efficient tour by considering both local and global connectivity. The `distance_to_node` (local) and `avg_remaining_distance` (global) are weighted equally in the score calculation, with the node yielding the lowest total score chosen next.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the current distance and the average distance to all remaining unvisited nodes, balancing immediate and global path costs to achieve a more balanced tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        score = distance_to_node + avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.4729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of the current distance to the node and the maximum possible remaining distance from that node to the destination or other unvisited nodes, balancing immediate and worst-case path costs. The `distance_to_node` is prioritized over the `max_remaining_distance`, ensuring the algorithm favors closer nodes while considering potential future path lengths. The `select_next_node` function iterates through unvisited nodes, computes the total cost for each, and chooses the node with the lowest sum.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the sum of the current distance and the maximum possible remaining distance to the destination, ensuring a balance between immediate and worst-case path costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_total = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        max_remaining_distance = max([distance_matrix[node][n] for n in unvisited_nodes if n != node] + [distance_matrix[node][destination_node]])\n        total = distance_to_node + max_remaining_distance\n        if total < min_total:\n            min_total = total\n            next_node = node\n    return next_node",
          "objective": 8.62178,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance to the current node and a weighted average of remaining distances, where the weight dynamically adjusts based on the proportion of unvisited nodes. It prioritizes shorter immediate distances while accounting for global progress, with the weighting factor (`1 + remaining_ratio`) emphasizing global considerations as more nodes remain unvisited. The score combines these factors to guide the selection toward a node that minimizes both immediate and projected future distances.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor for the average remaining distance, which adjusts based on the proportion of unvisited nodes to the total nodes, promoting a balance between local and global considerations in the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node] + [destination_node]\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = 1 + remaining_ratio\n        score = distance_to_node + weight * avg_remaining_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 10.16626,
          "other_inf": null
     }
]