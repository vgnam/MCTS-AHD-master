[
     {
          "algorithm": "The algorithm combines a nearest-neighbor heuristic (70% weight) with a global measure (30% weight) that balances centrality (inverse sum of all distances) and inverse average distance to unvisited nodes. It prioritizes local proximity (via nearest neighbor) while incorporating limited global considerations to avoid myopia, with the hybrid score ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the nearest neighbor heuristic from No.2 with a refined global measure that considers both centrality and inverse global distance, inspired by No.1, to balance local and global optimization with a hybrid score (70% local, 30% global).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_measure = lambda node: 0.7 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.3 * (1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10))\n    hybrid_score = lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * global_measure(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.52706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest-neighbor) and global (centrality and unvisited-distance) factors, adjusting weights based on the remaining unvisited nodes' density. Local weight increases as the tour progresses, prioritizing nearest neighbors early, while global factors (centrality and average unvisited distance) gain importance later. The hybrid score combines these factors with dynamic weights, ensuring a smooth transition between local and global optimization.",
          "thought": "The new algorithm modifies the hybrid approach by incorporating a dynamic weight adjustment mechanism that balances local (nearest-neighbor) and global (centrality and unvisited-distance) factors, where weights adapt based on the remaining unvisited nodes' density, ensuring a smoother transition between local and global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weights based on remaining unvisited nodes\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.7 + 0.3 * (1 - remaining_ratio)  # Increase local weight as tour progresses\n    global_weight = 1 - local_weight\n\n    # Nearest-neighbor component\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Global components\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def unvisited_avg_distance(node):\n        return 1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10)\n\n    # Hybrid score with dynamic weights\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * (0.6 * centrality(node) + 0.4 * unvisited_avg_distance(node))\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.62032,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local distance and global centrality dynamically: early in the tour, it prioritizes high centrality (global_weight \u2248 0.7) to ensure the path remains central, while later it shifts to minimizing local distance (local_weight \u2248 0.7) to optimize the immediate next step. The hybrid score combines these factors using a weighted sum, where weights adjust based on the remaining unvisited nodes.",
          "thought": "The new algorithm modifies the hybrid scoring by emphasizing centrality early in the tour (high global_weight) and shifting to local distance later (high local_weight), while the original prioritizes local distance early and centrality later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    global_weight = 0.7 + 0.3 * (1 - remaining_ratio)\n    local_weight = 1 - global_weight\n\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * centrality(node)\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.73095,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances global centrality (80% weight) and local proximity (20% weight) to select the next node in TSP. It prioritizes nodes with higher centrality (inverse of total distances to all nodes) while slightly favoring nearby nodes to avoid premature local optima. The `global_centrality` function combines these factors, and the next node is chosen via `min` over unvisited nodes.",
          "thought": "The new algorithm prioritizes a global centrality measure (80% weight) that considers the inverse of the sum of distances to all nodes, combined with a limited local proximity factor (20% weight) to ensure balanced exploration and exploitation, avoiding premature convergence to local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    global_centrality = lambda node: 0.8 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.2 * (distance_matrix[current_node][node])\n    next_node = min(unvisited_nodes, key=global_centrality)\n    return next_node",
          "objective": 6.81635,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances global centrality (60% weight) and local proximity (40% weight), selecting the next node by minimizing a hybrid score that combines the inverse of total distances (global centrality) and the direct distance from the current node (local proximity). The code prioritizes nodes that are globally central (lower total distances to all other nodes) while slightly favoring closer neighbors to avoid excessive detours. The `hybrid_score` function computes this weighted combination, and the algorithm iteratively selects the node with the minimum score from the unvisited nodes.",
          "thought": "The new algorithm prioritizes global centrality (60% weight) over local proximity (40% weight), using the inverse of total distances as the primary metric while incorporating a small local distance consideration to prevent excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    global_centrality = lambda node: 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n    hybrid_score = lambda node: 0.4 * distance_matrix[current_node][node] + 0.6 * global_centrality(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.95824,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance with a weighted balance of global distance, centrality, and inverse global distance, prioritizing nodes that are both close (local distance) and globally central (higher weights for centrality and inverse global distance). The score function multiplies local distance by a weighted sum of global metrics (1.0 for global distance, 0.5 for centrality, and 0.2 for inverse global), with centrality and inverse global given higher priority than global distance. The next node is selected as the unvisited node with the minimum score.",
          "thought": "The new algorithm combines local distance with a weighted balance of global distance, centrality, and inverse global distance, inspired by No.1, but uses a multiplicative scoring approach like No.2 to prioritize nodes that are both close and globally central.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance * (1.0 + 0.3 * global_distance + 0.5 * centrality + 0.2 * inverse_global)\n    next_node = min(unvisited_nodes, key=score)\n    return next_node",
          "objective": 6.95963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with a dynamic balance between local distance and global centrality, where local distance is prioritized early in the tour (higher `local_weight`) and global centrality becomes more influential as the tour progresses (higher `global_weight`). The `centrality` of a node is inversely proportional to its total distance to all other nodes, ensuring the tour avoids peripheral nodes late in the process. The `hybrid_score` function weights these factors dynamically, selecting the next node based on the current phase of the tour.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a dynamic balance between local distance and global centrality, where the weight of centrality increases as the tour progresses, ensuring a smooth transition from local to global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.7 + 0.3 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * centrality(node)\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.97615,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three key factors\u2014**local distance**, **global centrality**, and **node degree**\u2014to prioritize next nodes, adjusting weights based on tour progress. Early in the tour, it heavily favors **local distance** (60% weight) to ensure short-term efficiency, while later it increases **centrality** and **degree** (up to 50% and 10% weights, respectively) to avoid peripheral, less-connected nodes. The hybrid score combines these factors with dynamically adjusted weights, ensuring adaptability to the tour's stage.",
          "thought": "The new algorithm dynamically balances local distance, global centrality, and node degree (number of connections) to prioritize nodes that are close, central, and highly connected, adjusting weights based on the tour's progress to avoid peripheral and less connected nodes late in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 0.3 + 0.2 * remaining_ratio\n    degree_weight = 0.1 * (1 - remaining_ratio)\n\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def node_degree(node):\n        return sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0)\n\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * centrality(node) +\n        degree_weight * node_degree(node)\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.97915,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global factors dynamically, prioritizing local distance early (higher weight) and gradually shifting to global metrics (centrality, global distance, and inverse global distance) as the tour progresses. Local distance dominates early (weighted by `local_weight`), while global factors (weighted by `global_weight`) become more influential later. The hybrid score balances these factors, with centrality (0.5), global distance (0.4), and inverse global distance (0.1) influencing the global component.",
          "thought": "The new algorithm combines No.1's weighted balance of local distance, global distance, centrality, and inverse global distance with No.2's dynamic weighting between local and global factors, using a phase-dependent balance where local distance dominates early and global metrics become more influential later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.8 + 0.2 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def global_distance(node):\n        return sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n    def inverse_global(node):\n        return 1 / (global_distance(node) + 1e-10)\n\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * (0.4 * global_distance(node) + 0.5 * centrality(node) + 0.1 * inverse_global(node))\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.99267,
          "other_inf": null
     }
]