[
     {
          "algorithm": "The algorithm implements a **nearest neighbor heuristic** for TSP, prioritizing the closest unvisited node from the current position to minimize incremental path length. The `select_next_node` function evaluates all unvisited nodes based on the `distance_matrix`, selecting the one with the smallest distance to the `current_node`. If no unvisited nodes remain, it returns the `destination_node`. The heuristic prioritizes proximity over global optimality, making it computationally efficient but not guaranteed to find the shortest possible tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with dynamic local-global balancing, where local distances (weighted by `1 - visited_ratio`) and global average distances (weighted by `visited_ratio * 0.4`) are prioritized, while penalizing nodes with high variance in distances to unvisited nodes (scaled by `0.3`). This balances short-term optimality with global connectivity, avoiding local optima by dynamically adjusting weights based on progress.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a dynamic balance between local and global considerations, similar to No.2, but introduces a weighted global term (0.4) and a penalty for nodes with high variance in distances to unvisited nodes (0.3 * variance) to avoid local optima and improve global performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.3 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.4 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.18734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (current distance) and global (average distance to unvisited nodes) priorities dynamically via a `visited_ratio`-weighted combination. It penalizes nodes with high variance in distances to unvisited nodes to avoid erratic selections, with the penalty term (`0.2 * variance`) reducing the score of such nodes. The `local_weight` decreases as more nodes are visited, prioritizing global considerations in later stages.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts based on the ratio of visited nodes to total nodes, balancing local and global distances more adaptively. It also introduces a penalty term for nodes with high variance in distances to unvisited nodes to reduce erratic selections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance  # Penalize high variance\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.25138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global priorities by weighting the current node's distance to potential candidates (local_weight) against their average distance to unvisited nodes (global_weight), while penalizing high-variance nodes to avoid hubs and encouraging exploration through a novelty factor that diminishes as more nodes are visited. The exploration term further adjusts selection by favoring closer nodes later in the process.",
          "thought": "The new algorithm dynamically adjusts node selection by combining local and global priorities with a novelty factor that penalizes nodes with high variance in distances to unvisited nodes, while incorporating a adaptive exploration term based on the ratio of visited nodes to encourage diversity in later stages.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n    novelty_factor = math.exp(-visited_ratio)  # Encourages exploration in early stages\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n\n        # Novelty term: penalize high variance and encourage exploration\n        novelty_penalty = novelty_factor * variance\n        exploration_term = (1.0 - novelty_factor) * (1.0 / (1.0 + avg_distance))\n\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                novelty_penalty -\n                exploration_term)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.42354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor approach with a balanced scoring mechanism, prioritizing the closest unvisited node (local distance) while slightly considering the average distance to other unvisited nodes (0.3 weight) to avoid local optima. The `calculate_score` function computes a weighted sum of these distances, and the next node is selected based on the minimum score. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines the nearest neighbor approach of No.1 with the balanced scoring of No.2, prioritizing the closest unvisited node while slightly considering the average distance to other unvisited nodes to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes:\n            return local_distance\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        return local_distance + 0.3 * avg_distance\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.42568,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing local distance (highest priority) with a weighted sum of global distance (0.4 weight) and centrality (0.6 weight), prioritizing nodes that are both nearby and globally central. The `calculate_score` function computes a score for each unvisited node, combining these factors, and the node with the lowest score is chosen as the next visit. The centrality is defined as the inverse of the sum of distances to all other nodes, ensuring nodes well-connected to the rest of the graph are preferred.",
          "thought": "The new algorithm uses a hybrid heuristic that balances local distance with a weighted sum of global distance and the node's centrality (inverse of the sum of distances to all other nodes), prioritizing nodes that are both close locally and central globally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        return local_distance + 0.4 * global_distance + 0.6 * centrality\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.53533,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest neighbor and farthest insertion heuristics, prioritizing local (nearest neighbor) and global (farthest insertion) costs with a weighted balance (60% local, 40% global). It selects the next node by minimizing a hybrid score that considers both immediate distance from the current node and the node's distance to the destination, ensuring a trade-off between short-term and long-term path optimization. The function handles edge cases (e.g., no unvisited nodes) and uses the distance matrix for efficient distance lookups.",
          "thought": "The new algorithm implements a hybrid approach that combines nearest neighbor and farthest insertion heuristics to minimize the sum of immediate and global distances, using a weighted combination of local and global costs to balance path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_insertion = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node])\n    hybrid_score = lambda node: 0.6 * distance_matrix[current_node][node] + 0.4 * distance_matrix[node][destination_node]\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a greedy heuristic to select the next node in the TSP path by balancing local distance (distance from the current node) and global distance (average distance to all unvisited nodes). The function prioritizes minimizing the sum of these two weighted distances, giving slightly more weight to the global average (multiplied by 0.5). The `destination_node` is returned if no unvisited nodes remain, ensuring the path loops back to the start. The `distance_matrix` and `unvisited_nodes` are critical inputs, while the current node steers local decisions.",
          "thought": "The algorithm implements a greedy selection strategy that prioritizes nodes which minimize the sum of their distance to the current node and the average distance to all other unvisited nodes, balancing local and global considerations for a more optimized path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        return distance_matrix[current_node][node] + 0.5 * avg_distance\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.81012,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global distances by adjusting weights based on the visited ratio, prioritizing local distances early and global optimization later. It penalizes high variance in global distances to avoid poor connectivity, using a variance penalty term. The next node is selected by minimizing a weighted sum of local distance, average global distance, and variance penalty, ensuring a smooth transition from local to global optimization.",
          "thought": "This new algorithm dynamically balances local and global distances while penalizing high variance in global distances and adaptively adjusting weights based on visited ratio, ensuring a smooth transition from local to global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - 0.5 * visited_ratio\n    global_weight = 0.5 + 0.5 * visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.3 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.91145,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a greedy heuristic that prioritizes selecting the next node by minimizing the sum of the immediate distance from the current node and the distance from that node to the destination, balancing local and global path optimization. The `current_node` and `destination_node` are given higher priority in the selection, while `unvisited_nodes` and `distance_matrix` are used to compute the optimal next node. The function efficiently handles the selection by leveraging the `min` function with a lambda to evaluate the cost function for each unvisited node.",
          "thought": "This algorithm implements a greedy heuristic that selects the next node by considering both the immediate distance to the current node and the potential reduction in total path length by connecting to the destination node, balancing local and global path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     }
]