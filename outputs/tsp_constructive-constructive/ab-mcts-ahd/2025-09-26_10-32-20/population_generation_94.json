[
     {
          "algorithm": "The algorithm combines a nearest-neighbor heuristic (70% weight) with a global measure (30% weight) that balances centrality (inverse sum of all distances) and inverse average distance to unvisited nodes. It prioritizes local proximity (via nearest neighbor) while incorporating limited global considerations to avoid myopia, with the hybrid score ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the nearest neighbor heuristic from No.2 with a refined global measure that considers both centrality and inverse global distance, inspired by No.1, to balance local and global optimization with a hybrid score (70% local, 30% global).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_measure = lambda node: 0.7 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.3 * (1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10))\n    hybrid_score = lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * global_measure(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.52706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance with a weighted balance of global distance, centrality, and inverse global distance, prioritizing nodes that are both close (local distance) and globally central (higher weights for centrality and inverse global distance). The score function multiplies local distance by a weighted sum of global metrics (1.0 for global distance, 0.5 for centrality, and 0.2 for inverse global), with centrality and inverse global given higher priority than global distance. The next node is selected as the unvisited node with the minimum score.",
          "thought": "The new algorithm combines local distance with a weighted balance of global distance, centrality, and inverse global distance, inspired by No.1, but uses a multiplicative scoring approach like No.2 to prioritize nodes that are both close and globally central.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance * (1.0 + 0.3 * global_distance + 0.5 * centrality + 0.2 * inverse_global)\n    next_node = min(unvisited_nodes, key=score)\n    return next_node",
          "objective": 6.95963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest neighbor heuristic** for TSP, prioritizing the closest unvisited node from the current position to minimize incremental path length. The `select_next_node` function evaluates all unvisited nodes based on the `distance_matrix`, selecting the one with the smallest distance to the `current_node`. If no unvisited nodes remain, it returns the `destination_node`. The heuristic prioritizes proximity over global optimality, making it computationally efficient but not guaranteed to find the shortest possible tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that maximizes the difference between the distance from the current node and the distance to the destination, balancing immediate distance with global path optimization. It uses a lambda function to compute `-distance_matrix[current_node][node] + distance_matrix[node][destination_node]`, where the negative sign ensures higher distances from the current node are favored, while the positive term minimizes the distance to the destination. The `max` function then selects the node with the highest computed value, ensuring a trade-off between local and global objectives.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the immediate distance from the current node and minimizing the distance from that node to the destination, emphasizing global path optimization over local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: -distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global considerations by weighting local distances (1 - visited_ratio) and global average distances (visited_ratio * 0.5), while penalizing nodes with high variance (0.2 * variance) to avoid hubs. It prioritizes proximity to the current node early on (high local_weight) but gradually shifts toward global optimization (higher global_weight) as more nodes are visited. The variance penalty ensures diversity in the path.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic local-global balancing, where local distances are weighted by (1 - visited_ratio) and global average distances are weighted by visited_ratio * 0.5, while penalizing nodes with high variance in distances to unvisited nodes scaled by 0.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.5 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.1494,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (current node) and global (destination node) costs using a weight that decreases as nodes are visited, while penalizing detours beyond a threshold. It combines nearest-neighbor and farthest-insertion heuristics, prioritizing local distances early and global distances later, with a penalty for excessive path increases. The hybrid score integrates these factors, favoring nodes that minimize both immediate and long-term costs while avoiding detours.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances local and global costs based on the ratio of remaining unvisited nodes to total nodes, ensuring a smooth transition from local to global optimization. It also incorporates a penalty factor for nodes that increase the path length beyond a threshold, further refining the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    dynamic_weight = 0.7 * remaining_ratio + 0.3  # Weight decreases as nodes are visited\n\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_insertion = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node])\n\n    penalty_threshold = 1.5 * distance_matrix[current_node][destination_node]\n    penalty = lambda node: max(0, (distance_matrix[current_node][node] + distance_matrix[node][destination_node]) - penalty_threshold)\n\n    hybrid_score = lambda node: (\n        dynamic_weight * distance_matrix[current_node][node] +\n        (1 - dynamic_weight) * distance_matrix[node][destination_node] +\n        0.1 * penalty(node)  # Penalize nodes causing excessive detours\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 7.16001,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with dynamic local-global balancing, where local distances (weighted by `1 - visited_ratio`) and global average distances (weighted by `visited_ratio * 0.4`) are prioritized, while penalizing nodes with high variance in distances to unvisited nodes (scaled by `0.3`). This balances short-term optimality with global connectivity, avoiding local optima by dynamically adjusting weights based on progress.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a dynamic balance between local and global considerations, similar to No.2, but introduces a weighted global term (0.4) and a penalty for nodes with high variance in distances to unvisited nodes (0.3 * variance) to avoid local optima and improve global performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.3 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.4 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.18734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and long-term detours (maximum remaining distances), weighted dynamically based on unvisited nodes, while penalizing cycles by avoiding revisits to the start/destination nodes. The dynamic weight (`weight = 1.0 / (1.0 + remaining_nodes)`) prioritizes proximity early and long-term detours later, while the `cycle_penalty` discourages cycles. The `calculate_score` function combines these factors to evaluate node suitability.",
          "thought": "The new algorithm modifies the scoring mechanism by introducing a dynamic weight that adjusts the balance between immediate proximity and long-term detours based on the remaining unvisited nodes, while also incorporating a penalty for revisiting nodes that were part of the initial path to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n\n        max_distance = max(distance_matrix[node][n] for n in unvisited_nodes)\n        cycle_penalty = 0.5 if node in [current_node, destination_node] else 0.0  # Penalty for potential cycles\n\n        return (1 - weight) * distance_matrix[current_node][node] + weight * max_distance + cycle_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.20027,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (1/dist) while dynamically boosting connectivity via the node's average distance to unvisited neighbors (0.1 * 1/avg_neighbor_dist), balancing local and global path optimization. The connectivity weight is scaled down (0.1) to avoid overemphasizing it, and the score function combines these factors multiplicatively. The destination node is returned if no unvisited nodes remain.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for connectivity, where the boost is proportional to the node's average distance to unvisited neighbors, ensuring a balance between proximity and adaptability to the remaining network structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def score(node):\n        dist = distance_matrix[current_node][node]\n        if not unvisited_nodes:\n            return 1.0 / (dist + 1e-6)\n        avg_neighbor_dist = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        connectivity_weight = 0.1 * (1.0 / (avg_neighbor_dist + 1e-6))\n        return (1.0 / (dist + 1e-6)) * (1.0 + connectivity_weight)\n    next_node = max(unvisited_nodes, key=score)\n    return next_node",
          "objective": 7.20878,
          "other_inf": null
     }
]