[
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014local distance, centrality, and coherence\u2014where local distance is prioritized early (higher `weight_local`), centrality gains importance later (increasing `weight_centrality`), and coherence follows a bell curve (peaking midway). The `calculate_score` function combines these weighted factors to select the next node, favoring nearby nodes initially but shifting toward more central and coherent choices as progress increases. The weights adjust linearly or via a bell curve based on the remaining unvisited nodes.",
          "thought": "The new algorithm emphasizes early focus on local distances and later prioritizes centrality and coherence, using inverse-progress-weighted factors where weight_local starts high and decreases, weight_centrality starts low and increases, and weight_coherence follows a bell curve centered in the middle of the path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.7 - 0.4 * progress\n    weight_centrality = 0.1 + 0.4 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence priorities, starting with high local distance weight (0.7) and gradually shifting focus to centrality (0.2\u21920.6) and coherence (0.1\u21920.5) as the search progresses, optimizing the path by prioritizing global metrics early and refining local choices later. The `calculate_score` function combines these weighted factors to select the next node, where local distance dominates early, while centrality and coherence gain importance as unvisited nodes decrease. The weights adjust dynamically based on remaining nodes, ensuring a balance between immediate proximity and global structure.",
          "thought": "The new algorithm dynamically shifts focus from local distance to centrality and coherence, starting with high local distance weight (0.7\u21920.3) and gradually increasing centrality (0.2\u21920.6) and coherence (0.1\u21920.5) weights, prioritizing global metrics early and refining local choices later for better path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    weight_local = 0.7 - 0.4 * (1 - remaining_ratio)\n    weight_centrality = 0.2 + 0.4 * (1 - remaining_ratio)\n    weight_coherence = 0.1 + 0.4 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.42324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local optimization (prioritized early) with global structure (emphasized later) by adjusting weights: `weight_local` increases linearly, `weight_centrality` decreases exponentially, and `weight_coherence` increases linearly. It selects the next node by minimizing a weighted score combining local distance, node centrality (inverse of total distance to all nodes), and coherence (average distance to unvisited nodes). Early in the path, local distance dominates, while centrality and coherence gain importance as progress increases.",
          "thought": "The new algorithm prioritizes local distance early in the path construction, with centrality and coherence becoming more influential later. It uses linearly increasing weight_local, exponentially decreasing weight_centrality, and linearly increasing weight_coherence, dynamically adjusting these weights based on progress to balance local optimization and global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.3 + 0.7 * progress\n    weight_centrality = 0.6 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.43208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines adaptive weight scaling with exponential decay to balance local distance, centrality, and coherence, prioritizing local distance (weight 0.7-1.0) and centrality (weight 0.2-0.6) over coherence (weight 0.1-0.8), while dynamically adjusting weights based on remaining nodes. It uses a multiplicative local-global balance metric and subtractive coherence term to avoid over-prioritization, with weights decaying exponentially as the tour progresses. The score is minimized to select the next node.",
          "thought": "This algorithm modifies the original by introducing adaptive weight scaling with exponential decay and incorporating a novel 'local-global balance' metric that combines distance and centrality in a multiplicative fashion, while preserving coherence as a subtractive term to avoid over-prioritization.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    decay_factor = math.exp(-remaining_ratio)\n\n    weight_local = 0.7 * decay_factor + 0.3\n    weight_centrality = 0.4 * decay_factor + 0.2\n    weight_coherence = 0.1 * decay_factor + 0.4\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        local_global_balance = (local_distance * centrality) ** 0.5\n        return (weight_local * local_distance) + (weight_centrality * local_global_balance) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.43243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence by adjusting weights (60% local/centrality, 40% coherence) based on remaining nodes, prioritizing immediate proximity and long-term optimization. It selects the next node by minimizing a weighted score combining local distance, node centrality (inverse of total distances), and average coherence (distances to unvisited nodes). The weights are adaptive, favoring local/centrality early and coherence later, ensuring a trade-off between short-term and long-term optimization.",
          "thought": "The new algorithm combines the adaptive weighting of local distance, centrality, and coherence from No.1 with the hybrid nearest-neighbor and farthest-insertion approach of No.2, using dynamic weights (60% local/centrality, 40% coherence) that adjust based on remaining nodes, ensuring a balance between immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_local = 0.6 - 0.2 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.3 + 0.1 * (remaining_nodes / len(distance_matrix))\n    weight_coherence = 0.4 - 0.2 * (remaining_nodes / len(distance_matrix))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.44406,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global considerations by adjusting weights based on remaining nodes, prioritizing local distance early (higher weight) and gradually incorporating global centrality and inverse global distance (lower weight) for long-term optimization. It selects the next node by minimizing a weighted score combining these factors, with local distance dominating initially and global metrics gaining importance as the tour progresses. The code structure clearly separates weight calculation, score computation, and node selection, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weighting with local distance, global centrality, and inverse global distance inspired by No.1, while maintaining the dynamic weight adjustment of No.2 to balance exploration and exploitation. The algorithm calculates dynamic weights based on remaining nodes, prioritizes local distance early, and gradually incorporates global centrality and inverse global distance for better long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_weight * local_distance + global_weight * (0.5 * centrality + 0.5 * inverse_global)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.48396,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances global optimization (coherence) and local constraints (distance/centrality) by adjusting weights inversely proportional to remaining nodes. Early in the search, it heavily favors coherence (70% weight) to ensure long-term path coherence, gradually shifting to local distance (30%) and centrality (20%) as nodes are visited. The `calculate_score` function computes a weighted sum of local distance, centrality (node importance), and coherence (average distance to unvisited nodes), prioritizing coherence initially before adapting to local factors.",
          "thought": "The new algorithm prioritizes global optimization by emphasizing coherence (70% weight) early and gradually shifting to local distance (30%) and centrality (20%) as nodes are visited, ensuring long-term path coherence while maintaining adaptability to local constraints.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_coherence = 0.7 - 0.4 * (remaining_nodes / len(distance_matrix))\n    weight_local = 0.3 + 0.2 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.2 + 0.1 * (remaining_nodes / len(distance_matrix))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.49596,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes **local distance** (weighted by `local_weight`) and **centrality** (weighted by `centrality_weight`) while penalizing **coherence** (weighted by `coherence_weight`), balancing these factors dynamically based on remaining unvisited nodes. Weights adjust inversely with the number of remaining nodes, favoring centrality and coherence in later stages while emphasizing direct distance early on. The score function combines these metrics to select the next node, ensuring adaptability to the problem's evolving state.",
          "thought": "The new algorithm combines dynamic weight adjustment with local and global optimization, inspired by No.1's centrality and coherence prioritization, while maintaining No.2's simplicity and adaptability. It balances direct distance with node centrality and coherence, adjusting weights based on remaining nodes to refine the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    local_weight = remaining_nodes / (remaining_nodes + 1)\n    global_weight = 1 - local_weight\n    centrality_weight = 0.3 + 0.5 * (1 - remaining_ratio)\n    coherence_weight = 0.2 + 0.5 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (local_weight * local_distance +\n                centrality_weight * centrality -\n                coherence_weight * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.50048,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local distance (highest priority), global centrality (medium priority), and coherence (lowest priority), with weights adjusted based on remaining nodes. It uses historical selection patterns to reinforce frequently chosen nodes, optimizing long-term path efficiency. The code structures these factors into a weighted score, selecting the node with the minimal value to guide the path.",
          "thought": "The new algorithm introduces a dynamic prioritization mechanism that combines local distance, global centrality, and coherence with adaptive weights, but also incorporates a reinforcement learning-inspired component that adjusts weights based on historical node selection patterns to improve long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    base_weight_local = 0.5\n    base_weight_centrality = 0.3\n    base_weight_coherence = 0.2\n\n    # Dynamic weight adjustment based on remaining nodes\n    weight_local = base_weight_local * (1 - 0.3 * (remaining_nodes / len(distance_matrix)))\n    weight_centrality = base_weight_centrality * (1 + 0.2 * (remaining_nodes / len(distance_matrix)))\n    weight_coherence = base_weight_coherence * (1 - 0.1 * (remaining_nodes / len(distance_matrix)))\n\n    # Historical selection pattern reinforcement\n    selection_history = {}\n    for node in unvisited_nodes:\n        selection_history[node] = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = selection_history[node]\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.51569,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts selection priorities by weighting local distance (higher early on), global centrality (moderate), and path coherence (lower initially) based on remaining nodes, using a scoring function that balances these factors. Local distance dominates early, while coherence gains importance later. The weights are inversely proportional to the remaining path length, ensuring adaptability.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment mechanism based on the remaining path length, combining local distance, global centrality, and a novel \"path coherence\" factor that measures alignment with the overall path direction, while preserving the original structure with a different scoring function and adaptive weights.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_local = 0.5 + 0.4 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.3 + 0.2 * (remaining_nodes / len(distance_matrix))\n    weight_coherence = 0.2 + 0.3 * (remaining_nodes / len(distance_matrix))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.52042,
          "other_inf": null
     }
]