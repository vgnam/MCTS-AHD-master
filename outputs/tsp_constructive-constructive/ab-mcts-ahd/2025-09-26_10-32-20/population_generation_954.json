[
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014local distance, centrality, and coherence\u2014where local distance is prioritized early (higher `weight_local`), centrality gains importance later (increasing `weight_centrality`), and coherence follows a bell curve (peaking midway). The `calculate_score` function combines these weighted factors to select the next node, favoring nearby nodes initially but shifting toward more central and coherent choices as progress increases. The weights adjust linearly or via a bell curve based on the remaining unvisited nodes.",
          "thought": "The new algorithm emphasizes early focus on local distances and later prioritizes centrality and coherence, using inverse-progress-weighted factors where weight_local starts high and decreases, weight_centrality starts low and increases, and weight_coherence follows a bell curve centered in the middle of the path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.7 - 0.4 * progress\n    weight_centrality = 0.1 + 0.4 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor (prioritizing local distance) with dynamic weights that balance centrality (favoring well-connected nodes) and coherence (avoiding isolated nodes) as the tour progresses. Higher weights are given to local distance and coherence early in the tour, while centrality gains importance later. The weights adjust based on progress (total nodes visited), creating a dynamic trade-off between local and global considerations.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting scheme inspired by No.1, balancing local distance (increasing weight) with node centrality (decreasing weight) and coherence (increasing weight) to avoid local optima and improve global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.4 + 0.6 * progress\n    weight_centrality = 0.5 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014local distance, node centrality, and coherence\u2014to guide the next step in TSP. Early in the search, local distance dominates (high weight), while centrality and coherence gradually gain importance (weights increase with progress). The scoring function prioritizes nearby nodes, highly connected nodes, and nodes that align well with unvisited nodes, ensuring a smooth transition from local to global optimization.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.1 (progress-based weights) with the structured balance of No.2 (local, centrality, coherence), using a smooth transition where local distance dominates early (0.5\u21920.9) while centrality (0.3\u21920.7) and coherence (0.2\u21920.8) rise proportionally, ensuring a gradual shift from local to global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n    weight_local = 0.5 + 0.4 * progress\n    weight_centrality = 0.3 + 0.4 * progress\n    weight_coherence = 0.2 + 0.6 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37892,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence by adjusting weights based on progress (progress = 1 - remaining_nodes / total_nodes). Early in the tour, it prioritizes local distance (weight_local = 0.5 + 0.4 * progress) and centrality (weight_centrality = 0.3 * (0.7 ** progress) + 0.3 * (0.5 - abs(progress - 0.5))), while later it emphasizes coherence (weight_coherence = 0.2 + 0.6 * progress). The next node is selected by minimizing a weighted score of local distance, centrality (inverse of total node distances), and coherence (average distance to unvisited nodes).",
          "thought": "The new algorithm dynamically balances local distance, centrality, and coherence with weights that evolve smoothly from local to global optimization, combining the adaptive weighting of No.2 with the balanced factor prioritization of No.1.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.5 + 0.4 * progress\n    weight_centrality = 0.3 * (0.7 ** progress) + 0.3 * (0.5 - abs(progress - 0.5))\n    weight_coherence = 0.2 + 0.6 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37914,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach with dynamic weights to balance local distance, node centrality, and coherence, adjusting priorities based on tour progress. Early in the tour, it prioritizes local distance and centrality (with weights decreasing over time), while later stages emphasize coherence to refine the path. The weights (`weight_local`, `weight_centrality`, `weight_coherence`) evolve linearly or exponentially with progress, ensuring global optimization early and local refinement later.",
          "thought": "The new algorithm combines the greedy heuristic from No.2 with dynamic weights inspired by No.1, balancing local distance, centrality, and coherence with weights adjusting based on tour progress to prioritize global optimization early and local refinement later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.5 + 0.5 * progress\n    weight_centrality = 0.3 * (0.7 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38247,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP dynamically selects the next node by balancing local distance (50%), centrality (30%), and coherence (20%), while incorporating an adaptive exploration factor (50%) that increases as the algorithm progresses (later stages prioritize exploration). The exploration factor rewards nodes with greater distance from the current node, encouraging diversity to escape local optima. The weights are fixed, with local distance given the highest priority, while centrality and coherence contribute moderately, and coherence is negatively weighted to discourage clustering. The algorithm adapts exploration based on remaining nodes, making it more exploratory in later stages.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines local distance, centrality, and coherence, but with adaptive weights that adjust based on the remaining nodes' distribution and a novel 'exploration factor' that encourages diversity in node selection, particularly in later stages when local minima might trap the solution.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    exploration_factor = 0.1 + 0.9 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        exploration_bonus = (1 - distance_matrix[node][current_node] / max(max(row) for row in distance_matrix)) * exploration_factor\n        return (0.5 * local_distance +\n                0.3 * centrality -\n                0.2 * coherence +\n                0.5 * exploration_bonus)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38422,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance (prioritized early), node centrality (increasing later), and global coherence (peaking midway) using adaptive weights. It combines nearest-neighbor and farthest-insertion heuristics in a hybrid scoring mechanism, adjusting priorities based on progress (progress = 1 - remaining_nodes/total_nodes). Early stages favor short-term connections (weight_local = 0.6 early), while later stages emphasize centrality (weight_centrality increases to 0.5). Coherence (weight_coherence) peaks at mid-progress (0.4) to maintain global structure. The score for each node is calculated as (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality), with the next node selected as the minimum score.",
          "thought": "The new algorithm dynamically balances local distance, global coherence, and node centrality with adaptive weights, prioritizing short-term connections early, mid-term centrality, and long-term coherence later, using a hybrid scoring mechanism that combines nearest-neighbor and farthest-insertion heuristics with progress-based weight adjustments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_coherence = 0.2 + 0.3 * (0.5 - abs(progress - 0.5))\n    weight_centrality = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38959,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence priorities during the tour construction, starting with high local distance weight early (prioritizing immediate proximity), transitioning to centrality weight midway (favoring well-connected nodes), and increasing coherence weight later (optimizing global tour consistency). Weights decay exponentially (0.8^progress) and adapt based on progress (progress = 1 - unvisited/total nodes), with centrality peaking at 50% progress. The score combines weighted local distance, centrality (inverse total distance), and coherence (average unvisited distances), selecting the node with minimal score.",
          "thought": "The new algorithm combines the adaptive weighting strategy of No.1 with the exponential decay and dynamic centrality-coherence balancing of No.2, prioritizing local distance early, centrality midway, and coherence later while using exponentially decaying weights to refine the tour globally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.5 * (0.8 ** progress)\n    weight_centrality = 0.3 + 0.2 * (0.6 - abs(progress - 0.5))\n    weight_coherence = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39191,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three key factors\u2014**local distance**, **centrality**, and **coherence**\u2014to select the next node in the TSP path. Early in the process, **centrality** (node importance) is prioritized, while **local distance** (proximity to the current node) dominates later, with **coherence** (alignment with unvisited nodes) following a bell-curve pattern. The weights are adjusted based on progress, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.2 (local and global optimization) with the centrality and coherence factors from No.1, where centrality is prioritized early and coherence follows a bell curve. The algorithm selects the next node by balancing local distance, centrality, and coherence, with weights adjusted based on progress and coherence's bell curve pattern.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.3 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39596,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three key factors\u2014local distance, centrality, and coherence\u2014to dynamically select the next node in the TSP path, with weights adjusted based on progress. Early in the tour, local distance dominates, while centrality gains importance midway, and coherence becomes critical later. The weighted scoring balances these factors to guide the path toward optimal efficiency.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 (balancing local distance, centrality, and coherence) with the progress-based dynamic adjustment of No.2, using a weighted score that prioritizes local distance early, centrality midway, and coherence later, with weights calculated based on remaining nodes and progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n    weight_coherence = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39842,
          "other_inf": null
     }
]