[
     {
          "algorithm": "The algorithm combines a nearest-neighbor heuristic (70% weight) with a global measure (30% weight) that balances centrality (inverse sum of all distances) and inverse average distance to unvisited nodes. It prioritizes local proximity (via nearest neighbor) while incorporating limited global considerations to avoid myopia, with the hybrid score ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the nearest neighbor heuristic from No.2 with a refined global measure that considers both centrality and inverse global distance, inspired by No.1, to balance local and global optimization with a hybrid score (70% local, 30% global).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_measure = lambda node: 0.7 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.3 * (1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10))\n    hybrid_score = lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * global_measure(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.52706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest neighbor heuristic** for TSP, prioritizing the closest unvisited node from the current position to minimize incremental path length. The `select_next_node` function evaluates all unvisited nodes based on the `distance_matrix`, selecting the one with the smallest distance to the `current_node`. If no unvisited nodes remain, it returns the `destination_node`. The heuristic prioritizes proximity over global optimality, making it computationally efficient but not guaranteed to find the shortest possible tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global considerations by weighting local distances (1 - visited_ratio) and global average distances (visited_ratio * 0.5), while penalizing nodes with high variance (0.2 * variance) to avoid hubs. It prioritizes proximity to the current node early on (high local_weight) but gradually shifts toward global optimization (higher global_weight) as more nodes are visited. The variance penalty ensures diversity in the path.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic local-global balancing, where local distances are weighted by (1 - visited_ratio) and global average distances are weighted by visited_ratio * 0.5, while penalizing nodes with high variance in distances to unvisited nodes scaled by 0.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.5 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.1494,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (current node) and global (destination node) costs using a weight that decreases as nodes are visited, while penalizing detours beyond a threshold. It combines nearest-neighbor and farthest-insertion heuristics, prioritizing local distances early and global distances later, with a penalty for excessive path increases. The hybrid score integrates these factors, favoring nodes that minimize both immediate and long-term costs while avoiding detours.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that balances local and global costs based on the ratio of remaining unvisited nodes to total nodes, ensuring a smooth transition from local to global optimization. It also incorporates a penalty factor for nodes that increase the path length beyond a threshold, further refining the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    dynamic_weight = 0.7 * remaining_ratio + 0.3  # Weight decreases as nodes are visited\n\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_insertion = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node])\n\n    penalty_threshold = 1.5 * distance_matrix[current_node][destination_node]\n    penalty = lambda node: max(0, (distance_matrix[current_node][node] + distance_matrix[node][destination_node]) - penalty_threshold)\n\n    hybrid_score = lambda node: (\n        dynamic_weight * distance_matrix[current_node][node] +\n        (1 - dynamic_weight) * distance_matrix[node][destination_node] +\n        0.1 * penalty(node)  # Penalize nodes causing excessive detours\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 7.16001,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with dynamic local-global balancing, where local distances (weighted by `1 - visited_ratio`) and global average distances (weighted by `visited_ratio * 0.4`) are prioritized, while penalizing nodes with high variance in distances to unvisited nodes (scaled by `0.3`). This balances short-term optimality with global connectivity, avoiding local optima by dynamically adjusting weights based on progress.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a dynamic balance between local and global considerations, similar to No.2, but introduces a weighted global term (0.4) and a penalty for nodes with high variance in distances to unvisited nodes (0.3 * variance) to avoid local optima and improve global performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.3 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.4 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.18734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (current distance) and global (average distance to unvisited nodes) priorities dynamically via a `visited_ratio`-weighted combination. It penalizes nodes with high variance in distances to unvisited nodes to avoid erratic selections, with the penalty term (`0.2 * variance`) reducing the score of such nodes. The `local_weight` decreases as more nodes are visited, prioritizing global considerations in later stages.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts based on the ratio of visited nodes to total nodes, balancing local and global distances more adaptively. It also introduces a penalty term for nodes with high variance in distances to unvisited nodes to reduce erratic selections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance  # Penalize high variance\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.25138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and potential closeness to the destination, prioritizing nodes that are nearby but also have a good connection to the end of the tour. It uses a weighted combination of the current distance and future distance (scaled by a factor of 1) to guide the selection, ensuring a trade-off between immediate and long-term path efficiency. The key design idea is to minimize the product of these distances, favoring nodes that are both close to the current position and likely to lead to the destination efficiently.",
          "thought": "The new algorithm combines the exploration of distant nodes (from farthest insertion) with proximity prioritization (from nearest neighbor) by selecting the next node as the one that balances distance from the current node and the potential to connect to the destination node, aiming to reduce the total tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 7.2688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance prioritization with weighted global distance and adaptive centrality, dynamically balancing proximity, global connectivity, and path optimization. It assigns higher priority to local distance, followed by a weighted combination of average global distance (40%) and centrality (60%), with dynamic weights adjusting based on remaining unvisited nodes. The centrality factor (inverse of total distances to all nodes) and dynamic weighting (0.5 + 0.5 \u00d7 remaining nodes ratio) ensure adaptability to problem size and structure.",
          "thought": "The new algorithm combines the local distance prioritization from No.2, the weighted global distance from No.1, and introduces adaptive centrality and dynamic weighting based on remaining unvisited nodes, ensuring a balance between proximity, global connectivity, and path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        dynamic_weight = 0.5 + 0.5 * (len(unvisited_nodes) / len(distance_matrix))\n        return local_distance + dynamic_weight * (0.4 * global_distance + 0.6 * centrality)\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.37893,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) while balancing global distance (0.2 weight) and centrality (0.3 weight), favoring nodes with better centrality and lower global distances. The `calculate_score` function combines these factors, and the next node is chosen as the unvisited node with the minimum score. The weights ensure a trade-off between proximity, overall connectivity, and centrality in the network.",
          "thought": "The new algorithm combines the prioritization of local distance (highest priority) with a balance between global distance (weighted by 0.2) and centrality (weighted by 0.3), while favoring nodes with better centrality and lower global distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        return local_distance + 0.2 * global_distance + 0.3 * centrality\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.39542,
          "other_inf": null
     }
]