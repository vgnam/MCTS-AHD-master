[
     {
          "algorithm": "The algorithm dynamically balances local and global considerations by adjusting weights based on remaining nodes, prioritizing local distance early (higher weight) and gradually incorporating global centrality and inverse global distance (lower weight) for long-term optimization. It selects the next node by minimizing a weighted score combining these factors, with local distance dominating initially and global metrics gaining importance as the tour progresses. The code structure clearly separates weight calculation, score computation, and node selection, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weighting with local distance, global centrality, and inverse global distance inspired by No.1, while maintaining the dynamic weight adjustment of No.2 to balance exploration and exploitation. The algorithm calculates dynamic weights based on remaining nodes, prioritizes local distance early, and gradually incorporates global centrality and inverse global distance for better long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_weight * local_distance + global_weight * (0.5 * centrality + 0.5 * inverse_global)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.48396,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor heuristic (70% weight) with a global measure (30% weight) that balances centrality (inverse sum of all distances) and inverse average distance to unvisited nodes. It prioritizes local proximity (via nearest neighbor) while incorporating limited global considerations to avoid myopia, with the hybrid score ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the nearest neighbor heuristic from No.2 with a refined global measure that considers both centrality and inverse global distance, inspired by No.1, to balance local and global optimization with a hybrid score (70% local, 30% global).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_measure = lambda node: 0.7 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.3 * (1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10))\n    hybrid_score = lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * global_measure(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.52706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by combining three factors: local distance (60% weight), centrality (30% weight), and inverse global distance (10% weight). It prioritizes immediate proximity to the current node while also considering the node's centrality in the graph and its average distance to unvisited nodes, ensuring a balance between short-term and long-term optimization. The `calculate_score` function computes a weighted sum of these factors, and the node with the minimum score is chosen as the next step.",
          "thought": "The new algorithm combines the hybrid scoring approach of No.2 with the centrality and global distance considerations of No.1, prioritizing immediate distance (60%), centrality (30%), and inverse global distance (10%) to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return 0.6 * local_distance + 0.3 * centrality + 0.1 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61548,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest-neighbor) and global (centrality and unvisited-distance) factors, adjusting weights based on the remaining unvisited nodes' density. Local weight increases as the tour progresses, prioritizing nearest neighbors early, while global factors (centrality and average unvisited distance) gain importance later. The hybrid score combines these factors with dynamic weights, ensuring a smooth transition between local and global optimization.",
          "thought": "The new algorithm modifies the hybrid approach by incorporating a dynamic weight adjustment mechanism that balances local (nearest-neighbor) and global (centrality and unvisited-distance) factors, where weights adapt based on the remaining unvisited nodes' density, ensuring a smoother transition between local and global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weights based on remaining unvisited nodes\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.7 + 0.3 * (1 - remaining_ratio)  # Increase local weight as tour progresses\n    global_weight = 1 - local_weight\n\n    # Nearest-neighbor component\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Global components\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def unvisited_avg_distance(node):\n        return 1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10)\n\n    # Hybrid score with dynamic weights\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * (0.6 * centrality(node) + 0.4 * unvisited_avg_distance(node))\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.62032,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for TSP combines **local distance** (with dynamic weighting), **global centrality** (node importance), and an **exploration bonus** that prioritizes distant nodes early on. Local distance dominates early (higher weight), while global centrality and exploration gain importance as the tour progresses. The exploration bonus, decaying quadratically, encourages visiting distant nodes when few remain unvisited, balancing exploitation and exploration dynamically. The hybrid score balances these components with weights adjusted by the remaining unvisited nodes.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism where nodes are scored based on a combination of local distance, global centrality, and a novel \"exploration bonus\" term that increases with the number of unvisited nodes, creating a balance between exploitation and exploration with dynamic weight adjustments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n\n    # Dynamic weights with exploration bonus\n    local_weight = 0.5 + 0.5 * (1 - remaining_ratio)\n    global_weight = 0.5 * remaining_ratio\n    exploration_bonus = 0.3 * (1 - remaining_ratio) ** 2  # Quadratic decay for exploration\n\n    # Nearest-neighbor component\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    # Global components\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def unvisited_avg_distance(node):\n        return 1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10)\n\n    # Exploration bonus term\n    def exploration_term(node):\n        return exploration_bonus * (1 - distance_matrix[current_node][node] / max(distance_matrix[current_node][n] for n in unvisited_nodes))\n\n    # Hybrid score with dynamic weights\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * (0.7 * centrality(node) + 0.3 * unvisited_avg_distance(node)) +\n        exploration_term(node)\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.63963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a hybrid scoring approach that dynamically adjusts between local (nearest-neighbor) and global (centrality and unvisited-distance) factors, prioritizing local optimization early (higher local weight) and shifting toward global optimization as the tour progresses (higher global weight). The hybrid score balances distance to the next node, distance to the destination, centrality (inverse of total distance to all nodes), and average unvisited distance (inverse of average distance to remaining nodes), with weights adjusted based on remaining nodes. The code structure ensures smooth transitions between local and global optimization throughout the tour construction.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes, hybrid local-global scoring with improved centrality and unvisited distance measures, and adaptive weighting between nearest neighbor and global factors, ensuring smoother transitions between local and global optimization throughout the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    def improved_centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    def improved_unvisited_avg_distance(node):\n        return 1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10)\n\n    hybrid_score = lambda node: (\n        local_weight * (0.8 * distance_matrix[current_node][node] + 0.2 * distance_matrix[node][destination_node]) +\n        global_weight * (0.5 * improved_centrality(node) + 0.5 * improved_unvisited_avg_distance(node))\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.70485,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local distance and global centrality dynamically: early in the tour, it prioritizes high centrality (global_weight \u2248 0.7) to ensure the path remains central, while later it shifts to minimizing local distance (local_weight \u2248 0.7) to optimize the immediate next step. The hybrid score combines these factors using a weighted sum, where weights adjust based on the remaining unvisited nodes.",
          "thought": "The new algorithm modifies the hybrid scoring by emphasizing centrality early in the tour (high global_weight) and shifting to local distance later (high local_weight), while the original prioritizes local distance early and centrality later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    global_weight = 0.7 + 0.3 * (1 - remaining_ratio)\n    local_weight = 1 - global_weight\n\n    def centrality(node):\n        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n\n    hybrid_score = lambda node: (\n        local_weight * distance_matrix[current_node][node] +\n        global_weight * centrality(node)\n    )\n\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.73095,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting weights based on the visited ratio of nodes, with higher priority given to exploitation (closer to the destination) and exploration (shorter current distances) as the tour progresses. It also incorporates variance among unvisited nodes and a penalty term based on the current node's proximity to the destination, prioritizing nodes that reduce variance and maintain progress toward the destination. The weights (0.5, 0.4, 0.2) reflect the relative importance of exploitation, variance, and position penalties, respectively.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts to the current state of the tour by incorporating both local and global distance considerations, while also using a reinforcement learning-inspired approach to balance exploration and exploitation, with a novel penalty term based on the ratio of the current node's position to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = 0.5 * (1 - visited_ratio)\n    exploitation_weight = 0.5 * visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n\n        position_penalty = 0.2 * (distance_matrix[current_node][destination_node] / (distance_matrix[node][destination_node] + 1e-6))\n\n        exploration_term = exploration_weight * distance_matrix[current_node][node]\n        exploitation_term = exploitation_weight * avg_distance\n        variance_penalty = 0.4 * variance\n\n        return exploration_term + exploitation_term + variance_penalty + position_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.78568,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances global centrality (80% weight) and local proximity (20% weight) to select the next node in TSP. It prioritizes nodes with higher centrality (inverse of total distances to all nodes) while slightly favoring nearby nodes to avoid premature local optima. The `global_centrality` function combines these factors, and the next node is chosen via `min` over unvisited nodes.",
          "thought": "The new algorithm prioritizes a global centrality measure (80% weight) that considers the inverse of the sum of distances to all nodes, combined with a limited local proximity factor (20% weight) to ensure balanced exploration and exploitation, avoiding premature convergence to local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    global_centrality = lambda node: 0.8 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.2 * (distance_matrix[current_node][node])\n    next_node = min(unvisited_nodes, key=global_centrality)\n    return next_node",
          "objective": 6.81635,
          "other_inf": null
     }
]