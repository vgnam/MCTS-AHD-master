[
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest neighbor heuristic** for TSP, prioritizing the closest unvisited node from the current position to minimize incremental path length. The `select_next_node` function evaluates all unvisited nodes based on the `distance_matrix`, selecting the one with the smallest distance to the `current_node`. If no unvisited nodes remain, it returns the `destination_node`. The heuristic prioritizes proximity over global optimality, making it computationally efficient but not guaranteed to find the shortest possible tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global considerations by weighting local distances (1 - visited_ratio) and global average distances (visited_ratio * 0.5), while penalizing nodes with high variance (0.2 * variance) to avoid hubs. It prioritizes proximity to the current node early on (high local_weight) but gradually shifts toward global optimization (higher global_weight) as more nodes are visited. The variance penalty ensures diversity in the path.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic local-global balancing, where local distances are weighted by (1 - visited_ratio) and global average distances are weighted by visited_ratio * 0.5, while penalizing nodes with high variance in distances to unvisited nodes scaled by 0.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.5 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.1494,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with dynamic local-global balancing, where local distances (weighted by `1 - visited_ratio`) and global average distances (weighted by `visited_ratio * 0.4`) are prioritized, while penalizing nodes with high variance in distances to unvisited nodes (scaled by `0.3`). This balances short-term optimality with global connectivity, avoiding local optima by dynamically adjusting weights based on progress.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a dynamic balance between local and global considerations, similar to No.2, but introduces a weighted global term (0.4) and a penalty for nodes with high variance in distances to unvisited nodes (0.3 * variance) to avoid local optima and improve global performance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.3 * variance\n        return (local_weight * distance_matrix[current_node][node] +\n                0.4 * global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.18734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (current distance) and global (average distance to unvisited nodes) priorities dynamically via a `visited_ratio`-weighted combination. It penalizes nodes with high variance in distances to unvisited nodes to avoid erratic selections, with the penalty term (`0.2 * variance`) reducing the score of such nodes. The `local_weight` decreases as more nodes are visited, prioritizing global considerations in later stages.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts based on the ratio of visited nodes to total nodes, balancing local and global distances more adaptively. It also introduces a penalty term for nodes with high variance in distances to unvisited nodes to reduce erratic selections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n        penalty = 0.2 * variance  # Penalize high variance\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.25138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance prioritization with weighted global distance and adaptive centrality, dynamically balancing proximity, global connectivity, and path optimization. It assigns higher priority to local distance, followed by a weighted combination of average global distance (40%) and centrality (60%), with dynamic weights adjusting based on remaining unvisited nodes. The centrality factor (inverse of total distances to all nodes) and dynamic weighting (0.5 + 0.5 \u00d7 remaining nodes ratio) ensure adaptability to problem size and structure.",
          "thought": "The new algorithm combines the local distance prioritization from No.2, the weighted global distance from No.1, and introduces adaptive centrality and dynamic weighting based on remaining unvisited nodes, ensuring a balance between proximity, global connectivity, and path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        dynamic_weight = 0.5 + 0.5 * (len(unvisited_nodes) / len(distance_matrix))\n        return local_distance + dynamic_weight * (0.4 * global_distance + 0.6 * centrality)\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.37893,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance, global connectivity, and centrality, with dynamic weights adjusted based on remaining unvisited nodes. It prioritizes local distance and centrality (higher weights) while penalizing nodes with high average distances to avoid poorly connected nodes, with global distance given a dynamically adjusted weight. The score combines these factors to guide exploration/exploitation, favoring nodes that are close to the current node, central in the graph, and not overly distant from others.",
          "thought": "The new algorithm modifies the original by introducing a dynamic weight adjustment for global distance and centrality based on the proportion of unvisited nodes, ensuring a balance between exploration and exploitation, and incorporates a penalty term for nodes with high average distances to all other nodes to avoid poorly connected nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n\n        # Dynamic weight adjustment based on unvisited nodes proportion\n        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)\n        dynamic_weight = 0.4 + 0.4 * (1 - remaining_ratio)\n\n        # Penalty for nodes with high average distance to all other nodes\n        avg_distance_to_all = sum(distance_matrix[node][n] for n in range(len(distance_matrix))) / len(distance_matrix)\n        penalty = 0.5 * avg_distance_to_all\n\n        return local_distance + dynamic_weight * global_distance + 0.6 * centrality - penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.40355,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global priorities by weighting the current node's distance to potential candidates (local_weight) against their average distance to unvisited nodes (global_weight), while penalizing high-variance nodes to avoid hubs and encouraging exploration through a novelty factor that diminishes as more nodes are visited. The exploration term further adjusts selection by favoring closer nodes later in the process.",
          "thought": "The new algorithm dynamically adjusts node selection by combining local and global priorities with a novelty factor that penalizes nodes with high variance in distances to unvisited nodes, while incorporating a adaptive exploration term based on the ratio of visited nodes to encourage diversity in later stages.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    local_weight = 1.0 - visited_ratio\n    global_weight = visited_ratio\n    novelty_factor = math.exp(-visited_ratio)  # Encourages exploration in early stages\n\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n\n        distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes]\n        avg_distance = sum(distances_to_unvisited) / len(unvisited_nodes)\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_unvisited) / len(unvisited_nodes)\n\n        # Novelty term: penalize high variance and encourage exploration\n        novelty_penalty = novelty_factor * variance\n        exploration_term = (1.0 - novelty_factor) * (1.0 / (1.0 + avg_distance))\n\n        return (local_weight * distance_matrix[current_node][node] +\n                global_weight * avg_distance +\n                novelty_penalty -\n                exploration_term)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.42354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor approach with a balanced scoring mechanism, prioritizing the closest unvisited node (local distance) while slightly considering the average distance to other unvisited nodes (0.3 weight) to avoid local optima. The `calculate_score` function computes a weighted sum of these distances, and the next node is selected based on the minimum score. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines the nearest neighbor approach of No.1 with the balanced scoring of No.2, prioritizing the closest unvisited node while slightly considering the average distance to other unvisited nodes to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes:\n            return local_distance\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        return local_distance + 0.3 * avg_distance\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.42568,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: **local distance** (direct proximity), **global distance** (average distance to unvisited nodes), and **centrality** (inverse of total distances to all nodes). It prioritizes **centrality (0.7 weight)** over **global distance (0.3 weight)** and **local distance (directly added)**, aiming to favor nodes that are centrally located while considering both immediate and broader connectivity. The `calculate_score` function computes these weighted contributions, and the node with the minimum score is chosen.",
          "thought": "The new algorithm combines the local distance prioritization from No.2 with the weighted balance of local and global distances from No.1, adjusting weights to favor global factors slightly more while maintaining centrality considerations, aiming for a lower objective value by balancing proximity, global reach, and node centrality more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.48352,
          "other_inf": null
     }
]