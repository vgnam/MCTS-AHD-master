[
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014local distance, centrality, and coherence\u2014where local distance is prioritized early (higher `weight_local`), centrality gains importance later (increasing `weight_centrality`), and coherence follows a bell curve (peaking midway). The `calculate_score` function combines these weighted factors to select the next node, favoring nearby nodes initially but shifting toward more central and coherent choices as progress increases. The weights adjust linearly or via a bell curve based on the remaining unvisited nodes.",
          "thought": "The new algorithm emphasizes early focus on local distances and later prioritizes centrality and coherence, using inverse-progress-weighted factors where weight_local starts high and decreases, weight_centrality starts low and increases, and weight_coherence follows a bell curve centered in the middle of the path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.7 - 0.4 * progress\n    weight_centrality = 0.1 + 0.4 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor (prioritizing local distance) with dynamic weights that balance centrality (favoring well-connected nodes) and coherence (avoiding isolated nodes) as the tour progresses. Higher weights are given to local distance and coherence early in the tour, while centrality gains importance later. The weights adjust based on progress (total nodes visited), creating a dynamic trade-off between local and global considerations.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting scheme inspired by No.1, balancing local distance (increasing weight) with node centrality (decreasing weight) and coherence (increasing weight) to avoid local optima and improve global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.4 + 0.6 * progress\n    weight_centrality = 0.5 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37567,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP dynamically selects the next node by balancing local distance (50%), centrality (30%), and coherence (20%), while incorporating an adaptive exploration factor (50%) that increases as the algorithm progresses (later stages prioritize exploration). The exploration factor rewards nodes with greater distance from the current node, encouraging diversity to escape local optima. The weights are fixed, with local distance given the highest priority, while centrality and coherence contribute moderately, and coherence is negatively weighted to discourage clustering. The algorithm adapts exploration based on remaining nodes, making it more exploratory in later stages.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines local distance, centrality, and coherence, but with adaptive weights that adjust based on the remaining nodes' distribution and a novel 'exploration factor' that encourages diversity in node selection, particularly in later stages when local minima might trap the solution.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    exploration_factor = 0.1 + 0.9 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        exploration_bonus = (1 - distance_matrix[node][current_node] / max(max(row) for row in distance_matrix)) * exploration_factor\n        return (0.5 * local_distance +\n                0.3 * centrality -\n                0.2 * coherence +\n                0.5 * exploration_bonus)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38422,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance (prioritized early), node centrality (increasing later), and global coherence (peaking midway) using adaptive weights. It combines nearest-neighbor and farthest-insertion heuristics in a hybrid scoring mechanism, adjusting priorities based on progress (progress = 1 - remaining_nodes/total_nodes). Early stages favor short-term connections (weight_local = 0.6 early), while later stages emphasize centrality (weight_centrality increases to 0.5). Coherence (weight_coherence) peaks at mid-progress (0.4) to maintain global structure. The score for each node is calculated as (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality), with the next node selected as the minimum score.",
          "thought": "The new algorithm dynamically balances local distance, global coherence, and node centrality with adaptive weights, prioritizing short-term connections early, mid-term centrality, and long-term coherence later, using a hybrid scoring mechanism that combines nearest-neighbor and farthest-insertion heuristics with progress-based weight adjustments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_coherence = 0.2 + 0.3 * (0.5 - abs(progress - 0.5))\n    weight_centrality = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38959,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three key factors\u2014**local distance**, **centrality**, and **coherence**\u2014to select the next node in the TSP path. Early in the process, **centrality** (node importance) is prioritized, while **local distance** (proximity to the current node) dominates later, with **coherence** (alignment with unvisited nodes) following a bell-curve pattern. The weights are adjusted based on progress, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.2 (local and global optimization) with the centrality and coherence factors from No.1, where centrality is prioritized early and coherence follows a bell curve. The algorithm selects the next node by balancing local distance, centrality, and coherence, with weights adjusted based on progress and coherence's bell curve pattern.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.3 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39596,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three key factors\u2014local distance, centrality, and coherence\u2014to dynamically select the next node in the TSP path, with weights adjusted based on progress. Early in the tour, local distance dominates, while centrality gains importance midway, and coherence becomes critical later. The weighted scoring balances these factors to guide the path toward optimal efficiency.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 (balancing local distance, centrality, and coherence) with the progress-based dynamic adjustment of No.2, using a weighted score that prioritizes local distance early, centrality midway, and coherence later, with weights calculated based on remaining nodes and progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n    weight_coherence = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39842,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence priorities, starting with high local distance weight (0.7) and gradually shifting focus to centrality (0.2\u21920.6) and coherence (0.1\u21920.5) as the search progresses, optimizing the path by prioritizing global metrics early and refining local choices later. The `calculate_score` function combines these weighted factors to select the next node, where local distance dominates early, while centrality and coherence gain importance as unvisited nodes decrease. The weights adjust dynamically based on remaining nodes, ensuring a balance between immediate proximity and global structure.",
          "thought": "The new algorithm dynamically shifts focus from local distance to centrality and coherence, starting with high local distance weight (0.7\u21920.3) and gradually increasing centrality (0.2\u21920.6) and coherence (0.1\u21920.5) weights, prioritizing global metrics early and refining local choices later for better path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    weight_local = 0.7 - 0.4 * (1 - remaining_ratio)\n    weight_centrality = 0.2 + 0.4 * (1 - remaining_ratio)\n    weight_coherence = 0.1 + 0.4 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.42324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local optimization (prioritized early) with global structure (emphasized later) by adjusting weights: `weight_local` increases linearly, `weight_centrality` decreases exponentially, and `weight_coherence` increases linearly. It selects the next node by minimizing a weighted score combining local distance, node centrality (inverse of total distance to all nodes), and coherence (average distance to unvisited nodes). Early in the path, local distance dominates, while centrality and coherence gain importance as progress increases.",
          "thought": "The new algorithm prioritizes local distance early in the path construction, with centrality and coherence becoming more influential later. It uses linearly increasing weight_local, exponentially decreasing weight_centrality, and linearly increasing weight_coherence, dynamically adjusting these weights based on progress to balance local optimization and global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.3 + 0.7 * progress\n    weight_centrality = 0.6 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.43208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines adaptive weight scaling with exponential decay to balance local distance, centrality, and coherence, prioritizing local distance (weight 0.7-1.0) and centrality (weight 0.2-0.6) over coherence (weight 0.1-0.8), while dynamically adjusting weights based on remaining nodes. It uses a multiplicative local-global balance metric and subtractive coherence term to avoid over-prioritization, with weights decaying exponentially as the tour progresses. The score is minimized to select the next node.",
          "thought": "This algorithm modifies the original by introducing adaptive weight scaling with exponential decay and incorporating a novel 'local-global balance' metric that combines distance and centrality in a multiplicative fashion, while preserving coherence as a subtractive term to avoid over-prioritization.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    decay_factor = math.exp(-remaining_ratio)\n\n    weight_local = 0.7 * decay_factor + 0.3\n    weight_centrality = 0.4 * decay_factor + 0.2\n    weight_coherence = 0.1 * decay_factor + 0.4\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        local_global_balance = (local_distance * centrality) ** 0.5\n        return (weight_local * local_distance) + (weight_centrality * local_global_balance) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.43243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three priorities\u2014**local distance (highest weight initially)**, **centrality (moderate weight initially)**, and **coherence (lowest weight initially)**\u2014by adjusting weights based on the remaining unvisited nodes. It prioritizes immediate proximity early on while increasingly considering node centrality and coherence as the tour progresses, ensuring a trade-off between short-term and long-term optimization. The weights are computed using a ratio of remaining nodes, with local distance dominating early (weight_local = 0.6), centrality and coherence increasing over time. The next node is selected by minimizing a weighted score combining direct distance, centrality, and average remaining distance.",
          "thought": "The new algorithm combines the dynamic weight balancing of No.1 (adjusting local distance, centrality, and coherence priorities) with the modified farthest insertion approach of No.2 (balancing direct distance and average remaining distance), resulting in a heuristic that prioritizes immediate proximity while adaptively considering centrality and coherence as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    weight_local = 0.6 - 0.3 * (1 - remaining_ratio)\n    weight_centrality = 0.2 + 0.3 * (1 - remaining_ratio)\n    weight_coherence = 0.2 + 0.5 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        direct_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        avg_remaining_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return (weight_local * direct_distance) + (weight_centrality * centrality) - (weight_coherence * avg_remaining_distance)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.44109,
          "other_inf": null
     }
]