[
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014local distance, centrality, and coherence\u2014where local distance is prioritized early (higher `weight_local`), centrality gains importance later (increasing `weight_centrality`), and coherence follows a bell curve (peaking midway). The `calculate_score` function combines these weighted factors to select the next node, favoring nearby nodes initially but shifting toward more central and coherent choices as progress increases. The weights adjust linearly or via a bell curve based on the remaining unvisited nodes.",
          "thought": "The new algorithm emphasizes early focus on local distances and later prioritizes centrality and coherence, using inverse-progress-weighted factors where weight_local starts high and decreases, weight_centrality starts low and increases, and weight_coherence follows a bell curve centered in the middle of the path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.7 - 0.4 * progress\n    weight_centrality = 0.1 + 0.4 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor (prioritizing local distance) with dynamic weights that balance centrality (favoring well-connected nodes) and coherence (avoiding isolated nodes) as the tour progresses. Higher weights are given to local distance and coherence early in the tour, while centrality gains importance later. The weights adjust based on progress (total nodes visited), creating a dynamic trade-off between local and global considerations.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting scheme inspired by No.1, balancing local distance (increasing weight) with node centrality (decreasing weight) and coherence (increasing weight) to avoid local optima and improve global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.4 + 0.6 * progress\n    weight_centrality = 0.5 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.37567,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP dynamically selects the next node by balancing local distance (50%), centrality (30%), and coherence (20%), while incorporating an adaptive exploration factor (50%) that increases as the algorithm progresses (later stages prioritize exploration). The exploration factor rewards nodes with greater distance from the current node, encouraging diversity to escape local optima. The weights are fixed, with local distance given the highest priority, while centrality and coherence contribute moderately, and coherence is negatively weighted to discourage clustering. The algorithm adapts exploration based on remaining nodes, making it more exploratory in later stages.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines local distance, centrality, and coherence, but with adaptive weights that adjust based on the remaining nodes' distribution and a novel 'exploration factor' that encourages diversity in node selection, particularly in later stages when local minima might trap the solution.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    exploration_factor = 0.1 + 0.9 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        exploration_bonus = (1 - distance_matrix[node][current_node] / max(max(row) for row in distance_matrix)) * exploration_factor\n        return (0.5 * local_distance +\n                0.3 * centrality -\n                0.2 * coherence +\n                0.5 * exploration_bonus)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38422,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance (prioritized early), node centrality (increasing later), and global coherence (peaking midway) using adaptive weights. It combines nearest-neighbor and farthest-insertion heuristics in a hybrid scoring mechanism, adjusting priorities based on progress (progress = 1 - remaining_nodes/total_nodes). Early stages favor short-term connections (weight_local = 0.6 early), while later stages emphasize centrality (weight_centrality increases to 0.5). Coherence (weight_coherence) peaks at mid-progress (0.4) to maintain global structure. The score for each node is calculated as (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality), with the next node selected as the minimum score.",
          "thought": "The new algorithm dynamically balances local distance, global coherence, and node centrality with adaptive weights, prioritizing short-term connections early, mid-term centrality, and long-term coherence later, using a hybrid scoring mechanism that combines nearest-neighbor and farthest-insertion heuristics with progress-based weight adjustments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_coherence = 0.2 + 0.3 * (0.5 - abs(progress - 0.5))\n    weight_centrality = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.38959,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three key factors\u2014**local distance**, **centrality**, and **coherence**\u2014to select the next node in the TSP path. Early in the process, **centrality** (node importance) is prioritized, while **local distance** (proximity to the current node) dominates later, with **coherence** (alignment with unvisited nodes) following a bell-curve pattern. The weights are adjusted based on progress, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.2 (local and global optimization) with the centrality and coherence factors from No.1, where centrality is prioritized early and coherence follows a bell curve. The algorithm selects the next node by balancing local distance, centrality, and coherence, with weights adjusted based on progress and coherence's bell curve pattern.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.3 * progress\n    weight_coherence = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39596,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three key factors\u2014local distance, centrality, and coherence\u2014to dynamically select the next node in the TSP path, with weights adjusted based on progress. Early in the tour, local distance dominates, while centrality gains importance midway, and coherence becomes critical later. The weighted scoring balances these factors to guide the path toward optimal efficiency.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 (balancing local distance, centrality, and coherence) with the progress-based dynamic adjustment of No.2, using a weighted score that prioritizes local distance early, centrality midway, and coherence later, with weights calculated based on remaining nodes and progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.6 - 0.3 * progress\n    weight_centrality = 0.2 + 0.4 * (0.5 - abs(progress - 0.5))\n    weight_coherence = 0.2 + 0.3 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.39842,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically balances three priorities\u2014local distance (prioritized early), centrality (prioritized midway), and coherence (prioritized late)\u2014by adjusting weights based on progress. It combines nearest-neighbor and farthest-insertion principles, favoring nearby nodes early, central nodes midway, and cohesive clusters late. The `select_next_node` function calculates a weighted score for each unvisited node, combining local distance (decreased weight), centrality (increased weight), and coherence (increased weight) to determine the next node.",
          "thought": "The new algorithm dynamically adjusts weights for local distance (decreasing early), centrality (increasing midway), and coherence (peaking late) based on progress, combining nearest-neighbor and farthest-insertion principles with adaptive priorities.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.7 - 0.4 * progress\n    weight_centrality = 0.2 + 0.3 * (0.5 - abs(progress - 0.5))\n    weight_coherence = 0.1 + 0.4 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.4214,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence priorities, starting with high local distance weight (0.7) and gradually shifting focus to centrality (0.2\u21920.6) and coherence (0.1\u21920.5) as the search progresses, optimizing the path by prioritizing global metrics early and refining local choices later. The `calculate_score` function combines these weighted factors to select the next node, where local distance dominates early, while centrality and coherence gain importance as unvisited nodes decrease. The weights adjust dynamically based on remaining nodes, ensuring a balance between immediate proximity and global structure.",
          "thought": "The new algorithm dynamically shifts focus from local distance to centrality and coherence, starting with high local distance weight (0.7\u21920.3) and gradually increasing centrality (0.2\u21920.6) and coherence (0.1\u21920.5) weights, prioritizing global metrics early and refining local choices later for better path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    weight_local = 0.7 - 0.4 * (1 - remaining_ratio)\n    weight_centrality = 0.2 + 0.4 * (1 - remaining_ratio)\n    weight_coherence = 0.1 + 0.4 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.42324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a hybrid scoring mechanism that dynamically adjusts weights for local distance, centrality, and coherence based on progress. Early in the search (low progress), it prioritizes local distance and centrality, while later (high progress), it shifts focus to coherence and centrality. The weights are calculated using a progress-dependent formula, ensuring adaptability to different stages of the TSP traversal. The `calculate_score` function computes a weighted sum of these factors, with local distance penalized and centrality rewarded, while coherence is inversely weighted. The next node is selected as the one with the minimal score, balancing immediate proximity, long-term centrality, and coherence with unvisited nodes.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (balancing local distance, centrality, and coherence) with the efficiency and connectivity-aware selection of No.2, using a weighted score that prioritizes proximity, centrality, and coherence in a hybrid scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.5 - 0.2 * progress\n    weight_coherence = 0.3 + 0.2 * (0.5 - abs(progress - 0.5))\n    weight_centrality = 0.3 + 0.2 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) - (weight_coherence * coherence) + (weight_centrality * centrality)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.42933,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local optimization (prioritized early) with global structure (emphasized later) by adjusting weights: `weight_local` increases linearly, `weight_centrality` decreases exponentially, and `weight_coherence` increases linearly. It selects the next node by minimizing a weighted score combining local distance, node centrality (inverse of total distance to all nodes), and coherence (average distance to unvisited nodes). Early in the path, local distance dominates, while centrality and coherence gain importance as progress increases.",
          "thought": "The new algorithm prioritizes local distance early in the path construction, with centrality and coherence becoming more influential later. It uses linearly increasing weight_local, exponentially decreasing weight_centrality, and linearly increasing weight_coherence, dynamically adjusting these weights based on progress to balance local optimization and global structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    progress = 1 - (remaining_nodes / total_nodes)\n\n    weight_local = 0.3 + 0.7 * progress\n    weight_centrality = 0.6 * (0.5 ** progress)\n    weight_coherence = 0.2 + 0.8 * progress\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.43208,
          "other_inf": null
     }
]