[
     {
          "algorithm": "The algorithm dynamically balances local distance, centrality, and coherence by adjusting weights (60% local/centrality, 40% coherence) based on remaining nodes, prioritizing immediate proximity and long-term optimization. It selects the next node by minimizing a weighted score combining local distance, node centrality (inverse of total distances), and average coherence (distances to unvisited nodes). The weights are adaptive, favoring local/centrality early and coherence later, ensuring a trade-off between short-term and long-term optimization.",
          "thought": "The new algorithm combines the adaptive weighting of local distance, centrality, and coherence from No.1 with the hybrid nearest-neighbor and farthest-insertion approach of No.2, using dynamic weights (60% local/centrality, 40% coherence) that adjust based on remaining nodes, ensuring a balance between immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_local = 0.6 - 0.2 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.3 + 0.1 * (remaining_nodes / len(distance_matrix))\n    weight_coherence = 0.4 - 0.2 * (remaining_nodes / len(distance_matrix))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.44406,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global considerations by adjusting weights based on remaining nodes, prioritizing local distance early (higher weight) and gradually incorporating global centrality and inverse global distance (lower weight) for long-term optimization. It selects the next node by minimizing a weighted score combining these factors, with local distance dominating initially and global metrics gaining importance as the tour progresses. The code structure clearly separates weight calculation, score computation, and node selection, ensuring a smooth transition between exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weighting with local distance, global centrality, and inverse global distance inspired by No.1, while maintaining the dynamic weight adjustment of No.2 to balance exploration and exploitation. The algorithm calculates dynamic weights based on remaining nodes, prioritizes local distance early, and gradually incorporates global centrality and inverse global distance for better long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_weight * local_distance + global_weight * (0.5 * centrality + 0.5 * inverse_global)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.48396,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts selection priorities by weighting local distance (higher early on), global centrality (moderate), and path coherence (lower initially) based on remaining nodes, using a scoring function that balances these factors. Local distance dominates early, while coherence gains importance later. The weights are inversely proportional to the remaining path length, ensuring adaptability.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment mechanism based on the remaining path length, combining local distance, global centrality, and a novel \"path coherence\" factor that measures alignment with the overall path direction, while preserving the original structure with a different scoring function and adaptive weights.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_local = 0.5 + 0.4 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.3 + 0.2 * (remaining_nodes / len(distance_matrix))\n    weight_coherence = 0.2 + 0.3 * (remaining_nodes / len(distance_matrix))\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.52042,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor heuristic (70% weight) with a global measure (30% weight) that balances centrality (inverse sum of all distances) and inverse average distance to unvisited nodes. It prioritizes local proximity (via nearest neighbor) while incorporating limited global considerations to avoid myopia, with the hybrid score ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the nearest neighbor heuristic from No.2 with a refined global measure that considers both centrality and inverse global distance, inspired by No.1, to balance local and global optimization with a hybrid score (70% local, 30% global).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_measure = lambda node: 0.7 * (1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)) + 0.3 * (1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10))\n    hybrid_score = lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * global_measure(node)\n    next_node = min(unvisited_nodes, key=hybrid_score)\n    return next_node",
          "objective": 6.52706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically prioritizes local distance (higher early), centrality (moderate), and coherence (higher late) using weighted factors that adjust based on remaining nodes. Local distance dominates early (weight 0.6\u20130.9), while coherence gains importance later (weight 0.1\u20130.5), with centrality (fixed 0.3) as a steady balancing factor. The weights are derived from the ratio of unvisited nodes to total nodes, ensuring adaptability to problem size.",
          "thought": "The new algorithm combines the adaptive weighting of local distance, centrality, and coherence from No.1 with the fixed-weight structure of No.2, but uses dynamic weights that prioritize local distance early and coherence later, while maintaining centrality as a moderate factor throughout.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_local = 0.6 + 0.3 * (remaining_nodes / len(distance_matrix))\n    weight_centrality = 0.3\n    weight_coherence = 0.1 + 0.4 * (1 - remaining_nodes / len(distance_matrix))\n\n    def calculate_weight(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_weight)\n    return next_node",
          "objective": 6.53054,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance (prioritized early) with global metrics (centrality and inverse global distance) using dynamic weights that shift from local to global focus as unvisited nodes decrease. Local distance dominates early (high initial weight), while centrality (node importance) and inverse global distance (proximity to unvisited nodes) gain influence later, balancing short-term and long-term optimization. The scoring function dynamically adjusts weights based on remaining nodes, ensuring adaptability throughout the TSP traversal.",
          "thought": "The new algorithm combines dynamic weight adjustment between local distance and global metrics (centrality and inverse global distance) inspired by No.1, while maintaining the hybrid scoring framework of No.2. It prioritizes local distance early and gradually incorporates global metrics for long-term optimization, with weights shifting based on remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n    local_weight = 0.6 + 0.4 * (1 - remaining_ratio)\n    global_weight = 1 - local_weight\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_weight * local_distance + global_weight * (0.6 * centrality + 0.4 * inverse_global)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.5571,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm dynamically balances local distance, centrality, and coherence by adjusting weights based on remaining nodes, prioritizing local distance early and global metrics later. Weights for local distance increase (0.6\u21921.0), while centrality (0.3\u21920.5) and coherence (0.1\u21920.5) weights rise proportionally, ensuring smooth transition from exploration to exploitation. The scoring function combines these weighted components to select the next node, favoring nodes with shorter local distances, higher centrality, and better coherence with unvisited nodes.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (local distance early, global metrics later) with the scoring function structure of No.2 (balancing local distance, centrality, and coherence), where weights are inversely proportional to remaining nodes, ensuring a smooth transition from exploration to exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    remaining_ratio = remaining_nodes / total_nodes\n    weight_local = 0.6 + 0.4 * (1 - remaining_ratio)\n    weight_centrality = 0.3 + 0.2 * (1 - remaining_ratio)\n    weight_coherence = 0.1 + 0.4 * (1 - remaining_ratio)\n\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)\n        coherence = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)\n        return (weight_local * local_distance) + (weight_centrality * centrality) - (weight_coherence * coherence)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.57788,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (70% weight) with global centrality (20% weight) and inverse average distance (10% weight) to balance local efficiency and long-term optimization. It prioritizes immediate proximity (local_distance) while incorporating limited global considerations (centrality and inverse_avg) to avoid getting stuck in local optima. The weights reflect a strong preference for short-term gains, with minimal consideration for long-term path quality.",
          "thought": "The new algorithm combines nearest-neighbor selection with global centrality and inverse average distance, weighted to balance local efficiency and long-term path optimization, using a hybrid score that prioritizes immediate proximity while incorporating limited global considerations through centrality and inverse average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_avg = 1 / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) + 1e-10)\n        return 0.7 * local_distance + 0.2 * centrality + 0.1 * inverse_avg\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.58482,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing local distance (highest priority) and combining it with a weighted sum of global distance (0.3 weight), centrality (0.7 weight), and inverse global distance (0.2 weight), where centrality is calculated as the inverse of the sum of distances to all nodes (to favor globally central nodes). The function first checks if all nodes are visited and returns the destination if true; otherwise, it evaluates each unvisited node based on the weighted score and selects the one with the minimum score.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are both nearby and globally central, balancing local distance (highest priority) with a weighted sum of global distance (0.3 weight) and centrality (0.7 weight), while also considering the inverse of the sum of distances to unvisited nodes as a secondary global factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        if not unvisited_nodes:\n            return distance_matrix[current_node][node]\n        local_distance = distance_matrix[current_node][node]\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return local_distance + 0.3 * global_distance + 0.7 * centrality + 0.2 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by combining three factors: local distance (60% weight), centrality (30% weight), and inverse global distance (10% weight). It prioritizes immediate proximity to the current node while also considering the node's centrality in the graph and its average distance to unvisited nodes, ensuring a balance between short-term and long-term optimization. The `calculate_score` function computes a weighted sum of these factors, and the node with the minimum score is chosen as the next step.",
          "thought": "The new algorithm combines the hybrid scoring approach of No.2 with the centrality and global distance considerations of No.1, prioritizing immediate distance (60%), centrality (30%), and inverse global distance (10%) to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def calculate_score(node):\n        local_distance = distance_matrix[current_node][node]\n        centrality = 1 / (sum(distance_matrix[node][n] for n in range(len(distance_matrix))) + 1e-10)\n        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        inverse_global = 1 / (global_distance + 1e-10)\n        return 0.6 * local_distance + 0.3 * centrality + 0.1 * inverse_global\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.61548,
          "other_inf": null
     }
]