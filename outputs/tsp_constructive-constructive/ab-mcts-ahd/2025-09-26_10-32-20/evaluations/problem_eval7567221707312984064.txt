import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(unvisited_nodes) + 1
    exploration_factor = 1 / (1 + math.exp(-5 * (remaining_nodes / total_nodes - 0.5)))

    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes
    dynamic_threshold = 1.2 * avg_distance_to_dest

    def hybrid_score(node):
        local_cost = distance_matrix[current_node][node]
        global_cost = distance_matrix[node][destination_node]
        path_cost = local_cost + global_cost
        penalty = max(0, (path_cost - dynamic_threshold) ** 1.5)
        normalized_cost = (local_cost + global_cost) / (distance_matrix[current_node][destination_node] + 1e-6)
        return (1 - exploration_factor) * normalized_cost + exploration_factor * penalty

    candidates = sorted(unvisited_nodes, key=hybrid_score)[:max(1, remaining_nodes // 2)]
    next_node = random.choice(candidates) if random.random() < exploration_factor else candidates[0]
    return next_node
