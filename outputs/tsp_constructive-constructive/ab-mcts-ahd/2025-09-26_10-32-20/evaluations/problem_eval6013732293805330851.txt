import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1
    progress = 1 - (len(unvisited_nodes) / total_nodes)

    # Temperature-based dynamic weighting
    temperature = math.exp(-5 * progress)
    weight_local = temperature * (1 - progress)
    weight_global = (1 - temperature) * progress

    # Novel adaptive penalty function
    penalty = lambda node: (
        0.1 * distance_matrix[current_node][node] +
        0.3 * distance_matrix[node][destination_node] +
        0.6 * sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)
    ) if unvisited_nodes else 0

    # Temperature-adjusted hybrid score
    hybrid_score = lambda node: (
        weight_local * distance_matrix[current_node][node] +
        weight_global * distance_matrix[node][destination_node] +
        penalty(node) * (1 + 0.5 * temperature)
    )

    # Adaptive selection with fallback
    try:
        candidates = sorted(unvisited_nodes, key=hybrid_score)
        next_node = candidates[0] if len(candidates) > 0 else destination_node
    except:
        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])

    return next_node
