import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    decay_factor = math.exp(-remaining_nodes / len(unvisited_nodes))  # Decays as nodes are visited
    local_weight = decay_factor
    global_weight = 1 - decay_factor

    def cost_function(node):
        local_dist = distance_matrix[current_node][node]
        global_dist = distance_matrix[node][destination_node]
        detour_penalty = max(0, (local_dist + global_dist) - 1.5 * distance_matrix[current_node][destination_node])
        weighted_cost = (local_weight * local_dist) + (global_weight * global_dist) + detour_penalty
        return weighted_cost

    # Calculate probabilities inversely proportional to cost
    costs = [cost_function(node) for node in unvisited_nodes]
    min_cost = min(costs)
    max_cost = max(costs)
    normalized_costs = [(max_cost - cost + min_cost) / (max_cost - min_cost + 1e-10) for cost in costs]
    total_utility = sum(normalized_costs)
    probabilities = [utility / total_utility for utility in normalized_costs]

    # Select node based on probability
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]
    return next_node
