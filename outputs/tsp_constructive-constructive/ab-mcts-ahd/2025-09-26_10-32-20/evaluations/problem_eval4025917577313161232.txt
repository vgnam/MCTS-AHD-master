def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def calculate_score(node):
        local_distance = distance_matrix[current_node][node]
        if not unvisited_nodes:
            return local_distance
        global_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)
        remaining_nodes = len(unvisited_nodes)
        weight_factor = 1 - (1 / (1 + remaining_nodes))
        return (1 - weight_factor) * local_distance + weight_factor * global_distance

    scores = {node: calculate_score(node) for node in unvisited_nodes}
    min_score = min(scores.values())
    max_score = max(scores.values())
    threshold = min_score + 0.3 * (max_score - min_score)  # Dynamic threshold

    candidates = [node for node, score in scores.items() if score <= threshold]
    if not candidates:
        next_node = min(unvisited_nodes, key=lambda x: scores[x])
    else:
        next_node = min(candidates, key=lambda x: scores[x])

    return next_node
