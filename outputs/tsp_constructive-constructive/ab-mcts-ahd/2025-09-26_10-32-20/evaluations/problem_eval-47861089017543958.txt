def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Dynamic penalty term based on historical costs (simulated here as a simple penalty)
    penalty = {node: sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0
               for node in unvisited_nodes}

    # Weighted selection: prioritize nodes that are closer to current and destination, penalize high-cost nodes
    next_node = max(unvisited_nodes, key=lambda node: (
        -distance_matrix[current_node][node] * 0.6  # Weighted local distance
        + distance_matrix[node][destination_node] * 0.4  # Weighted global distance
        - penalty[node] * 0.2  # Dynamic penalty term
    ))
    return next_node
