def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_ratio = len(unvisited_nodes) / total_nodes
    local_weight = 0.5 * (1 - remaining_ratio)
    global_weight = 1 - local_weight

    def centrality(node):
        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)

    scores = []
    for node in unvisited_nodes:
        local_score = distance_matrix[current_node][node]
        global_score = centrality(node)
        hybrid_score = local_weight * local_score + global_weight * global_score
        scores.append((node, hybrid_score))

    if not scores:
        return destination_node

    min_score = min(score for _, score in scores)
    max_score = max(score for _, score in scores)

    if min_score == max_score:
        probabilities = [1.0 / len(scores)] * len(scores)
    else:
        normalized_scores = [(max_score - score) / (max_score - min_score) for _, score in scores]
        total_normalized = sum(normalized_scores)
        probabilities = [score / total_normalized for score in normalized_scores]

    selected_index = np.random.choice(len(scores), p=probabilities)
    next_node = scores[selected_index][0]

    return next_node
