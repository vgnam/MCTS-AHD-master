def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    phase_progress = remaining_nodes / total_nodes

    # Sigmoid-based weight transition
    local_weight = 0.7 * (1 / (1 + math.exp(10 * (phase_progress - 0.5))))
    global_weight = 1 - local_weight

    def cost_function(node):
        local_dist = distance_matrix[current_node][node]
        node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] < 1e-10)
        centrality = node_degree / (total_nodes - 1)
        global_dist = distance_matrix[node][destination_node]
        global_var = np.var([distance_matrix[node][n] for n in unvisited_nodes])

        weighted_cost = (local_weight * (0.6 * local_dist + 0.4 * centrality) +
                         global_weight * (0.7 * global_dist + 0.3 * global_var))
        return weighted_cost

    next_node = min(unvisited_nodes, key=cost_function)
    return next_node
