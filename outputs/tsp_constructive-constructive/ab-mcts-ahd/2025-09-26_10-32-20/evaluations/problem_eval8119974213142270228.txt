def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate centroid of remaining unvisited nodes
    centroid = [0.0, 0.0]
    for node in unvisited_nodes:
        centroid[0] += distance_matrix[node][0]  # Assuming node coordinates are stored in distance_matrix
        centroid[1] += distance_matrix[node][1]
    centroid = [c / len(unvisited_nodes) for c in centroid]

    def weighted_score(node):
        # Distance to centroid (exploration factor)
        node_coords = [distance_matrix[node][0], distance_matrix[node][1]]
        centroid_distance = ((node_coords[0] - centroid[0])**2 + (node_coords[1] - centroid[1])**2)**0.5

        # Direct distance to current node (exploitation factor)
        direct_distance = distance_matrix[current_node][node]

        # Add small randomness to escape local optima
        random_factor = 0.1 * (len(unvisited_nodes) / (len(distance_matrix) + 1))

        return (direct_distance * 0.6 + centroid_distance * 0.4) * (1 + random_factor)

    next_node = max(unvisited_nodes, key=weighted_score)
    return next_node
