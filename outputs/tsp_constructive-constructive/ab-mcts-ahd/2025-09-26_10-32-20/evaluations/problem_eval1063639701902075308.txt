def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Compute weighted sum of distances
    weighted_distances = [
        (node, distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])
        for node in unvisited_nodes
    ]

    # Softmax to convert distances into probabilities
    distances = [dist for _, dist in weighted_distances]
    max_dist = max(distances)
    exp_distances = [math.exp(-dist / max_dist) for dist in distances]
    sum_exp = sum(exp_distances)
    probabilities = [exp / sum_exp for exp in exp_distances]

    # Select node based on probabilities
    next_node = random.choices(
        [node for node, _ in weighted_distances],
        weights=probabilities,
        k=1
    )[0]

    return next_node
