def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_ratio = len(unvisited_nodes) / total_nodes
    temperature = remaining_ratio  # Decreases as more nodes are visited

    nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    farthest_insertion = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node])

    def centrality(node):
        return 1 / (sum(distance_matrix[node][n] for n in range(total_nodes)) + 1e-10)

    scores = []
    for node in unvisited_nodes:
        nn_score = distance_matrix[current_node][node]
        fi_score = distance_matrix[node][destination_node]
        c_score = centrality(node)
        combined_score = 0.5 * nn_score + 0.3 * fi_score + 0.2 * c_score
        scores.append(combined_score)

    min_score = min(scores)
    max_score = max(scores)
    normalized_scores = [(max_score - s + 1e-10) / (max_score - min_score + 1e-10) for s in scores]

    probabilities = [np.exp(-s / temperature) for s in normalized_scores]
    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]

    next_node = np.random.choice(unvisited_nodes, p=probabilities)
    return next_node
