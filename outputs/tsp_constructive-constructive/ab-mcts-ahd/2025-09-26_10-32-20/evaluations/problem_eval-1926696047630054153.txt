def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    decay_factor = 0.5 ** (1 / remaining_nodes)
    weight_proximity = decay_factor * (remaining_nodes / (remaining_nodes + 1))

    # Memory-based penalty for recently visited nodes (simplified)
    penalty = {node: 0.1 if node == current_node else 0 for node in unvisited_nodes}

    next_node = min(unvisited_nodes, key=lambda node:
        weight_proximity * distance_matrix[current_node][node] +
        (1 - weight_proximity) * (distance_matrix[node][destination_node] ** 1.5) +
        penalty[node]
    )
    return next_node
