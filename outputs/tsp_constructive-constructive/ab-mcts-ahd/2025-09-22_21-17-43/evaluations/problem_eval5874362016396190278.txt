def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic weights based on path progress
    current_distance = distance_matrix[current_node][destination_node]
    avg_distance = sum(sum(row) for row in distance_matrix) / (len(distance_matrix) ** 2)
    progress_ratio = current_distance / avg_distance if avg_distance > 0 else 1.0
    local_weight = 0.5 + 0.4 * progress_ratio
    destination_weight = 1.0 - local_weight

    # Track visit history (simplified for this example)
    visit_counts = {node: 0 for node in unvisited_nodes}
    for node in unvisited_nodes:
        if node in visit_counts:
            visit_counts[node] += 1

    def weighted_score(node):
        local_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]
        penalty = 0.1 * visit_counts.get(node, 0)  # Penalize frequently visited nodes
        return (local_weight * local_distance + destination_weight * destination_distance) * (1 + penalty)

    next_node = min(unvisited_nodes, key=lambda node: weighted_score(node))
    return next_node
