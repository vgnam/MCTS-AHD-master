[
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing unvisited nodes over the destination node until all nodes are visited, then returning to the destination. The `select_next_node` function prioritizes `unvisited_nodes` over the `destination_node` by checking if `unvisited_nodes` is empty before returning the destination. It uses the `distance_matrix` to find the closest unvisited node, ensuring efficiency and correctness in TSP path construction.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing unvisited nodes to ensure all nodes are visited before returning to the destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and destination distances using a weighted score, where weights adjust based on progress (higher local weight early, higher destination weight later). It penalizes frequently visited nodes to encourage diversification, with the next node selected by minimizing this weighted score. The `progress_ratio` and `visit_counts` dictate priorities, favoring closer local moves early and more strategic long-term connections later.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between local and destination distances based on the ratio of the current path length to the estimated total path length, ensuring adaptability to different stages of the tour construction. It also incorporates a penalty for nodes that have been visited multiple times in the past to encourage diversification.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weights based on path progress\n    current_distance = distance_matrix[current_node][destination_node]\n    avg_distance = sum(sum(row) for row in distance_matrix) / (len(distance_matrix) ** 2)\n    progress_ratio = current_distance / avg_distance if avg_distance > 0 else 1.0\n    local_weight = 0.5 + 0.4 * progress_ratio\n    destination_weight = 1.0 - local_weight\n\n    # Track visit history (simplified for this example)\n    visit_counts = {node: 0 for node in unvisited_nodes}\n    for node in unvisited_nodes:\n        if node in visit_counts:\n            visit_counts[node] += 1\n\n    def weighted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        penalty = 0.1 * visit_counts.get(node, 0)  # Penalize frequently visited nodes\n        return (local_weight * local_distance + destination_weight * destination_distance) * (1 + penalty)\n\n    next_node = min(unvisited_nodes, key=lambda node: weighted_score(node))\n    return next_node",
          "objective": 7.00685,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance, destination proximity, and deviation from the average distance to unvisited nodes. It prioritizes shorter local distances (weighted 1.0) and penalizes nodes farther from the destination (weighted 0.3), while dynamically adjusting for how much a node's distance deviates from the average (weighted 0.2). The structure ensures exploration while favoring nodes that are both locally close and strategically positioned relative to the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic penalty term based on the average distance from the current node to all unvisited nodes, combined with a distance-to-destination penalty, to balance exploration and local optimality more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def adjusted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        penalty = 0.3 * distance_matrix[node][destination_node]\n        average_distance = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        dynamic_penalty = 0.2 * (distance_matrix[current_node][node] - average_distance)\n        return local_distance + penalty + dynamic_penalty\n    next_node = min(unvisited_nodes, key=lambda node: adjusted_score(node))\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (prioritized) and a progress penalty (weighted at 0.3) that decreases as the number of unvisited nodes decreases, encouraging closer nodes early while gradually favoring paths that progress toward the destination. The `adjusted_score` combines these factors dynamically, with local distance dominating early and the penalty term becoming more influential as the tour nears completion.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic penalty based on the node's position relative to the current path's progress, using a weighted combination of local distance and a penalty term that decreases as the algorithm approaches the destination, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    def adjusted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        progress_penalty = (total_unvisited / (total_unvisited + 1)) * distance_matrix[node][destination_node]\n        return local_distance + 0.3 * progress_penalty\n\n    next_node = min(unvisited_nodes, key=lambda node: adjusted_score(node))\n    return next_node",
          "objective": 7.37817,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global considerations: it prioritizes immediate proximity (local distance) while also accounting for the average distance to remaining unvisited nodes (global factor), with a 20% weight given to the global factor. The `combined_score` function balances these two factors, and the next node is selected based on the minimum score. The global factor is only computed if there are multiple unvisited nodes, ensuring efficiency.",
          "thought": "The new algorithm combines the local distance optimization from No.2 with a global consideration inspired by No.1, balancing immediate proximity to the current node with the average distance to remaining unvisited nodes to guide the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def combined_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_factor = 0\n        if len(unvisited_nodes) > 1:\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    global_factor += distance_matrix[node][other_node]\n            global_factor /= (len(unvisited_nodes) - 1)\n        return local_distance + 0.2 * global_factor\n    next_node = min(unvisited_nodes, key=lambda node: combined_score(node))\n    return next_node",
          "objective": 7.3983,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global factors in TSP by prioritizing nodes with minimal immediate distance (`local_distance`) while adjusting the weight of global connectivity (`global_factor`) and maximum distance (`max_distance`) based on remaining unvisited nodes. The dynamic weight (`dynamic_weight`) decreases as the number of remaining nodes decreases, reducing global influence in later stages of the path, while the `max_distance` term ensures robustness by penalizing nodes far from unvisited nodes.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting scheme that adjusts the balance between local and global factors based on the remaining unvisited nodes, using a novel scoring mechanism that considers both immediate proximity and long-term connectivity, while also introducing a heuristic to prioritize nodes that minimize the maximum distance to any unvisited node to ensure robustness in path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def combined_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_factor = 0\n        max_distance = 0\n        remaining_nodes = len(unvisited_nodes)\n\n        if remaining_nodes > 1:\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    dist = distance_matrix[node][other_node]\n                    global_factor += dist\n                    if dist > max_distance:\n                        max_distance = dist\n            global_factor /= (remaining_nodes - 1)\n\n        dynamic_weight = 0.5 / (1 + remaining_nodes)\n        return local_distance + dynamic_weight * global_factor + 0.2 * max_distance\n\n    next_node = min(unvisited_nodes, key=lambda node: combined_score(node))\n    return next_node",
          "objective": 7.40423,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance, a non-linear penalty for distance to the destination, and a proximity bonus to encourage diversity. It prioritizes nodes closer to the current node but penalizes those too far from the destination, while slightly rewarding intermediate distances. The `adjusted_score` function combines these factors to guide the selection toward a trade-off between proximity and global efficiency.",
          "thought": "The new algorithm modifies the selection by incorporating a dynamic penalty that grows non-linearly with the distance to the destination, ensuring a balance between proximity to the current node and exploration of less direct but potentially more efficient paths, while also favoring nodes that are neither too close nor too far from the current node to encourage diversity in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def adjusted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        penalty = 0.3 * (distance_matrix[node][destination_node] ** 1.5)\n        proximity_bonus = 0.2 * (1 / (1 + distance_matrix[current_node][node]))\n        return local_distance + penalty - proximity_bonus\n    next_node = min(unvisited_nodes, key=lambda node: adjusted_score(node))\n    return next_node",
          "objective": 7.41142,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (local optimization) with potential long-term tour impact (global consideration), prioritizing nodes that minimize both the distance from the current node and the average distance to remaining unvisited nodes. The `combined_score` function weights the local distance (100%) and global factor (30%) to guide the selection, while the `min` function ensures the node with the lowest combined score is chosen. The algorithm defaults to the destination when no unvisited nodes remain.",
          "thought": "The algorithm dynamically selects the next node by combining local distance optimization with global tour balance, favoring nodes that minimize the immediate distance while also considering their potential to reduce the overall tour length by connecting to the destination or remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def combined_score(node):\n        local_distance = distance_matrix[current_node][node]\n        global_factor = 0\n        if len(unvisited_nodes) > 1:\n            for other_node in unvisited_nodes:\n                if other_node != node:\n                    global_factor += distance_matrix[node][other_node]\n            global_factor /= (len(unvisited_nodes) - 1)\n        return local_distance + 0.3 * global_factor\n    next_node = min(unvisited_nodes, key=lambda node: combined_score(node))\n    return next_node",
          "objective": 7.44662,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the shortest distance from the current node while penalizing nodes that are too close to the destination, balancing local optimality and exploration. The `adjusted_score` function combines the direct distance to the current node with a penalty proportional to the distance from the chosen node to the destination, ensuring intermediate nodes are favored. The `min` function then selects the node with the lowest adjusted score from the unvisited set.",
          "thought": "The algorithm selects the next node by considering the minimum distance to the current node while also incorporating a penalty for nodes that are too close to the destination, encouraging exploration of intermediate nodes and potentially reducing tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def adjusted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        penalty = 0.5 * distance_matrix[node][destination_node]\n        return local_distance + penalty\n    next_node = min(unvisited_nodes, key=lambda node: adjusted_score(node))\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (50% weight), penalized destination distance (30% weight with a non-linear 1.5 power penalty), and a proximity bonus (20% weight that rewards shorter local distances). It prioritizes nodes closer to the current node and those that reduce the distance to the destination, while slightly favoring intermediate nodes to encourage path diversity. The `weighted_score` function combines these factors linearly to determine the optimal next node.",
          "thought": "The new algorithm combines the No.1's non-linear penalty for distance to the destination with the No.2's linear weighting approach, using a 50% weight for local distance and a 30% weight for the penalized destination distance, while adding a 20% bonus for intermediate distances to encourage diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def weighted_score(node):\n        local_weight = 0.5\n        destination_weight = 0.3\n        proximity_bonus = 0.2\n        local_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node] ** 1.5\n        return local_weight * local_distance + destination_weight * destination_distance - proximity_bonus * (1 / (1 + local_distance))\n    next_node = min(unvisited_nodes, key=lambda node: weighted_score(node))\n    return next_node",
          "objective": 7.55096,
          "other_inf": null
     }
]