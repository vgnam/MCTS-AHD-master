[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance while moving towards the destination. The `destination_node` is only returned if no unvisited nodes remain, and the `distance_matrix` guides the selection of the nearest neighbor. The `current_node` and `unvisited_nodes` are central to the decision-making process, while the `destination_node` serves as a fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the path progresses towards the destination node while minimizing total distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity and long-term connectivity by combining direct distance to a node and its average distance to unvisited nodes, with weights adjusted based on the number of remaining nodes. As the number of unvisited nodes decreases, the weight on direct distance increases, prioritizing shorter-term gains. The score for each candidate node is computed as a weighted sum of these distances, ensuring adaptability to different stages of tour construction.",
          "thought": "The new algorithm modifies the selection criteria by introducing a weighted combination of direct distance and the average distance to unvisited nodes, where the weights are dynamically adjusted based on the remaining number of unvisited nodes to balance immediate proximity and long-term connectivity, ensuring adaptability to different stages of the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Higher weight for direct distance as nodes decrease\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        score = (1 - weight_factor) * distance_to_node + weight_factor * avg_distance_to_unvisited\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while also considering progress toward the destination, with the distance to the current node given higher priority (directly added) and the distance to the destination given lower priority (scaled by 0.3). It iterates through unvisited nodes, computes a combined score, and selects the node with the lowest score, ensuring efficient path progression with minimal detours. The `distance_matrix` provides distances between nodes, and the function returns the destination if no unvisited nodes remain.",
          "thought": "The new algorithm balances proximity to the current node and progress toward the destination by combining the distance to the current node (higher priority) with a weighted distance to the destination (lower priority, scaled by 0.3), ensuring efficient path progression while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + 0.3 * dest_distance\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing proximity to the current node and progress toward the destination, dynamically adjusting the weight of destination distance based on remaining unvisited nodes. It penalizes large detours with a quadratic term, ensuring efficiency and completeness. The weight decreases as unvisited nodes decrease, favoring local proximity early and destination alignment later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for the destination distance, which decreases as the number of unvisited nodes decreases, ensuring a balance between proximity to the current node and progress toward the destination. It also penalizes nodes that are too far from the current node by adding a quadratic term to the score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Dynamic weight\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + weight * dest_distance + 0.1 * (current_distance ** 2)  # Penalize large detours\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.41786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends the nearest neighbor approach by dynamically balancing the distance to the next node (prioritized with weight `alpha=0.7`) and the distance to the destination (prioritized with weight `1-alpha`). It selects the next node by minimizing a weighted sum of these distances, ensuring adaptability between short-term and long-term objectives. The higher `alpha` value emphasizes closer nodes, while the remaining weight (`1-alpha`) considers the path's progress toward the destination.",
          "thought": "The new algorithm extends the nearest neighbor approach by incorporating a dynamic weight factor that balances the distance to the next node with the distance to the destination, ensuring a more adaptive path selection that considers both immediate and long-term objectives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    alpha = 0.7  # Weight for distance to next node, higher alpha prioritizes closer nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = alpha * distance_to_node + (1 - alpha) * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node and progress toward the destination by combining the distance to the current node (higher priority) with a weighted distance to the destination (lower priority, scaled by 0.5). It iterates through unvisited nodes, computes a combined score, and selects the node with the minimum score, ensuring efficient path progression while minimizing detours. The `combined_score` prioritizes local distances while slightly favoring nodes that advance toward the destination.",
          "thought": "The new algorithm prioritizes the next node based on a weighted combination of distance to the current node and distance to the destination, balancing proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + 0.5 * dest_distance\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest neighbor approach with a dynamic weighting mechanism, prioritizing immediate distance (70% weight) over long-term efficiency (30% weight) to select the next node. It calculates a score for each unvisited node by balancing the direct distance from the current node with the average distance to remaining unvisited nodes, ensuring a balance between short-term and long-term path optimization. The loop iterates through unvisited nodes, computes the weighted score, and selects the node with the lowest score.",
          "thought": "The new algorithm enhances the nearest neighbor approach by incorporating a dynamic weighting mechanism that balances the immediate distance to the next node with the potential long-term path efficiency, estimated using a heuristic that considers the average distance to remaining unvisited nodes. This approach dynamically adjusts the selection criterion to prioritize nodes that offer both short-term and long-term advantages, improving overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if immediate_distance == 0:\n            continue\n\n        # Estimate long-term efficiency by average distance to remaining nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_remaining_distance = sum(\n                distance_matrix[node][other] for other in remaining_nodes\n            ) / len(remaining_nodes)\n        else:\n            avg_remaining_distance = 0\n\n        # Dynamic weighting: balance immediate and long-term efficiency\n        weight_immediate = 0.7\n        weight_long_term = 0.3\n        score = (weight_immediate * immediate_distance) + (weight_long_term * avg_remaining_distance)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.71312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing minimizing the maximum distance to any other unvisited node, while also considering the direct distance to the current node. It balances immediate proximity (direct distance) and long-term connectivity (maximum distance to unvisited nodes) by combining them into a score where the maximum distance is weighted lower (0.5x) than the direct distance. The function iterates through unvisited nodes, computes the score for each, and returns the node with the lowest score.",
          "thought": "The new algorithm prioritizes minimizing the maximum distance to any other unvisited node while slightly considering the direct distance, aiming to balance immediate proximity and long-term connectivity by selecting the node with the lowest combined score of direct distance and the maximum distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        max_distance_to_unvisited = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) if len(unvisited_nodes) > 1 else 0\n        score = distance_to_node + 0.5 * max_distance_to_unvisited\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.74606,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the smallest sum of the distance from the current node and the distance from that node to the destination, ensuring the path remains efficient while forming a closed loop. It evaluates all unvisited nodes, choosing the one that minimizes the combined distance, and defaults to the destination if no unvisited nodes remain. The focus is on minimizing the sum of distances, balancing proximity to the current node and potential closure to the destination.",
          "thought": "This algorithm selects the next node by prioritizing the smallest distance to the current node, but also considers the potential to form a closed loop by evaluating the combined distance to the current node and the destination node, favoring nodes that minimize the sum of these two distances while ensuring the tour can be completed efficiently.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_node + distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and progress toward the destination by adjusting weights based on remaining unvisited nodes. It prioritizes minimizing detours by combining current distance and weighted destination distance, with higher weights given to destination distance as nodes remain unvisited. The weight formula (0.5 + 0.5*(remaining_nodes/(remaining_nodes+1))) ensures progressive focus on the destination as the tour nears completion.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between proximity to the current node and progress toward the destination based on the remaining number of unvisited nodes, ensuring efficient path progression while minimizing detours by using a novel combined score formula that incorporates a non-linear scaling factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining unvisited nodes\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        combined_score = current_distance + weight * dest_distance\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 8.00647,
          "other_inf": null
     }
]