[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance while moving towards the destination. The `destination_node` is only returned if no unvisited nodes remain, and the `distance_matrix` guides the selection of the nearest neighbor. The `current_node` and `unvisited_nodes` are central to the decision-making process, while the `destination_node` serves as a fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the path progresses towards the destination node while minimizing total distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that maximize the difference between the distance to the destination and the distance from the current node, balancing exploration (distance to destination) and proximity (distance from current node). The `score` is computed as `node_to_dest - current_to_node`, favoring nodes closer to the destination but farther from the current node, ensuring a trade-off between exploration and proximity. The function iterates over unvisited nodes, updates the best candidate based on the highest score, and returns the optimal next node.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the distance from the destination while minimizing the distance from the current node, aiming to balance exploration and proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        score = node_to_dest - current_to_node\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity and long-term connectivity by combining direct distance to a node and its average distance to unvisited nodes, with weights adjusted based on the number of remaining nodes. As the number of unvisited nodes decreases, the weight on direct distance increases, prioritizing shorter-term gains. The score for each candidate node is computed as a weighted sum of these distances, ensuring adaptability to different stages of tour construction.",
          "thought": "The new algorithm modifies the selection criteria by introducing a weighted combination of direct distance and the average distance to unvisited nodes, where the weights are dynamically adjusted based on the remaining number of unvisited nodes to balance immediate proximity and long-term connectivity, ensuring adaptability to different stages of the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Higher weight for direct distance as nodes decrease\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        score = (1 - weight_factor) * distance_to_node + weight_factor * avg_distance_to_unvisited\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between proximity to the current node and distance to the destination, prioritizing proximity early (higher weight) and destination alignment later (lower weight) by adjusting weights based on remaining unvisited nodes. It selects the next node by minimizing a weighted sum of incremental travel cost and destination alignment, ensuring smoother transitions while optimizing path length. The weights (`proximity_weight` and `destination_weight`) are inversely proportional to the number of unvisited nodes, giving more emphasis to proximity early and destination alignment as the tour nears completion.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between proximity to the current node and the distance to the destination based on the remaining number of unvisited nodes, ensuring a smoother transition toward the destination while minimizing incremental travel costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = (total_unvisited / (total_unvisited + 1)) ** 2\n        destination_weight = 1 - proximity_weight\n        score = (proximity_weight * current_to_node) + (destination_weight * node_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.28282,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while also considering progress toward the destination, with the distance to the current node given higher priority (directly added) and the distance to the destination given lower priority (scaled by 0.3). It iterates through unvisited nodes, computes a combined score, and selects the node with the lowest score, ensuring efficient path progression with minimal detours. The `distance_matrix` provides distances between nodes, and the function returns the destination if no unvisited nodes remain.",
          "thought": "The new algorithm balances proximity to the current node and progress toward the destination by combining the distance to the current node (higher priority) with a weighted distance to the destination (lower priority, scaled by 0.3), ensuring efficient path progression while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + 0.3 * dest_distance\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing proximity to the current node and progress toward the destination, dynamically adjusting the weight of destination distance based on remaining unvisited nodes. It penalizes large detours with a quadratic term, ensuring efficiency and completeness. The weight decreases as unvisited nodes decrease, favoring local proximity early and destination alignment later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight for the destination distance, which decreases as the number of unvisited nodes decreases, ensuring a balance between proximity to the current node and progress toward the destination. It also penalizes nodes that are too far from the current node by adding a quadratic term to the score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Dynamic weight\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + weight * dest_distance + 0.1 * (current_distance ** 2)  # Penalize large detours\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.41786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends the nearest neighbor approach by dynamically balancing the distance to the next node (prioritized with weight `alpha=0.7`) and the distance to the destination (prioritized with weight `1-alpha`). It selects the next node by minimizing a weighted sum of these distances, ensuring adaptability between short-term and long-term objectives. The higher `alpha` value emphasizes closer nodes, while the remaining weight (`1-alpha`) considers the path's progress toward the destination.",
          "thought": "The new algorithm extends the nearest neighbor approach by incorporating a dynamic weight factor that balances the distance to the next node with the distance to the destination, ensuring a more adaptive path selection that considers both immediate and long-term objectives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    alpha = 0.7  # Weight for distance to next node, higher alpha prioritizes closer nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = alpha * distance_to_node + (1 - alpha) * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node and progress toward the destination by combining the distance to the current node (higher priority) with a weighted distance to the destination (lower priority, scaled by 0.5). It iterates through unvisited nodes, computes a combined score, and selects the node with the minimum score, ensuring efficient path progression while minimizing detours. The `combined_score` prioritizes local distances while slightly favoring nodes that advance toward the destination.",
          "thought": "The new algorithm prioritizes the next node based on a weighted combination of distance to the current node and distance to the destination, balancing proximity to the current node and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        combined_score = current_distance + 0.5 * dest_distance\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local optimization early (high decay rate) and global optimization later (low decay rate) by balancing the current node's distance and potential to the destination, while dynamically penalizing revisits to avoid cycles. The balance factor (`decay_rate`) shifts from favoring local distances to favoring global progress as the number of unvisited nodes decreases, and a penalty term discourages revisits. The score combines these factors to select the next node, ensuring a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm modifies the balance factor to use an exponential decay based on the remaining nodes, emphasizing local optimization early and global optimization later, while incorporating a dynamic penalty for revisiting nodes to avoid cycles and improve path diversity.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        potential_to_destination = distance_matrix[node][destination_node]\n        decay_rate = math.exp(-remaining_nodes / total_nodes)\n        balance_factor = decay_rate\n        penalty = 0.1 * (total_nodes - remaining_nodes) / total_nodes  # Dynamic penalty for revisiting\n        score = (balance_factor * distance_to_node) + ((1 - balance_factor) * potential_to_destination) + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.55633,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest neighbor approach with a dynamic weighting mechanism, prioritizing immediate distance (70% weight) over long-term efficiency (30% weight) to select the next node. It calculates a score for each unvisited node by balancing the direct distance from the current node with the average distance to remaining unvisited nodes, ensuring a balance between short-term and long-term path optimization. The loop iterates through unvisited nodes, computes the weighted score, and selects the node with the lowest score.",
          "thought": "The new algorithm enhances the nearest neighbor approach by incorporating a dynamic weighting mechanism that balances the immediate distance to the next node with the potential long-term path efficiency, estimated using a heuristic that considers the average distance to remaining unvisited nodes. This approach dynamically adjusts the selection criterion to prioritize nodes that offer both short-term and long-term advantages, improving overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if immediate_distance == 0:\n            continue\n\n        # Estimate long-term efficiency by average distance to remaining nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_remaining_distance = sum(\n                distance_matrix[node][other] for other in remaining_nodes\n            ) / len(remaining_nodes)\n        else:\n            avg_remaining_distance = 0\n\n        # Dynamic weighting: balance immediate and long-term efficiency\n        weight_immediate = 0.7\n        weight_long_term = 0.3\n        score = (weight_immediate * immediate_distance) + (weight_long_term * avg_remaining_distance)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.71312,
          "other_inf": null
     }
]