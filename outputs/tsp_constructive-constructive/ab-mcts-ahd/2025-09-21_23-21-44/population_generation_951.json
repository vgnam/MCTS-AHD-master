[
     {
          "algorithm": "The algorithm prioritizes nodes that minimize a weighted score combining immediate distance, potential path savings, and a penalty for distant nodes, aggressively optimizing the tour by favoring nodes that reduce the remaining path length while penalizing excessively distant selections. The score calculation balances `current_dist` and `dest_dist` with a multiplicative factor and additive penalty, where `path_savings` and penalty terms influence the selection. The heuristic ensures a trade-off between immediate proximity and long-term savings, favoring nodes that save the most path length while discouraging overly distant choices.",
          "thought": "\nThe new algorithm prioritizes selecting nodes based on a dynamic balance of immediate distance and potential path savings, using a multiplicative factor to emphasize nodes that significantly reduce the remaining path length while penalizing nodes that are too distant, ensuring a more aggressive optimization of the tour.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            # Aggressive optimization: prioritize nodes that save the most path length\n            path_savings = current_dist - dest_dist\n            penalty = 1 + (current_dist / (dest_dist + 1e-10))  # Stronger penalty for distant nodes\n            score = (current_dist / dest_dist) * penalty + path_savings\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.4857,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the next node (weighted by the ratio of unvisited nodes) while penalizing proximity to the destination node (weighted by -0.5), balancing short-term and long-term objectives. The weight factor adjusts dynamically based on remaining unvisited nodes, favoring closer nodes early on but gradually emphasizing destination proximity.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that balances immediate distance (weighted by unvisited nodes ratio) and penalizes long-term proximity to the destination (weighted by -0.5).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_factor * immediate_distance) - (0.5 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.4981,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting nodes that balance the ratio of current-to-next and next-to-destination distances while incorporating a penalty for distant nodes and path savings. The score is computed as a weighted sum of the ratio (0.5), path savings (0.5), and a multiplicative penalty (1 + current_dist / (dest_dist + \u03b5)). The node with the lowest score is chosen, favoring closer nodes with better path savings. The destination node is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines the aggressive path savings of No.1 with the balanced scoring of No.2, selecting nodes that minimize a weighted score of the ratio of current-to-next and next-to-destination distances, while incorporating a multiplicative penalty for distant nodes and an additive path savings term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            ratio = current_dist / dest_dist\n            penalty = 1 + (current_dist / (dest_dist + 1e-10))\n            path_savings = current_dist - dest_dist\n            score = 0.5 * ratio + 0.5 * path_savings + penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.53403,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a dynamic weight factor (based on remaining unvisited nodes) with a balanced scoring mechanism, prioritizing immediate distance (weighted by `weight_factor`), penalizing destination distance (weighted by `-0.5 * weight_factor`), and incorporating centrality (weighted by `0.2 * (1 - weight_factor)`). The weight factor adjusts dynamically, favoring immediate distance early and balancing with centrality and destination distance as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weight factor from No.2 with the balanced scoring mechanism of No.1, where the weight factor adjusts based on the number of unvisited nodes, and the score prioritizes immediate distance (weighted by weight_factor), penalizes destination distance (weighted by -0.5 * weight_factor), and incorporates centrality (weighted by 0.2 * (1 - weight_factor)).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = (weight_factor * immediate_distance) - (0.5 * weight_factor * destination_distance) + (0.2 * (1 - weight_factor) * centrality_heuristic)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53942,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance prioritization with long-term optimization by dynamically adjusting a weight factor that decreases as nodes are visited. It prioritizes short-term efficiency (immediate distance) early in the search and gradually shifts focus to long-term optimization (potential distance to the destination) as more nodes are visited. The score calculation combines these priorities with a penalty term (-0.5 * potential_distance) to refine node selection.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that decreases as nodes are visited, balancing short-term efficiency with long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * immediate_distance) + ((1 - weight_factor) * potential_distance) - 0.5 * potential_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55369,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple heuristics (ratio, path savings, and product) with dynamic balancing of immediate and future distances, using a dynamic factor to prioritize local optimization early and global optimization later. It assigns higher priority to path savings (0.3 weight) and lower priority to the product term (0.3 weight), while dynamically adjusting penalties for distant nodes based on the remaining unvisited nodes. The weighted score is computed with a 70-30 split favoring the heuristic terms early on, shifting to a 30-70 split later, ensuring a balance between local and global optimization.",
          "thought": "The new algorithm combines the weighted combination of ratio, path savings, and product from No.1 with the dynamic balancing of immediate and future distances from No.2, using a dynamic factor to prioritize local optimization early and global optimization later, while incorporating a penalty for distant nodes to avoid detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_factor = 1 / (1 + remaining_nodes)\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            ratio = current_dist / dest_dist\n            path_savings = current_dist - dest_dist\n            product = current_dist * dest_dist\n            penalty = 1 + (current_dist / (dest_dist + 1e-10))\n\n            weighted_score = (0.4 * ratio + 0.3 * path_savings + 0.3 * product) * (0.7 - dynamic_factor) + penalty * (0.3 + dynamic_factor)\n\n        if weighted_score < min_score:\n            min_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.55788,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (60%), penalizing long-term distance (30%), and incorporating centrality (10%) to balance greediness with path efficiency. It calculates a weighted score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between short-term and long-term planning while considering node centrality. If no valid node is found, it defaults to the node with the highest average distance.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the weighted balance between short-term and long-term planning from No.2, while adding a centrality heuristic to ensure robustness. It selects the next node by minimizing a score that weights immediate distance (60%), penalizes long-term distance (30%), and incorporates centrality (10%), ensuring a trade-off between greediness and path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n\n        score = (0.6 * immediate_distance) - (0.3 * destination_distance) + (0.1 * centrality_heuristic)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is None and unvisited_nodes:\n        next_node = max(unvisited_nodes, key=lambda x: sum(distance_matrix[x]))\n\n    return next_node",
          "objective": 6.59757,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a weighted combination of the ratio of current-to-node and node-to-destination distances, path savings (current_dist - dest_dist), the product of these distances, and a penalty for distant nodes. The weights (0.4, 0.3, 0.3) prioritize the ratio and path savings over the product, while the penalty discourages long detours. The score is computed for each unvisited node, and the node with the lowest score is chosen.",
          "thought": "The new algorithm combines the multiplicative weighting of No.2 with the ratio and path savings of No.1, favoring nodes that minimize a weighted product of the current-to-node and node-to-destination distances, while incorporating path savings and a penalty for distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            ratio = current_dist / dest_dist\n            penalty = 1 + (current_dist / (dest_dist + 1e-10))\n            path_savings = current_dist - dest_dist\n            product = current_dist * dest_dist\n            score = 0.4 * ratio + 0.3 * path_savings + 0.3 * product + penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (highest priority, weight 1), destination proximity (medium priority, weight -0.5), and node centrality (lowest priority, weight 0.2). It prioritizes nodes close to the current node while penalizing those far from the destination, and slightly favors nodes with lower average distances to all other nodes. The scoring mechanism ensures a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the balanced multi-factor scoring of No.2, adding a centrality component (weighted 0.2) to further optimize path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = immediate_distance - 0.5 * destination_distance + 0.2 * centrality_heuristic\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6208,
          "other_inf": null
     }
]