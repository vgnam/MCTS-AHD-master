[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (highest priority, weight 1), destination proximity (medium priority, weight -0.5), and node centrality (lowest priority, weight 0.2). It prioritizes nodes close to the current node while penalizing those far from the destination, and slightly favors nodes with lower average distances to all other nodes. The scoring mechanism ensures a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the balanced multi-factor scoring of No.2, adding a centrality component (weighted 0.2) to further optimize path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = immediate_distance - 0.5 * destination_distance + 0.2 * centrality_heuristic\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance to the current node and projected distance to the destination, while penalizing nodes that are too far from the current position. Nodes with lower scores (computed as a weighted ratio of current distance to destination distance with a penalty factor) are preferred, ensuring a trade-off between immediate and long-term path efficiency. The penalty factor dynamically adjusts the ratio based on the current and projected distances, favoring nodes that reduce the overall path length more effectively.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the ratio calculation based on the node's potential to reduce the overall path length, using a combination of immediate and projected future distances, and introduces a penalty factor for nodes that are too far from the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            # Dynamic weighting: favor nodes that reduce path length more\n            projected_path_length = current_dist + dest_dist\n            penalty = 1 + (current_dist / (projected_path_length + 1e-10))  # Avoid division by zero\n            score = (current_dist / dest_dist) * penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and long-term efficiency (ratio of current distance to destination distance), prioritizing nodes with lower combined scores. It iterates through unvisited nodes, computes a score as the sum of direct distance and the ratio, and selects the node with the minimum score. The ratio ensures long-term efficiency is considered, while the direct distance ensures immediate proximity is prioritized.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring approach of No.2. It computes a score as the sum of the distance to the current node and a weighted ratio of the distance to the current node over the distance to the destination, prioritizing nodes that balance immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by evaluating a weighted combination of the immediate distance from the current node and the ratio of that distance to the distance to the destination node, with adjustable weights (default: 60% for immediate distance, 40% for the ratio). It prioritizes nodes that offer a good balance between proximity to the current node and progress toward the destination, avoiding division by zero for the destination distance. The structure iteratively compares scores to find the optimal next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of immediate distance and the ratio of current distance to destination distance, with adjustable weights to balance exploration and exploitation, while the original algorithm uses a simple sum of these two components.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, weight_current=0.6, weight_ratio=0.4):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = weight_current * current_dist + weight_ratio * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.75,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance prioritization with probabilistic selection based on node centrality, using a centrality factor that increases as unvisited nodes decrease. It evaluates each unvisited node by combining the immediate distance from the current node, the average distance to other unvisited nodes (centrality), and the distance to the destination, with the centrality term gaining higher weight as the tour progresses. The node with the lowest combined score is selected, favoring centrality more in later stages while still considering immediate distance and destination proximity.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance prioritization with a probabilistic selection based on node centrality and distance, where the selection probability is influenced by both the immediate distance and the node's potential to minimize the total tour length, with the centrality factor increasing as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    centrality_factor = 1 - (total_unvisited / (total_unvisited + 1))\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_score = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        combined_score = (centrality_factor * centrality_score) + ((1 - centrality_factor) * immediate_distance) - (0.3 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.75679,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node to visit by balancing distance and centrality, favoring closer nodes while slightly penalizing highly connected nodes (to avoid revisits) using the score equation `-distance + 0.3 * (centrality / (degree + 1))`. The distance is given higher priority (negative weight) than centrality (positive weight scaled by 0.3), and centrality is adjusted by the node's degree to avoid over-penalizing isolated nodes. The code iterates through unvisited nodes, computes the score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance and node centrality, favoring closer nodes while slightly penalizing highly connected nodes to avoid revisits, using the score equation: `-distance + 0.3 * (centrality / (degree + 1))` where centrality is the sum of distances to all other nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = None\n    best_score = float('-inf')\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        centrality = sum(d for d in distance_matrix[node] if d > 0)\n        score = -distance + 0.3 * (centrality / (degree + 1))\n        if score > best_score:\n            best_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance prioritization (given higher weight) with long-term efficiency (penalized by a factor of 0.5). It calculates a score as the sum of the direct distance from the current node to the candidate node and a ratio of this distance to the candidate's distance to the destination, then picks the node with the lowest score. The ratio penalization ensures long-term efficiency is considered but with reduced influence compared to immediate distance.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the long-term efficiency ratio from No.2, using a weighted sum of the direct distance and the ratio of current distance to destination distance, where the ratio is penalized by a factor of 0.5 to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + 0.5 * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.78776,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by balancing immediate distance (70% weight) and the ratio of current distance to destination distance (30% weight), prioritizing closer nodes while also considering progress toward the destination. It ensures a trade-off between local efficiency and global progress by combining these two factors in the scoring function. The code iterates through unvisited nodes, computes the weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and progress toward the destination from No.1 with the simplicity of No.2's local-global trade-off, using a 70-30 split for immediate and ratio-based scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = 0.7 * current_dist + 0.3 * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.8001,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing two factors: the immediate distance from the current node (weighted 0.8) and the ratio of the current distance to the distance from the candidate node to the destination (weighted 0.2). This ensures a trade-off between proximity to the current node and alignment with the path to the destination, prioritizing immediate travel efficiency while slightly favoring nodes that better align with the overall route.",
          "thought": "The new algorithm combines the immediate distance (weighted 0.8) with the ratio of current distance to destination distance (weighted 0.2), inspired by No.1's success, while maintaining the simplicity of No.2's structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = 0.8 * current_dist + 0.2 * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.83088,
          "other_inf": null
     }
]