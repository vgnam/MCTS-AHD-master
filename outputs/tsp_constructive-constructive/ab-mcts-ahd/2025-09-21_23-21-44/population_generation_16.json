[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, defaulting to the destination node if no unvisited nodes remain. It ensures a greedy, constructive approach to TSP by always choosing the locally optimal step, with the destination serving as a fallback when no unvisited nodes are left. The priority is given to minimizing the immediate distance, with the destination acting as a lower-priority fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a bias towards the destination node if no unvisited nodes remain, ensuring a constructive approach to solving the TSP.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance (70%) with future potential (30%), prioritizing nodes that offer both short-term proximity and long-term connectivity. It iteratively evaluates each unvisited node using a weighted combination of current and minimum future distances, selecting the node with the lowest weighted score. The code efficiently handles edge cases (e.g., no unvisited nodes) and ensures the path returns to the destination node.",
          "thought": "The new algorithm modifies the greedy nearest-neighbor approach by incorporating a dynamic weight that balances the immediate distance to the nearest unvisited node with the potential long-term impact of choosing nodes that lead to closer future steps, using a weighted combination of current and future distances to select the next node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_weighted_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = min(distance_matrix[node][n] for n in unvisited_nodes if n != node) if len(unvisited_nodes) > 1 else 0\n        weighted_score = 0.7 * current_distance + 0.3 * future_distance\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n    return next_node",
          "objective": 7.35407,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance from current node) and global proximity (distance to destination), with the latter given 30% weight. It prioritizes nodes that are both close to the current position and closer to the destination, ensuring a trade-off between immediate and long-term optimality. The `score` is computed as `distance_to_current + 0.3 * distance_to_destination`, and the node with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance to the current node and a heuristic that favors nodes closer to the destination, ensuring a balance between local and global optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential long-term proximity to the destination, prioritizing the former (weighted 1.0) over the latter (weighted 0.5). It iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score. The function efficiently handles edge cases (e.g., no unvisited nodes) and returns the destination if all nodes are visited.",
          "thought": "The new algorithm selects the next node by prioritizing the closest unvisited node to the current node, but with a bias towards nodes that are closer to the destination, combining immediate distance and long-term proximity considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance + 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of the distance from the current node and the distance to the destination, ensuring efficiency by balancing immediate proximity and long-term potential. The `destination_node` is chosen as a fallback when no unvisited nodes remain, highlighting its secondary priority. The function iterates through unvisited nodes, calculates the sum of distances, and returns the node with the smallest total distance, emphasizing the critical role of the `distance_matrix` and `unvisited_nodes` in determining the path.",
          "thought": "This algorithm prioritizes nodes that minimize the sum of the current distance to the node and the node's distance to the destination, balancing immediate proximity and long-term potential, with the destination as a fallback when no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_total_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        total_distance = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach (selecting the closest unvisited node) with a global consideration (balancing immediate proximity and average distances to unvisited nodes). It prioritizes immediate proximity (immediate_cost) but also considers the node's average distance to other unvisited nodes (avg_cost), ensuring both local efficiency and global connectivity. The combined_cost is minimized to select the next node, with higher priority given to immediate_cost and lower priority to avg_cost.",
          "thought": "The new algorithm combines the greedy approach of No.2 (selecting the closest unvisited node) with a global consideration inspired by No.1 (balancing immediate proximity and average distances to unvisited nodes). It selects the next node as the one minimizing the sum of its distance to the current node and its average distance to all other unvisited nodes, ensuring both local efficiency and global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_combined_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][node]\n        avg_cost = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                avg_cost += distance_matrix[node][other_node]\n        avg_cost /= len(unvisited_nodes) if len(unvisited_nodes) > 1 else 1\n        combined_cost = immediate_cost + avg_cost\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = node\n    return next_node",
          "objective": 8.40257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the average distance to all unvisited nodes, balancing immediate proximity and global connectivity. It evaluates each unvisited node by summing its distances to all other unvisited nodes and normalizes by the count, then picks the node with the smallest average. The `destination_node` is returned if no unvisited nodes remain. The code emphasizes global optimization over purely greedy local choices by considering the unvisited set's average distances.",
          "thought": "The new algorithm prioritizes nodes that balance immediate distance from the current node and the average distance of unvisited nodes, ensuring a more globally informed selection while maintaining efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_avg_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        avg_distance = distance_matrix[current_node][node]\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                avg_distance += distance_matrix[node][other_node]\n        avg_distance /= len(unvisited_nodes)\n        if avg_distance < min_avg_distance:\n            min_avg_distance = avg_distance\n            next_node = node\n    return next_node",
          "objective": 21.8348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the maximum distance to any other unvisited node, balancing immediate proximity (via `distance_matrix[current_node][node]`) with long-term coverage (via the inner loop checking all other unvisited nodes). The `min_max_distance` variable ensures the chosen node is the most \"central\" among unvisited nodes, while the inner loop (`for other_node in unvisited_nodes`) computes the worst-case coverage for each candidate. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "This algorithm selects the next node by minimizing the sum of the distance from the current node and the maximum distance to any other unvisited node, ensuring a balance between immediate proximity and long-term coverage of the remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_max_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        max_distance = distance_matrix[current_node][node]\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                current_distance = distance_matrix[node][other_node]\n                if current_distance > max_distance:\n                    max_distance = current_distance\n        if max_distance < min_max_distance:\n            min_max_distance = max_distance\n            next_node = node\n    return next_node",
          "objective": 25.18681,
          "other_inf": null
     }
]