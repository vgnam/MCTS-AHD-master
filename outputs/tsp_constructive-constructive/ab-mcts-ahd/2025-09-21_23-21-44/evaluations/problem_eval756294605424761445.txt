import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = float('-inf')

    for node in unvisited_nodes:
        immediate_cost = distance_matrix[current_node][node]
        max_cost = 0
        for other_node in unvisited_nodes:
            if other_node != node:
                max_cost = max(max_cost, distance_matrix[node][other_node])

        # Dynamic weighting: prioritize immediate cost but consider max_cost with a probabilistic twist
        weight = 0.7 if random.random() < 0.6 else 0.3  # Randomly adjust weight between 0.3 and 0.7
        weighted_cost = (weight * immediate_cost) + ((1 - weight) * max_cost)

        # Additional heuristic: prefer nodes closer to the destination if few unvisited nodes remain
        if len(unvisited_nodes) <= 3:
            weighted_cost += 0.2 * distance_matrix[node][destination_node]

        if weighted_cost < best_score or next_node is None:
            best_score = weighted_cost
            next_node = node

    return next_node
