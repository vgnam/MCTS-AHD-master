def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1
    weight_factor = len(unvisited_nodes) / total_nodes
    scores = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Calculate centrality score (average distance to all other nodes)
        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)

        # Combine weighted scores with centrality
        score = (weight_factor * immediate_distance) + ((1 - weight_factor) * potential_distance) + (0.3 * centrality)
        scores.append((node, score))

    # Select top 3 candidates and choose probabilistically
    candidates = sorted(scores, key=lambda x: x[1])[:3]
    if not candidates:
        return unvisited_nodes[0]

    # Probabilistic selection based on inverse score (better scores have higher probability)
    total_inverse_score = sum(1 / (score[1] + 1e-6) for score in candidates)
    rand_val = random.random() * total_inverse_score
    cumulative = 0

    for node, score in candidates:
        cumulative += 1 / (score[1] + 1e-6)
        if rand_val <= cumulative:
            return node

    return next_node
