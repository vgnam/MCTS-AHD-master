def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    exploration_factor = 1 - (1 / (1 + remaining_nodes))

    node_scores = []
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        normalized_immediate = immediate_distance / sum(distance_matrix[current_node][n] for n in unvisited_nodes)
        normalized_future = future_distance / sum(distance_matrix[n][destination_node] for n in unvisited_nodes)
        score = (0.6 * normalized_immediate) + (0.4 * normalized_future) + exploration_factor * (normalized_future - normalized_immediate)
        node_scores.append(score)

    exp_scores = [math.exp(score) for score in node_scores]
    sum_exp_scores = sum(exp_scores)
    probabilities = [exp_score / sum_exp_scores for exp_score in exp_scores]

    selected_index = np.random.choice(len(unvisited_nodes), p=probabilities)
    return next_node
