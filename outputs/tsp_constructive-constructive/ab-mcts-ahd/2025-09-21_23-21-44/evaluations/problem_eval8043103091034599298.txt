def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    centralities = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        if len(unvisited_nodes) > 1:
            future_distance = min(distance_matrix[node][n] for n in unvisited_nodes if n != node)
            centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)
        else:
            future_distance = 0
            centrality = 0

        weighted_score = 0.5 * current_distance + 0.3 * future_distance + 0.2 * centrality
        scores.append((node, weighted_score))
        centralities.append(centrality)

    if not scores:
        return destination_node

    min_score = min(score for _, score in scores)
    max_centrality = max(centralities) if centralities else 0

    probabilities = []
    for node, score in scores:
        normalized_score = (score - min_score) / (max_centrality - min_score) if (max_centrality - min_score) > 0 else 0
        probability = 1 - normalized_score
        probabilities.append((node, probability))

    total_prob = sum(prob for _, prob in probabilities)
    if total_prob == 0:
        return min(probabilities, key=lambda x: x[1])[0]

    rand_val = random.random() * total_prob
    cumulative_prob = 0
    for node, prob in probabilities:
        cumulative_prob += prob
        if rand_val <= cumulative_prob:
            return node

    return next_node
