def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_scores = []
    remaining_nodes = len(unvisited_nodes)
    dynamic_factor = 1 / (1 + remaining_nodes)
    max_possible_distance = max(max(row) for row in distance_matrix)

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        balance_factor = (0.6 - dynamic_factor) * immediate_distance + (0.4 + dynamic_factor) * future_distance
        penalty = (future_distance / max_possible_distance) ** 2 if future_distance > 0.8 * max_possible_distance else 0
        total_score = balance_factor + penalty
        node_scores.append((node, total_score))

    if not node_scores:
        return random.choice(unvisited_nodes)

    total_weight = sum(1 / score for _, score in node_scores)
    rand_val = random.random() * total_weight
    cumulative_weight = 0

    for node, score in node_scores:
        cumulative_weight += 1 / score
        if rand_val <= cumulative_weight:
            return node

    return next_node
