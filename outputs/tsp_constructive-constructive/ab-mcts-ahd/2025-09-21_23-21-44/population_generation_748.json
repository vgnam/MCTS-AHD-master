[
     {
          "algorithm": "The algorithm prioritizes immediate distance to the next node (weighted by the ratio of unvisited nodes) while penalizing proximity to the destination node (weighted by -0.5), balancing short-term and long-term objectives. The weight factor adjusts dynamically based on remaining unvisited nodes, favoring closer nodes early on but gradually emphasizing destination proximity.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that balances immediate distance (weighted by unvisited nodes ratio) and penalizes long-term proximity to the destination (weighted by -0.5).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_factor * immediate_distance) - (0.5 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.4981,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a dynamic weight factor (based on remaining unvisited nodes) with a balanced scoring mechanism, prioritizing immediate distance (weighted by `weight_factor`), penalizing destination distance (weighted by `-0.5 * weight_factor`), and incorporating centrality (weighted by `0.2 * (1 - weight_factor)`). The weight factor adjusts dynamically, favoring immediate distance early and balancing with centrality and destination distance as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weight factor from No.2 with the balanced scoring mechanism of No.1, where the weight factor adjusts based on the number of unvisited nodes, and the score prioritizes immediate distance (weighted by weight_factor), penalizes destination distance (weighted by -0.5 * weight_factor), and incorporates centrality (weighted by 0.2 * (1 - weight_factor)).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = (weight_factor * immediate_distance) - (0.5 * weight_factor * destination_distance) + (0.2 * (1 - weight_factor) * centrality_heuristic)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53942,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (60%), penalizing long-term distance (30%), and incorporating centrality (10%) to balance greediness with path efficiency. It calculates a weighted score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between short-term and long-term planning while considering node centrality. If no valid node is found, it defaults to the node with the highest average distance.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the weighted balance between short-term and long-term planning from No.2, while adding a centrality heuristic to ensure robustness. It selects the next node by minimizing a score that weights immediate distance (60%), penalizes long-term distance (30%), and incorporates centrality (10%), ensuring a trade-off between greediness and path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n\n        score = (0.6 * immediate_distance) - (0.3 * destination_distance) + (0.1 * centrality_heuristic)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is None and unvisited_nodes:\n        next_node = max(unvisited_nodes, key=lambda x: sum(distance_matrix[x]))\n\n    return next_node",
          "objective": 6.59757,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (highest priority, weight 1), destination proximity (medium priority, weight -0.5), and node centrality (lowest priority, weight 0.2). It prioritizes nodes close to the current node while penalizing those far from the destination, and slightly favors nodes with lower average distances to all other nodes. The scoring mechanism ensures a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the balanced multi-factor scoring of No.2, adding a centrality component (weighted 0.2) to further optimize path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = immediate_distance - 0.5 * destination_distance + 0.2 * centrality_heuristic\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance to the current node and projected distance to the destination, while penalizing nodes that are too far from the current position. Nodes with lower scores (computed as a weighted ratio of current distance to destination distance with a penalty factor) are preferred, ensuring a trade-off between immediate and long-term path efficiency. The penalty factor dynamically adjusts the ratio based on the current and projected distances, favoring nodes that reduce the overall path length more effectively.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the ratio calculation based on the node's potential to reduce the overall path length, using a combination of immediate and projected future distances, and introduces a penalty factor for nodes that are too far from the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            score = current_dist\n        else:\n            # Dynamic weighting: favor nodes that reduce path length more\n            projected_path_length = current_dist + dest_dist\n            penalty = 1 + (current_dist / (projected_path_length + 1e-10))  # Avoid division by zero\n            score = (current_dist / dest_dist) * penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and long-term efficiency (ratio of current distance to destination distance), prioritizing nodes with lower combined scores. It iterates through unvisited nodes, computes a score as the sum of direct distance and the ratio, and selects the node with the minimum score. The ratio ensures long-term efficiency is considered, while the direct distance ensures immediate proximity is prioritized.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring approach of No.2. It computes a score as the sum of the distance to the current node and a weighted ratio of the distance to the current node over the distance to the destination, prioritizing nodes that balance immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the balance between immediate distance and progress ratio (current distance to destination distance) based on the number of remaining unvisited nodes, while penalizing nodes that are significantly farther than the average distance. It prioritizes minimizing the weighted sum of these factors, with weights dynamically adjusted between 0.5 and 0.7, and the penalty term (0.2 weight) ensuring nodes are not excessively distant. The score function balances local (current distance) and global (progress ratio) considerations, with the penalty term acting as a constraint.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that adapts the balance between immediate distance and progress ratio based on the remaining unvisited nodes, using a normalized score function that incorporates both local and global factors, while also introducing a penalty for nodes that are too far from the current node relative to the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Calculate average distance from current node to unvisited nodes\n    total_dist = sum(distance_matrix[current_node][node] for node in unvisited_nodes)\n    avg_dist = total_dist / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        remaining_nodes = len(unvisited_nodes)\n        weight = 0.5 + 0.2 * (1 - remaining_nodes / (remaining_nodes + 1))  # Adjusts between 0.5 and 0.7\n\n        # Penalty for nodes too far from current node\n        penalty = max(0, (current_dist - avg_dist) / avg_dist) if avg_dist > 0 else 0\n\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n\n        score = weight * current_dist + (1 - weight) * ratio + 0.2 * penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69443,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (weight 1.0) and proximity to the destination (weight -0.3), prioritizing shorter immediate distances while slightly penalizing nodes farther from the destination. It iterates through unvisited nodes, computes a combined score, and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.2 with the long-term proximity penalty from No.1, using weights of 1.0 for immediate distance and -0.3 for destination distance to balance short-term efficiency and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.3 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a balanced scoring approach with dynamic weighting, prioritizing immediate distance (high weight early, lower later) and destination proximity (lower weight early, higher later) while considering centrality (low weight early, higher later). It adjusts weights based on remaining nodes to balance short-term gains and long-term efficiency, with immediate distance having the highest priority initially, followed by destination proximity and centrality. The score is computed as a weighted sum of these factors, and the node with the lowest score is selected next.",
          "thought": "The new algorithm combines the No.1's balanced scoring approach (immediate distance, destination proximity, and centrality) with No.2's dynamic weighting strategy, adjusting weights based on remaining nodes to prioritize immediate gains early and long-term efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    num_nodes = len(distance_matrix)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        weight_immediate = 0.8 if remaining_nodes > 3 else 0.5\n        weight_destination = 0.3 if remaining_nodes > 3 else 0.4\n        weight_centrality = 0.1 if remaining_nodes > 3 else 0.3\n        score = (weight_immediate * immediate_distance -\n                 weight_destination * destination_distance +\n                 weight_centrality * centrality_heuristic)\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.74713,
          "other_inf": null
     }
]