[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and long-term efficiency (ratio of current distance to destination distance), prioritizing nodes with lower combined scores. It iterates through unvisited nodes, computes a score as the sum of direct distance and the ratio, and selects the node with the minimum score. The ratio ensures long-term efficiency is considered, while the direct distance ensures immediate proximity is prioritized.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring approach of No.2. It computes a score as the sum of the distance to the current node and a weighted ratio of the distance to the current node over the distance to the destination, prioritizing nodes that balance immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node to visit by balancing distance and centrality, favoring closer nodes while slightly penalizing highly connected nodes (to avoid revisits) using the score equation `-distance + 0.3 * (centrality / (degree + 1))`. The distance is given higher priority (negative weight) than centrality (positive weight scaled by 0.3), and centrality is adjusted by the node's degree to avoid over-penalizing isolated nodes. The code iterates through unvisited nodes, computes the score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance and node centrality, favoring closer nodes while slightly penalizing highly connected nodes to avoid revisits, using the score equation: `-distance + 0.3 * (centrality / (degree + 1))` where centrality is the sum of distances to all other nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = None\n    best_score = float('-inf')\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        centrality = sum(d for d in distance_matrix[node] if d > 0)\n        score = -distance + 0.3 * (centrality / (degree + 1))\n        if score > best_score:\n            best_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, balancing immediate proximity and long-term efficiency. It selects the next node to visit by minimizing this ratio, ensuring the path remains efficient while progressively moving toward the destination. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, ensuring a balance between immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_ratio = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with dynamic weight adjustment, where the weight factor decreases as unvisited nodes decrease, balancing short-term (immediate distance) and long-term (approximate return distance) optimization. The `combined_score` prioritizes minimizing immediate distance (weighted by `weight_factor`) and maximizing the negative of the destination distance (weighted by `1 - weight_factor`), dynamically adjusting the balance between the two as the tour progresses. The `select_next_node` function iterates through unvisited nodes, computes the score, and selects the node with the lowest score, ensuring a smooth transition from local to global optimization.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that decreases as the number of unvisited nodes decreases, ensuring a smooth balance between short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_factor * immediate_distance) + ((1 - weight_factor) * -0.5 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.96919,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, defaulting to the destination node if no unvisited nodes remain. It ensures a greedy, constructive approach to TSP by always choosing the locally optimal step, with the destination serving as a fallback when no unvisited nodes are left. The priority is given to minimizing the immediate distance, with the destination acting as a lower-priority fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a bias towards the destination node if no unvisited nodes remain, ensuring a constructive approach to solving the TSP.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by dynamically balancing three factors: immediate distance (prioritized when many nodes remain), proximity to the destination (moderately weighted), and node centrality (lowest priority). The weight factor adjusts based on the number of unvisited nodes, ensuring flexibility in early vs. late stages of the tour. The score combines these factors with weights (weight_factor, 0.3, 0.2) to guide the selection toward efficient, balanced paths.",
          "thought": "The new algorithm combines dynamic weight adjustment for immediate distance (heavily weighted when many nodes remain) with balanced proximity to destination and centrality (node connectivity), where weights shift based on remaining unvisited nodes. The score balances these factors to select the next node efficiently.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n    num_nodes = len(distance_matrix)\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_from_node = distance_matrix[node][destination_node]\n        centrality_heuristic = sum(distance_matrix[node]) / (num_nodes - 1)\n        score = (weight_factor * distance_to_node) + (0.3 * (1 - weight_factor) * distance_from_node) + (0.2 * (1 - weight_factor) * centrality_heuristic)\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.11748,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the immediate distance from the current node (weighted 1.0) and the proximity to the destination (weighted 0.5, adjusted by a dynamic factor). The dynamic weight factor, calculated as `len(unvisited_nodes) / (len(unvisited_nodes) + 1)`, decreases as more nodes are visited, prioritizing closer nodes early on and refining choices toward the destination later. The combined score minimizes immediate and adjusted destination distances to guide the path efficiently.",
          "thought": "The new algorithm combines the immediate distance from the current node (weighted 1.0) and the proximity to the destination (weighted 0.5), while also incorporating a dynamic weight factor based on the number of unvisited nodes to balance exploration and exploitation, similar to No.1 but with a simpler structure inspired by No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance + (0.5 * (1 - weight_factor) * destination_distance)\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term goals by weighting the distance to the next node (`distance_to_current`) and the distance to the destination (`distance_to_destination`), where the latter's weight increases as the number of remaining nodes decreases (`1 - remaining_nodes_ratio`). This ensures the algorithm prioritizes local efficiency early and global optimality later, adapting to the problem's state. The `score` computation ensures a trade-off between minimizing the current step and aligning with the final destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism where the global proximity weight adjusts based on the number of remaining nodes, increasing the emphasis on long-term optimality as the tour progresses. It computes a score as `distance_to_current + (1 - remaining_nodes_ratio) * distance_to_destination`, where `remaining_nodes_ratio` is the proportion of unvisited nodes, ensuring a balance between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes_ratio = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + (1 - remaining_nodes_ratio) * distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, with a dynamic weight factor that prioritizes immediate distance when fewer nodes remain unvisited. The weight factor adjusts based on the number of unvisited nodes, ensuring a smooth transition from short-term to long-term optimization. The `score` calculation gives higher priority to immediate distance (weighted by `weight_factor`) and lower priority to potential distance (weighted by `1 - weight_factor`).",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between the immediate distance to the next node and the potential long-term distance to the destination, using a dynamic weight factor that adjusts based on the remaining unvisited nodes, thereby optimizing path selection for varying problem sizes and structures.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * immediate_distance) + ((1 - weight_factor) * potential_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     }
]