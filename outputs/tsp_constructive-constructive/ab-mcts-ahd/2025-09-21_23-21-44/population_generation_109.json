[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and long-term efficiency (ratio of current distance to destination distance), prioritizing nodes with lower combined scores. It iterates through unvisited nodes, computes a score as the sum of direct distance and the ratio, and selects the node with the minimum score. The ratio ensures long-term efficiency is considered, while the direct distance ensures immediate proximity is prioritized.",
          "thought": "The new algorithm combines the ratio-based selection of No.1 with the weighted scoring approach of No.2. It computes a score as the sum of the distance to the current node and a weighted ratio of the distance to the current node over the distance to the destination, prioritizing nodes that balance immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by evaluating a weighted combination of the immediate distance from the current node and the ratio of that distance to the distance to the destination node, with adjustable weights (default: 60% for immediate distance, 40% for the ratio). It prioritizes nodes that offer a good balance between proximity to the current node and progress toward the destination, avoiding division by zero for the destination distance. The structure iteratively compares scores to find the optimal next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of immediate distance and the ratio of current distance to destination distance, with adjustable weights to balance exploration and exploitation, while the original algorithm uses a simple sum of these two components.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, weight_current=0.6, weight_ratio=0.4):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = weight_current * current_dist + weight_ratio * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.75,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node to visit by balancing distance and centrality, favoring closer nodes while slightly penalizing highly connected nodes (to avoid revisits) using the score equation `-distance + 0.3 * (centrality / (degree + 1))`. The distance is given higher priority (negative weight) than centrality (positive weight scaled by 0.3), and centrality is adjusted by the node's degree to avoid over-penalizing isolated nodes. The code iterates through unvisited nodes, computes the score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance and node centrality, favoring closer nodes while slightly penalizing highly connected nodes to avoid revisits, using the score equation: `-distance + 0.3 * (centrality / (degree + 1))` where centrality is the sum of distances to all other nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = None\n    best_score = float('-inf')\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        degree = sum(1 for d in distance_matrix[node] if d > 0)\n        centrality = sum(d for d in distance_matrix[node] if d > 0)\n        score = -distance + 0.3 * (centrality / (degree + 1))\n        if score > best_score:\n            best_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance prioritization (given higher weight) with long-term efficiency (penalized by a factor of 0.5). It calculates a score as the sum of the direct distance from the current node to the candidate node and a ratio of this distance to the candidate's distance to the destination, then picks the node with the lowest score. The ratio penalization ensures long-term efficiency is considered but with reduced influence compared to immediate distance.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the long-term efficiency ratio from No.2, using a weighted sum of the direct distance and the ratio of current distance to destination distance, where the ratio is penalized by a factor of 0.5 to balance short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        score = current_dist + 0.5 * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.78776,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, balancing immediate proximity and long-term efficiency. It selects the next node to visit by minimizing this ratio, ensuring the path remains efficient while progressively moving toward the destination. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, ensuring a balance between immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_ratio = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with dynamic weight adjustment, where the weight factor decreases as unvisited nodes decrease, balancing short-term (immediate distance) and long-term (approximate return distance) optimization. The `combined_score` prioritizes minimizing immediate distance (weighted by `weight_factor`) and maximizing the negative of the destination distance (weighted by `1 - weight_factor`), dynamically adjusting the balance between the two as the tour progresses. The `select_next_node` function iterates through unvisited nodes, computes the score, and selects the node with the lowest score, ensuring a smooth transition from local to global optimization.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that decreases as the number of unvisited nodes decreases, ensuring a smooth balance between short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_factor * immediate_distance) + ((1 - weight_factor) * -0.5 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.96919,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term efficiency (immediate distance) and long-term efficiency (ratio of current to destination distance) by combining them into a weighted score, where the weight decreases as the number of remaining nodes decreases. The scoring function prioritizes nodes that are closer to the destination (lower ratio) while also considering proximity to the current node, with the weight dynamically adjusting to favor long-term efficiency as the tour progresses.",
          "thought": "The new algorithm designs a scoring function that combines immediate distance and a weighted ratio of current distance to destination distance, where the weight is inversely proportional to the number of remaining nodes, to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        weight = 1.0 / remaining_nodes\n        score = current_dist + weight * ratio\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.98761,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate distance to the next node and long-term efficiency (ratio of current distance to destination distance) by adjusting weights based on remaining nodes. It penalizes nodes that are significantly farther than average to avoid detours, prioritizing nodes that are closer to the current path while considering the overall efficiency toward the destination. The score is computed as a weighted sum of current distance, ratio, and penalty, with weights adjusted to favor immediate distance when more nodes remain.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting mechanism that adjusts the balance between immediate distance and long-term efficiency based on the number of remaining nodes, while also considering the average distance to the destination for normalization, and introducing a penalty for nodes that are too far from the current path to avoid detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    avg_dest_dist = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes if remaining_nodes > 0 else 1\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        penalty = max(0, (current_dist - avg_dest_dist) / avg_dest_dist) if avg_dest_dist > 0 else 0\n        score = weight * current_dist + (1 - weight) * ratio + penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.99314,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, defaulting to the destination node if no unvisited nodes remain. It ensures a greedy, constructive approach to TSP by always choosing the locally optimal step, with the destination serving as a fallback when no unvisited nodes are left. The priority is given to minimizing the immediate distance, with the destination acting as a lower-priority fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a bias towards the destination node if no unvisited nodes remain, ensuring a constructive approach to solving the TSP.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     }
]