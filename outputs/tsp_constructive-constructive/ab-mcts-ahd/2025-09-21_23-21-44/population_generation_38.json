[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (weighted 1.0) while slightly penalizing long-term proximity to the destination (weighted -0.5), balancing short-term efficiency with long-term path optimization. The function iterates through unvisited nodes, computes a combined score for each, and chooses the node with the lowest score, ensuring a trade-off between immediate distance and overall path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing immediate distance from the current node (weighted 1.0) and penalizing long-term proximity to the destination (weighted -0.5), encouraging exploration of intermediate nodes that may lead to shorter overall paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = immediate_distance - 0.5 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, balancing immediate proximity and long-term efficiency. It selects the next node to visit by minimizing this ratio, ensuring the path remains efficient while progressively moving toward the destination. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes based on the ratio of the distance from the current node to the distance to the destination, ensuring a balance between immediate proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_ratio = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        if dest_dist == 0:\n            ratio = current_dist\n        else:\n            ratio = current_dist / dest_dist\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with dynamic weight adjustment, where the weight factor decreases as unvisited nodes decrease, balancing short-term (immediate distance) and long-term (approximate return distance) optimization. The `combined_score` prioritizes minimizing immediate distance (weighted by `weight_factor`) and maximizing the negative of the destination distance (weighted by `1 - weight_factor`), dynamically adjusting the balance between the two as the tour progresses. The `select_next_node` function iterates through unvisited nodes, computes the score, and selects the node with the lowest score, ensuring a smooth transition from local to global optimization.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.1 with the dynamic weight adjustment from No.2, using a weight factor that decreases as the number of unvisited nodes decreases, ensuring a smooth balance between short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_factor * immediate_distance) + ((1 - weight_factor) * -0.5 * destination_distance)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.96919,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, defaulting to the destination node if no unvisited nodes remain. It ensures a greedy, constructive approach to TSP by always choosing the locally optimal step, with the destination serving as a fallback when no unvisited nodes are left. The priority is given to minimizing the immediate distance, with the destination acting as a lower-priority fallback.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a bias towards the destination node if no unvisited nodes remain, ensuring a constructive approach to solving the TSP.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, with a dynamic weight factor that prioritizes immediate distance when fewer nodes remain unvisited. The weight factor adjusts based on the number of unvisited nodes, ensuring a smooth transition from short-term to long-term optimization. The `score` calculation gives higher priority to immediate distance (weighted by `weight_factor`) and lower priority to potential distance (weighted by `1 - weight_factor`).",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between the immediate distance to the next node and the potential long-term distance to the destination, using a dynamic weight factor that adjusts based on the remaining unvisited nodes, thereby optimizing path selection for varying problem sizes and structures.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * immediate_distance) + ((1 - weight_factor) * potential_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted 1.5) over long-term proximity to the destination (weighted 0.3), balancing short-term gains with some consideration for future efficiency. It selects the next node by minimizing a combined score that heavily favors the distance from the current node while slightly accounting for the distance to the destination. The function iterates through unvisited nodes, computes the weighted sum, and returns the node with the lowest score.",
          "thought": "The new algorithm prioritizes immediate distance (weighted 1.5) over potential long-term proximity to the destination (weighted 0.3), balancing exploration and exploitation with a more aggressive focus on short-term gains.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = 1.5 * immediate_distance + 0.3 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 7.25108,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach with a look-ahead mechanism, prioritizing immediate distance (80% weight) while also considering long-term proximity to the destination (20% weight), balancing exploration and exploitation. The `select_next_node` function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the minimum combined score, ensuring efficient path progression.",
          "thought": "The new algorithm combines the greedy approach of prioritizing immediate distance with a look-ahead mechanism that considers both immediate and long-term proximity, using weights of 0.8 and 0.2 respectively, to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        combined_score = 0.8 * immediate_distance + 0.2 * destination_distance\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance (70%) with future potential (30%), prioritizing nodes that offer both short-term proximity and long-term connectivity. It iteratively evaluates each unvisited node using a weighted combination of current and minimum future distances, selecting the node with the lowest weighted score. The code efficiently handles edge cases (e.g., no unvisited nodes) and ensures the path returns to the destination node.",
          "thought": "The new algorithm modifies the greedy nearest-neighbor approach by incorporating a dynamic weight that balances the immediate distance to the nearest unvisited node with the potential long-term impact of choosing nodes that lead to closer future steps, using a weighted combination of current and future distances to select the next node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_weighted_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = min(distance_matrix[node][n] for n in unvisited_nodes if n != node) if len(unvisited_nodes) > 1 else 0\n        weighted_score = 0.7 * current_distance + 0.3 * future_distance\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n    return next_node",
          "objective": 7.35407,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance from current node) and global proximity (distance to destination), with the latter given 30% weight. It prioritizes nodes that are both close to the current position and closer to the destination, ensuring a trade-off between immediate and long-term optimality. The `score` is computed as `distance_to_current + 0.3 * distance_to_destination`, and the node with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance to the current node and a heuristic that favors nodes closer to the destination, ensuring a balance between local and global optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the next node with a weight of 0.7, while the distance from the next node to the destination is considered with a weight of 0.3. This ensures aggressive short-term optimization while still accounting for potential long-term path efficiency. The function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the minimum score as the next step.",
          "thought": "The new algorithm prioritizes immediate distance more aggressively by using a fixed weight factor of 0.7, ensuring stronger short-term optimization while maintaining some consideration for potential distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    weight_factor = 0.7\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * immediate_distance) + ((1 - weight_factor) * potential_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     }
]