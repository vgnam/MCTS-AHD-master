[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node to the current node, ensuring minimal immediate distance traversal. If no unvisited nodes remain, it returns the destination node directly. The key design choices are prioritizing local distance optimization over global path efficiency, using the `distance_matrix` for comparisons, and handling edge cases (empty unvisited nodes) explicitly. The `destination_node` is only considered as a fallback when all nodes are visited.",
          "thought": "The algorithm selects the next node to visit from the unvisited nodes by choosing the one with the smallest distance from the current node, prioritizing nodes that are closer to the destination to improve overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the greedy approach by balancing immediate distance to the next node and potential future impact, using a heuristic that combines current distance (`current_dist`) and an estimated future distance (`future_dist`). The future distance is prioritized with a weight of 0.3, while the destination node is always selected if no unvisited nodes remain. This ensures a trade-off between short-term and long-term path optimization.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic weight factor that balances between the immediate distance to the next node and the potential future impact on the total path length, using a heuristic that combines current and estimated future distances, while still prioritizing the destination when all nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        future_dist = distance_matrix[node][destination_node] if unvisited_nodes == {node} else min(\n            distance_matrix[node][n] for n in unvisited_nodes - {node}\n        )\n        return current_dist + 0.3 * future_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node by balancing the immediate distance from the current node with a heuristic estimate of the node's proximity to the destination (weighted 50% less). It selects the unvisited node that minimizes the sum of these two distances, ensuring a trade-off between local optimization and global path efficiency. The code structure is straightforward, with `distance_matrix[current_node][node]` representing local distance and `0.5 * distance_matrix[node][destination_node]` representing the heuristic estimate, making the destination influence less prominent.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance to the current node and a heuristic estimate of the node's potential to lead to the destination, balancing local optimization with global path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (prioritized with 100% weight) and the minimum future distance to remaining nodes (weighted at 50%). It ensures efficiency by considering both short-term and long-term travel costs, with the immediate distance being the dominant factor in the decision. The `node_score` function computes this weighted sum, and the algorithm chooses the node with the lowest score from the unvisited set.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of immediate distance and the minimum future distance to any remaining node, aiming to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_distance\n        min_future_distance = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_distance + 0.5 * min_future_distance\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 7.45538,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node in TSP by balancing immediate distance (70% weight) and an average estimate of remaining path costs (30% weight). It prioritizes short-term gains while accounting for long-term efficiency, using a weighted sum to guide node selection. The weights (0.7 and 0.3) reflect a preference for minimizing immediate travel distance over estimated future costs.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the immediate distance to the next node and a heuristic estimate of the remaining path length, balancing local optimization with global efficiency. It prioritizes nodes that offer the best trade-off between short-term and long-term path cost, using a weighted sum of the current distance and the average distance to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic_cost(node):\n        current_dist = distance_matrix[current_node][node]\n        avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        return 0.7 * current_dist + 0.3 * avg_remaining_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: heuristic_cost(node))\n    return next_node",
          "objective": 7.60743,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term efficiency by weighting the current distance (prioritized when few nodes remain) and average future distances (prioritized when many nodes remain), while penalizing nodes far from the current position based on local density. The `weight_factor` adjusts this balance, and the `distance_penalty` discourages long jumps, ensuring efficiency and locality.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate distance and long-term efficiency based on the remaining unvisited nodes, using a heuristic that prioritizes nodes with high local density and low average future distances, while incorporating a penalty for nodes far from the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_distance\n\n        avg_future_distance = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        local_density = len([other for other in remaining_nodes if distance_matrix[node][other] < 2 * current_distance])\n\n        weight_factor = 0.7 if len(remaining_nodes) > 3 else 0.3\n        distance_penalty = (current_distance ** 2) / (1 + local_density)\n\n        return (weight_factor * current_distance) + ((1 - weight_factor) * avg_future_distance) + distance_penalty\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 7.81335,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances between immediate distance and future efficiency by dynamically adjusting a weight factor (0.6 for many remaining nodes, 0.4 for few). It prioritizes minimizing the weighted sum of current distance and average future distances to the remaining nodes, ensuring long-term efficiency when nodes are plentiful and immediate distance when few remain. The `node_score` function calculates this weighted sum, and the algorithm selects the node with the minimum score.",
          "thought": "The new algorithm combines the local distance optimization of No.2 with a dynamic balance between immediate and future distances inspired by No.1, using a weight factor that depends on the number of remaining nodes to prioritize long-term efficiency when many nodes are left and immediate distance when few remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_distance\n\n        avg_future_distance = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight_factor = 0.6 if len(remaining_nodes) > 4 else 0.4\n\n        return (weight_factor * current_distance) + ((1 - weight_factor) * avg_future_distance)\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 8.30081,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing immediate distance (`current_distance`) and potential long-term efficiency (`avg_future_distance`), favoring nodes that minimize their sum. It gives higher priority to nodes closer to the current node and those that, on average, are closer to the remaining unvisited nodes. The `node_score` function computes this balance, and `min` selects the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that balance immediate distance and potential long-term path efficiency by considering both the current distance and the average distance to remaining unvisited nodes, favoring nodes that minimize the sum of these two metrics.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_distance\n        avg_future_distance = sum(distance_matrix[node][other] for other in unvisited_nodes - {node}) / len(unvisited_nodes - {node})\n        return current_distance + avg_future_distance\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node with the maximum potential future distance to remaining unvisited nodes, favoring nodes that minimize the sum of these values. This ensures both short-term efficiency (proximity) and long-term potential (future distances), optimizing the trade-off between immediate and potential long-term costs. The `node_score` function computes this sum, and the algorithm selects the node with the minimum score.",
          "thought": "The new algorithm prioritizes nodes by balancing immediate distance and the maximum future distance to the remaining unvisited nodes, favoring nodes that minimize the sum of these values, which encourages both proximity and potential long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_distance\n        max_future_distance = max(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_distance + max_future_distance\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 8.58622,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term and medium-term efficiency by prioritizing nodes that minimize both the immediate distance from the current node and the sum of distances to the next two closest unvisited nodes (weighted at 50%). This ensures a trade-off between immediate proximity and future path efficiency. The function first checks for termination (no unvisited nodes), then computes a score for each candidate node, and selects the one with the lowest score.",
          "thought": "The new algorithm combines the immediate distance from the current node with a weighted sum of the distances to the next two closest unvisited nodes, balancing short-term and medium-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def node_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_unvisited = unvisited_nodes - {node}\n        if not remaining_unvisited:\n            return current_distance\n        next_two = sorted(remaining_unvisited, key=lambda n: distance_matrix[node][n])[:2]\n        sum_next_two = sum(distance_matrix[node][n] for n in next_two)\n        return current_distance + 0.5 * sum_next_two\n\n    next_node = min(unvisited_nodes, key=node_score)\n    return next_node",
          "objective": 8.73731,
          "other_inf": null
     }
]