[
     {
          "algorithm": "The algorithm dynamically balances immediate and potential distances by weighting them against node centrality, using a sigmoid function to smoothly transition between exploration (favoring distant nodes) and exploitation (prioritizing central nodes), while incorporating a deviation term to adapt to historical path preferences. Immediate distances are weighted more heavily when centrality is high, while potential distances dominate when centrality is low. The sigmoid function adjusts the influence of deviation based on the proportion of remaining unvisited nodes, ensuring adaptability throughout the search.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of immediate and potential distances based on node centrality and remaining unvisited nodes, using a sigmoid function to smooth transitions between exploration and exploitation phases, while incorporating a reinforcement learning-inspired deviation term that adapts to historical path preferences.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = len(unvisited_nodes) / len(distance_matrix)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.5798,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by selecting the next node based on a weighted cost that combines the immediate distance from the current node and a weighted potential distance to the destination, with the weight factor decreasing as the number of remaining nodes increases. This ensures that shorter-term gains are favored early in the search, balancing immediate proximity with potential long-term efficiency. The `weight_factor` dynamically adjusts the trade-off between immediate and future distances, with higher weights given to immediate distances when fewer nodes remain.",
          "thought": "The new algorithm prioritizes immediate proximity over long-term efficiency by using a weight factor that decreases as the number of remaining nodes increases, ensuring shorter-term gains are favored early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.68026,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with distance ratio and penalty mechanisms to balance immediate proximity, potential distance to the destination, and adaptability to node distributions. It prioritizes nodes with lower immediate distance and better potential connectivity to the destination, while penalizing nodes that are disproportionately distant from others, ensuring a trade-off between local and global optimization. The weighted cost function adjusts dynamically based on remaining nodes and node centrality, with distance ratio and penalty terms modulating the selection.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the distance ratio and penalty mechanism from No.2, creating a hybrid approach that balances immediate proximity, potential distance to the destination, and adaptability to node distributions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor)) + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.83746,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate proximity (via `immediate_distance`) and potential distance to the destination (via `potential_distance`), while penalizing nodes distant from the destination (`penalty`). It uses a weighted cost (`weighted_cost`) combining these factors, with exploration driven by `exploration_factor` and dynamic adjustment via `distance_ratio` and `penalty`. The destination is selected only if no other nodes remain.",
          "thought": "The new algorithm combines the exploration factor from No.1 with the dynamic weight adjustment and penalty mechanism from No.2, prioritizing nodes that balance immediate proximity and potential distance to the destination while penalizing nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.94507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with exploration and distance balancing, prioritizing nodes that are close to the current node while considering their potential distance to the destination. It calculates a weighted cost for each unvisited node, combining immediate distance, a distance ratio (relative to average distance), and an exploration factor (inverse of potential distance to destination), then selects the node with the lowest weighted cost. The immediate distance is given the highest priority, followed by the distance ratio and exploration factor. If no unvisited nodes remain, it defaults to the destination node.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with the exploration factor and distance ratio from No.1, prioritizing nodes that are close to the current node while considering potential distance to the destination and balancing immediate and potential distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        exploration_factor = 1 / (1 + potential_distance)\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.97517,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing exploration (favoring nodes with lower potential distance to the destination) and exploitation (prioritizing central nodes in the graph) using adaptive weights. Exploration is weighted more heavily early in the search (via `exploration_penalty`) to encourage diversity, while exploitation (via `centrality`) becomes more influential as fewer nodes remain. The weighted cost combines immediate distance, potential distance, and centrality, with exploration and exploitation weights dynamically adjusted based on remaining nodes.",
          "thought": "Design idea: The new algorithm introduces adaptive neighborhood weighting and dynamic penalty factors to balance exploration and exploitation, where neighborhood influence decays with distance and penalties increase for recent visits, while maintaining the core structure of weighted cost calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes) - 1\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        # Adaptive neighborhood weighting\n        neighborhood_sum = sum(distance_matrix[node])\n        neighborhood_weight = 1 / (1 + neighborhood_sum)  # Inverse relationship\n\n        # Dynamic penalty factors\n        exploration_penalty = (remaining_nodes / total_nodes) ** 3\n        exploitation_boost = 1 - exploration_penalty\n\n        # Centrality measure with neighborhood weighting\n        centrality = neighborhood_weight * (sum(distance_matrix[node]) / (total_nodes - 1))\n\n        # Dynamic weight adjustment\n        exploration_weight = 0.6 * exploration_penalty\n        exploitation_weight = 0.4 * exploitation_boost\n\n        weighted_cost = (1 - exploration_weight - exploitation_weight) * immediate_distance + \\\n                        exploration_weight * potential_distance + \\\n                        exploitation_weight * centrality\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07087,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted hybrid approach (3:2 ratio for immediate vs. potential distances) with dynamic weight adjustment based on remaining unvisited nodes. It prioritizes immediate distances (1.5x weight) while incorporating a variable weight for potential distances, which decreases as more nodes are visited. The dynamic weight ensures long-term considerations gain more influence as the tour progresses, balancing short-term and long-term path optimality.",
          "thought": "The new algorithm will combine the hybrid approach of No.2 (3:2 weight ratio) with dynamic adjustment of weights based on remaining nodes, similar to No.1, to balance short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 1.5 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.08505,
          "other_inf": null
     }
]