[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) with potential distance to the destination (30% weight), dynamically adjusting the potential weight based on remaining unvisited nodes. This prioritizes short-term efficiency while considering long-term relevance, favoring closer nodes early but increasingly valuing paths that lead directly to the destination as fewer nodes remain. The dynamic weight ensures the algorithm adapts to the problem's phase, shifting focus from exploration to completion.",
          "thought": "The new algorithm balances immediate distance (weighted 0.7) with potential distance to the destination (weighted 0.3), dynamically adjusting the potential weight based on the remaining unvisited nodes to favor short-term efficiency while considering long-term relevance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.7 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, weighted dynamically by the remaining unvisited nodes. It prioritizes immediate distance (given higher weight) while adjusting for proximity to the destination (lower weight) as the number of unvisited nodes decreases. The dynamic weight ensures exploration of closer nodes early while still considering long-term relevance to the destination.",
          "thought": "The new algorithm modifies the weighted cost calculation by incorporating a dynamic factor that adjusts the weight of the potential distance based on the remaining unvisited nodes, promoting exploration of closer nodes while still considering their relevance to the destination. The algorithm iterates through unvisited nodes, skips the destination unless no other options exist, and selects the node with the minimum adjusted weighted cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by minimizing the weighted cost of the next node, where the cost is calculated as the product of the distance from the current node and the destination node's distance raised to a static weight factor (0.3). This ensures the algorithm balances short-term efficiency (immediate distance) with long-term efficiency (destination distance), favoring nodes closer to both the current and destination nodes. The destination node is selected early if it offers the best immediate cost, but the weight factor ensures it does not dominate the decision.",
          "thought": "The new algorithm prioritizes immediate proximity with a static weight factor of 0.3, ensuring long-term efficiency is considered but not dominant, and allows the destination node to be selected early if it offers the best immediate cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    weight_factor = 0.3\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = immediate_distance * (potential_distance ** weight_factor)\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.17604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance prioritization (90% weight) with potential distance to the destination (10% weight), ensuring a trade-off between short-term proximity and long-term efficiency. The code iterates through unvisited nodes, computes a weighted cost for each, and selects the node with the minimum cost.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with the balanced weighting approach of No.1, using weights of 0.9 for immediate distance and 0.1 for potential distance to the destination, aiming for a lower objective value by favoring closer nodes while still considering long-term proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 0.9 * immediate_distance + 0.1 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    return next_node",
          "objective": 7.20675,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by `beta`) while balancing it with a geometric mean of immediate and potential distances to the destination, dynamically adjusting the weight (`gamma`) based on the remaining unvisited nodes to ensure efficient exploration. The destination is only selected if no other nodes are available, ensuring it is visited last.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, uses a geometric mean for distance trade-off, and dynamically adjusts weights based on the number of unvisited nodes to balance exploration and exploitation, while still avoiding revisits and ensuring the destination is visited last.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    beta = 0.7\n    gamma = 1.0 / len(unvisited_nodes) if unvisited_nodes else 1.0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if immediate_distance == 0 or potential_distance == 0:\n            geometric_mean = float('inf')\n        else:\n            geometric_mean = (immediate_distance * potential_distance) ** 0.5\n        distance_ratio = immediate_distance / potential_distance if potential_distance > 0 else float('inf')\n        weighted_cost = geometric_mean * (1 - beta) + distance_ratio * beta * gamma\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.25913,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm prioritizes choosing the next node by balancing immediate distance to the current node and potential distance to the destination, while dynamically adjusting weights based on the ratio of immediate distance to the average distance. It introduces a non-linear penalty for nodes distant from the destination, ensuring adaptability to spatial distributions by emphasizing proximity and long-term goals. The algorithm iteratively evaluates each unvisited node, computes a weighted cost incorporating these factors, and selects the node with the minimal cost.",
          "thought": "The new algorithm introduces dynamic weighting for potential distance based on the ratio of immediate distance to average distance, ensuring adaptability to varying spatial distributions, while maintaining a balance between proximity and long-term goals by incorporating a non-linear penalty for nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.27883,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node (60% priority) and estimated distance to the destination (40% priority), dynamically adjusting weights based on remaining unvisited nodes. A small penalty term discourages revisiting nodes, with weights scaling inversely with the number of unvisited nodes. The selection prioritizes shorter paths while considering long-term goals, with exploration favoring immediate gains early and shifting toward estimated distances later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of immediate distance, estimated distance, and a penalty term for revisiting nodes, dynamically adjusting weights based on the remaining unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        estimated_distance = distance_matrix[node][destination_node]\n        penalty = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 0.0\n        weight_immediate = 0.6 + 0.2 * (remaining_nodes / len(unvisited_nodes))\n        weight_estimated = 0.4 - 0.2 * (remaining_nodes / len(unvisited_nodes))\n        score = (weight_immediate * immediate_distance) + (weight_estimated * estimated_distance) + (penalty * immediate_distance)\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.29683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance with long-term efficiency by dynamically adjusting weights based on remaining nodes. It prioritizes nodes closer to the current node while penalizing those with high potential distances to the destination, using a weighted cost that balances proximity and future efficiency. The weight factor decreases as nodes are visited, ensuring adaptability to the remaining tour.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the balanced cost calculation and penalty mechanism from No.1, creating a hybrid approach that prioritizes both immediate proximity and long-term efficiency while dynamically adjusting weights based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes / (remaining_nodes + 1)) ** 2\n        weighted_cost = immediate_distance + (distance_ratio * potential_distance) * weight_factor\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.30731,
          "other_inf": null
     }
]