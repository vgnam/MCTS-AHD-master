[
     {
          "algorithm": "The algorithm combines centrality-based prioritization with dynamic weight adjustment to balance immediate distance, potential distance to the destination, and centrality influence. It prioritizes immediate distance early in the search (higher weights) but gradually shifts focus to potential distance as unvisited nodes decrease, while penalizing long edges exceeding a threshold. Centrality (average reciprocal distance to unvisited nodes) influences the weight balance, with higher centrality increasing immediate distance priority.",
          "thought": "The new algorithm combines centrality-based prioritization with dynamic weight adjustment and penalizes long edges, balancing immediate distance, potential distance, and centrality influence while adapting weights based on remaining nodes and applying penalties for edges exceeding a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    decay_factor = 0.3\n    max_distance_threshold = 1.5\n    remaining_nodes = len(unvisited_nodes)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n    weight_factor = 1.0 - (remaining_nodes / (remaining_nodes + 1))\n    base_weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    weight = base_weight * (1 + centrality) if centrality > 0.5 else base_weight * (1 - centrality)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        adjusted_cost = weight * immediate_distance + (1 - weight) * potential_distance + decay_factor * (immediate_distance + potential_distance)\n        if immediate_distance > max_distance_threshold:\n            adjusted_cost *= (1 + (immediate_distance - max_distance_threshold) * 0.1)\n        if adjusted_cost < min_cost:\n            min_cost = adjusted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.52217,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines a centrality-weighted trade-off with dynamic balancing, prioritizing nodes that balance immediate distance (weighted by `2 + centrality`) and potential future distance (weighted by `0.5 - centrality`), while also penalizing deviations from the average distance. The centrality measure (inverse of distances) influences the weights, favoring nodes with higher centrality (lower distances) for immediate steps and lower centrality for potential steps, with deviations slightly adjusted to avoid excessive detours. The algorithm dynamically balances these factors to guide the path selection.",
          "thought": "The new algorithm combines the centrality-weighted trade-off from No.1 with the dynamic weight balancing and deviation term from No.2, prioritizing nodes that balance immediate and potential distances while adapting to historical path preferences.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            weighted_cost = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (2 + centrality)\n            weighted_potential = potential_distance * (0.5 - centrality)\n            weighted_cost = weighted_immediate + weighted_potential\n\n        deviation = abs(immediate_distance - avg_distance)\n        cost = weighted_cost + deviation * 0.5\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.52251,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in TSP by balancing immediate distance and potential distance to the destination, with weights adjusted dynamically based on remaining nodes and centrality. Early in the search, it prioritizes immediate distance with centrality influence, while later it shifts to potential distance with higher centrality weight. The centrality metric (inverse average distance to unvisited nodes) ensures nodes near the \"center\" of the problem space are favored.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the centrality-aware trade-off of No.1, where weights are adjusted based on remaining nodes and centrality, prioritizing immediate distance early with centrality influence and shifting to potential distance with higher centrality weight as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if remaining_nodes > 2:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (0.5 - centrality)\n        else:\n            weighted_immediate = immediate_distance * (0.5 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n        weighted_cost = weighted_immediate + weighted_potential\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.52863,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment based on remaining nodes and centrality to balance immediate and potential distances, prioritizing immediate distance when centrality is high and potential distance when centrality is low. The weight is calculated adaptively using the number of remaining nodes and centrality, with higher weights favoring immediate distance in dense regions and potential distance in sparse regions. The next node is selected by minimizing a weighted cost of immediate and potential distances, ensuring efficient path selection.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the short-term and long-term efficiency balancing from No.2, using centrality-based prioritization to adaptively weigh immediate and potential distances based on the remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1))) * (1 + centrality) if centrality > 0.5 else 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1))) * (1 - centrality)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = weight * immediate_distance + (1 - weight) * potential_distance\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54289,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance (weighted by `1 + centrality`) and potential future distance (weighted by `1 - centrality`), while also incorporating deviation penalties and sigmoid-based exploration/exploitation control. Centrality (calculated as the average inverse distance) adjusts the trade-off between near-term and long-term costs, with higher centrality nodes receiving more weight for immediate distance. The sigmoid function (`1 / (1 + exp(-gamma))`) dynamically adjusts the influence of deviation penalties based on the remaining nodes, favoring exploration when few nodes are left. The algorithm ensures robustness by handling edge cases (e.g., zero distances) and defaults to the destination node if no valid next node is found.",
          "thought": "The new algorithm combines centrality-weighted trade-off with dynamic balancing, prioritizing nodes that balance immediate distance (weighted by `1 + centrality`) and potential future distance (weighted by `1 - centrality`), while also incorporating deviation penalties and sigmoid-based exploration/exploitation control, similar to No.2 but with centrality adjustments inspired by No.1.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n\n    if not remaining_nodes:\n        return destination_node\n\n    avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / len(remaining_nodes)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / len(remaining_nodes)\n    gamma = len(remaining_nodes) / len(distance_matrix)\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            weighted_cost = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            weighted_cost = weighted_immediate + weighted_potential\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        total_cost = weighted_cost + deviation * sigmoid_gamma\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.55077,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance over potential distance in high-centrality areas (lower centrality values) and vice versa (higher centrality values), using a centrality-weighted trade-off. The immediate distance is weighted more heavily (2 + centrality) when centrality is low, while the potential distance is weighted more heavily (0.5 - centrality) when centrality is high. The algorithm selects the next node based on the combined weighted cost, ensuring a balance between short-term and long-term path optimization.",
          "thought": "The new algorithm prioritizes immediate distance over potential distance in high-centrality areas and vice versa, using a centrality-weighted trade-off, but with a more aggressive shift in weighting and a different normalization approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (2 + centrality)\n        weighted_potential = potential_distance * (0.5 - centrality)\n        combined_weight = weighted_immediate + weighted_potential\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.5544,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and potential distances by dynamically weighting them based on centrality (average inverse distance to unvisited nodes), prioritizing immediate distances (weighted 1.5 + centrality) while slightly de-emphasizing potential distances (weighted 0.6 - centrality). It selects the next node with the lowest combined weighted cost, ensuring a trade-off between short-term efficiency and long-term path optimization. The centrality factor adjusts weights dynamically, giving higher priority to immediate distances in dense regions and more emphasis on potential distances in sparse regions.",
          "thought": "The new algorithm combines the centrality-weighted trade-off from No.1 with the immediate and potential distance prioritization from No.2, dynamically adjusting weights based on centrality to balance short-term and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1.5 + centrality)\n        weighted_potential = potential_distance * (0.6 - centrality)\n        weighted_cost = weighted_immediate + weighted_potential\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.55501,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate (proximity) and potential (future efficiency) distance considerations, adjusting weights based on remaining unvisited nodes and incorporating centrality to prioritize nodes that are both close to the current position and strategically positioned for long-term efficiency. It dynamically shifts focus from immediate distances (weighted higher early on) to potential future distances (weighted higher later), while centrality ensures a balance between proximity and centrality in node selection.",
          "thought": "The new algorithm combines the immediate and potential distance considerations from No.1 with the simple combined score approach of No.2, dynamically adjusting weights based on remaining nodes and incorporating centrality to balance proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight_immediate = 0.7 - (0.3 * (remaining_count / (remaining_count + 1)))\n    weight_potential = 0.3 + (0.3 * (remaining_count / (remaining_count + 1)))\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_immediate * immediate_distance * (1 + centrality)) + (weight_potential * potential_distance * (1 - centrality))\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.56643,
          "other_inf": null
     }
]