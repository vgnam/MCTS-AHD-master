def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    total_remaining = len(remaining_nodes)
    node_centrality = {}
    for node in remaining_nodes:
        centrality = sum(distance_matrix[node][other] for other in remaining_nodes) / total_remaining
        node_centrality[node] = centrality

    probabilities = []
    temperature = 1.0 / (len(unvisited_nodes) ** 0.5) if len(unvisited_nodes) > 1 else 0.1

    for node in remaining_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality_factor = node_centrality[node] / (sum(node_centrality.values()) / total_remaining) if total_remaining > 0 else 1.0

        cost = (0.4 * immediate_distance + 0.4 * potential_distance + 0.2 * centrality_factor) * (1 + temperature)
        probabilities.append(1.0 / cost)

    probabilities = [p / sum(probabilities) for p in probabilities]
    next_node = np.random.choice(list(remaining_nodes), p=probabilities)
    return next_node
