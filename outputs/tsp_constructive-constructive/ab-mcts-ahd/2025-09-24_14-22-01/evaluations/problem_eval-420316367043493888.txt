def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Dynamic weights based on tour progress
    progress_ratio = (len(unvisited_nodes) - 1) / len(unvisited_nodes) if len(unvisited_nodes) > 1 else 0.5
    immediate_weight = 0.3 + 0.4 * (1 - progress_ratio)
    potential_weight = 0.4 + 0.3 * (1 - progress_ratio)
    diversity_weight = 0.3 * progress_ratio

    # Sigmoid function for smooth transition
    def sigmoid(x):
        return 1 / (1 + math.exp(-x))

    candidates = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        diversity_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1 if len(unvisited_nodes) > 1 else 1)

        # Apply sigmoid to diversity factor
        diversity_factor = sigmoid(diversity_factor)

        weighted_cost = (immediate_weight * immediate_distance) + (potential_weight * potential_distance) + (diversity_weight * diversity_factor)
        candidates.append((node, weighted_cost))

    if not candidates:
        return destination_node

    # Probabilistic selection based on cost
    costs = [cost for _, cost in candidates]
    min_cost = min(costs)
    max_cost = max(costs)
    normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]

    # Threshold for probabilistic selection
    threshold = 0.7
    if random.random() < threshold:
        # Select node with lowest cost
        best_node = min(candidates, key=lambda x: x[1])[0]
    else:
        # Select node probabilistically
        probs = [cost / sum(normalized_costs) for cost in normalized_costs]
        best_node = random.choices([node for node, _ in candidates], weights=probs, k=1)[0]

    return next_node
