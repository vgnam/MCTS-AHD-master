def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_scores = []
    base_decay = 0.5
    exploration_bias = 0.3
    penalty_factor = 1.8

    # Calculate average remaining distance to destination
    avg_remaining = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Dynamic bias factor based on exploration/exploitation trade-off
        bias = exploration_bias * (1 - (potential_distance / (avg_remaining + 1e-6)))

        # Non-linear score combining immediate distance and potential
        score = (immediate_distance ** 1.1) + base_decay * (potential_distance ** 0.9) * (1 - bias)

        # Penalty for nodes that deviate too far from the expected path
        if immediate_distance > 1.2 * avg_remaining:
            score *= penalty_factor

        node_scores.append((node, score))

    # Select node with the lowest score (probabilistically weighted)
    if node_scores:
        nodes, scores = zip(*node_scores)
        probabilities = [1 / (score + 1e-6) for score in scores]
        total_prob = sum(probabilities)
        normalized_probs = [p / total_prob for p in probabilities]
        next_node = np.random.choice(nodes, p=normalized_probs)
        return next_node
    else:
        return next_node
