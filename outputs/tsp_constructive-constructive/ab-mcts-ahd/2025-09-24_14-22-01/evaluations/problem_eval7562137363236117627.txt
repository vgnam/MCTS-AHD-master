def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_cost = float('inf')
    next_node = None
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node
    avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / len(remaining_nodes)
    node_density = {}
    for node in remaining_nodes:
        neighbors = [n for n in remaining_nodes if n != node]
        if neighbors:
            node_density[node] = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)
        else:
            node_density[node] = 0
    avg_density = sum(node_density.values()) / len(node_density) if node_density else 0
    weights = {'immediate': 0.5, 'potential': 0.3, 'density': 0.2}
    if len(unvisited_nodes) > 5:
        weights['immediate'] += 0.1
        weights['potential'] -= 0.05
    else:
        weights['potential'] += 0.1
        weights['density'] += 0.05
    candidates = []
    for node in remaining_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        density_factor = (node_density[node] / avg_density) if avg_density else 1
        total_cost = (weights['immediate'] * immediate_distance +
                      weights['potential'] * potential_distance +
                      weights['density'] * (immediate_distance * density_factor))
        candidates.append((node, total_cost))
    if candidates:
        candidates.sort(key=lambda x: x[1])
        top_candidates = candidates[:min(3, len(candidates))]
        if len(top_candidates) > 1:
            next_node = top_candidates[np.random.choice(len(top_candidates), p=[0.7, 0.2, 0.1] if len(top_candidates) == 3 else [0.8, 0.2])][0]
        else:
            next_node = top_candidates[0][0]
    return next_node
