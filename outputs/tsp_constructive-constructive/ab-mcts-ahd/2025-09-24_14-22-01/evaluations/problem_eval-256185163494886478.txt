def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    phase = min(1.0, (total_nodes - remaining_nodes) / (total_nodes * 0.7))  # Non-linear phase transition

    # Calculate phase-based weights
    if phase < 0.3:  # Early phase: focus on immediate distance
        immediate_weight = 1.0
        return_weight = 0.1
    elif phase < 0.7:  # Middle phase: balance both
        immediate_weight = 0.7
        return_weight = 0.7
    else:  # Late phase: focus on return distance
        immediate_weight = 0.3
        return_weight = 1.0

    # Calculate visit frequency weights
    visit_frequencies = {}
    for node in unvisited_nodes:
        visit_frequencies[node] = 1.0 / (1 + (remaining_nodes - 1) * 0.1)  # Relative frequency factor

    min_score = float('inf')
    next_node = None
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        estimated_return_distance = distance_matrix[node][destination_node]
        score = (immediate_weight * immediate_distance +
                 return_weight * estimated_return_distance *
                 (1 + visit_frequencies[node]))
        if score < min_score:
            min_score = score
            next_node = node
    return next_node
