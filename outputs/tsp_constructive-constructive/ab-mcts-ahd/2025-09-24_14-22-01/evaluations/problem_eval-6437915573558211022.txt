defaulting to the destination when no valid options remain.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_cost = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes) - 1
    candidate_nodes = []
    candidate_costs = []

    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        dynamic_weight = 1.0 - (0.5 ** (remaining_nodes + 1))  # Exponential decay weight
        weighted_cost = immediate_distance + dynamic_weight * potential_distance
        if node in unvisited_nodes and node != current_node:
            weighted_cost += 1.0  # Penalize revisits
        candidate_nodes.append(node)
        candidate_costs.append(weighted_cost)

    if not candidate_nodes:
        return destination_node

    # Normalize costs and select with probabilistic softmax
    exp_costs = [math.exp(-cost) for cost in candidate_costs]
    sum_exp = sum(exp_costs)
    probabilities = [exp / sum_exp for exp in exp_costs]
    next_node = random.choices(candidate_nodes, weights=probabilities, k=1)[0]

    return next_node
