def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_cost = float('inf')
    next_node = None
    total_nodes = len(distance_matrix)
    visited_nodes = total_nodes - len(unvisited_nodes)

    # Calculate historical performance factor
    if not hasattr(select_next_node, 'history'):
        select_next_node.history = []
    if len(select_next_node.history) >= 3:
        avg_recent = sum(select_next_node.history[-3:]) / 3
        learning_factor = 0.7 if avg_recent > 1.2 * (sum(select_next_node.history) / len(select_next_node.history)) else 0.3
    else:
        learning_factor = 0.5

    # Node novelty bonus
    novelty_bonus = {node: 1.0 + (1.0 - (visited_nodes / total_nodes)) * 0.4 for node in unvisited_nodes}

    # Calculate node connectivity to unvisited nodes
    connectivity = []
    for node in range(total_nodes):
        conn = sum(1 for n in unvisited_nodes if distance_matrix[node][n] > 0)
        connectivity.append(conn)

    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Dead-end avoidance: prioritize nodes with high connectivity to unvisited nodes
        conn_bonus = 1.0 + (connectivity[node] / max(connectivity)) * 0.3

        # Dynamic weighting based on learning factor
        weighted_cost = (
            (immediate_distance * (1 - learning_factor) +
             potential_distance * learning_factor) *
            novelty_bonus[node] *
            conn_bonus
        )

        if weighted_cost < min_cost:
            min_cost = weighted_cost
            next_node = node

    if next_node is None:
        next_node = destination_node

    # Update history with the selected distance
    if next_node != destination_node:
        select_next_node.history.append(distance_matrix[current_node][next_node])

    return next_node
