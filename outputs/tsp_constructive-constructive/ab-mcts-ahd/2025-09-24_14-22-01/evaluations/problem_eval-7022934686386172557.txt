def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes - {destination_node}:
        return destination_node

    remaining_nodes = unvisited_nodes - {destination_node}
    num_remaining = len(remaining_nodes)
    total_nodes = len(unvisited_nodes)
    exploration_weight = 0.2 + 0.6 * (num_remaining / total_nodes)
    exploitation_weight = 0.8 - 0.6 * (num_remaining / total_nodes)

    candidate_scores = []
    for node in remaining_nodes:
        immediate_cost = distance_matrix[current_node][node]
        potential_cost = distance_matrix[node][destination_node]
        local_search_bonus = min(distance_matrix[node][n] for n in remaining_nodes - {node}) if num_remaining > 1 else 0

        combined_score = (exploration_weight * immediate_cost +
                          exploitation_weight * potential_cost -
                          0.2 * local_search_bonus)

        candidate_scores.append((node, combined_score))

    if not candidate_scores:
        return remaining_nodes.pop()

    candidate_scores.sort(key=lambda x: x[1])
    top_candidates = candidate_scores[:max(1, len(candidate_scores) // 3)]
    selected_node, _ = top_candidates[np.random.choice(len(top_candidates))]

    return next_node
