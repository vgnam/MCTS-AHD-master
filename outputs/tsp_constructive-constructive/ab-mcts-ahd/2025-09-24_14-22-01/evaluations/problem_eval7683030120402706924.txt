import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = len(unvisited_nodes)
    weight_factor = 0.5 + (0.5 * (1 / (remaining_nodes + 1)))  # Dynamic weight adjustment
    costs = []
    nodes = []

    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        weighted_cost = immediate_distance + weight_factor * potential_distance

        # Apply penalty if immediate distance is too high
        if immediate_distance > 2.0 * distance_matrix[current_node][destination_node]:
            weighted_cost *= 1.5

        costs.append(weighted_cost)
        nodes.append(node)

    if not nodes:
        return destination_node

    # Convert costs to probabilities using softmax
    costs = np.array(costs)
    probabilities = np.exp(-costs) / np.sum(np.exp(-costs))

    # Select node based on probabilities
    next_node = np.random.choice(nodes, p=probabilities)
    return next_node
