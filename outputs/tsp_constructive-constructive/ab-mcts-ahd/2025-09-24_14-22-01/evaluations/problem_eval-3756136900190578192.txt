def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = set(unvisited_nodes) | {current_node, destination_node}
    num_remaining = len(remaining_nodes)
    total_nodes = len(distance_matrix)

    # Sigmoid-based dynamic weights
    alpha = 1 / (1 + math.exp(-5 * (num_remaining / total_nodes - 0.5)))
    beta = 1 - alpha

    min_cost = float('inf')
    next_node = None

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Path diversity factor: average distance + variance of distances
        distances_to_remaining = [distance_matrix[node][n] for n in remaining_nodes]
        diversity = (sum(distances_to_remaining) / num_remaining +
                    np.var(distances_to_remaining) * 0.1)  # Reduced weight for variance

        # Novel cost function with diversity
        weighted_cost = (alpha * immediate_distance +
                        beta * potential_distance +
                        0.3 * diversity)  # Increased weight for diversity

        if weighted_cost < min_cost:
            min_cost = weighted_cost
            next_node = node

    return next_node
