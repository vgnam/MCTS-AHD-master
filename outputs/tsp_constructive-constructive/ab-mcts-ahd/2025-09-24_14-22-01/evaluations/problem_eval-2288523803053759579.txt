def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    total_nodes = len(unvisited_nodes) + 1  # +1 to include current node
    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes
    weight = 1 / (1 + math.exp(-10 * (visited_ratio - 0.5)))  # Sigmoid transition from 0.7 to 0.3

    min_score = float('inf')
    next_node = None
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        estimated_remaining_distance = distance_matrix[node][destination_node]

        # Calculate penalty based on average distance to remaining unvisited nodes
        penalty = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0

        score = (weight * immediate_distance) + ((1 - weight) * estimated_remaining_distance) + (0.1 * penalty)

        if score < min_score:
            min_score = score
            next_node = node
    return next_node
