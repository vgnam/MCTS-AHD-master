def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    exploration_factor = 0.8 ** (1 / remaining_nodes)  # Decaying exploration factor

    node_scores = []
    for node in unvisited_nodes:
        if node == destination_node:
            node_scores.append((node, 0.0))
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Lookahead mechanism: evaluate next two nodes
        lookahead_distance = float('inf')
        if remaining_nodes > 1:
            for next_node in unvisited_nodes:
                if next_node != node and next_node != destination_node:
                    lookahead_distance = min(lookahead_distance, distance_matrix[node][next_node])

        # Combine metrics with exploration factor
        cost = (immediate_distance + potential_distance * 0.7) + (lookahead_distance * 0.3)
        node_scores.append((node, exploration_factor * cost))

    # Softmax selection for probabilistic choice
    scores = [score for _, score in node_scores]
    if all(s == 0 for s in scores):
        return max(unvisited_nodes, key=lambda x: -distance_matrix[current_node][x])

    exp_scores = [math.exp(s - max(scores)) for s in scores]
    probs = [e / sum(exp_scores) for e in exp_scores]

    selected_node = random.choices(
        [node for node, _ in node_scores],
        weights=probs,
        k=1
    )[0]

    return next_node
