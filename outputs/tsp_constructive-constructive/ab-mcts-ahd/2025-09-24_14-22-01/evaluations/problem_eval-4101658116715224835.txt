importance.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_score = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        estimated_distance = distance_matrix[node][destination_node]

        # Calculate node centrality (average distance to all unvisited nodes)
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_nodes if total_nodes > 0 else 0

        # Dynamic weights based on remaining nodes
        weight_immediate = 0.6 - 0.2 * (remaining_nodes / total_nodes)
        weight_estimated = 0.2 + 0.2 * (remaining_nodes / total_nodes)
        weight_centrality = 0.2 * (1 - (remaining_nodes / total_nodes))

        # Penalty term based on both distance and centrality
        penalty = (immediate_distance * centrality) / (remaining_nodes + 1) if remaining_nodes > 0 else 0

        # Combined score
        score = (weight_immediate * immediate_distance) + \
                (weight_estimated * estimated_distance) - \
                (weight_centrality * centrality) + \
                penalty

        if score < min_score:
            min_score = score
            next_node = node

    return next_node
