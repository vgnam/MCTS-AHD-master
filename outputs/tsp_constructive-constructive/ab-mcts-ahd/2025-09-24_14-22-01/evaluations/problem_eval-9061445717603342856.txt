import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    total_remaining = len(remaining_nodes)
    avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / total_remaining
    node_centrality = {node: sum(1 / (distance_matrix[node][n] + 1e-6) for n in remaining_nodes) / total_remaining for node in remaining_nodes}

    context_factor = 1.0 if len(unvisited_nodes) > len(distance_matrix) * 0.7 else 0.5
    memory_boost = {node: 0.1 if node in unvisited_nodes and len(unvisited_nodes) > 3 else 0.0 for node in remaining_nodes}

    candidate_scores = []
    for node in remaining_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality_factor = node_centrality[node] * context_factor

        novelty_bonus = 1.0 / (1.0 + memory_boost[node])
        dynamic_weight_immediate = 0.4 + 0.2 * centrality_factor
        dynamic_weight_potential = 0.3 + 0.15 * memory_boost[node]
        dynamic_weight_novelty = 0.25 * novelty_bonus

        total_cost = (dynamic_weight_immediate * immediate_distance +
                      dynamic_weight_potential * potential_distance +
                      dynamic_weight_novelty * centrality_factor)

        candidate_scores.append((node, total_cost))

    if not candidate_scores:
        return random.choice(list(remaining_nodes))

    candidate_scores.sort(key=lambda x: x[1])
    top_candidates = [node for node, cost in candidate_scores[:min(3, len(candidate_scores))]]
    probabilities = [math.exp(-cost) for _, cost in candidate_scores[:min(3, len(candidate_scores))]]
    sum_probs = sum(probabilities)
    probabilities = [p / sum_probs for p in probabilities]

    return next_node
