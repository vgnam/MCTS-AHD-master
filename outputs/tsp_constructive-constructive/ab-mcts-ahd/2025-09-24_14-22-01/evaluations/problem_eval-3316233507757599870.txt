def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = len(unvisited_nodes)
    if remaining_nodes == 0:
        return destination_node

    # Dynamic routing penalty based on node density
    node_density = len(unvisited_nodes) / len(distance_matrix)
    penalty_factor = 1.0 + (node_density * 0.5)

    # Heuristic for future path efficiency
    avg_nearby_distance = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])
    efficiency_heuristic = avg_nearby_distance / (distance_matrix[current_node][destination_node] + 1e-6)

    # Temperature for probabilistic selection
    temperature = 1.0 / (remaining_nodes + 1)
    cost_scores = []

    for node in unvisited_nodes:
        if node == destination_node:
            cost_scores.append((float('inf'), node))
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Dynamic cost calculation
        dynamic_cost = immediate_distance + (1 - efficiency_heuristic) * potential_distance

        # Apply routing penalty
        if immediate_distance > penalty_factor * distance_matrix[current_node][destination_node]:
            dynamic_cost *= (1 + penalty_factor)

        cost_scores.append((dynamic_cost, node))

    # Probabilistic selection based on temperature
    if temperature > 0.1:
        costs = [cost for cost, _ in cost_scores]
        min_cost = min(costs)
        max_cost = max(costs)
        normalized_costs = [(cost - min_cost) / (max_cost - min_cost + 1e-6) for cost, _ in cost_scores]
        probabilities = [math.exp(-nc / temperature) for nc in normalized_costs]
        probabilities = [p / sum(probabilities) for p in probabilities]
        next_node = random.choices([node for _, node in cost_scores], weights=probabilities, k=1)[0]
    else:
        next_node = min(cost_scores, key=lambda x: x[0])[1]

    return next_node
