importance of immediate proximity and long-term efficiency based on the current state of the tour, using a decay factor to prioritize local optimization early and global optimization later. It also incorporates a penalty term for nodes that deviate significantly from the average distance to encourage balanced path selection.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_total_cost = float('inf')
    next_node = None
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    decay_factor = 0.5 ** (1 - len(unvisited_nodes) / len(distance_matrix))  # Prioritize local early, global late
    for node in unvisited_nodes:
        current_to_node = distance_matrix[current_node][node]
        node_to_dest = distance_matrix[node][destination_node]
        distance_penalty = abs(current_to_node - avg_distance) ** 1.5  # Non-linear penalty for deviation
        total_cost = (1 - decay_factor) * current_to_node + decay_factor * node_to_dest + distance_penalty
        if total_cost < min_total_cost:
            min_total_cost = total_cost
            next_node = node
    return next_node
