import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    # Calculate centrality scores for remaining nodes
    centrality_scores = {}
    for node in remaining_nodes:
        centrality = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)
        centrality_scores[node] = centrality

    # Dynamic temperature parameter
    temperature = 1.0 - (len(remaining_nodes) / len(unvisited_nodes)) ** 2

    # Calculate weighted probabilities for each node
    probabilities = []
    total_weight = 0.0
    for node in remaining_nodes:
        immediate = distance_matrix[current_node][node]
        potential = distance_matrix[node][destination_node]
        centrality = centrality_scores[node]

        # Weighted combination with dynamic temperature
        weight = (0.5 * immediate + 0.3 * potential + 0.2 * centrality) * (1.0 / (1.0 + temperature))
        probabilities.append((node, weight))
        total_weight += weight

    # Normalize probabilities
    normalized_probs = [(node, weight / total_weight) for node, weight in probabilities]

    # Select node based on weighted probabilities
    r = random.random()
    cumulative_prob = 0.0
    for node, prob in normalized_probs:
        cumulative_prob += prob
        if r <= cumulative_prob:
            return node
    return next_node
