def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    costs = []
    nodes = []

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        diversity_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1 if len(unvisited_nodes) > 1 else 1)

        # Dynamic diversity factor: consider local and global connectivity
        local_connectivity = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node and distance_matrix[node][other] < immediate_distance) / (len(unvisited_nodes) - 1 if len(unvisited_nodes) > 1 else 1)
        global_connectivity = sum(distance_matrix[node][other] for other in range(len(distance_matrix))) / len(distance_matrix)
        diversity_factor = 0.7 * local_connectivity + 0.3 * global_connectivity

        # Penalty for revisiting nodes in the current path's neighborhood
        neighborhood_penalty = 1.0
        if node in distance_matrix[current_node] and distance_matrix[current_node][node] < 0.5 * sum(distance_matrix[current_node]) / len(distance_matrix):
            neighborhood_penalty = 0.8

        weighted_cost = (0.4 * immediate_distance) + (0.4 * potential_distance) + (0.1 * diversity_factor) + (0.1 * neighborhood_penalty)
        costs.append(weighted_cost)
        nodes.append(node)

    if not nodes:
        return destination_node

    # Probabilistic selection using softmax with temperature
    temperature = 0.5
    exp_costs = [math.exp(-cost / temperature) for cost in costs]
    sum_exp_costs = sum(exp_costs)
    probs = [exp_cost / sum_exp_costs for exp_cost in exp_costs]

    next_node = random.choices(nodes, weights=probs, k=1)[0]

    return next_node
