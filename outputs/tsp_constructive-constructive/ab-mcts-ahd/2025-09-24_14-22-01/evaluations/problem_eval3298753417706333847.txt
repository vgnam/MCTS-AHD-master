def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_cost = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Dynamic weighting based on remaining nodes
        if remaining_nodes > 1:
            weight_immediate = 1.5 - 0.1 * remaining_nodes
            weight_potential = 0.5 + 0.1 * remaining_nodes
        else:
            weight_immediate = 1.4
            weight_potential = 0.4

        # Penalty for nodes too close to current node
        if immediate_distance < 10:  # Threshold can be adjusted
            penalty = 5 * (10 - immediate_distance)
        else:
            penalty = 0

        weighted_cost = weight_immediate * immediate_distance + weight_potential * potential_distance + penalty

        if weighted_cost < min_cost:
            min_cost = weighted_cost
            next_node = node

    return next_node
