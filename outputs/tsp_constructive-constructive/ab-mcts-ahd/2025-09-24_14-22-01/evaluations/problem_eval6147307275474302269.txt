import math
    import random
    if not unvisited_nodes:
        return destination_node
    remaining_nodes = len(unvisited_nodes)
    alpha = 0.7 if remaining_nodes > 2 else 0.3
    temperature = max(0.1, 1.0 / (remaining_nodes + 1))
    costs = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        if immediate_distance == 0 or potential_distance == 0:
            geometric_mean = float('inf')
        else:
            geometric_mean = (immediate_distance * potential_distance) ** 0.5
        position_factor = (distance_matrix[current_node][destination_node] - immediate_distance) / distance_matrix[current_node][destination_node] if distance_matrix[current_node][destination_node] > 0 else 0
        revisit_penalty = (remaining_nodes / (remaining_nodes + 1)) ** 2
        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)
        weighted_cost = geometric_mean * (1 - alpha) + (position_factor * alpha) * revisit_penalty * weight_factor
        costs.append((node, weighted_cost))
    if not costs:
        return destination_node
    min_cost = min(cost for _, cost in costs)
    boltzmann_weights = [math.exp(-(cost - min_cost) / temperature) for _, cost in costs]
    total_weight = sum(boltzmann_weights)
    normalized_weights = [w / total_weight for w in boltzmann_weights]
    next_node = random.choices([node for node, _ in costs], weights=normalized_weights, k=1)[0]
    return next_node
