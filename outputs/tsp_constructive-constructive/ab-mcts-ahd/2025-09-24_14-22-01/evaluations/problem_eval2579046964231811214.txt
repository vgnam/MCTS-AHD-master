def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    min_cost = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    if remaining_nodes == 0:
        return destination_node

    # Calculate average potential distance and nearest neighbor distance
    avg_potential_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes
    nearest_neighbor_distance = min(distance_matrix[current_node][node] for node in unvisited_nodes) if unvisited_nodes else 0

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Normalize distances
        normalized_immediate = immediate_distance / nearest_neighbor_distance if nearest_neighbor_distance > 0 else 1
        normalized_potential = potential_distance / avg_potential_distance if avg_potential_distance > 0 else 1

        # Dynamic weight factor using sigmoid function
        sigmoid_input = 10 * (remaining_nodes / len(unvisited_nodes) - 0.5)
        weight_factor = 1 / (1 + math.exp(-sigmoid_input))

        # Combined cost with local search consideration
        weighted_cost = (normalized_immediate * (1 - weight_factor) + normalized_potential * weight_factor) * (1 + 0.1 * normalized_immediate)

        if weighted_cost < min_cost:
            min_cost = weighted_cost
            next_node = node

    if next_node is None:
        next_node = destination_node
    return next_node
