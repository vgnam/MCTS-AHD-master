def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    base_weight_immediate = 0.4
    base_weight_potential = 0.3
    base_weight_centrality = 0.2
    base_weight_lookahead = 0.1

    # Dynamic weight adjustment based on remaining nodes
    weight_immediate = base_weight_immediate * (1.0 - 0.1 * (remaining_nodes / len(distance_matrix)))
    weight_potential = base_weight_potential * (1.0 + 0.1 * (remaining_nodes / len(distance_matrix)))
    weight_centrality = base_weight_centrality
    weight_lookahead = base_weight_lookahead

    node_scores = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node]) / (len(distance_matrix) - 1)
        lookahead_cost = min([distance_matrix[node][n] for n in unvisited_nodes if n != node and n != destination_node], default=0)

        # Normalized costs
        max_immediate = max([distance_matrix[current_node][n] for n in unvisited_nodes if n != destination_node], default=1)
        max_potential = max([distance_matrix[n][destination_node] for n in unvisited_nodes if n != destination_node], default=1)
        max_centrality = max([sum(distance_matrix[n]) / (len(distance_matrix) - 1) for n in unvisited_nodes if n != destination_node], default=1)
        max_lookahead = max([min([distance_matrix[n][m] for m in unvisited_nodes if m != n and m != destination_node], default=0) for n in unvisited_nodes if n != destination_node], default=1)

        norm_immediate = immediate_distance / max_immediate if max_immediate > 0 else 0
        norm_potential = potential_distance / max_potential if max_potential > 0 else 0
        norm_centrality = centrality / max_centrality if max_centrality > 0 else 0
        norm_lookahead = lookahead_cost / max_lookahead if max_lookahead > 0 else 0

        total_cost = (weight_immediate * norm_immediate +
                      weight_potential * norm_potential +
                      weight_centrality * norm_centrality +
                      weight_lookahead * norm_lookahead)

        node_scores.append((node, total_cost))

    if not node_scores:
        return destination_node

    # Select node with lowest cost, with slight randomness to avoid local minima
    node_scores.sort(key=lambda x: x[1])
    if len(node_scores) > 1 and remaining_nodes > 2:
        # Introduce randomness in top 3 candidates
        candidates = node_scores[:3]
        probabilities = [1.0 - 0.2 * i for i in range(len(candidates))]
        total_prob = sum(probabilities)
        norm_prob = [p / total_prob for p in probabilities]
        selected_idx = np.random.choice(len(candidates), p=norm_prob)
        next_node = candidates[selected_idx][0]
    else:
        next_node = node_scores[0][0]

    return next_node
