import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    num_nodes = len(distance_matrix)
    exploration_factor = math.log(len(remaining_nodes) + 1) / math.log(num_nodes + 1)

    def harmonic_mean(a, b):
        return 2 * a * b / (a + b) if (a + b) != 0 else 0

    def path_coherence(node):
        if not unvisited_nodes - {current_node, node}:
            return 0
        coherence = 0
        for neighbor in unvisited_nodes - {current_node, node}:
            coherence += 1 / (distance_matrix[node][neighbor] + distance_matrix[neighbor][destination_node] + 1e-6)
        return coherence / len(unvisited_nodes - {current_node, node}) if (unvisited_nodes - {current_node, node}) else 0

    def neighborhood_influence(node):
        influence = 0
        for neighbor in remaining_nodes:
            if neighbor != node:
                influence += math.exp(-distance_matrix[node][neighbor] / max(distance_matrix[node][n] for n in remaining_nodes if n != node))
        return influence / len(remaining_nodes) if remaining_nodes else 0

    min_cost = float('inf')
    next_node = None

    for node in remaining_nodes:
        immediate = distance_matrix[current_node][node]
        potential = distance_matrix[node][destination_node]
        weighted_distance = harmonic_mean(immediate, potential)

        coherence = path_coherence(node)
        influence = neighborhood_influence(node)

        entropy_term = exploration_factor * math.log(len(remaining_nodes) + 1)
        cost = (1 - exploration_factor) * weighted_distance + exploration_factor * (coherence + influence) + entropy_term

        if cost < min_cost:
            min_cost = cost
            next_node = node

    return next_node
