import math
    import random

    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes) - 1
    temperature = 1.0 - (remaining_nodes / total_nodes)  # Decreases as progress increases

    # Dynamic weights using sigmoid function
    exploration_weight = 1 / (1 + math.exp(-5 * (remaining_nodes / total_nodes - 0.5)))
    exploitation_weight = 1 - exploration_weight

    # Memory-based penalty (higher penalty for recently visited nodes)
    memory_penalty = {node: 1.0 for node in unvisited_nodes}
    if hasattr(select_next_node, 'visited_history'):
        for node in select_next_node.visited_history:
            if node in memory_penalty:
                memory_penalty[node] *= 1.5

    # Calculate probabilities
    probabilities = []
    for node in unvisited_nodes:
        if node == destination_node:
            probabilities.append(0.0)
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node]) / (total_nodes - 1)

        # Weighted cost with memory penalty
        cost = (exploitation_weight * immediate_distance +
                exploration_weight * potential_distance +
                0.2 * centrality) * memory_penalty[node]

        probabilities.append(1.0 / (cost + 1e-6))  # Avoid division by zero

    # Normalize probabilities and apply temperature
    total_prob = sum(probabilities)
    if total_prob == 0:
        probabilities = [1.0 / len(unvisited_nodes) for _ in unvisited_nodes]
    else:
        probabilities = [p / total_prob for p in probabilities]

    # Apply temperature to probabilities
    probabilities = [p ** (1 / temperature) for p in probabilities]
    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]

    # Select node based on probabilities
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]

    # Update visited history
    if not hasattr(select_next_node, 'visited_history'):
        select_next_node.visited_history = []
    select_next_node.visited_history.append(next_node)

    return next_node
