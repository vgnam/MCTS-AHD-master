def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = len(unvisited_nodes) - 1 if destination_node in unvisited_nodes else len(unvisited_nodes)
    dynamic_weight = 0.75 if remaining_nodes > 1 else 0.5
    costs = []
    nodes = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        weighted_cost = immediate_distance + dynamic_weight * potential_distance
        costs.append(weighted_cost)
        nodes.append(node)
    if not nodes:
        return destination_node
    min_cost = min(costs)
    max_cost = max(costs)
    probabilities = [(max_cost - cost + 1) / (max_cost - min_cost + 1) for cost in costs]
    probabilities = [p / sum(probabilities) for p in probabilities]
    next_node = np.random.choice(nodes, p=probabilities)
    return next_node
