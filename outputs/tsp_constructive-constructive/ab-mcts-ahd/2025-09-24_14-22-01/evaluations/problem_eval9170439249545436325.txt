importance, incorporating a probabilistic selection approach to balance exploration and exploitation, while also integrating a adaptive deviation penalty to ensure balanced route selection.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    import math
    import random
    min_cost = float('inf')
    next_node = None
    total_nodes = len(distance_matrix)
    visited_nodes = total_nodes - len(unvisited_nodes)
    exploration_factor = (visited_nodes / total_nodes) ** 1.5
    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)

    candidates = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        weighted_immediate = immediate_distance * (1 + centrality * (1 - exploration_factor))
        deviation = abs(immediate_distance - avg_distance) ** 1.2
        weighted_cost = (weighted_immediate * (1 - exploration_factor) + potential_distance * exploration_factor) + deviation
        candidates.append((node, weighted_cost))

    if not candidates:
        return destination_node

    costs = [cost for _, cost in candidates]
    min_cost = min(costs)
    max_cost = max(costs)
    normalized_costs = [(max_cost - cost + 1e-6) / (max_cost - min_cost + 1e-6) for _, cost in candidates]
    probabilities = [math.exp(-cost) / sum(math.exp(-cost) for cost in normalized_costs) for cost in normalized_costs]
    next_node = random.choices([node for node, _ in candidates], weights=probabilities, k=1)[0]

    return next_node
