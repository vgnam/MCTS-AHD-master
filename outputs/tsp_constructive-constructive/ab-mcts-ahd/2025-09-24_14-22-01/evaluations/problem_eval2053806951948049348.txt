def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    candidates = []
    base_decay = 0.5
    threshold_sensitivity = 0.3
    exploration_factor = 0.7
    remaining_nodes = len(unvisited_nodes)

    # Calculate average remaining distance to destination
    avg_remaining = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Sigmoid-based dynamic threshold
        relative_distance = potential_distance / avg_remaining
        sigmoid = 1 / (1 + math.exp(-threshold_sensitivity * (relative_distance - 1)))
        adjusted_threshold = 1.2 * (1 + sigmoid * exploration_factor)

        # Decay factor based on remaining nodes
        decay_factor = base_decay * (remaining_nodes / (remaining_nodes + 1)) ** 0.5

        # Path potential with dynamic decay
        path_potential = (immediate_distance ** 1.1) + decay_factor * (potential_distance ** 0.9)

        # Probabilistic selection component
        if immediate_distance > adjusted_threshold:
            penalty = 1.5 + (immediate_distance - adjusted_threshold) * 0.2
            path_potential *= penalty

        candidates.append((node, path_potential))

    # Select node with minimum potential or probabilistically based on rank
    if not candidates:
        return destination_node

    candidates.sort(key=lambda x: x[1])
    selected_index = min(int(len(candidates) * exploration_factor), len(candidates) - 1)
    next_node = candidates[selected_index][0]

    return next_node
