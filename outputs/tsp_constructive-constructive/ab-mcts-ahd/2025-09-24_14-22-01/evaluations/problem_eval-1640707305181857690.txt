def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    total_nodes = len(distance_matrix)
    visited_nodes = total_nodes - len(unvisited_nodes)
    exploration_factor = (visited_nodes / total_nodes) ** 1.5
    stochastic_factor = 1.0 - (visited_nodes / total_nodes) ** 0.5
    node_scores = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        revisit_penalty = 1.0 if node in unvisited_nodes else 1.5
        weighted_cost = (immediate_distance * (1 - exploration_factor) + potential_distance * exploration_factor) * revisit_penalty
        node_scores.append((node, weighted_cost))
    if not node_scores:
        return destination_node
    min_cost = min(score for _, score in node_scores)
    max_cost = max(score for _, score in node_scores)
    normalized_scores = [(node, (max_cost - score + 1) / (max_cost - min_cost + 1)) for node, score in node_scores]
    probabilities = [score ** (1 / stochastic_factor) for _, score in normalized_scores]
    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]
    next_node = np.random.choice([node for node, _ in normalized_scores], p=probabilities)
    return next_node
