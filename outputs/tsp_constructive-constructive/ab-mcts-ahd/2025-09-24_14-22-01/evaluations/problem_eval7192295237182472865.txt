def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))
    avg_distance = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])

    candidates = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        penalty = 0.2 * (potential_distance / avg_distance) if avg_distance > 0 else 0
        weighted_cost = immediate_distance + weight * potential_distance - penalty
        candidates.append((node, weighted_cost))

    if not candidates:
        return destination_node

    candidates.sort(key=lambda x: x[1])
    top_candidates = candidates[:min(3, len(candidates))]
    selected = random.choices(
        [c[0] for c in top_candidates],
        weights=[1/(i+1) for i in range(len(top_candidates))],
        k=1
    )[0]

    return next_node
