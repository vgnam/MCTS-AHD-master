def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    total_remaining = len(remaining_nodes)
    avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / total_remaining

    # Calculate node centrality as inverse of average distance to other nodes
    node_centrality = {
        node: 1 / (sum(distance_matrix[node][n] for n in remaining_nodes) / total_remaining + 1e-6)
        for node in remaining_nodes
    }

    # Memory factor based on historical selection patterns (simplified)
    memory_factor = {
        node: 0.7 if node in unvisited_nodes and len(unvisited_nodes) > 3 else 0.3
        for node in remaining_nodes
    }

    min_cost = float('inf')
    next_node = None

    for node in remaining_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality_score = node_centrality[node]
        memory_score = memory_factor[node]

        # Dynamic weight calculation with novel components
        weight_proximity = 0.4 + 0.15 * centrality_score
        weight_destination = 0.35 + 0.2 * memory_score
        weight_centrality = 0.25 - 0.1 * centrality_score

        # Novel cost function combining multiple factors
        cost_proximity = immediate_distance * weight_proximity
        cost_destination = potential_distance * weight_destination
        cost_centrality = centrality_score * weight_centrality

        total_cost = cost_proximity + cost_destination + cost_centrality

        if total_cost < min_cost:
            min_cost = total_cost
            next_node = node

    return next_node
