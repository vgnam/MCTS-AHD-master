import math
    import random
    min_cost = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    alpha = 0.7 if remaining_nodes > 2 else 0.3
    temperature = max(0.1, 1.0 / (remaining_nodes + 1))
    candidate_scores = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        if immediate_distance == 0 or potential_distance == 0:
            geometric_mean = float('inf')
        else:
            geometric_mean = (immediate_distance * potential_distance) ** 0.5
        local_density = sum(1 / (distance_matrix[node][other] + 1e-6) for other in unvisited_nodes if other != node) / (remaining_nodes - 1)
        position_factor = (distance_matrix[current_node][destination_node] - immediate_distance) / distance_matrix[current_node][destination_node] if distance_matrix[current_node][destination_node] > 0 else 0
        revisit_penalty = (remaining_nodes / (remaining_nodes + 1)) ** 2
        weighted_cost = geometric_mean * (1 - alpha) + (position_factor * alpha) * revisit_penalty
        weighted_cost *= math.exp(-local_density * temperature)
        candidate_scores.append((node, weighted_cost))
    if not candidate_scores:
        return destination_node
    candidate_scores.sort(key=lambda x: x[1])
    probabilities = [math.exp(-score[1] / temperature) for score in candidate_scores]
    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]
    selected_node = random.choices([node for node, _ in candidate_scores], weights=probabilities, k=1)[0]
    return next_node
