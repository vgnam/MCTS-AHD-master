def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_utility = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    exploration_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1)) ** 2
    exploitation_weight = 1 - exploration_weight

    node_density = {}
    for node in unvisited_nodes:
        neighbors = [n for n in unvisited_nodes if n != node]
        if neighbors:
            node_density[node] = len(neighbors) / sum(distance_matrix[node][n] for n in neighbors)
        else:
            node_density[node] = 0

    max_density = max(node_density.values()) if node_density else 1
    memory_factor = 0.9 ** (len(unvisited_nodes) - remaining_nodes + 1)

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        density_score = node_density[node] / max_density if max_density else 0

        utility = (exploration_weight * (immediate_distance + potential_distance) +
                   exploitation_weight * (1 - density_score) +
                   memory_factor * (1 / (immediate_distance + 1e-6)))

        if utility < min_utility:
            min_utility = utility
            next_node = node

    return next_node
