def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = unvisited_nodes - {destination_node}
    if not remaining_nodes:
        return destination_node

    dynamic_weight = 0.1 + 0.5 * (1 - (len(remaining_nodes) / len(unvisited_nodes)))
    temperature = len(remaining_nodes) / len(unvisited_nodes)

    costs = []
    for node in remaining_nodes:
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        regret_factor = (potential_distance - immediate_distance) / immediate_distance if immediate_distance != 0 else 0
        total_cost = (0.4 - dynamic_weight) * immediate_distance + (0.5 + dynamic_weight) * potential_distance + 0.1 * regret_factor
        costs.append((node, total_cost))

    if temperature > 0:
        probabilities = [math.exp(-cost / temperature) for _, cost in costs]
        total_prob = sum(probabilities)
        probabilities = [p / total_prob for p in probabilities]
        next_node = random.choices([node for node, _ in costs], weights=probabilities, k=1)[0]
    else:
        next_node = min(costs, key=lambda x: x[1])[0]

    return next_node
