import random
    best_score = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    total_unvisited = remaining_nodes + 1
    novelty_weights = {node: 1.0 / (1 + sum(1 for n in unvisited_nodes if n == node)) for node in unvisited_nodes}

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]
        dynamic_weight = 0.7 * (1 - (remaining_nodes / total_unvisited))
        penalty = 1.0 if immediate_distance > 1.5 * distance_matrix[current_node][destination_node] else 0.8
        combined_score = (immediate_distance + dynamic_weight * destination_distance) * penalty * novelty_weights[node]

        if combined_score < best_score:
            best_score = combined_score
            next_node = node

    # Add probabilistic selection to escape local optima
    if random.random() < 0.2 and remaining_nodes > 2:
        candidates = [node for node in unvisited_nodes if node != next_node]
        if candidates:
            next_node = random.choice(candidates)

    return next_node
