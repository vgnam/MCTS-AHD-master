def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, temperature=1.0, memory=None, iteration=0, max_iterations=100):
    if memory is None:
        memory = set()

    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes) - 1

    costs = []
    nodes = []

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Novel centrality measure: combination of proximity and connectivity
        proximity = sum(distance_matrix[node]) / (total_nodes - 1)
        connectivity = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0) / total_nodes
        centrality = 0.6 * proximity + 0.4 * connectivity

        # Dynamic temperature-based weights
        exploration_weight = 0.5 * (1 - (iteration / max_iterations) ** 2)
        exploitation_weight = 0.5 * (iteration / max_iterations)

        # Memory-based penalty
        penalty = 1.0 if node in memory else 1.0

        weighted_cost = (1 - exploration_weight - exploitation_weight) * immediate_distance + \
                        exploration_weight * potential_distance + \
                        exploitation_weight * centrality * penalty

        costs.append(weighted_cost)
        nodes.append(node)

    if not costs:
        return destination_node

    # Probabilistic selection with temperature
    probabilities = [math.exp(-cost / temperature) for cost in costs]
    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]

    next_node = random.choices(nodes, weights=probabilities, k=1)[0]

    # Update memory
    memory.add(next_node)

    return next_node
