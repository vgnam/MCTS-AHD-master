def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    weight_immediate = 0.7 if remaining_nodes <= 2 else 0.3
    weight_potential = 0.2 if remaining_nodes <= 2 else 0.5
    weight_centrality = 0.1 if remaining_nodes <= 2 else 0.2

    candidates = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node]) / (len(distance_matrix) - 1)
        heuristic = (weight_immediate * immediate_distance +
                    weight_potential * potential_distance +
                    weight_centrality * centrality)
        candidates.append((node, heuristic))

    if not candidates:
        return destination_node

    candidates.sort(key=lambda x: x[1])
    top_candidates = candidates[:max(1, len(candidates) // 2)]
    probabilities = [1.0 / (i + 1) for i in range(len(top_candidates))]
    probabilities = [p / sum(probabilities) for p in probabilities]
    selected_idx = np.random.choice(len(top_candidates), p=probabilities)
    next_node = top_candidates[selected_idx][0]

    return next_node
