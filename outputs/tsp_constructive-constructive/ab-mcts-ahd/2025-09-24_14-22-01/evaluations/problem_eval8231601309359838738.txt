def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    total_nodes = len(distance_matrix)
    unvisited_count = len(unvisited_nodes)
    temperature = 1.0 * unvisited_count / total_nodes  # Dynamic temperature
    costs = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        cost = immediate_distance + potential_distance
        # Sigmoid-based adjustment for long immediate distances
        adjusted_cost = cost * (1 - 1 / (1 + math.exp(-(immediate_distance - 1.5))))
        costs.append((node, adjusted_cost))
    if not costs:
        return destination_node
    # Softmax with temperature to select node probabilistically
    max_cost = max(cost for _, cost in costs)
    probs = [math.exp(-cost / (temperature * max_cost)) for _, cost in costs]
    prob_sum = sum(probs)
    probs = [p / prob_sum for p in probs]
    selected_node = random.choices([node for node, _ in costs], weights=probs, k=1)[0]
    return next_node
