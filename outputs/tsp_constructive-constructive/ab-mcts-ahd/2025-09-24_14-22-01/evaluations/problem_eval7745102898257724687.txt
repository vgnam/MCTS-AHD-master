def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_cost = float('inf')
    next_node = None
    base_decay = 0.3
    threshold_decay = 0.3
    dynamic_threshold = 1.4
    centrality_weight = 0.2

    # Calculate average remaining distance to destination and centrality
    avg_remaining = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)

    # Dynamic weight adjustment
    weight_immediate = 0.7 + 0.3 * (avg_remaining / max(distance_matrix[current_node][destination_node], 1))
    weight_future = 1.0 - weight_immediate

    candidates = []
    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Dynamic threshold adjustment
        adjusted_threshold = dynamic_threshold * (1 + threshold_decay * (potential_distance / avg_remaining))

        # Multi-objective cost function
        cost_immediate = (immediate_distance ** 1.1)
        cost_future = base_decay * (potential_distance ** 0.9)
        cost_centrality = centrality_weight * centrality[node]

        path_potential = (weight_immediate * cost_immediate) + (weight_future * cost_future) + cost_centrality

        # Dynamic penalty for exceeding adjusted threshold
        if immediate_distance > adjusted_threshold:
            penalty = 1.5 + (immediate_distance - adjusted_threshold) * 0.2
            path_potential *= penalty

        candidates.append((node, path_potential))

    # Probabilistic selection to escape local optima
    if candidates:
        min_potential = min(c[1] for c in candidates)
        probabilities = [max(0.01, (1 - (c[1] - min_potential) / max_potential)) for c in candidates]
        total_prob = sum(probabilities)
        normalized_probs = [p / total_prob for p in probabilities]
        next_node = random.choices([c[0] for c in candidates], weights=normalized_probs, k=1)[0]

    return next_node
