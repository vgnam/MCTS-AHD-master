import math
    import random

    if not unvisited_nodes:
        return destination_node

    min_cost = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes) - 1
    total_nodes = len(distance_matrix)

    # Dynamic temperature decaying over iterations
    temperature = math.exp(-0.1 * remaining_nodes)

    # Memory-based penalty for recently visited nodes
    memory_penalty = {node: 1.0 - (0.5 ** (1 / (1 + math.exp(-(i - remaining_nodes))))) for i, node in enumerate(unvisited_nodes)}

    for node in unvisited_nodes:
        if node == destination_node:
            continue

        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]

        # Centrality measure: average distance to all other nodes
        centrality = sum(distance_matrix[node]) / (total_nodes - 1)

        # Weighted cost with temperature and memory penalty
        weighted_cost = (temperature * immediate_distance + (1 - temperature) * potential_distance) * memory_penalty[node] + 0.2 * centrality

        if weighted_cost < min_cost:
            min_cost = weighted_cost
            next_node = node

    # Probabilistic selection based on cost and temperature
    if next_node is None:
        next_node = destination_node
    else:
        # Calculate selection probabilities using softmax
        costs = []
        for node in unvisited_nodes:
            if node == destination_node:
                costs.append(float('inf'))
                continue
            immediate_distance = distance_matrix[current_node][node]
            potential_distance = distance_matrix[node][destination_node]
            centrality = sum(distance_matrix[node]) / (total_nodes - 1)
            cost = (temperature * immediate_distance + (1 - temperature) * potential_distance) * memory_penalty[node] + 0.2 * centrality
            costs.append(cost)

        # Softmax probabilities
        exp_costs = [math.exp(-cost / temperature) for cost in costs]
        sum_exp = sum(exp_costs)
        probs = [exp_cost / sum_exp for exp_cost in exp_costs]

        # Select node based on probabilities
        next_node = random.choices(unvisited_nodes, weights=probs, k=1)[0]

    return next_node
