import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    candidates = []
    remaining_nodes = len(unvisited_nodes)
    decay_factor = (remaining_nodes + 1) / (remaining_nodes + 2)

    for node in unvisited_nodes:
        if node == destination_node:
            continue
        immediate_distance = distance_matrix[current_node][node]
        potential_distance = distance_matrix[node][destination_node]
        priority_score = (immediate_distance + potential_distance) * decay_factor
        candidates.append((node, priority_score))

    if not candidates:
        return destination_node

    candidates.sort(key=lambda x: x[1])
    min_score = candidates[0][1]
    max_score = candidates[-1][1]
    score_range = max_score - min_score if max_score != min_score else 1

    weighted_candidates = []
    for node, score in candidates:
        normalized_score = (score - min_score) / score_range
        probability = 1 - normalized_score
        weighted_candidates.append((node, probability))

    total_prob = sum(prob for _, prob in weighted_candidates)
    if total_prob <= 0:
        return random.choice([node for node, _ in weighted_candidates])

    selected_node = None
    rand_val = random.random() * total_prob
    cumulative_prob = 0
    for node, prob in weighted_candidates:
        cumulative_prob += prob
        if rand_val <= cumulative_prob:
            selected_node = node
            break

    return next_node
