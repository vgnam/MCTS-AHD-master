[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted hybrid approach (3:2 ratio for immediate vs. potential distances) with dynamic weight adjustment based on remaining unvisited nodes. It prioritizes immediate distances (1.5x weight) while incorporating a variable weight for potential distances, which decreases as more nodes are visited. The dynamic weight ensures long-term considerations gain more influence as the tour progresses, balancing short-term and long-term path optimality.",
          "thought": "The new algorithm will combine the hybrid approach of No.2 (3:2 weight ratio) with dynamic adjustment of weights based on remaining nodes, similar to No.1, to balance short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 1.5 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.08505,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) with potential distance to the destination (30% weight), dynamically adjusting the potential weight based on remaining unvisited nodes. This prioritizes short-term efficiency while considering long-term relevance, favoring closer nodes early but increasingly valuing paths that lead directly to the destination as fewer nodes remain. The dynamic weight ensures the algorithm adapts to the problem's phase, shifting focus from exploration to completion.",
          "thought": "The new algorithm balances immediate distance (weighted 0.7) with potential distance to the destination (weighted 0.3), dynamically adjusting the potential weight based on the remaining unvisited nodes to favor short-term efficiency while considering long-term relevance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.7 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and foresighted costs by adjusting a weighting factor (`dynamic_weight`) based on remaining unvisited nodes, prioritizing immediate distances early and potential distances later. It avoids cycles by skipping the destination node unless no other options remain, and selects the next node with the lowest weighted cost. The structure iterates through unvisited nodes, calculates a weighted sum of immediate and potential distances, and updates the best candidate.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, transitioning from a more greedy approach early on to a more foresighted one as the tour progresses, while also penalizing revisits to previously visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        weighted_cost = dynamic_weight * immediate_distance + (1 - dynamic_weight) * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.12709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, weighted dynamically by the remaining unvisited nodes. It prioritizes immediate distance (given higher weight) while adjusting for proximity to the destination (lower weight) as the number of unvisited nodes decreases. The dynamic weight ensures exploration of closer nodes early while still considering long-term relevance to the destination.",
          "thought": "The new algorithm modifies the weighted cost calculation by incorporating a dynamic factor that adjusts the weight of the potential distance based on the remaining unvisited nodes, promoting exploration of closer nodes while still considering their relevance to the destination. The algorithm iterates through unvisited nodes, skips the destination unless no other options exist, and selects the node with the minimum adjusted weighted cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and potential distance to the destination (40% weight, dynamically adjusted based on remaining unvisited nodes). It prioritizes closer nodes early (high immediate distance weight) while gradually shifting focus to nodes that better connect to the destination (dynamic potential distance weight). The destination node is chosen if no other nodes are left.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate distance prioritization from No.2, using a higher weight for immediate distance (60%) and a dynamic weight (40%) for potential distance, adjusted by the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.4 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.6 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing local (distance from current node) and global (distance to destination) considerations, where the global weight dynamically adjusts based on remaining unvisited nodes. It prioritizes minimizing the weighted sum of these distances, with the global weight increasing as fewer nodes remain. The code uses a simple loop to evaluate each unvisited node, computing a combined value and selecting the node with the lowest value.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of the distance to the current node and the distance to the destination, where the weight for the distance to the destination is dynamically adjusted based on the number of remaining unvisited nodes, encouraging a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    min_value = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)\n        combined_value = (1 - weight) * distance_to_current + weight * distance_to_destination\n        if combined_value < min_value:\n            min_value = combined_value\n            next_node = node\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (weighted 0.6) and dynamic potential distance (weighted by 0.5 \u00d7 (1 - remaining_nodes/initial_nodes)), while penalizing revisits with 0.2 \u00d7 (1 - remaining_nodes/initial_nodes) to encourage exploration. It prioritizes closer nodes early but adjusts dynamically to avoid local optima, with penalties fading as the tour progresses. The destination node is only considered if no other unvisited nodes exist.",
          "thought": "The new algorithm combines the static weighted balance from No.1 with the dynamic exploration adjustment from No.2, while adding a penalty for revisiting nodes to avoid cycles. It selects the next node by balancing immediate distance (weighted 0.6) and potential distance (weighted dynamically by 0.5 * (1 - remaining_nodes/initial_nodes)), while penalizing revisits with 0.2 * (1 - remaining_nodes/initial_nodes) to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    initial_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / initial_nodes))\n        revisit_penalty = 0.2 * (1 - (remaining_nodes / initial_nodes))\n        weighted_cost = 0.6 * immediate_distance + dynamic_weight * potential_distance - revisit_penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.15649,
          "other_inf": null
     }
]