[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate distance to the next node and potential distance to the destination, adjusted dynamically by a weight that decreases as nodes are visited (favoring short-term proximity early). Centrality (inverse of average distance to unvisited nodes) modifies these priorities, increasing immediate distance influence and decreasing potential distance influence in high-centrality areas. The destination node is skipped during intermediate steps, ensuring it's only considered when no other nodes remain.",
          "thought": "The new algorithm combines the immediate and potential distance minimization from No.2 with dynamic weight adjustment and centrality-based balancing from No.1, prioritizing nodes that balance short-term proximity and long-term potential while avoiding the destination node during intermediate steps.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.57613,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes centrality-aware cost balancing by dynamically weighting immediate and potential distances, with centrality (inverse of average distance to unvisited nodes) adjusting the balance between local and global path considerations. The exploration factor (inverse of potential distance to destination) is scaled by a dynamic weight (0.3*(1-\u03b3), where \u03b3 is the fraction of nodes remaining), encouraging exploration when fewer nodes are left. The algorithm selects the next node by minimizing a combined cost of weighted distances and exploration, ensuring efficiency and adaptability to varying path requirements.",
          "thought": "The new algorithm combines the centrality-aware cost balancing from No.1 with the exploration factor from No.2, dynamically weighting immediate and potential distances while prioritizing nodes closer to the destination.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes) - 1\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - gamma)\n        cost = combined_weight + dynamic_weight * exploration_factor\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57735,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and potential distances by weighting them against node centrality, using a sigmoid function to smoothly transition between exploration (favoring distant nodes) and exploitation (prioritizing central nodes), while incorporating a deviation term to adapt to historical path preferences. Immediate distances are weighted more heavily when centrality is high, while potential distances dominate when centrality is low. The sigmoid function adjusts the influence of deviation based on the proportion of remaining unvisited nodes, ensuring adaptability throughout the search.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of immediate and potential distances based on node centrality and remaining unvisited nodes, using a sigmoid function to smooth transitions between exploration and exploitation phases, while incorporating a reinforcement learning-inspired deviation term that adapts to historical path preferences.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = len(unvisited_nodes) / len(distance_matrix)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.5798,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate and potential distances with centrality and density factors, using a hybrid cost function that balances exploration (via deviation and density) and exploitation (via weighted distances). Centrality and density are prioritized in weighting immediate and potential distances, while a sigmoid-adjusted deviation term and density factor refine the selection, favoring nodes with high connectivity and lower deviation from average distances. The structure iteratively evaluates each unvisited node, computing a total cost that integrates these factors to determine the next node in the path.",
          "thought": "The new algorithm combines the dynamic weighting of immediate and potential distances with centrality from No.1 with the hybrid cost function of No.2, using a sigmoid-adjusted deviation term to balance exploration and exploitation, while incorporating a density-based factor to prioritize nodes with higher connectivity.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n\n    if not remaining_nodes:\n        return destination_node\n\n    avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / len(remaining_nodes)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / len(remaining_nodes)\n    gamma = len(remaining_nodes) / len(distance_matrix)\n\n    node_density = {}\n    for node in remaining_nodes:\n        neighbors = [n for n in remaining_nodes if n != node]\n        if neighbors:\n            node_density[node] = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)\n        else:\n            node_density[node] = 0\n    avg_density = sum(node_density.values()) / len(node_density) if node_density else 0\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        density_factor = (node_density[node] / avg_density) if avg_density else 1\n\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        total_cost = combined_weight + deviation * sigmoid_gamma + 0.2 * (immediate_distance * density_factor)\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    return next_node",
          "objective": 6.63934,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by selecting the next node based on a weighted cost that combines the immediate distance from the current node and a weighted potential distance to the destination, with the weight factor decreasing as the number of remaining nodes increases. This ensures that shorter-term gains are favored early in the search, balancing immediate proximity with potential long-term efficiency. The `weight_factor` dynamically adjusts the trade-off between immediate and future distances, with higher weights given to immediate distances when fewer nodes remain.",
          "thought": "The new algorithm prioritizes immediate proximity over long-term efficiency by using a weight factor that decreases as the number of remaining nodes increases, ensuring shorter-term gains are favored early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.68026,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate and potential distances with dynamic centrality-based weighting, prioritizing immediate distance when centrality is high (global optimization) and potential distance when centrality is low (local optimization). Centrality is calculated as the average inverse of distances to unvisited nodes, adjusting weights dynamically to balance exploration and exploitation. The cost function penalizes zero distances (to avoid invalid paths) and selects the node with the lowest weighted cost.",
          "thought": "The new algorithm combines the weighted immediate and potential distances from No.1 with the simplified selection logic of No.2, using a centrality-based weighting scheme to balance local and global optimization. It calculates a cost for each unvisited node as a weighted sum of immediate and potential distances, where centrality adjusts the weights dynamically.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            cost = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (2 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            cost = weighted_immediate + weighted_potential\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.68265,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential distance to the destination, weighted by centrality (node importance) and dynamic weights based on remaining nodes. Higher centrality nodes are prioritized, while dynamic weights adjust the balance between immediate and potential distances as the tour progresses. The cost function combines these factors to minimize total path length while ensuring efficient coverage of key nodes.",
          "thought": "The new algorithm combines No.1's centrality-aware cost balancing with No.2's simple weighted approach, selecting the next node by prioritizing nodes with higher centrality while balancing immediate and potential distances with dynamic weights.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        cost = combined_weight + dynamic_weight * potential_distance\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.69175,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate efficiency (distance from current node) and long-term efficiency (distance to destination), scaled by a penalty based on remaining unvisited nodes. It prioritizes nodes with a favorable ratio of current-to-destination distances while penalizing excessively long paths to reduce detours. The score is minimized to guide the selection, with the penalty term increasing as the number of remaining nodes decreases, ensuring adaptability to the problem's constraints.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate and long-term efficiency based on the remaining unvisited nodes, using a normalized product of distances and a heuristic penalty for nodes that are too far from the current node or the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_to_node = distance_matrix[current_node][node]\n        node_to_dest = distance_matrix[node][destination_node]\n        distance_ratio = current_to_node / (node_to_dest + 1e-10)\n        penalty = (current_to_node + node_to_dest) / (remaining_nodes + 1)\n        score = distance_ratio + penalty\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.70192,
          "other_inf": null
     }
]