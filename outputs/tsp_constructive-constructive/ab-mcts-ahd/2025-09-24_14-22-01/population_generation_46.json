[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, weighted dynamically by the remaining unvisited nodes. It prioritizes immediate distance (given higher weight) while adjusting for proximity to the destination (lower weight) as the number of unvisited nodes decreases. The dynamic weight ensures exploration of closer nodes early while still considering long-term relevance to the destination.",
          "thought": "The new algorithm modifies the weighted cost calculation by incorporating a dynamic factor that adjusts the weight of the potential distance based on the remaining unvisited nodes, promoting exploration of closer nodes while still considering their relevance to the destination. The algorithm iterates through unvisited nodes, skips the destination unless no other options exist, and selects the node with the minimum adjusted weighted cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by `beta`) while balancing it with a geometric mean of immediate and potential distances to the destination, dynamically adjusting the weight (`gamma`) based on the remaining unvisited nodes to ensure efficient exploration. The destination is only selected if no other nodes are available, ensuring it is visited last.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, uses a geometric mean for distance trade-off, and dynamically adjusts weights based on the number of unvisited nodes to balance exploration and exploitation, while still avoiding revisits and ensuring the destination is visited last.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    beta = 0.7\n    gamma = 1.0 / len(unvisited_nodes) if unvisited_nodes else 1.0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if immediate_distance == 0 or potential_distance == 0:\n            geometric_mean = float('inf')\n        else:\n            geometric_mean = (immediate_distance * potential_distance) ** 0.5\n        distance_ratio = immediate_distance / potential_distance if potential_distance > 0 else float('inf')\n        weighted_cost = geometric_mean * (1 - beta) + distance_ratio * beta * gamma\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.25913,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm prioritizes choosing the next node by balancing immediate distance to the current node and potential distance to the destination, while dynamically adjusting weights based on the ratio of immediate distance to the average distance. It introduces a non-linear penalty for nodes distant from the destination, ensuring adaptability to spatial distributions by emphasizing proximity and long-term goals. The algorithm iteratively evaluates each unvisited node, computes a weighted cost incorporating these factors, and selects the node with the minimal cost.",
          "thought": "The new algorithm introduces dynamic weighting for potential distance based on the ratio of immediate distance to average distance, ensuring adaptability to varying spatial distributions, while maintaining a balance between proximity and long-term goals by incorporating a non-linear penalty for nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.27883,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (weighted 0.8) with the potential distance to the destination (weighted 0.2), ensuring closer nodes are favored while slightly considering long-term proximity. The code iterates through unvisited nodes, skips the destination if it's still unvisited, and returns the destination only if no other nodes remain. The weights reflect a bias toward short-term efficiency with minimal long-term planning.",
          "thought": "The new algorithm prioritizes immediate distance to the current node while slightly considering the potential distance to the destination, using a weighted cost of 0.8 for immediate distance and 0.2 for potential distance, ensuring closer nodes are favored with minimal long-term consideration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 0.8 * immediate_distance + 0.2 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node while also considering their distance to the destination, with a 3:2 weight ratio (immediate distance:potential distance). It skips the destination until no other nodes remain, ensuring the path is optimized for immediate progress while keeping the destination in mind. The weighted cost balances short-term gains with long-term strategy, making it a hybrid of greedy and foresighted approaches.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node and far from the destination, using a weighted cost where immediate distance has weight 1.5 and potential distance has weight 0.5, ensuring the destination is only chosen when no other nodes are available.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 1.5 * immediate_distance + 0.5 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.39182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the geometric mean of immediate (current to candidate node) and potential (candidate to destination) distances with a deviation from average distance adjustment, dynamically weighted by the inverse of remaining unvisited nodes. It prioritizes balancing local (geometric mean) and global (deviation adjustment) considerations, where the deviation term's weight decreases as more nodes are visited. The cost function `geometric_mean + (distance - avg_distance) * gamma` ensures shorter immediate paths are preferred early, while deviation adjustments refine choices later.",
          "thought": "The new algorithm combines the geometric mean of immediate and potential distances from No.1 with the deviation from average distance adjustment from No.2, dynamically adjusting the weight based on remaining unvisited nodes to balance local and global considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = 1.0 / len(unvisited_nodes) if unvisited_nodes else 1.0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if immediate_distance == 0 or potential_distance == 0:\n            geometric_mean = float('inf')\n        else:\n            geometric_mean = (immediate_distance * potential_distance) ** 0.5\n        cost = geometric_mean + (distance_matrix[current_node][node] - avg_distance) * gamma\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.39566,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (current node to candidate) and long-term efficiency (candidate to destination), using a dynamic weight factor that prioritizes the latter as the number of remaining nodes decreases. It avoids the destination node during intermediate steps, ensuring it is only chosen when no other options remain. The weight factor is calculated as `(remaining_nodes / (remaining_nodes + 1)) ** 2`, giving higher priority to long-term efficiency as the search progresses.",
          "thought": "The new algorithm modifies the product cost calculation by incorporating a dynamic weight factor that adjusts based on the remaining nodes' distances to the destination, ensuring a balance between immediate proximity and long-term path efficiency, while still avoiding the destination during intermediate steps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes / (remaining_nodes + 1)) ** 2\n        weighted_cost = immediate_distance * (potential_distance ** weight_factor)\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.41909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) and potential distance to the destination (30% weight), prioritizing local efficiency while considering global progress. It skips the destination node unless no other options remain, ensuring the solution remains efficient and complete. The code structure iteratively evaluates unvisited nodes, computes weighted costs, and updates the best choice dynamically.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of immediate distance and potential distance, using a different weighting factor to balance local and global considerations, and ensures the destination node is only chosen when no other options remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        total_cost = 0.7 * immediate_distance + 0.3 * potential_distance\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential distance to the destination, with the latter weighted by 0.5. It prioritizes nodes that offer a good trade-off between short-term and long-term benefits, favoring closer nodes while still considering their proximity to the destination. The code iterates through unvisited nodes, skips the destination (unless no other options exist), and selects the node with the minimum weighted cost.",
          "thought": "This algorithm selects the next node by considering both the immediate distance from the current node and the potential distance to the destination, but it also incorporates a weighted factor to balance exploration and exploitation, favoring nodes that offer a good trade-off between immediate and long-term benefits.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = immediate_distance + 0.5 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]