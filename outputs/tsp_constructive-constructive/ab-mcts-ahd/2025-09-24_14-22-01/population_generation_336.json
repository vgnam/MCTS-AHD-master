[
     {
          "algorithm": "The algorithm prioritizes immediate proximity by selecting the next node based on a weighted cost that combines the immediate distance from the current node and a weighted potential distance to the destination, with the weight factor decreasing as the number of remaining nodes increases. This ensures that shorter-term gains are favored early in the search, balancing immediate proximity with potential long-term efficiency. The `weight_factor` dynamically adjusts the trade-off between immediate and future distances, with higher weights given to immediate distances when fewer nodes remain.",
          "thought": "The new algorithm prioritizes immediate proximity over long-term efficiency by using a weight factor that decreases as the number of remaining nodes increases, ensuring shorter-term gains are favored early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.68026,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate proximity (via `immediate_distance`) and potential distance to the destination (via `potential_distance`), while penalizing nodes distant from the destination (`penalty`). It uses a weighted cost (`weighted_cost`) combining these factors, with exploration driven by `exploration_factor` and dynamic adjustment via `distance_ratio` and `penalty`. The destination is selected only if no other nodes remain.",
          "thought": "The new algorithm combines the exploration factor from No.1 with the dynamic weight adjustment and penalty mechanism from No.2, prioritizing nodes that balance immediate proximity and potential distance to the destination while penalizing nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.94507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with exploration and distance balancing, prioritizing nodes that are close to the current node while considering their potential distance to the destination. It calculates a weighted cost for each unvisited node, combining immediate distance, a distance ratio (relative to average distance), and an exploration factor (inverse of potential distance to destination), then selects the node with the lowest weighted cost. The immediate distance is given the highest priority, followed by the distance ratio and exploration factor. If no unvisited nodes remain, it defaults to the destination node.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with the exploration factor and distance ratio from No.1, prioritizing nodes that are close to the current node while considering potential distance to the destination and balancing immediate and potential distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        exploration_factor = 1 / (1 + potential_distance)\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.97517,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing exploration (favoring nodes with lower potential distance to the destination) and exploitation (prioritizing central nodes in the graph) using adaptive weights. Exploration is weighted more heavily early in the search (via `exploration_penalty`) to encourage diversity, while exploitation (via `centrality`) becomes more influential as fewer nodes remain. The weighted cost combines immediate distance, potential distance, and centrality, with exploration and exploitation weights dynamically adjusted based on remaining nodes.",
          "thought": "Design idea: The new algorithm introduces adaptive neighborhood weighting and dynamic penalty factors to balance exploration and exploitation, where neighborhood influence decays with distance and penalties increase for recent visits, while maintaining the core structure of weighted cost calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes) - 1\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        # Adaptive neighborhood weighting\n        neighborhood_sum = sum(distance_matrix[node])\n        neighborhood_weight = 1 / (1 + neighborhood_sum)  # Inverse relationship\n\n        # Dynamic penalty factors\n        exploration_penalty = (remaining_nodes / total_nodes) ** 3\n        exploitation_boost = 1 - exploration_penalty\n\n        # Centrality measure with neighborhood weighting\n        centrality = neighborhood_weight * (sum(distance_matrix[node]) / (total_nodes - 1))\n\n        # Dynamic weight adjustment\n        exploration_weight = 0.6 * exploration_penalty\n        exploitation_weight = 0.4 * exploitation_boost\n\n        weighted_cost = (1 - exploration_weight - exploitation_weight) * immediate_distance + \\\n                        exploration_weight * potential_distance + \\\n                        exploitation_weight * centrality\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07087,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a weighted hybrid approach (3:2 ratio for immediate vs. potential distances) with dynamic weight adjustment based on remaining unvisited nodes. It prioritizes immediate distances (1.5x weight) while incorporating a variable weight for potential distances, which decreases as more nodes are visited. The dynamic weight ensures long-term considerations gain more influence as the tour progresses, balancing short-term and long-term path optimality.",
          "thought": "The new algorithm will combine the hybrid approach of No.2 (3:2 weight ratio) with dynamic adjustment of weights based on remaining nodes, similar to No.1, to balance short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 1.5 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.08505,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing proximity to the current node and the destination, with a weight that adjusts based on remaining nodes. It prioritizes nodes closer to the current position while penalizing those too far from the destination, ensuring a trade-off between local and global optimization. The dynamic weight (0.7 for remaining nodes, 0.3 for distance) and penalty (0.2 for excessive distance) guide the selection toward more balanced paths.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that adjusts based on both the remaining nodes and the proximity to the destination, while also adding a penalty for nodes that are too far from the current node to encourage more balanced exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_value = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_unvisited_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 0.7 * (1 - (remaining_nodes / total_unvisited_nodes)) + 0.3 * (distance_to_current / max(distance_matrix[current_node]))\n        penalty = 0.2 * (distance_to_current - distance_to_destination) if distance_to_current > 1.5 * distance_to_destination else 0\n        combined_value = distance_to_current + dynamic_weight * distance_to_destination + penalty\n        if combined_value < min_value:\n            min_value = combined_value\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.09699,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) with potential distance to the destination (30% weight), dynamically adjusting the potential weight based on remaining unvisited nodes. This prioritizes short-term efficiency while considering long-term relevance, favoring closer nodes early but increasingly valuing paths that lead directly to the destination as fewer nodes remain. The dynamic weight ensures the algorithm adapts to the problem's phase, shifting focus from exploration to completion.",
          "thought": "The new algorithm balances immediate distance (weighted 0.7) with potential distance to the destination (weighted 0.3), dynamically adjusting the potential weight based on the remaining unvisited nodes to favor short-term efficiency while considering long-term relevance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.7 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     }
]