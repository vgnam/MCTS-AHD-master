[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines immediate and potential distance considerations, dynamically adjusting weights based on remaining nodes (prioritizing immediate distance early, potential distance later) and incorporating centrality (node connectivity) to balance exploration. It also penalizes nodes with distances deviating from the average, favoring efficiency. The algorithm selects the next node by minimizing a weighted cost that balances immediate and potential distances, modulated by centrality and penalized for path length deviations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality and potential distance balancing from No.1, using centrality to modulate the weights between immediate and potential distances, while penalizing nodes that deviate from the average path length to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight_immediate = 0.7 - (0.3 * (remaining_count / (remaining_count + 1)))\n    weight_potential = 0.3 + (0.3 * (remaining_count / (remaining_count + 1)))\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n    avg_distance = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        novelty_factor = abs(immediate_distance - avg_distance)\n        penalty = 0.05 * novelty_factor if immediate_distance > avg_distance else -0.05 * novelty_factor\n        weighted_cost = (weight_immediate * immediate_distance * (1 + centrality)) + (weight_potential * potential_distance * (1 - centrality)) + penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate distance to the next node and potential distance to the destination, adjusted dynamically by a weight that decreases as nodes are visited (favoring short-term proximity early). Centrality (inverse of average distance to unvisited nodes) modifies these priorities, increasing immediate distance influence and decreasing potential distance influence in high-centrality areas. The destination node is skipped during intermediate steps, ensuring it's only considered when no other nodes remain.",
          "thought": "The new algorithm combines the immediate and potential distance minimization from No.2 with dynamic weight adjustment and centrality-based balancing from No.1, prioritizing nodes that balance short-term proximity and long-term potential while avoiding the destination node during intermediate steps.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.57613,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically adjusts node selection by balancing immediate distances (weighted by centrality) and potential distances to the destination, while penalizing deviations from average distances. It prioritizes immediate distances early (high weight) and potential distances later (low weight) through dynamic weight adjustment, with centrality influencing the balance. The cost function combines these factors to guide the next node selection, ensuring a trade-off between proximity and future potential.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes, centrality-aware cost balancing, and deviation penalties to select the next node, prioritizing immediate distances early and potential distances later while penalizing deviations from average distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        cost = weight * combined_weight + (1 - weight) * deviation\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57703,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes centrality-aware cost balancing by dynamically weighting immediate and potential distances, with centrality (inverse of average distance to unvisited nodes) adjusting the balance between local and global path considerations. The exploration factor (inverse of potential distance to destination) is scaled by a dynamic weight (0.3*(1-\u03b3), where \u03b3 is the fraction of nodes remaining), encouraging exploration when fewer nodes are left. The algorithm selects the next node by minimizing a combined cost of weighted distances and exploration, ensuring efficiency and adaptability to varying path requirements.",
          "thought": "The new algorithm combines the centrality-aware cost balancing from No.1 with the exploration factor from No.2, dynamically weighting immediate and potential distances while prioritizing nodes closer to the destination.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes) - 1\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - gamma)\n        cost = combined_weight + dynamic_weight * exploration_factor\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57735,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and potential distances by weighting them against node centrality, using a sigmoid function to smoothly transition between exploration (favoring distant nodes) and exploitation (prioritizing central nodes), while incorporating a deviation term to adapt to historical path preferences. Immediate distances are weighted more heavily when centrality is high, while potential distances dominate when centrality is low. The sigmoid function adjusts the influence of deviation based on the proportion of remaining unvisited nodes, ensuring adaptability throughout the search.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of immediate and potential distances based on node centrality and remaining unvisited nodes, using a sigmoid function to smooth transitions between exploration and exploitation phases, while incorporating a reinforcement learning-inspired deviation term that adapts to historical path preferences.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = len(unvisited_nodes) / len(distance_matrix)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.5798,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance to the current node and potential distance to the destination, dynamically adjusting weights based on remaining nodes. It prioritizes nodes balancing proximity and centrality, where immediate distance is weighted more heavily when few nodes remain, while potential distance dominates early on. The centrality measure (inverse average distance to remaining nodes) influences how much each factor contributes to the cost calculation.",
          "thought": "The new algorithm combines the immediate and potential distance considerations from No.2 with dynamic weighting and node centrality from No.1, prioritizing nodes that balance proximity to the current node and potential connections to the destination, while adjusting weights based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight = 1.0 / (remaining_count + 1)\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        total_cost = (1 - weight) * combined_weight + weight * immediate_distance\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.60259,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate and potential distances while incorporating node centrality and density. It prioritizes nodes that are both locally efficient (low immediate distance) and globally connected (high centrality), adjusting weights dynamically based on remaining unvisited nodes. Density is used as a tiebreaker to refine selection, with nodes in denser regions favored when immediate and potential distances are similar. The weight between immediate and potential distances is inversely proportional to the number of remaining nodes.",
          "thought": "The new algorithm combines the dynamic weight balancing of No.2 with the centrality and density factors of No.1, dynamically adjusting the weight between immediate and potential distances while incorporating node centrality and density to refine the selection, prioritizing nodes that are both locally efficient and globally connected.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight = 1.0 / (remaining_count + 1)\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n\n    node_density = {}\n    for node in remaining_nodes:\n        neighbors = [n for n in remaining_nodes if n != node]\n        if neighbors:\n            node_density[node] = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)\n        else:\n            node_density[node] = 0\n    avg_density = sum(node_density.values()) / len(node_density) if node_density else 0\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        density_factor = (node_density[node] / avg_density) if avg_density else 1\n\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        total_cost = (1 - weight) * combined_weight + weight * (immediate_distance * density_factor)\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    return next_node",
          "objective": 6.60899,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and centrality, where weights dynamically adjust based on remaining nodes and centrality. Immediate distance is prioritized earlier in the search (higher weight), while potential distance and heuristic factors gain more influence as the search progresses. The centrality measure ensures nodes with better connectivity are favored.",
          "thought": "The new algorithm combines dynamic weight adjustment and centrality-based balancing from No.1 with the heuristic factor and distance balancing from No.2. It selects the next node by weighting immediate distance and potential distance, where weights adjust based on remaining nodes and centrality, while also considering the heuristic factor for global guidance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1 if destination_node in unvisited_nodes else len(unvisited_nodes)\n    heuristic_factor = (remaining_nodes + 1) / (remaining_nodes + 2) if remaining_nodes > 0 else 1.0\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        total_cost = weight * combined_weight + (1 - weight) * heuristic_factor * potential_distance\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.61176,
          "other_inf": null
     }
]