[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate distance to the next node and potential distance to the destination, adjusted dynamically by a weight that decreases as nodes are visited (favoring short-term proximity early). Centrality (inverse of average distance to unvisited nodes) modifies these priorities, increasing immediate distance influence and decreasing potential distance influence in high-centrality areas. The destination node is skipped during intermediate steps, ensuring it's only considered when no other nodes remain.",
          "thought": "The new algorithm combines the immediate and potential distance minimization from No.2 with dynamic weight adjustment and centrality-based balancing from No.1, prioritizing nodes that balance short-term proximity and long-term potential while avoiding the destination node during intermediate steps.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.57613,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and potential distances by weighting them against node centrality, using a sigmoid function to smoothly transition between exploration (favoring distant nodes) and exploitation (prioritizing central nodes), while incorporating a deviation term to adapt to historical path preferences. Immediate distances are weighted more heavily when centrality is high, while potential distances dominate when centrality is low. The sigmoid function adjusts the influence of deviation based on the proportion of remaining unvisited nodes, ensuring adaptability throughout the search.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of immediate and potential distances based on node centrality and remaining unvisited nodes, using a sigmoid function to smooth transitions between exploration and exploitation phases, while incorporating a reinforcement learning-inspired deviation term that adapts to historical path preferences.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = len(unvisited_nodes) / len(distance_matrix)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.5798,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by selecting the next node based on a weighted cost that combines the immediate distance from the current node and a weighted potential distance to the destination, with the weight factor decreasing as the number of remaining nodes increases. This ensures that shorter-term gains are favored early in the search, balancing immediate proximity with potential long-term efficiency. The `weight_factor` dynamically adjusts the trade-off between immediate and future distances, with higher weights given to immediate distances when fewer nodes remain.",
          "thought": "The new algorithm prioritizes immediate proximity over long-term efficiency by using a weight factor that decreases as the number of remaining nodes increases, ensuring shorter-term gains are favored early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.68026,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential distance to the destination, weighted by centrality (node importance) and dynamic weights based on remaining nodes. Higher centrality nodes are prioritized, while dynamic weights adjust the balance between immediate and potential distances as the tour progresses. The cost function combines these factors to minimize total path length while ensuring efficient coverage of key nodes.",
          "thought": "The new algorithm combines No.1's centrality-aware cost balancing with No.2's simple weighted approach, selecting the next node by prioritizing nodes with higher centrality while balancing immediate and potential distances with dynamic weights.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        cost = combined_weight + dynamic_weight * potential_distance\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.69175,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity and future efficiency by combining the distance from the current node with a weighted estimate to the destination. It prioritizes nodes closer to the current node but also considers their potential to lead to the destination, where the weight decreases as more nodes are visited. The weighted cost is calculated as `immediate_distance / (potential_distance ** weight)`, where `weight` adjusts dynamically based on remaining nodes.",
          "thought": "The new algorithm combines the weighted cost approach of No.1 with the dynamic weight adjustment of No.2, using a weight factor that decreases as nodes are visited to balance immediate proximity and potential future efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 + 0.2 * (remaining_nodes / len(distance_matrix))\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.7295,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and a penalty for excessively long edges, using dynamic weights that prioritize nodes with lower combined costs while adjusting for remaining nodes and distance ratios. Nodes with immediate distances exceeding a threshold (`max_distance_threshold`) are penalized more heavily, ensuring shorter, more efficient paths. The `weight_factor` and `decay_factor` dynamically adjust the influence of potential distance and distance ratio, respectively, to optimize both local and global path quality.",
          "thought": "The new algorithm combines dynamic weight adjustment with immediate distance, potential distance, and penalty mechanisms to balance local and global optimization, prioritizing nodes with lower weighted costs while penalizing disproportionately distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    decay_factor = 0.4\n    max_distance_threshold = 1.5\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor)) + decay_factor * distance_ratio * potential_distance\n        if immediate_distance > max_distance_threshold:\n            weighted_cost *= (1 + (immediate_distance - max_distance_threshold) * 0.2)\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.79197,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with distance ratio and penalty mechanisms to balance immediate proximity, potential distance to the destination, and adaptability to node distributions. It prioritizes nodes with lower immediate distance and better potential connectivity to the destination, while penalizing nodes that are disproportionately distant from others, ensuring a trade-off between local and global optimization. The weighted cost function adjusts dynamically based on remaining nodes and node centrality, with distance ratio and penalty terms modulating the selection.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the distance ratio and penalty mechanism from No.2, creating a hybrid approach that balances immediate proximity, potential distance to the destination, and adaptability to node distributions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor)) + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.83746,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     }
]