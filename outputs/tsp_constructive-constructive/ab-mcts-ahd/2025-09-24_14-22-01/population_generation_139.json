[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) with potential distance to the destination (30% weight), dynamically adjusting the potential weight based on remaining unvisited nodes. This prioritizes short-term efficiency while considering long-term relevance, favoring closer nodes early but increasingly valuing paths that lead directly to the destination as fewer nodes remain. The dynamic weight ensures the algorithm adapts to the problem's phase, shifting focus from exploration to completion.",
          "thought": "The new algorithm balances immediate distance (weighted 0.7) with potential distance to the destination (weighted 0.3), dynamically adjusting the potential weight based on the remaining unvisited nodes to favor short-term efficiency while considering long-term relevance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.7 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, weighted dynamically by the remaining unvisited nodes. It prioritizes immediate distance (given higher weight) while adjusting for proximity to the destination (lower weight) as the number of unvisited nodes decreases. The dynamic weight ensures exploration of closer nodes early while still considering long-term relevance to the destination.",
          "thought": "The new algorithm modifies the weighted cost calculation by incorporating a dynamic factor that adjusts the weight of the potential distance based on the remaining unvisited nodes, promoting exploration of closer nodes while still considering their relevance to the destination. The algorithm iterates through unvisited nodes, skips the destination unless no other options exist, and selects the node with the minimum adjusted weighted cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and potential distance to the destination (40% weight, dynamically adjusted based on remaining unvisited nodes). It prioritizes closer nodes early (high immediate distance weight) while gradually shifting focus to nodes that better connect to the destination (dynamic potential distance weight). The destination node is chosen if no other nodes are left.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the immediate distance prioritization from No.2, using a higher weight for immediate distance (60%) and a dynamic weight (40%) for potential distance, adjusted by the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.4 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.6 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (weighted 0.6) and dynamic potential distance (weighted by 0.5 \u00d7 (1 - remaining_nodes/initial_nodes)), while penalizing revisits with 0.2 \u00d7 (1 - remaining_nodes/initial_nodes) to encourage exploration. It prioritizes closer nodes early but adjusts dynamically to avoid local optima, with penalties fading as the tour progresses. The destination node is only considered if no other unvisited nodes exist.",
          "thought": "The new algorithm combines the static weighted balance from No.1 with the dynamic exploration adjustment from No.2, while adding a penalty for revisiting nodes to avoid cycles. It selects the next node by balancing immediate distance (weighted 0.6) and potential distance (weighted dynamically by 0.5 * (1 - remaining_nodes/initial_nodes)), while penalizing revisits with 0.2 * (1 - remaining_nodes/initial_nodes) to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    initial_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / initial_nodes))\n        revisit_penalty = 0.2 * (1 - (remaining_nodes / initial_nodes))\n        weighted_cost = 0.6 * immediate_distance + dynamic_weight * potential_distance - revisit_penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.15649,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by minimizing the weighted cost of the next node, where the cost is calculated as the product of the distance from the current node and the destination node's distance raised to a static weight factor (0.3). This ensures the algorithm balances short-term efficiency (immediate distance) with long-term efficiency (destination distance), favoring nodes closer to both the current and destination nodes. The destination node is selected early if it offers the best immediate cost, but the weight factor ensures it does not dominate the decision.",
          "thought": "The new algorithm prioritizes immediate proximity with a static weight factor of 0.3, ensuring long-term efficiency is considered but not dominant, and allows the destination node to be selected early if it offers the best immediate cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    weight_factor = 0.3\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = immediate_distance * (potential_distance ** weight_factor)\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.17604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance prioritization (90% weight) with potential distance to the destination (10% weight), ensuring a trade-off between short-term proximity and long-term efficiency. The code iterates through unvisited nodes, computes a weighted cost for each, and selects the node with the minimum cost.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with the balanced weighting approach of No.1, using weights of 0.9 for immediate distance and 0.1 for potential distance to the destination, aiming for a lower objective value by favoring closer nodes while still considering long-term proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 0.9 * immediate_distance + 0.1 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    return next_node",
          "objective": 7.20675,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by `beta`) while balancing it with a geometric mean of immediate and potential distances to the destination, dynamically adjusting the weight (`gamma`) based on the remaining unvisited nodes to ensure efficient exploration. The destination is only selected if no other nodes are available, ensuring it is visited last.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, uses a geometric mean for distance trade-off, and dynamically adjusts weights based on the number of unvisited nodes to balance exploration and exploitation, while still avoiding revisits and ensuring the destination is visited last.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    beta = 0.7\n    gamma = 1.0 / len(unvisited_nodes) if unvisited_nodes else 1.0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if immediate_distance == 0 or potential_distance == 0:\n            geometric_mean = float('inf')\n        else:\n            geometric_mean = (immediate_distance * potential_distance) ** 0.5\n        distance_ratio = immediate_distance / potential_distance if potential_distance > 0 else float('inf')\n        weighted_cost = geometric_mean * (1 - beta) + distance_ratio * beta * gamma\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.25913,
          "other_inf": null
     }
]