[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate (proximity) and potential (future efficiency) distance considerations, adjusting weights based on remaining unvisited nodes and incorporating centrality to prioritize nodes that are both close to the current position and strategically positioned for long-term efficiency. It dynamically shifts focus from immediate distances (weighted higher early on) to potential future distances (weighted higher later), while centrality ensures a balance between proximity and centrality in node selection.",
          "thought": "The new algorithm combines the immediate and potential distance considerations from No.1 with the simple combined score approach of No.2, dynamically adjusting weights based on remaining nodes and incorporating centrality to balance proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight_immediate = 0.7 - (0.3 * (remaining_count / (remaining_count + 1)))\n    weight_potential = 0.3 + (0.3 * (remaining_count / (remaining_count + 1)))\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        combined_score = (weight_immediate * immediate_distance * (1 + centrality)) + (weight_potential * potential_distance * (1 - centrality))\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.56643,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines immediate and potential distance considerations, dynamically adjusting weights based on remaining nodes (prioritizing immediate distance early, potential distance later) and incorporating centrality (node connectivity) to balance exploration. It also penalizes nodes with distances deviating from the average, favoring efficiency. The algorithm selects the next node by minimizing a weighted cost that balances immediate and potential distances, modulated by centrality and penalized for path length deviations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality and potential distance balancing from No.1, using centrality to modulate the weights between immediate and potential distances, while penalizing nodes that deviate from the average path length to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {destination_node}\n    if not remaining_nodes:\n        return destination_node\n\n    remaining_count = len(remaining_nodes)\n    weight_immediate = 0.7 - (0.3 * (remaining_count / (remaining_count + 1)))\n    weight_potential = 0.3 + (0.3 * (remaining_count / (remaining_count + 1)))\n\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in remaining_nodes) / remaining_count\n    avg_distance = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])\n\n    for node in remaining_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        novelty_factor = abs(immediate_distance - avg_distance)\n        penalty = 0.05 * novelty_factor if immediate_distance > avg_distance else -0.05 * novelty_factor\n        weighted_cost = (weight_immediate * immediate_distance * (1 + centrality)) + (weight_potential * potential_distance * (1 - centrality)) + penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based prioritization, where the weight balances immediate distances (favored in high-centrality areas) and potential distances (favored in low-centrality areas). Centrality is calculated as the average inverse distance to unvisited nodes, and the weight is adjusted based on whether centrality exceeds 0.5. The cost function prioritizes immediate distance when centrality is high and potential distance when centrality is low, ensuring adaptability to the problem's structure.",
          "thought": "The new algorithm combines dynamic weight adjustment (as in No.2) with centrality-based prioritization (as in No.1), where centrality modifies the weight to favor immediate distances in high-centrality areas and potential distances in low-centrality areas.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    base_weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    weight = base_weight * (1 + centrality) if centrality > 0.5 else base_weight * (1 - centrality)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = weight * immediate_distance + (1 - weight) * potential_distance\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.57184,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate distance (weighted by centrality) and potential future distance to the destination, with a weight that adjusts based on remaining nodes. It prioritizes well-connected nodes (high centrality) for immediate distance while downweighting them for potential future distance, and dynamically adjusts between proximity and exploration using a weight factor. The exploration factor (inverse of potential distance) ensures the algorithm doesn't get stuck in local optima.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (balancing immediate and potential distances) with the exploration factor from No.2, while incorporating centrality to prioritize well-connected nodes. It dynamically adjusts weights based on remaining nodes and uses centrality to influence node selection, ensuring a balance between proximity and future potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        total_cost = weight * combined_weight + (1 - weight) * exploration_factor\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57398,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate distance to the next node and potential distance to the destination, adjusted dynamically by a weight that decreases as nodes are visited (favoring short-term proximity early). Centrality (inverse of average distance to unvisited nodes) modifies these priorities, increasing immediate distance influence and decreasing potential distance influence in high-centrality areas. The destination node is skipped during intermediate steps, ensuring it's only considered when no other nodes remain.",
          "thought": "The new algorithm combines the immediate and potential distance minimization from No.2 with dynamic weight adjustment and centrality-based balancing from No.1, prioritizing nodes that balance short-term proximity and long-term potential while avoiding the destination node during intermediate steps.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.57613,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm dynamically adjusts node selection by balancing immediate distances (weighted by centrality) and potential distances to the destination, while penalizing deviations from average distances. It prioritizes immediate distances early (high weight) and potential distances later (low weight) through dynamic weight adjustment, with centrality influencing the balance. The cost function combines these factors to guide the next node selection, ensuring a trade-off between proximity and future potential.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes, centrality-aware cost balancing, and deviation penalties to select the next node, prioritizing immediate distances early and potential distances later while penalizing deviations from average distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        cost = weight * combined_weight + (1 - weight) * deviation\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57703,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes centrality-aware cost balancing by dynamically weighting immediate and potential distances, with centrality (inverse of average distance to unvisited nodes) adjusting the balance between local and global path considerations. The exploration factor (inverse of potential distance to destination) is scaled by a dynamic weight (0.3*(1-\u03b3), where \u03b3 is the fraction of nodes remaining), encouraging exploration when fewer nodes are left. The algorithm selects the next node by minimizing a combined cost of weighted distances and exploration, ensuring efficiency and adaptability to varying path requirements.",
          "thought": "The new algorithm combines the centrality-aware cost balancing from No.1 with the exploration factor from No.2, dynamically weighting immediate and potential distances while prioritizing nodes closer to the destination.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3\n    total_nodes = len(distance_matrix)\n    remaining_nodes = len(unvisited_nodes) - 1\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - gamma)\n        cost = combined_weight + dynamic_weight * exploration_factor\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57735,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate distances (centrality-weighted) and potential distances to the destination (proximity-biased), where centrality prioritizes closer nodes and proximity adjusts weights based on node positions. The combined weight (immediate_distance * centrality_weight + potential_distance * potential_weight) ensures a trade-off between local and global optimization, with higher priority given to nodes minimizing this weighted sum. The proximity bias dynamically adjusts based on unvisited nodes' relative positions, refining the selection process iteratively.",
          "thought": "The new algorithm incorporates a dynamic priority mechanism that combines immediate distances with potential distances, weighted by both centrality and a novel \"proximity bias\" factor, which adjusts based on the relative positions of nodes in the path. It iteratively selects the next node by minimizing a weighted sum of these factors, ensuring a balance between local and global path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n    proximity_bias = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / (len(unvisited_nodes) ** 2) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            centrality_weight = (1 + centrality) * (1 - proximity_bias)\n            potential_weight = (1 - centrality) * (1 + proximity_bias)\n            combined_weight = immediate_distance * centrality_weight + potential_distance * potential_weight\n\n        if combined_weight < min_cost:\n            min_cost = combined_weight\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.57755,
          "other_inf": null
     }
]