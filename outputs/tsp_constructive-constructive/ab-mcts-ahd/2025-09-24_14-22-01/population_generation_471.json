[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality-based balancing and deviation penalties to select the next node in TSP. It prioritizes nodes with lower immediate and potential distances (weighted by centrality) while penalizing high deviation from average distances and long potential paths. The weight dynamically adjusts based on remaining nodes, balancing short-term and long-term path considerations.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the centrality-based balancing and deviation term from No.1, creating a hybrid approach that adapts weights based on remaining nodes while incorporating node centrality and deviation penalties for better path selection.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    weight = 0.3 + (0.7 * (remaining_nodes / (remaining_nodes + 1)))\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_immediate = immediate_distance * (1 + centrality)\n        weighted_potential = potential_distance * (1 - centrality)\n        combined_weight = (weighted_immediate + weighted_potential) / 2\n        deviation = abs(immediate_distance - avg_distance)\n        penalty = 0.2 * (potential_distance / max(distance_matrix[node])) if max(distance_matrix[node]) > 0 else 0\n        weighted_cost = weight * combined_weight + (1 - weight) * deviation - penalty\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.54792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-aware cost balancing (prioritizing nodes with high centrality) with dynamic weighting of potential distances (adjusting based on remaining nodes) using a sigmoid-adjusted deviation term to balance immediate and potential distances. It prioritizes nodes with lower immediate distances, higher centrality, and minimal deviation from the average distance, while dynamically weighting potential distances based on the fraction of remaining nodes. The sigmoid function smooths the influence of deviation, making the algorithm adaptable to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of potential distance from No.2 with the centrality-aware cost balancing from No.1, using a sigmoid-adjusted deviation term to adapt the balance between immediate and potential distances based on the remaining nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    total_nodes = len(distance_matrix)\n    gamma = remaining_nodes / total_nodes\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / total_nodes))\n        deviation = abs(immediate_distance - (sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + dynamic_weight * potential_distance + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.55261,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and potential distances by weighting them against node centrality, using a sigmoid function to smoothly transition between exploration (favoring distant nodes) and exploitation (prioritizing central nodes), while incorporating a deviation term to adapt to historical path preferences. Immediate distances are weighted more heavily when centrality is high, while potential distances dominate when centrality is low. The sigmoid function adjusts the influence of deviation based on the proportion of remaining unvisited nodes, ensuring adaptability throughout the search.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the influence of immediate and potential distances based on node centrality and remaining unvisited nodes, using a sigmoid function to smooth transitions between exploration and exploitation phases, while incorporating a reinforcement learning-inspired deviation term that adapts to historical path preferences.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    gamma = len(unvisited_nodes) / len(distance_matrix)\n    centrality = sum(1 / (distance_matrix[current_node][node] + 1e-6) for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n\n        if immediate_distance == 0 or potential_distance == 0:\n            combined_weight = float('inf')\n        else:\n            weighted_immediate = immediate_distance * (1 + centrality)\n            weighted_potential = potential_distance * (1 - centrality)\n            combined_weight = (weighted_immediate + weighted_potential) / 2\n\n        deviation = abs(immediate_distance - avg_distance)\n        sigmoid_gamma = 1 / (1 + math.exp(-gamma))\n        cost = combined_weight + deviation * sigmoid_gamma\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.5798,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity by selecting the next node based on a weighted cost that combines the immediate distance from the current node and a weighted potential distance to the destination, with the weight factor decreasing as the number of remaining nodes increases. This ensures that shorter-term gains are favored early in the search, balancing immediate proximity with potential long-term efficiency. The `weight_factor` dynamically adjusts the trade-off between immediate and future distances, with higher weights given to immediate distances when fewer nodes remain.",
          "thought": "The new algorithm prioritizes immediate proximity over long-term efficiency by using a weight factor that decreases as the number of remaining nodes increases, ensuring shorter-term gains are favored early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor))\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.68026,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and a penalty for excessively long edges, using dynamic weights that prioritize nodes with lower combined costs while adjusting for remaining nodes and distance ratios. Nodes with immediate distances exceeding a threshold (`max_distance_threshold`) are penalized more heavily, ensuring shorter, more efficient paths. The `weight_factor` and `decay_factor` dynamically adjust the influence of potential distance and distance ratio, respectively, to optimize both local and global path quality.",
          "thought": "The new algorithm combines dynamic weight adjustment with immediate distance, potential distance, and penalty mechanisms to balance local and global optimization, prioritizing nodes with lower weighted costs while penalizing disproportionately distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    decay_factor = 0.4\n    max_distance_threshold = 1.5\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor)) + decay_factor * distance_ratio * potential_distance\n        if immediate_distance > max_distance_threshold:\n            weighted_cost *= (1 + (immediate_distance - max_distance_threshold) * 0.2)\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.79197,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with distance ratio and penalty mechanisms to balance immediate proximity, potential distance to the destination, and adaptability to node distributions. It prioritizes nodes with lower immediate distance and better potential connectivity to the destination, while penalizing nodes that are disproportionately distant from others, ensuring a trade-off between local and global optimization. The weighted cost function adjusts dynamically based on remaining nodes and node centrality, with distance ratio and penalty terms modulating the selection.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the distance ratio and penalty mechanism from No.2, creating a hybrid approach that balances immediate proximity, potential distance to the destination, and adaptability to node distributions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weight_factor = (remaining_nodes + 1) / (remaining_nodes + 2)\n        weighted_cost = immediate_distance * (1 / (potential_distance ** weight_factor)) + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.83746,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, potential distance to the destination, and an exploration factor (closer nodes to the destination are prioritized). The cost function weights immediate distance (70%) and potential distance (30%), with the exploration factor (1/(1+potential_distance)) further boosting nearby nodes. If no unvisited nodes remain, it defaults to the destination.",
          "thought": "The new algorithm modifies the cost function by incorporating a weighted combination of immediate distance, potential distance, and an exploration factor that encourages visiting nodes closer to the destination first, while still ensuring the destination is chosen only when no other unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    exploration_weight = 0.3  # Weight for exploration factor\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)  # Encourages closer nodes to destination\n        total_cost = (1 - exploration_weight) * immediate_distance + exploration_weight * potential_distance + exploration_factor\n        if total_cost < min_cost:\n            min_cost = total_cost\n            next_node = node\n\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.86917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, potential distance to the destination, and exploration incentives to select the next node, prioritizing closer nodes while balancing exploration and destination proximity. It uses a dynamic penalty factor based on potential distance and average node distances to adjust selection, with the destination given special consideration when unvisited nodes are few. The weighted cost function balances immediate and potential distances, with the destination node prioritized when it remains unvisited.",
          "thought": "The new algorithm combines the dynamic exploration weight from No.2 with the balanced cost function from No.1, using immediate distance adjusted by a penalty factor that considers potential distance to the destination and exploration incentives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_unvisited = len(unvisited_nodes)\n    destination_weight = 0.5 / total_unvisited if total_unvisited > 1 else 1.0\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        if node == destination_node:\n            weighted_cost = immediate_distance * (1 - destination_weight) + exploration_factor\n        else:\n            weighted_cost = immediate_distance * (1 + destination_weight) + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.94165,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate proximity (via `immediate_distance`) and potential distance to the destination (via `potential_distance`), while penalizing nodes distant from the destination (`penalty`). It uses a weighted cost (`weighted_cost`) combining these factors, with exploration driven by `exploration_factor` and dynamic adjustment via `distance_ratio` and `penalty`. The destination is selected only if no other nodes remain.",
          "thought": "The new algorithm combines the exploration factor from No.1 with the dynamic weight adjustment and penalty mechanism from No.2, prioritizing nodes that balance immediate proximity and potential distance to the destination while penalizing nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        exploration_factor = 1 / (1 + potential_distance)\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.94507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with exploration and distance balancing, prioritizing nodes that are close to the current node while considering their potential distance to the destination. It calculates a weighted cost for each unvisited node, combining immediate distance, a distance ratio (relative to average distance), and an exploration factor (inverse of potential distance to destination), then selects the node with the lowest weighted cost. The immediate distance is given the highest priority, followed by the distance ratio and exploration factor. If no unvisited nodes remain, it defaults to the destination node.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with the exploration factor and distance ratio from No.1, prioritizing nodes that are close to the current node while considering potential distance to the destination and balancing immediate and potential distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        exploration_factor = 1 / (1 + potential_distance)\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance + exploration_factor\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 6.97517,
          "other_inf": null
     }
]