[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node to the current node, ignoring the destination's proximity, as it only considers the immediate step's distance. The function iterates through unvisited nodes, updating the next node based on the smallest distance from the current node, without considering the destination's role in the path selection. The `distance_matrix` provides distances, while `unvisited_nodes` and `current_node` guide the selection.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to ensure efficient path completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node with a dynamically weighted estimate of the potential distance to the destination, where the weight of the potential distance increases as the number of remaining unvisited nodes decreases. This ensures a trade-off between short-term efficiency and long-term goal alignment, prioritizing immediate distances early on but gradually favoring paths that better lead toward the destination as the tour progresses. The dynamic weight (`dynamic_weight`) adjusts based on the ratio of remaining nodes, making the potential distance more influential as fewer nodes remain unvisited.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 with a dynamic weight adjustment inspired by No.1, balancing short-term and long-term considerations by weighting the potential distance to the destination as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) with potential distance to the destination (30% weight), dynamically adjusting the potential weight based on remaining unvisited nodes. This prioritizes short-term efficiency while considering long-term relevance, favoring closer nodes early but increasingly valuing paths that lead directly to the destination as fewer nodes remain. The dynamic weight ensures the algorithm adapts to the problem's phase, shifting focus from exploration to completion.",
          "thought": "The new algorithm balances immediate distance (weighted 0.7) with potential distance to the destination (weighted 0.3), dynamically adjusting the potential weight based on the remaining unvisited nodes to favor short-term efficiency while considering long-term relevance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.3 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = 0.7 * immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and potential distance to the destination, weighted dynamically by the remaining unvisited nodes. It prioritizes immediate distance (given higher weight) while adjusting for proximity to the destination (lower weight) as the number of unvisited nodes decreases. The dynamic weight ensures exploration of closer nodes early while still considering long-term relevance to the destination.",
          "thought": "The new algorithm modifies the weighted cost calculation by incorporating a dynamic factor that adjusts the weight of the potential distance based on the remaining unvisited nodes, promoting exploration of closer nodes while still considering their relevance to the destination. The algorithm iterates through unvisited nodes, skips the destination unless no other options exist, and selects the node with the minimum adjusted weighted cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) - 1\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / len(unvisited_nodes)))\n        weighted_cost = immediate_distance + dynamic_weight * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weighted by `beta`) while balancing it with a geometric mean of immediate and potential distances to the destination, dynamically adjusting the weight (`gamma`) based on the remaining unvisited nodes to ensure efficient exploration. The destination is only selected if no other nodes are available, ensuring it is visited last.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, uses a geometric mean for distance trade-off, and dynamically adjusts weights based on the number of unvisited nodes to balance exploration and exploitation, while still avoiding revisits and ensuring the destination is visited last.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    beta = 0.7\n    gamma = 1.0 / len(unvisited_nodes) if unvisited_nodes else 1.0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        if immediate_distance == 0 or potential_distance == 0:\n            geometric_mean = float('inf')\n        else:\n            geometric_mean = (immediate_distance * potential_distance) ** 0.5\n        distance_ratio = immediate_distance / potential_distance if potential_distance > 0 else float('inf')\n        weighted_cost = geometric_mean * (1 - beta) + distance_ratio * beta * gamma\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.25913,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm prioritizes choosing the next node by balancing immediate distance to the current node and potential distance to the destination, while dynamically adjusting weights based on the ratio of immediate distance to the average distance. It introduces a non-linear penalty for nodes distant from the destination, ensuring adaptability to spatial distributions by emphasizing proximity and long-term goals. The algorithm iteratively evaluates each unvisited node, computes a weighted cost incorporating these factors, and selects the node with the minimal cost.",
          "thought": "The new algorithm introduces dynamic weighting for potential distance based on the ratio of immediate distance to average distance, ensuring adaptability to varying spatial distributions, while maintaining a balance between proximity and long-term goals by incorporating a non-linear penalty for nodes distant from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        distance_ratio = immediate_distance / avg_distance if avg_distance > 0 else 1.0\n        weighted_cost = immediate_distance + (0.5 * distance_ratio) * potential_distance\n        penalty = 1.0 + 0.2 * (potential_distance / (sum(distance_matrix[node]) / len(distance_matrix[node]))) if len(distance_matrix[node]) > 0 else 1.0\n        weighted_cost *= penalty\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.27883,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node (60% priority) and estimated distance to the destination (40% priority), dynamically adjusting weights based on remaining unvisited nodes. A small penalty term discourages revisiting nodes, with weights scaling inversely with the number of unvisited nodes. The selection prioritizes shorter paths while considering long-term goals, with exploration favoring immediate gains early and shifting toward estimated distances later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of immediate distance, estimated distance, and a penalty term for revisiting nodes, dynamically adjusting weights based on the remaining unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        estimated_distance = distance_matrix[node][destination_node]\n        penalty = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 0.0\n        weight_immediate = 0.6 + 0.2 * (remaining_nodes / len(unvisited_nodes))\n        weight_estimated = 0.4 - 0.2 * (remaining_nodes / len(unvisited_nodes))\n        score = (weight_immediate * immediate_distance) + (weight_estimated * estimated_distance) + (penalty * immediate_distance)\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.29683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (weighted 0.8) with the potential distance to the destination (weighted 0.2), ensuring closer nodes are favored while slightly considering long-term proximity. The code iterates through unvisited nodes, skips the destination if it's still unvisited, and returns the destination only if no other nodes remain. The weights reflect a bias toward short-term efficiency with minimal long-term planning.",
          "thought": "The new algorithm prioritizes immediate distance to the current node while slightly considering the potential distance to the destination, using a weighted cost of 0.8 for immediate distance and 0.2 for potential distance, ensuring closer nodes are favored with minimal long-term consideration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 0.8 * immediate_distance + 0.2 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a heuristic estimate of the remaining path cost to the destination, prioritizing closer nodes while considering global path efficiency. The score combines immediate distance (higher priority) and heuristic cost (lower priority, weighted by 0.3) to guide the selection. The function iterates through unvisited nodes, computes the score, and returns the node with the minimal score.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances the immediate distance to the next node with a heuristic estimate of the remaining path's cost to the destination, encouraging a more globally informed choice while retaining the greedy nature of the original approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        heuristic_cost = distance_matrix[node][destination_node]\n        score = immediate_distance + 0.3 * heuristic_cost\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node while also considering their distance to the destination, with a 3:2 weight ratio (immediate distance:potential distance). It skips the destination until no other nodes remain, ensuring the path is optimized for immediate progress while keeping the destination in mind. The weighted cost balances short-term gains with long-term strategy, making it a hybrid of greedy and foresighted approaches.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node and far from the destination, using a weighted cost where immediate distance has weight 1.5 and potential distance has weight 0.5, ensuring the destination is only chosen when no other nodes are available.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_cost = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == destination_node:\n            continue\n        immediate_distance = distance_matrix[current_node][node]\n        potential_distance = distance_matrix[node][destination_node]\n        weighted_cost = 1.5 * immediate_distance + 0.5 * potential_distance\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            next_node = node\n    if next_node is None:\n        next_node = destination_node\n    return next_node",
          "objective": 7.39182,
          "other_inf": null
     }
]