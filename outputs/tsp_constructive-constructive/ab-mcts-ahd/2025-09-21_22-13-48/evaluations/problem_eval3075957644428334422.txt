def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_score = float('inf')
    next_node = None
    alpha = 0.6  # Weight for current distance
    beta = 0.3   # Weight for destination distance
    gamma = 0.1   # Weight for path continuity penalty
    threshold = 1.5  # Dynamic threshold multiplier

    min_current_dist = min(distance_matrix[current_node][n] for n in unvisited_nodes)

    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Penalize nodes that are too far from the current path
        path_penalty = 0
        if unvisited_nodes:
            avg_dist = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)
            path_penalty = max(0, current_dist - avg_dist)

        score = alpha * current_dist + beta * dest_dist + gamma * path_penalty

        # Apply dynamic threshold filtering
        if current_dist > threshold * min_current_dist:
            continue

        if score < min_score:
            min_score = score
            next_node = node
        elif score == min_score:
            # Tie-breaker: prefer node closer to destination
            if dest_dist < distance_matrix[next_node][destination_node]:
                next_node = node

    return next_node
