def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    alpha = 0.7  # Base weight for current distance
    beta = 0.3   # Base weight for destination distance
    threshold = 1.5  # Dynamic threshold multiplier
    remaining_nodes = len(unvisited_nodes)

    # Adjust weights dynamically based on remaining nodes
    alpha_adj = alpha + (remaining_nodes / (remaining_nodes + 1)) * 0.1
    beta_adj = beta - (remaining_nodes / (remaining_nodes + 1)) * 0.1

    # Calculate minimum current distance for threshold
    min_current_dist = min(distance_matrix[current_node][n] for n in unvisited_nodes)

    # Prepare candidate nodes with scores
    candidates = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Skip if exceeds threshold
        if current_dist > threshold * min_current_dist:
            continue

        score = alpha_adj * current_dist + beta_adj * dest_dist
        candidates.append((node, score))

    # Select node probabilistically based on inverse score (better scores have higher probability)
    if candidates:
        nodes, scores = zip(*candidates)
        inv_scores = [1 / (s + 1e-6) for s in scores]  # Avoid division by zero
        total = sum(inv_scores)
        probs = [s / total for s in inv_scores]
        next_node = random.choices(nodes, weights=probs, k=1)[0]

    return next_node
