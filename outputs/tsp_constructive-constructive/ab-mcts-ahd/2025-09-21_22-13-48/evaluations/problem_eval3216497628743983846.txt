def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    alpha = 0.7  # Weight for proximity to current node (0.7) vs. destination (0.3)
    min_score = float('inf')
    next_node = None

    for node in unvisited_nodes:
        current_proximity = distance_matrix[current_node][node]
        dest_proximity = distance_matrix[node][destination_node]
        score = alpha * current_proximity + (1 - alpha) * dest_proximity

        # Penalize revisiting nodes to avoid cycles
        if node == destination_node and len(unvisited_nodes) > 1:
            score *= 1.5  # Slightly discourage early return if more nodes remain

        if score < min_score:
            min_score = score
            next_node = node

    return next_node
