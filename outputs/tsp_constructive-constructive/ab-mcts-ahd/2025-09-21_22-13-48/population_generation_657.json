[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted average of future savings (average distances from the candidate node to remaining unvisited nodes). The weight adjusts dynamically based on proximity to the destination (higher weight when close to destination). The code prioritizes immediate distance over future savings, with a focus on minimizing the immediate cost while considering future savings in a weighted manner. The structure iterates over unvisited nodes, computes a score combining immediate distance and weighted future savings, and selects the node with the lowest score.",
          "thought": "The new algorithm combines immediate distance with a dynamic weight for future savings, similar to No.1, but uses a weighted average of future distances to unvisited nodes, inspired by No.2. It balances short-term and long-term costs by adjusting the weight of future savings based on proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if unvisited_nodes:\n            avg_future_savings = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        else:\n            avg_future_savings = 0\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.7 if dist_to_dest < 1.0 else 0.3\n        score = immediate_distance - weight * avg_future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40357,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weight 1.5) over future savings (weight 0.8) to balance short-term gains and long-term efficiency, favoring closer nodes while still considering the potential savings of returning to the destination. It evaluates each unvisited node by computing a weighted score combining immediate travel distance and the difference between the direct return cost and the cost via the current node. The node with the lowest score is selected, ensuring a trade-off between proximity and strategic path optimization.",
          "thought": "The new algorithm prioritizes immediate distance (weight 1.5) over future savings (weight 0.8) to balance exploration and exploitation more aggressively, favoring immediate gains while still considering long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = 1.5 * immediate_distance - 0.8 * future_savings  # Adjusted weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47453,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines a greedy approach (prioritizing the closest unvisited node) with dynamic weighting of future savings (prioritizing nodes that reduce future travel distance when closer to the destination). The algorithm balances immediate distance (`distance`) and future savings (`future_savings`), with higher weight (`0.6` or `0.4`) given to savings when the current node is closer to the destination. The score calculation (`distance - weight * future_savings`) determines the next node, favoring nodes that minimize both immediate distance and long-term travel cost.",
          "thought": "The new algorithm combines the greedy approach of No.2 (selecting the closest unvisited node) with the dynamic weighting of future savings from No.1 (adjusting the weight based on distance to the destination). It prioritizes nodes that are both close to the current node and offer good future savings, with higher weight given to savings when closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.6 if dist_to_dest < 1.0 else 0.4  # Higher weight when closer to destination\n        score = distance - weight * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.4767,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future savings by adjusting weights based on remaining nodes, prioritizing closer nodes early (high `weight_immediate`) and optimizing long-term savings later (high `weight_future`). The score combines immediate distance (minimized) and future savings (maximized), with weights inversely proportional to remaining nodes. The loop evaluates all unvisited nodes to select the next best path segment.",
          "thought": "The new algorithm introduces an adaptive weighting mechanism that dynamically adjusts the balance between immediate distance and future savings based on the number of remaining nodes, ensuring a more flexible trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_immediate = 1.0 - (0.5 / (1.0 + remaining_nodes))  # Dynamic weight adjustment\n    weight_future = 0.5 + (0.5 / (1.0 + remaining_nodes))\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = weight_immediate * immediate_distance - weight_future * future_savings  # Adaptive weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance prioritization (weight 1.0) with a slightly higher weight (0.55) on future savings, favoring closer nodes while slightly preferring those that reduce future travel costs. It iterates through unvisited nodes, calculates a score combining immediate distance and the difference between the distance from the candidate node to the destination and the current distance to the destination, and selects the node with the lowest score. The structure ensures short-term efficiency while considering long-term savings.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 (weight 1.0) with a slightly higher future savings weight (0.55) to balance short-term efficiency and long-term savings more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.55 * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future savings, prioritizing immediate distance (weight 1.0) over future savings (weight 0.6). It calculates a score for each unvisited node as `immediate_distance - 0.6 * future_savings`, choosing the node with the lowest score. The `future_savings` term (distance saved by visiting a node before returning to the destination) is weighted lower, ensuring a trade-off between short-term efficiency and potential long-term savings.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.2 with the future savings consideration from No.1, using a balanced weight of 0.6 for future savings to achieve a better trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.6 * future_savings  # Balanced weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the weight of future savings in selecting the next node, prioritizing immediate distance when many nodes remain unvisited and balancing both immediate and future savings as the tour progresses. The dynamic weight (`dynamic_weight`) increases as the number of unvisited nodes decreases, ensuring a smoother transition toward the destination. The score combines immediate distance and future savings, with the latter weighted more heavily as the tour nears completion.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for future savings increases as the number of unvisited nodes decreases, ensuring a smoother transition towards the destination as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 0.5 * (1.0 + 1.0 / (1.0 + remaining_nodes))  # Weight increases as remaining nodes decrease\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - dynamic_weight * future_savings  # Dynamic weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49542,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance and future savings (weighted by 0.5) to prioritize short-term efficiency while balancing long-term progress toward the destination. It also incorporates a ratio-based adjustment to favor nodes that offer better immediate-to-future distance ratios, ensuring a trade-off between proximity and progress toward the goal. The `combined_score` balances these factors, with lower scores indicating better candidates for the next node.",
          "thought": "The new algorithm combines the weighted score from No.1 (balancing immediate distance and future savings) with the ratio-based selection from No.2, prioritizing nodes that offer both short-term efficiency and long-term progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.5 * future_savings  # Weighted combination\n        ratio = immediate_distance / (distance_matrix[node][destination_node] + 1e-10)  # Avoid division by zero\n\n        combined_score = score * ratio  # Balance weighted score and ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.50182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and long-term efficiency by prioritizing nodes that minimize current distance while considering future savings, with higher weight given to savings when closer to the destination. It dynamically adjusts the weight of future savings based on the current distance to the destination (0.5 when close, 0.3 otherwise) to ensure a balance between greedy and future-oriented decisions. The score function combines current distance and weighted future savings to select the next node, favoring nodes that offer both short-term proximity and long-term path efficiency.",
          "thought": "The new algorithm integrates the local optimality of the first approach with the future savings consideration of the second approach, by dynamically adjusting the weight of future savings based on the current distance to the destination, ensuring a balance between immediate and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.5 if dist_to_dest < 1.0 else 0.3  # Higher weight when closer to destination\n        score = distance - weight * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50521,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future savings, prioritizing closer nodes when few remain and adjusting weights based on unvisited nodes, while penalizing nodes too close to avoid revisiting areas. It uses a dynamic weight (`dynamic_weight`) to favor immediate distance when only 2 nodes remain, otherwise balancing future savings, and applies a penalty (`penalty`) to discourage selecting nodes that are too close to the current node. The scoring mechanism (`score`) combines these factors to select the next node, ensuring efficiency and avoiding local optima.",
          "thought": "The new algorithm modifies the scoring mechanism to incorporate a dynamic weight that adjusts based on the remaining unvisited nodes, favoring immediate distance when few nodes remain and balancing future savings when more nodes are left, while also penalizing nodes that are too close to the current node to avoid revisiting areas.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1.0 if remaining_nodes <= 2 else 0.5  # Adjust weight based on remaining nodes\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        penalty = 0.2 * immediate_distance if immediate_distance < 0.1 * distance_matrix[current_node][destination_node] else 0  # Penalize nodes too close\n        score = immediate_distance - dynamic_weight * future_savings + penalty  # Updated scoring\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50534,
          "other_inf": null
     }
]