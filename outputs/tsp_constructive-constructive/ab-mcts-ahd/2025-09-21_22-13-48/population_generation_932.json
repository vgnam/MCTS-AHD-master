[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted average of future savings (average distances from the candidate node to remaining unvisited nodes). The weight adjusts dynamically based on proximity to the destination (higher weight when close to destination). The code prioritizes immediate distance over future savings, with a focus on minimizing the immediate cost while considering future savings in a weighted manner. The structure iterates over unvisited nodes, computes a score combining immediate distance and weighted future savings, and selects the node with the lowest score.",
          "thought": "The new algorithm combines immediate distance with a dynamic weight for future savings, similar to No.1, but uses a weighted average of future distances to unvisited nodes, inspired by No.2. It balances short-term and long-term costs by adjusting the weight of future savings based on proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if unvisited_nodes:\n            avg_future_savings = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        else:\n            avg_future_savings = 0\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.7 if dist_to_dest < 1.0 else 0.3\n        score = immediate_distance - weight * avg_future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40357,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance prioritization (short-term efficiency) with dynamic future savings weighting (long-term efficiency) by assigning a higher weight (0.8) when the current node is close to the destination, ensuring better long-term path optimization. The score for each unvisited node is computed as `immediate_distance - weight * avg_future_savings`, where the weight dynamically adjusts based on proximity to the destination, favoring shorter-term gains when far from the destination and longer-term savings when closer. The algorithm prioritizes nodes that minimize this score, ensuring a trade-off between immediate and future efficiency.",
          "thought": "The new algorithm combines immediate distance prioritization (like No.2) with dynamic future savings weighting (like No.1), using a higher weight when close to the destination to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        avg_future_savings = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.8 if dist_to_dest < 1.0 else 0.4\n        score = immediate_distance - weight * avg_future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.42332,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance and future savings to select the next node, with a dynamic weight (0.3\u20130.7) for future savings that increases as the current node approaches the destination. It prioritizes immediate distance (weight 1.0) while adaptively balancing future savings based on proximity to the destination. The score is computed as `immediate_distance - weight * future_savings`, favoring nodes that minimize this weighted combination.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future savings from No.2 with the dynamic weighting of future savings based on proximity to the destination from No.1. It prioritizes immediate distance (weight 1.0) while dynamically adjusting the weight of future savings (ranging from 0.3 to 0.7) based on the distance to the destination, favoring higher weights when closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    dist_to_dest = distance_matrix[current_node][destination_node]\n    weight = 0.3 + 0.4 * (1.0 - min(dist_to_dest, 1.0))  # Dynamic weight (0.3 to 0.7)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - weight * future_savings  # Weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.46024,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (weight 1.5) over future savings (weight 0.8) to balance short-term gains and long-term efficiency, favoring closer nodes while still considering the potential savings of returning to the destination. It evaluates each unvisited node by computing a weighted score combining immediate travel distance and the difference between the direct return cost and the cost via the current node. The node with the lowest score is selected, ensuring a trade-off between proximity and strategic path optimization.",
          "thought": "The new algorithm prioritizes immediate distance (weight 1.5) over future savings (weight 0.8) to balance exploration and exploitation more aggressively, favoring immediate gains while still considering long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = 1.5 * immediate_distance - 0.8 * future_savings  # Adjusted weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47453,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines a greedy approach (prioritizing the closest unvisited node) with dynamic weighting of future savings (prioritizing nodes that reduce future travel distance when closer to the destination). The algorithm balances immediate distance (`distance`) and future savings (`future_savings`), with higher weight (`0.6` or `0.4`) given to savings when the current node is closer to the destination. The score calculation (`distance - weight * future_savings`) determines the next node, favoring nodes that minimize both immediate distance and long-term travel cost.",
          "thought": "The new algorithm combines the greedy approach of No.2 (selecting the closest unvisited node) with the dynamic weighting of future savings from No.1 (adjusting the weight based on distance to the destination). It prioritizes nodes that are both close to the current node and offer good future savings, with higher weight given to savings when closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        dist_to_dest = distance_matrix[current_node][destination_node]\n        weight = 0.6 if dist_to_dest < 1.0 else 0.4  # Higher weight when closer to destination\n        score = distance - weight * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.4767,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future savings by adjusting weights based on remaining nodes, prioritizing closer nodes early (high `weight_immediate`) and optimizing long-term savings later (high `weight_future`). The score combines immediate distance (minimized) and future savings (maximized), with weights inversely proportional to remaining nodes. The loop evaluates all unvisited nodes to select the next best path segment.",
          "thought": "The new algorithm introduces an adaptive weighting mechanism that dynamically adjusts the balance between immediate distance and future savings based on the number of remaining nodes, ensuring a more flexible trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_immediate = 1.0 - (0.5 / (1.0 + remaining_nodes))  # Dynamic weight adjustment\n    weight_future = 0.5 + (0.5 / (1.0 + remaining_nodes))\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = weight_immediate * immediate_distance - weight_future * future_savings  # Adaptive weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.47841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate and future costs, where future savings are weighted dynamically based on remaining unvisited nodes. Immediate distance is prioritized early (higher weight), while future savings gain importance as the search progresses (lower weight). The dynamic weight adjustment ensures a smooth transition from short-term efficiency to long-term optimization.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for future savings increases as the number of unvisited nodes decreases, ensuring a balanced transition from immediate to long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_future = 0.5 + (1.0 / (1.0 + remaining_nodes))  # Dynamic weight adjustment\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - weight_future * future_savings  # Dynamic weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance prioritization (weight 1.0) with a slightly higher weight (0.55) on future savings, favoring closer nodes while slightly preferring those that reduce future travel costs. It iterates through unvisited nodes, calculates a score combining immediate distance and the difference between the distance from the candidate node to the destination and the current distance to the destination, and selects the node with the lowest score. The structure ensures short-term efficiency while considering long-term savings.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.2 (weight 1.0) with a slightly higher future savings weight (0.55) to balance short-term efficiency and long-term savings more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.55 * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future savings, prioritizing immediate distance (weight 1.0) over future savings (weight 0.6). It calculates a score for each unvisited node as `immediate_distance - 0.6 * future_savings`, choosing the node with the lowest score. The `future_savings` term (distance saved by visiting a node before returning to the destination) is weighted lower, ensuring a trade-off between short-term efficiency and potential long-term savings.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.2 with the future savings consideration from No.1, using a balanced weight of 0.6 for future savings to achieve a better trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.6 * future_savings  # Balanced weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future savings, prioritizing immediate distance (weight 1.0) while slightly favoring future savings (weight 0.525). It iterates through unvisited nodes, computes a score combining these factors, and chooses the node with the lowest score, ensuring efficiency and a refined trade-off between short-term and long-term path optimization.",
          "thought": "The new algorithm combines the balanced approach of No.2 (weighting immediate distance and future savings) with the refined scoring mechanism of No.1 (using a slightly higher weight on future savings). It iterates through unvisited nodes, computes a score that prioritizes immediate distance (weight 1.0) while slightly favoring future savings (weight 0.525), and selects the node with the lowest score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.525 * future_savings\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49237,
          "other_inf": null
     }
]