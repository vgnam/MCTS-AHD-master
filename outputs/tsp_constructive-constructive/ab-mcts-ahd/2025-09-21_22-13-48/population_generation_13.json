[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the node and potential future savings (reduced distance to the destination), prioritizing immediate distance (weight 1.0) over future savings (weight 0.5). It iterates through unvisited nodes, computes a weighted score, and chooses the node with the lowest score, ensuring a trade-off between short-term and long-term efficiency.",
          "thought": "This algorithm selects the next node by considering the trade-off between the immediate distance to the next node and the potential savings in future travel distances, using a weighted combination of both factors to balance local optimality and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.5 * future_savings  # Weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts its focus between immediate distance and future savings, prioritizing immediate distance when few nodes remain (higher weight) and balancing both when more nodes are left (dynamic weight factor). It scores each candidate node based on a weighted combination of immediate distance and future savings, refining the selection with a heuristic that favors closer nodes early while considering potential long-term savings. The weight factor scales inversely with remaining nodes, ensuring a smooth transition between short-term and long-term efficiency.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes with a refined scoring mechanism that prioritizes immediate distance when few nodes remain and balances future savings with a higher weight on immediate distance when more nodes are left, ensuring a smoother transition between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight adjustment\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance * (1.0 + weight_factor) - 0.7 * future_savings * (1.0 - weight_factor)  # Refined weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53898,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the weight between immediate distance and future savings, prioritizing closer nodes when few unvisited nodes remain (higher weight on `immediate_distance`) and balancing future savings when more nodes are left (lower weight on `future_savings`). The `weight_factor` scales inversely with remaining nodes, and the `score` combines these factors in a weighted sum, favoring shorter-term gains when progress is slow. The `select_next_node` function iterates through unvisited nodes to find the one minimizing this score, ensuring a balance between proximity and long-term efficiency.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that prioritizes immediate distance with a higher weight when the remaining nodes are few, while balancing future savings more when many nodes are left, using a novel weighted score combining distance and savings with a variable coefficient.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight adjustment\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance * (1.0 + weight_factor) - 0.5 * future_savings * (1.0 - weight_factor)  # Dynamic weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58843,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (weight 1.0) with future savings (weight 0.8) to prioritize short-term efficiency while still considering long-term savings, selecting the next node by minimizing a weighted score combining immediate distance and the difference between future savings and current distance.",
          "thought": "The new algorithm prioritizes immediate distance (weight 1.0) over future savings (weight 0.8) to balance short-term efficiency with long-term savings, ensuring a more aggressive focus on immediate gains while still considering future savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance - 0.8 * future_savings  # Adjusted weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65741,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance over future savings, dynamically adjusting weights based on remaining nodes. When few nodes remain, it heavily favors closer nodes (high weight on `immediate_distance`), while balancing savings when more nodes are left (lower weight on `future_savings`). The score formula aggressively weights immediate gains, with `immediate_distance` multiplied by a factor `(1.0 + 2.0 * weight_factor)` and `future_savings` subtracted with a smaller factor `(0.3 * (1.0 - 2.0 * weight_factor))`. This ensures closer nodes are selected when progress is slow, while still considering future savings to some extent.",
          "thought": "The new algorithm prioritizes immediate distance over future savings by dynamically adjusting weights based on remaining nodes, favoring closer nodes when few remain and balancing savings when more nodes are left, but with a different scoring formula that emphasizes immediate gains more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight adjustment\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = immediate_distance * (1.0 + 2.0 * weight_factor) - 0.3 * future_savings * (1.0 - 2.0 * weight_factor)  # Aggressively weighted towards immediate distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.7977,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically prioritizes nodes by balancing immediate distance (weighted higher), centrality (average distance to unvisited nodes, given moderate weight), and future savings (subtracted with lower weight), where the weights adjust based on remaining unvisited nodes to favor exploration early and exploitation later. The scoring mechanism ensures the next node minimizes immediate cost while considering long-term tour efficiency.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, future savings, and a node's centrality (measured by average distance to all unvisited nodes), with the weight factor now also considering the node's potential to reduce the tour's total length by balancing exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes ** 0.5)  # Adjusted dynamic weight\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes  # Average distance to unvisited nodes\n\n        score = (immediate_distance * (1.0 + weight_factor) +\n                 centrality * (0.5 * weight_factor) -\n                 0.3 * future_savings * (1.0 - weight_factor))  # Balanced score\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the unvisited node closest to the current node, breaking ties by choosing the node that is closer to the destination. It uses the distance matrix to compare distances, ensuring the path is locally optimal at each step. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination node if multiple nodes have the same minimal distance to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n        elif distance == min_distance:\n            # If multiple nodes have the same minimal distance, choose the one closer to the destination\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the current node while also considering the average distance to unvisited nodes (weighted by 0.2), balancing short-term and long-term travel costs. The immediate distance is given higher priority (directly added to the score), while the average distance acts as a secondary, exploratory factor. The code iterates through unvisited nodes, computes the score, and selects the node with the lowest combined score. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes selecting the next node by considering the immediate distance to the current node and the average distance from the node to all other unvisited nodes, with the latter weighted by 0.2 to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if unvisited_nodes:\n            avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        else:\n            avg_distance = 0\n        score = immediate_distance + 0.2 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.39065,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and average future distance, prioritizing proximity when few nodes remain (via weight adjustment) and considering both factors when more nodes are left. It uses a weighted combination where immediate distance is emphasized more when unvisited nodes are scarce, while average future distance gains importance as more nodes remain. The score calculation dynamically adjusts weights based on the number of remaining nodes, ensuring flexibility in different stages of the TSP traversal.",
          "thought": "The new algorithm combines dynamic weight adjustment (like No.2) with immediate distance and average future distance (like No.1), prioritizing proximity when few nodes remain and balancing both factors when more nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight adjustment\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if unvisited_nodes:\n            avg_future_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        else:\n            avg_future_distance = 0\n        score = immediate_distance * (1.0 + weight_factor) + 0.2 * avg_future_distance * (1.0 - weight_factor)  # Dynamic weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.39185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (weight 1.0) and distance to the destination (weight 0.5), prioritizing shorter paths while breaking ties by choosing nodes closer to the destination. It ensures efficiency by evaluating each unvisited node's score and updating the best choice iteratively.",
          "thought": "The new algorithm combines the immediate distance prioritization of No.1 with the weighted balancing of No.2, selecting the next node by minimizing a score that considers immediate distance (weight 1.0) and the distance to the destination (weight 0.5), while also breaking ties by choosing the node closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = immediate_distance + 0.5 * destination_distance  # Weighted combination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n        elif score == best_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]