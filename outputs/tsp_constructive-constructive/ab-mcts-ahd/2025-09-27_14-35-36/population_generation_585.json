[
     {
          "algorithm": "The algorithm balances the proximity to the current node and the weighted proximity to the destination node, with a dynamic weight that reduces the influence of destination proximity as more nodes are visited. It calculates a score for each unvisited node, giving higher priority to nodes closer to the current node and those closer to the destination when fewer nodes remain, and selects the node with the best score. Additionally, it checks if the destination node should be prioritized if it is unvisited and is significantly closer than the next best node.",
          "thought": "Common ideas: Balancing proximity to the current node and weighted influence of proximity to the destination node. The No.1 algorithm uses dynamic weighting, where the influence of proximity to the destination decreases as more nodes are visited.\n\nDesign idea: Similar to No.2, balance proximity to both nodes but incorporate a dynamic weight based on the number of unvisited nodes to give more influence to the destination as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight * 0.6) + (destination_influence * 0.4)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.47488,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and influence towards the destination, incorporating a dynamic threshold based on the distance matrix. It calculates a weighted score using the inverse of distance to the current node and proportionally adjusted distance to the destination, prioritizing nodes closer to both. The algorithm also checks if the destination node should be prioritized directly if it is within a certain threshold distance compared to the next best node.",
          "thought": "Common ideas include balancing proximity to the current node and influence towards the destination, with a strict condition for destination prioritization. Design idea: Inspired by No.2, but incorporating a weighted score that balances proximity and destination influence with a dynamic threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = distance_to_dest / (1 + distance_to_node)\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.65:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.48605,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP by considering both the immediate distance to the candidate node and the future distance to the destination node, adjusting the balance with a weight factor that decreases as fewer nodes remain. If returning to the destination node significantly shortens the path, it prioritizes this option. The algorithm prioritizes nodes with shorter immediate distances while also accounting for their proximity to the destination, ensuring a balanced approach to minimizing the total path length.",
          "thought": "The new algorithm dynamically selects the next node by considering both immediate distance and the potential for future distances, adjusting weights as more nodes are visited, and encourages early returns to the destination node if it shortens the path significantly with a different weight and score calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = (remaining_nodes + 5) / (remaining_nodes + 15)  # Adjusted weight factor\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:  # Tightened early return condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.52931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node (via proximity_weight) and influence toward the destination (via destination_influence), while heavily favoring the destination if it's closer than 70% of the next best node's distance (strict threshold). The scoring formula dynamically adjusts weights based on unvisited nodes, and the destination is explicitly checked last to ensure its prioritization.",
          "thought": "The new algorithm combines the dynamic weighting mechanism from No.1 (balancing proximity to current node and destination influence) with the scoring formula from No.2 (prioritizing nodes closer to destination relative to immediate distance), while incorporating a stricter destination prioritization threshold (70% distance reduction).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54599,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node and the destination, using a weighted harmonic mean to combine these factors while dynamically adjusting for remaining nodes. It penalizes longer distances and reduces the impact of the destination when many nodes remain unvisited, but ensures the destination is prioritized if it is significantly closer. The score calculation emphasizes short-term efficiency (via harmonic mean) while accounting for long-term efficiency (via remaining nodes factor and penalty).",
          "thought": "The new algorithm combines the dynamic weighting from No.2 with the harmonic mean and penalty-based scoring from No.1, using a weighted harmonic mean to balance proximity and long-term efficiency while dynamically adjusting for remaining nodes and prioritizing the destination when it is significantly closer.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    remaining_nodes_factor = remaining_nodes / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            weight = remaining_nodes / (remaining_nodes + distance_to_node)\n            score = harmonic_mean * penalty * weight * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60252,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes closer to the destination while penalizing long distances more aggressively by combining a dynamic weighting factor (`weight = remaining_nodes / (remaining_nodes + distance_to_node)`) with a score that normalizes distance ratios (`distance_to_dest / distance_to_node`) and applies a distance penalty (`1 / (1 + 2 * distance_to_node)`). It also enforces a tighter margin (15%) for overriding selection when the destination is closer, ensuring efficiency and accuracy in path selection.",
          "thought": "The new algorithm combines the dynamic weighting factor from Algorithm 2 with an enhanced scoring mechanism that prioritizes nodes closer to the destination while penalizing long distances more aggressively, and uses a tighter margin (15%) for overriding selection when the destination is closer.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + distance_to_node)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + 2 * distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60282,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor heuristic by introducing a priority score for each unvisited node, which combines the immediate distance to the current node with the average distance to all other unvisited nodes. This score is calculated as the ratio of the immediate distance to the sum of distances to all other unvisited nodes, aiming to balance short-term and long-term path efficiency. The node with the lowest score is selected as the next node to visit, prioritizing nodes that are relatively closer to the current node while also being centrally located among remaining unvisited nodes.",
          "thought": "The new algorithm modifies the nearest neighbor heuristic by introducing a priority score that combines the distance to each node and a factor representing the node's relative proximity to all other unvisited nodes, aiming to balance short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_distances = {node: sum(distance_matrix[node][other] for other in unvisited_nodes) for node in unvisited_nodes}\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / total_distances[node])\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by computing a weighted harmonic mean of the distances to the current and destination nodes, and a penalty based on proximity to the previously visited node. The weight function adjusts the emphasis on proximity, prioritizing nodes that are neither too close to the starting node nor too far from the destination. The algorithm ensures the destination node is considered if it is among the unvisited nodes, prioritizing paths that minimize overall travel distance.",
          "thought": "The new algorithm selects the next node by calculating a weighted harmonic mean of the distance to the current node, the distance to the destination, and a penalty based on the current node's proximity to the previously visited node, using a novel weight function.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, previous_node=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            if previous_node is not None:\n                proximity_to_previous = distance_matrix[current_node][previous_node]\n                weight = 1 / (proximity_to_previous + 1)\n            else:\n                weight = 1\n            harmonic_mean = 3 / ((1 / distance_to_node) + (1 / distance_to_dest) + (1 / (weight + 1)))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61297,
          "other_inf": null
     }
]