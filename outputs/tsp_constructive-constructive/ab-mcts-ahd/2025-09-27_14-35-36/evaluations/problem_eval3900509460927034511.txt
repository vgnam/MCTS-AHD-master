import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def dynamic_weighted_distance(node):
        base_distance = distance_matrix[current_node][node]
        to_dest_distance = distance_matrix[node][destination_node]

        # Dynamic revisit penalty: higher for nodes closer to destination
        revisit_factor = 1.0 - (0.1 * (1.0 - (to_dest_distance / max(distance_matrix[node]))))

        # Probabilistic weight: favor nodes that haven't been visited recently
        visit_count = len(unvisited_nodes) - len(unvisited_nodes) + 1  # Simplified for demonstration
        prob_weight = 1.0 / (1.0 + math.exp(-0.5 * visit_count))

        return base_distance * revisit_factor * prob_weight

    # Select node with lowest weighted distance, with 20% chance to explore randomly
    if random.random() < 0.2:
        return random.choice(list(unvisited_nodes))
    else:
        return next_node
