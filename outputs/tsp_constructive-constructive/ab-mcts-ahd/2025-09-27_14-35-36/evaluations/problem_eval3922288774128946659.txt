def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    temperature = max(0.1, 1.0 - (1.0 / (1 + remaining_nodes)))  # Decreases over time

    scores = []
    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]

        # Dynamic weight based on node density
        if remaining_nodes > len(distance_matrix) / 2:
            weight = 0.7  # Early: favor immediate distance
        else:
            weight = 0.3  # Late: favor proximity to destination

        # Temperature-based score adjustment
        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_dest))
        score *= (1.0 + temperature * (random.random() - 0.5))  # Add noise

        scores.append((node, score))

    # Select top candidates and pick one probabilistically
    top_candidates = sorted(scores, key=lambda x: x[1], reverse=True)[:3]
    if top_candidates:
        selected = random.choices(
            [c[0] for c in top_candidates],
            weights=[c[1] for c in top_candidates],
            k=1
        )[0]
    else:
        selected = random.choice(unvisited_nodes)

    # Final check for destination proximity
    if destination_node in unvisited_nodes:
        dest_distance = distance_matrix[current_node][destination_node]
        if dest_distance < distance_matrix[current_node][selected] * 0.5:
            selected = destination_node

    return next_node
