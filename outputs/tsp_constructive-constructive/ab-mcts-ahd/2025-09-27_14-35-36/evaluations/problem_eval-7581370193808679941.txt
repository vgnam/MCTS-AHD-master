def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    scores = []
    total_score = 0.0
    remaining_nodes = len(unvisited_nodes)
    alpha = 0.6  # Proximity weight
    beta = 0.3   # Destination alignment weight
    gamma = 0.1  # Path potential weight
    temperature = max(1.0, remaining_nodes / 10)  # Dynamic temperature

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]

        # Proximity component (favors closer nodes)
        proximity_score = alpha * (1 / (1 + distance_to_node))

        # Destination alignment component (favors nodes that reduce total distance)
        alignment_score = beta * (distance_to_dest / (distance_to_node + distance_to_dest))

        # Path potential component (evaluates node's contribution to future path)
        path_potential = gamma * (1 / (1 + distance_to_node + distance_to_dest))

        # Dynamic adjustment based on remaining nodes and temperature
        adjustment_factor = (remaining_nodes / (remaining_nodes + distance_to_node)) ** (1 + 1/temperature)
        node_score = (proximity_score + alignment_score + path_potential) * adjustment_factor

        scores.append((node, node_score))
        total_score += node_score

    # Probabilistic selection based on scores and temperature
    if total_score > 0:
        normalized_scores = [(node, score / total_score) for node, score in scores]
        probabilities = [score ** (1/temperature) for _, score in normalized_scores]
        sum_prob = sum(probabilities)
        probabilities = [p / sum_prob for p in probabilities]
        next_node = np.random.choice([node for node, _ in normalized_scores], p=probabilities)
    else:
        next_node = unvisited_nodes[0] if unvisited_nodes else destination_node

    # Special case: prioritize destination if it's the last node or provides significant savings
    if destination_node in unvisited_nodes:
        dest_distance = distance_matrix[current_node][destination_node]
        if remaining_nodes == 1 or dest_distance < distance_matrix[current_node][next_node] * 0.6:
            next_node = destination_node

    return next_node
