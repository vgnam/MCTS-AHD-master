def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    best_score = float('-inf')
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)

    # Dynamic weight adjustment based on path length
    path_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes if node != destination_node)
    weight_factor = 0.3 if path_length > avg_distance * len(unvisited_nodes) * 0.8 else 0.7

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]

        # Novel scoring with dynamic weight and probabilistic exploration
        score = (1 / (1 + distance_to_node)) * (distance_to_dest ** 0.5) * weight_factor
        score += (0.5 * (distance_to_node / avg_distance)) * (1 - weight_factor)

        # Add probabilistic exploration when destination is not close
        if node != destination_node and distance_to_dest > avg_distance * 1.2:
            score *= 0.8 + 0.2 * (distance_to_node / avg_distance)

        if score > best_score:
            best_score = score
            next_node = node

    # Priority to destination if significantly closer
    if destination_node in unvisited_nodes:
        dest_distance = distance_matrix[current_node][destination_node]
        if dest_distance < avg_distance * 0.6:
            next_node = destination_node

    return next_node
