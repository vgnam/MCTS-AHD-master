importance" (e.g., centrality or historical visitation frequency), while still prioritizing the destination when it is closer than other candidates.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_weighted_distance = float('inf')
    centrality_scores = {node: sum(distance_matrix[node]) for node in unvisited_nodes}

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        centrality = centrality_scores[node]
        weighted_distance = distance * (1 / (1 + centrality))  # Lower centrality increases weight

        if weighted_distance < min_weighted_distance:
            min_weighted_distance = weighted_distance
            next_node = node

    if destination_node in unvisited_nodes:
        dest_distance = distance_matrix[current_node][destination_node]
        dest_centrality = centrality_scores[destination_node]
        dest_weighted_distance = dest_distance * (1 / (1 + dest_centrality))

        if dest_weighted_distance < min_weighted_distance:
            next_node = destination_node

    return next_node
