def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_unvisited = remaining_nodes + 1 if destination_node in unvisited_nodes else remaining_nodes
    decay_rate = 0.5 / (1 + total_unvisited)

    scores = []
    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]
        heuristic_score = (1 - decay_rate) * (1 / (1 + distance_to_node)) + decay_rate * (1 / (1 + distance_to_dest))
        scores.append((node, heuristic_score))

    if not scores:
        return destination_node

    max_score = max(score for _, score in scores)
    candidates = [node for node, score in scores if score >= max_score * 0.9]

    if destination_node in candidates and len(unvisited_nodes) <= 2:
        return destination_node

    selected_node = max(candidates, key=lambda x: distance_matrix[current_node][x] if x != destination_node else float('-inf'))
    return next_node
