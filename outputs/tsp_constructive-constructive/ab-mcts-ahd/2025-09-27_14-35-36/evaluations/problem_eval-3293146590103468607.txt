import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate average distance to unvisited nodes
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)

    # Calculate centrality of each node (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)

    # Dynamic temperature (decreases as more nodes are visited)
    temperature = 1.0 - (len(unvisited_nodes) / len(distance_matrix))

    # Combine distance and centrality with sigmoid weighting
    weights = []
    for node in unvisited_nodes:
        distance_weight = math.exp(-distance_matrix[current_node][node] / (avg_distance * 2))
        centrality_weight = 1 / (1 + math.exp(-centrality[node] / (avg_distance * 0.5)))
        combined_weight = (temperature * distance_weight) + ((1 - temperature) * centrality_weight)
        weights.append(combined_weight)

    total_weight = sum(weights)
    normalized_weights = [weight / total_weight for weight in weights]
    next_node = random.choices(list(unvisited_nodes), weights=normalized_weights, k=1)[0]
    return next_node
