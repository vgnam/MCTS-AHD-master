def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    dynamic_factor = 1 / (1 + math.exp(-(remaining_nodes - 5)))  # Sigmoid function to adjust heuristic factor dynamically

    # Calculate node degree centrality as secondary heuristic
    node_degrees = [sum(row) for row in distance_matrix]
    max_degree = max(node_degrees) if node_degrees else 1
    normalized_degrees = [degree / max_degree for degree in node_degrees]

    next_node = min(unvisited_nodes, key=lambda node: (
        dynamic_factor * distance_matrix[current_node][node] +
        (1 - dynamic_factor) * normalized_degrees[node]
    ))
    return next_node
