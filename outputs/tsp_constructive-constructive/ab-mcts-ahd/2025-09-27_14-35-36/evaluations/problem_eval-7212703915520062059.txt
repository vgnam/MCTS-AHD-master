def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    urgency_factor = remaining_nodes / 2.0
    candidate_scores = {}

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]
        score = distance_to_node + urgency_factor * distance_to_dest
        candidate_scores[node] = score

    if candidate_scores:
        min_score = min(candidate_scores.values())
        max_score = max(candidate_scores.values())
        normalized_scores = {node: (max_score - score) / (max_score - min_score) for node, score in candidate_scores.items()}
        total_weight = sum(normalized_scores.values())
        probabilities = {node: weight / total_weight for node, weight in normalized_scores.items()}
        selected_node = max(probabilities.items(), key=lambda x: x[1])[0]
        return selected_node
    else:
        return next_node
