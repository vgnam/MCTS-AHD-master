def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    remaining_nodes = len(unvisited_nodes)
    temperature = 1.0 / (1 + remaining_nodes)  # Dynamic temperature for exploration

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]

        # Novel scoring combining immediate distance and potential savings
        immediate_score = 1 / (1 + distance_to_node)
        future_score = distance_to_dest / (distance_to_node + 1e-6)
        score = (1 - temperature) * immediate_score + temperature * future_score

        scores.append((node, score))

    # Probabilistic selection based on scores
    if scores:
        nodes, node_scores = zip(*scores)
        total_score = sum(node_scores)
        probabilities = [s / total_score for s in node_scores]
        next_node = np.random.choice(nodes, p=probabilities)
    else:
        next_node = destination_node

    # Destination prioritization when close
    if destination_node in unvisited_nodes:
        dest_distance = distance_matrix[current_node][destination_node]
        if dest_distance < distance_matrix[current_node][next_node] * 0.7:
            next_node = destination_node

    return next_node
