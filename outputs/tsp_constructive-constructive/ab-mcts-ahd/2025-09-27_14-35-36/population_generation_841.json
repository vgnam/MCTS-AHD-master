[
     {
          "algorithm": "The algorithm balances the proximity to the current node and the weighted proximity to the destination node, with a dynamic weight that reduces the influence of destination proximity as more nodes are visited. It calculates a score for each unvisited node, giving higher priority to nodes closer to the current node and those closer to the destination when fewer nodes remain, and selects the node with the best score. Additionally, it checks if the destination node should be prioritized if it is unvisited and is significantly closer than the next best node.",
          "thought": "Common ideas: Balancing proximity to the current node and weighted influence of proximity to the destination node. The No.1 algorithm uses dynamic weighting, where the influence of proximity to the destination decreases as more nodes are visited.\n\nDesign idea: Similar to No.2, balance proximity to both nodes but incorporate a dynamic weight based on the number of unvisited nodes to give more influence to the destination as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight * 0.6) + (destination_influence * 0.4)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.47488,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and influence towards the destination, incorporating a dynamic threshold based on the distance matrix. It calculates a weighted score using the inverse of distance to the current node and proportionally adjusted distance to the destination, prioritizing nodes closer to both. The algorithm also checks if the destination node should be prioritized directly if it is within a certain threshold distance compared to the next best node.",
          "thought": "Common ideas include balancing proximity to the current node and influence towards the destination, with a strict condition for destination prioritization. Design idea: Inspired by No.2, but incorporating a weighted score that balances proximity and destination influence with a dynamic threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = distance_to_dest / (1 + distance_to_node)\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.65:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.48605,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP by considering both the immediate distance to the candidate node and the future distance to the destination node, adjusting the balance with a weight factor that decreases as fewer nodes remain. If returning to the destination node significantly shortens the path, it prioritizes this option. The algorithm prioritizes nodes with shorter immediate distances while also accounting for their proximity to the destination, ensuring a balanced approach to minimizing the total path length.",
          "thought": "The new algorithm dynamically selects the next node by considering both immediate distance and the potential for future distances, adjusting weights as more nodes are visited, and encourages early returns to the destination node if it shortens the path significantly with a different weight and score calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = (remaining_nodes + 5) / (remaining_nodes + 15)  # Adjusted weight factor\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:  # Tightened early return condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.52931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node (via proximity_weight) and influence toward the destination (via destination_influence), while heavily favoring the destination if it's closer than 70% of the next best node's distance (strict threshold). The scoring formula dynamically adjusts weights based on unvisited nodes, and the destination is explicitly checked last to ensure its prioritization.",
          "thought": "The new algorithm combines the dynamic weighting mechanism from No.1 (balancing proximity to current node and destination influence) with the scoring formula from No.2 (prioritizing nodes closer to destination relative to immediate distance), while incorporating a stricter destination prioritization threshold (70% distance reduction).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54599,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by prioritizing proximity to the current node while balancing potential path efficiency, using a dynamic weight that adapts to remaining unvisited nodes. It penalizes nodes that could increase inefficiency and slightly favors the destination node if it's close. The score combines these factors to choose the best next node, with higher weight given to proximity and lower weight to penalties as the search progresses.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, favoring nodes that balance proximity to the current node and potential to reduce the overall path length, while also considering the destination's closeness, and introducing a penalty for nodes that could disrupt the path's efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1 + (1 / (remaining_nodes + 1))  # Adjusts based on remaining nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        total_distance = distance_to_node + distance_to_dest\n\n        # Penalize nodes that could increase the path's inefficiency\n        penalty = 1 + (distance_to_node / (sum(distance_matrix[node]) / len(distance_matrix[node])))\n\n        score = (dynamic_weight / total_distance) * distance_to_dest / penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 1.1:  # Slightly relaxed condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54972,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP by balancing the cost to the node with adaptive exploration-exploitation factors. It adjusts the weight towards exploitation as fewer nodes remain unvisited, prioritizing proximity to the destination. Additionally, it includes a penalty for longer paths and prefers the direct path to the destination if it significantly reduces the overall cost.",
          "thought": "The new algorithm dynamically selects the next node by balancing the cost to the node with an adaptive exploration-exploitation heuristic that increases the exploration of less visited nodes and the exploitation of proximity to the destination as fewer nodes remain, using a modified adaptive weight and a penalty for longer paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    num_unvisited = len(unvisited_nodes)\n    total_unvisited = len(distance_matrix) - 1\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        adaptive_weight = 1 - (num_unvisited / total_unvisited)\n        exploration_factor = 1 / (1 + len(unvisited_nodes))\n        exploitation_factor = adaptive_weight * (1 / (1 + distance_to_dest))\n        cost_factor = 1 / (1 + distance_to_node)\n        score = cost_factor + exploration_factor - exploitation_factor\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56868,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a weighted score that balances immediate proximity to the current node and future proximity to the destination node, adjusting the weight dynamically based on the remaining unvisited nodes. The destination node is given priority if it is significantly closer than the best-scored node. The heuristic uses a combination of proximity distances and a dynamic weight to make informed decisions about the next node to visit, aiming to minimize the total travel distance.",
          "thought": "Combining dynamic weight adjustment, balancing immediate distance and future destination proximity, minimizing the sum of distances, and giving special consideration to the destination node, the new algorithm calculates a score that prioritizes nodes based on a weighted balance of current proximity and destination proximity, with the weight decreasing as more nodes are visited, and prioritizes the destination node if it is significantly closer than the best-scored node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = (remaining_nodes + 5) / (remaining_nodes + 20)\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57868,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity (70%) over destination influence (30%) while dynamically adjusting the destination's weight based on the square root of remaining nodes and the ratio of unvisited nodes. It forces a detour to the destination if its distance is below 70% of the average distance to other unvisited nodes, ensuring efficiency and adaptability. The code structure evaluates each unvisited node by combining proximity-based and destination-based scores, with a final check for forced detours.",
          "thought": "The new algorithm combines proximity prioritization (70%) with destination influence (30%), dynamically adjusting the destination's weight by the square root of the remaining nodes, and forces a detour to the destination if it's below 70% of the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        adjusted_dest = (distance_to_dest ** 0.5) * (unvisited_count / (unvisited_count + 2))\n        score = (proximity_weight * 0.7) + (adjusted_dest * 0.3)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < avg_distance * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57912,
          "other_inf": null
     }
]