[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor heuristic by introducing a priority score for each unvisited node, which combines the immediate distance to the current node with the average distance to all other unvisited nodes. This score is calculated as the ratio of the immediate distance to the sum of distances to all other unvisited nodes, aiming to balance short-term and long-term path efficiency. The node with the lowest score is selected as the next node to visit, prioritizing nodes that are relatively closer to the current node while also being centrally located among remaining unvisited nodes.",
          "thought": "The new algorithm modifies the nearest neighbor heuristic by introducing a priority score that combines the distance to each node and a factor representing the node's relative proximity to all other unvisited nodes, aiming to balance short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_distances = {node: sum(distance_matrix[node][other] for other in unvisited_nodes) for node in unvisited_nodes}\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / total_distances[node])\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by computing a weighted harmonic mean of the distances to the current and destination nodes, and a penalty based on proximity to the previously visited node. The weight function adjusts the emphasis on proximity, prioritizing nodes that are neither too close to the starting node nor too far from the destination. The algorithm ensures the destination node is considered if it is among the unvisited nodes, prioritizing paths that minimize overall travel distance.",
          "thought": "The new algorithm selects the next node by calculating a weighted harmonic mean of the distance to the current node, the distance to the destination, and a penalty based on the current node's proximity to the previously visited node, using a novel weight function.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, previous_node=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            if previous_node is not None:\n                proximity_to_previous = distance_matrix[current_node][previous_node]\n                weight = 1 / (proximity_to_previous + 1)\n            else:\n                weight = 1\n            harmonic_mean = 3 / ((1 / distance_to_node) + (1 / distance_to_dest) + (1 / (weight + 1)))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61297,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate proximity and long-term efficiency by dynamically weighting node selection based on remaining nodes, with closer-to-destination nodes favored when few nodes remain. It uses a refined scoring system combining normalized distances and a stricter early return condition (30% margin) to ensure optimal path selection. The weight parameter adjusts between proximity and destination alignment, while the score calculation ensures efficient exploration of the solution space.",
          "thought": "The new algorithm combines dynamic weighting based on remaining nodes, prioritizes nodes closer to the destination when few nodes remain, and uses a refined scoring system that balances immediate proximity and long-term efficiency, while also incorporating a stricter early return condition (30% margin) to ensure optimal path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 2)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_dest))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61309,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing immediate proximity and long-term efficiency. It uses a weighted scoring system that adjusts based on the number of remaining unvisited nodes, prioritizing nodes closer to the destination when fewer nodes are left. Additionally, the algorithm considers returning to the destination early if it significantly shortens the path compared to continuing with the current best option.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61795,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritizing nodes close to the current node) and long-term efficiency (prioritizing nodes that are closer to the destination), using a weighted score combining these factors. It checks if the destination is closer than the best candidate node (with a 20% margin) and overrides the selection if true, ensuring the path remains efficient. The score is calculated as `(distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))`, where the second term penalizes longer distances to the next node.",
          "thought": "The new algorithm prioritizes nodes by considering the shortest path to the destination while also ensuring that intermediate nodes are as close as possible to the current node, balancing immediate proximity with long-term path efficiency. It calculates a weighted score combining direct distance to the node and the node's potential to lead to the destination, avoiding unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate proximity and long-term efficiency, adjusting weights as more nodes are visited, and penalizing longer immediate distances. It includes a special condition to consider early returns to the destination node if it significantly shortens the path. The key parameters are the remaining node count, distances to the next and destination nodes, and a dynamically adjusted weight factor.",
          "thought": "Design idea: A new algorithm that dynamically weights immediate proximity and long-term efficiency more heavily as fewer nodes remain, includes a penalty for longer immediate distances, and considers early returns to the destination if they significantly shorten the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 10)  # Adjusted weight factor\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:  # Tightened early return condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61993,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score that balances the distance to the destination, the distance from the current node, and a penalty for visited neighbors, with a dynamic weighting factor that prioritizes nodes closer to the destination as fewer nodes remain. The score is influenced by a penalty for neighboring nodes that have already been visited, and the algorithm also considers directly visiting the destination if it is significantly closer than any other unvisited node.",
          "thought": "Design idea based on No.2 algorithm and main steps: The algorithm calculates a score for each unvisited node by balancing the distance to the destination, the distance from the current node, a penalty for already visited neighbors, and a dynamic weighting factor based on the remaining nodes, prioritizing nodes closer to the destination when fewer nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        visited_neighbors = [n for n in unvisited_nodes if n in distance_matrix[node] and n != node]\n        penalty = len(visited_neighbors) * 0.1\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * ((distance_to_dest / (distance_to_node + distance_to_dest)) - penalty)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62008,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by incorporating a dynamic penalty factor that decreases as fewer unvisited nodes remain, and an adaptive proximity threshold to the destination, allowing for earlier returns if the destination is relatively closer. The score for each node is calculated based on the ratio of distances to the node and destination, adjusted by the penalty factor, and the proximity to the current node. If the destination is among the unvisited nodes and is closer than a dynamically adjusted threshold compared to the best alternative, it is chosen as the next node.",
          "thought": "The new algorithm introduces a dynamic penalty factor based on the fraction of unvisited nodes and incorporates an adaptive proximity threshold to the destination, allowing for earlier returns if the destination is relatively close compared to the best alternative.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    penalty_factor = 1 - (remaining_nodes / (remaining_nodes + 5))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        adaptive_threshold = 0.7 + (0.1 * (remaining_nodes / len(distance_matrix)))\n\n        score = (distance_to_dest / distance_to_node) * (1 - penalty_factor) + (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * adaptive_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62179,
          "other_inf": null
     }
]