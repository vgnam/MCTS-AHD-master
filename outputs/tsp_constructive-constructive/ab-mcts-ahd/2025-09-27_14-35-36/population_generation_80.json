[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing immediate proximity and long-term efficiency. It uses a weighted scoring system that adjusts based on the number of remaining unvisited nodes, prioritizing nodes closer to the destination when fewer nodes are left. Additionally, the algorithm considers returning to the destination early if it significantly shortens the path compared to continuing with the current best option.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61795,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritizing nodes close to the current node) and long-term efficiency (prioritizing nodes that are closer to the destination), using a weighted score combining these factors. It checks if the destination is closer than the best candidate node (with a 20% margin) and overrides the selection if true, ensuring the path remains efficient. The score is calculated as `(distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))`, where the second term penalizes longer distances to the next node.",
          "thought": "The new algorithm prioritizes nodes by considering the shortest path to the destination while also ensuring that intermediate nodes are as close as possible to the current node, balancing immediate proximity with long-term path efficiency. It calculates a weighted score combining direct distance to the node and the node's potential to lead to the destination, avoiding unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score that balances the distance to the destination, the distance from the current node, and a penalty for visited neighbors, with a dynamic weighting factor that prioritizes nodes closer to the destination as fewer nodes remain. The score is influenced by a penalty for neighboring nodes that have already been visited, and the algorithm also considers directly visiting the destination if it is significantly closer than any other unvisited node.",
          "thought": "Design idea based on No.2 algorithm and main steps: The algorithm calculates a score for each unvisited node by balancing the distance to the destination, the distance from the current node, a penalty for already visited neighbors, and a dynamic weighting factor based on the remaining nodes, prioritizing nodes closer to the destination when fewer nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        visited_neighbors = [n for n in unvisited_nodes if n in distance_matrix[node] and n != node]\n        penalty = len(visited_neighbors) * 0.1\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * ((distance_to_dest / (distance_to_node + distance_to_dest)) - penalty)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62008,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate proximity and long-term efficiency using a weighted score mechanism. This score factors in the distance to the node, the distance to the destination, and the remaining nodes, adapting as nodes are visited. It prioritizes nodes that are relatively closer to the destination while considering the path's efficiency and the number of unvisited nodes.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length, ensuring a more adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.63198,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing exploration (favoring nodes closer to the current node early on) and exploitation (prioritizing nodes closer to the destination later), using a dynamic weight inversely proportional to the number of unvisited nodes. It also penalizes nodes that are far from the average distance to unvisited nodes, ensuring a compromise between local and global decisions. The score prioritizes nodes that minimize the ratio of distance to the destination over the distance from the current node, adjusted by the dynamic weight and average distance penalty. If the destination is close enough, it overrides the selection to ensure efficient completion.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor for the score, where the weight is inversely proportional to the number of unvisited nodes, encouraging exploration early and exploitation later, while also introducing a penalty term based on the average distance to unvisited nodes to balance local and global decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    num_unvisited = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / num_unvisited if num_unvisited > 0 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = 1 / (1 + num_unvisited)\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node + (1 - weight) * avg_distance))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.65203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes closer to the destination while penalizing longer immediate distances, dynamically adjusting weights based on remaining unvisited nodes, and includes a 20% margin check for early returns to the destination. It balances proximity to the destination and immediate distance efficiency, with the destination being selected if it is significantly closer (within 80%) than the next best candidate. The scoring mechanism combines a weighted ratio of destination distance to current distance with a penalty for longer immediate steps.",
          "thought": "This new algorithm combines the dynamic weighting from Algorithm 2 with a refined scoring mechanism that prioritizes nodes closer to the destination while penalizing longer immediate distances, and incorporates a 20% margin check for early destination returns, similar to both algorithms.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.66099,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach with a dynamic weighting mechanism to balance immediate distance reduction and long-term path efficiency. It prioritizes minimizing the current distance (weighted higher early in the process) while also considering the potential to reach the destination efficiently (weighted higher later). The score calculation dynamically adjusts based on remaining nodes, favoring proximity early and strategic positioning later, with an optional direct-to-destination check for efficiency.",
          "thought": "The new algorithm prioritizes immediate distance reduction by combining a greedy approach with a lookahead factor, balancing proximity to the current node and potential long-term path efficiency through a dynamic weighting mechanism that adapts to the remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = 1 - (remaining_nodes / (remaining_nodes + 2))\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (distance_to_node + distance_to_dest))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.66959,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines dynamic weighting with reinforcement learning to select the next node in TSP, prioritizing both immediate proximity (via proximity_score) and long-term efficiency (via historical_performance), while adaptively biasing toward the destination as the tour progresses (via destination_bias). The weights (alpha, beta) control the balance between learning and immediate decisions, with historical performance updated after each selection. The algorithm also includes an early return to the destination if it becomes significantly closer, optimizing for both local and global efficiency.",
          "thought": "The new algorithm modifies the dynamic weighting approach by incorporating a reinforcement learning-inspired mechanism that adjusts node selection probabilities based on historical performance, while maintaining a hybrid scoring system that balances immediate proximity and long-term efficiency with an adaptive bias toward destination proximity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    alpha = 0.7  # Learning rate for historical performance\n    beta = 0.3   # Weight for historical performance in scoring\n\n    # Initialize or update historical performance (simplified for demonstration)\n    if 'historical_performance' not in select_next_node.__dict__:\n        select_next_node.historical_performance = {}\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Base score components\n        proximity_score = 1 / (1 + distance_to_node)\n        destination_bias = (remaining_nodes / (remaining_nodes + 2)) * (distance_to_dest / distance_to_node)\n\n        # Historical performance component (reinforcement learning inspired)\n        historical_factor = select_next_node.historical_performance.get(node, 0.5)\n        historical_factor = alpha * historical_factor + (1 - alpha) * (1 / (1 + distance_to_node))\n\n        # Combined score with adaptive weighting\n        score = (beta * historical_factor + (1 - beta) * proximity_score) * destination_bias\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    # Update historical performance for the selected node\n    if next_node is not None:\n        select_next_node.historical_performance[next_node] = select_next_node.historical_performance.get(next_node, 0.5) + 0.1\n\n    # Early return to destination if significantly closer\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.67072,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity-based and dynamic weighting approaches, prioritizing nodes that balance immediate distance to the current node and long-term distance to the destination, scaled by a dynamic weight that adjusts based on remaining unvisited nodes. It favors closer nodes early (high weight for `distance_to_node`) but also considers the path to the destination (low weight for `distance_to_dest`), with a special check to prioritize the destination if it's significantly closer than the next node. The weight `remaining_nodes / (remaining_nodes + 1)` ensures flexibility in balancing short-term and long-term efficiency.",
          "thought": "The new algorithm combines the proximity-based scoring from No.1 with the dynamic weighting from No.2, using a score that balances immediate and long-term efficiency, while adjusting priority based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (1 / (distance_to_node + distance_to_dest)) * distance_to_dest + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.68881,
          "other_inf": null
     }
]