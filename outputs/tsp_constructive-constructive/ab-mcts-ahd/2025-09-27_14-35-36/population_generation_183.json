[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by computing a weighted harmonic mean of the distances to the current and destination nodes, and a penalty based on proximity to the previously visited node. The weight function adjusts the emphasis on proximity, prioritizing nodes that are neither too close to the starting node nor too far from the destination. The algorithm ensures the destination node is considered if it is among the unvisited nodes, prioritizing paths that minimize overall travel distance.",
          "thought": "The new algorithm selects the next node by calculating a weighted harmonic mean of the distance to the current node, the distance to the destination, and a penalty based on the current node's proximity to the previously visited node, using a novel weight function.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, previous_node=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            if previous_node is not None:\n                proximity_to_previous = distance_matrix[current_node][previous_node]\n                weight = 1 / (proximity_to_previous + 1)\n            else:\n                weight = 1\n            harmonic_mean = 3 / ((1 / distance_to_node) + (1 / distance_to_dest) + (1 / (weight + 1)))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61297,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate proximity and long-term efficiency by dynamically weighting node selection based on remaining nodes, with closer-to-destination nodes favored when few nodes remain. It uses a refined scoring system combining normalized distances and a stricter early return condition (30% margin) to ensure optimal path selection. The weight parameter adjusts between proximity and destination alignment, while the score calculation ensures efficient exploration of the solution space.",
          "thought": "The new algorithm combines dynamic weighting based on remaining nodes, prioritizes nodes closer to the destination when few nodes remain, and uses a refined scoring system that balances immediate proximity and long-term efficiency, while also incorporating a stricter early return condition (30% margin) to ensure optimal path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 2)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_dest))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61309,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing immediate proximity and long-term efficiency. It uses a weighted scoring system that adjusts based on the number of remaining unvisited nodes, prioritizing nodes closer to the destination when fewer nodes are left. Additionally, the algorithm considers returning to the destination early if it significantly shortens the path compared to continuing with the current best option.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61795,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritizing nodes close to the current node) and long-term efficiency (prioritizing nodes that are closer to the destination), using a weighted score combining these factors. It checks if the destination is closer than the best candidate node (with a 20% margin) and overrides the selection if true, ensuring the path remains efficient. The score is calculated as `(distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))`, where the second term penalizes longer distances to the next node.",
          "thought": "The new algorithm prioritizes nodes by considering the shortest path to the destination while also ensuring that intermediate nodes are as close as possible to the current node, balancing immediate proximity with long-term path efficiency. It calculates a weighted score combining direct distance to the node and the node's potential to lead to the destination, avoiding unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score that balances the distance to the destination, the distance from the current node, and a penalty for visited neighbors, with a dynamic weighting factor that prioritizes nodes closer to the destination as fewer nodes remain. The score is influenced by a penalty for neighboring nodes that have already been visited, and the algorithm also considers directly visiting the destination if it is significantly closer than any other unvisited node.",
          "thought": "Design idea based on No.2 algorithm and main steps: The algorithm calculates a score for each unvisited node by balancing the distance to the destination, the distance from the current node, a penalty for already visited neighbors, and a dynamic weighting factor based on the remaining nodes, prioritizing nodes closer to the destination when fewer nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        visited_neighbors = [n for n in unvisited_nodes if n in distance_matrix[node] and n != node]\n        penalty = len(visited_neighbors) * 0.1\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * ((distance_to_dest / (distance_to_node + distance_to_dest)) - penalty)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62008,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing proximity to the next node and proximity to the destination node, with the emphasis on the latter decreasing as more nodes remain unvisited. A weighted scoring system, influenced by a variable weight adjusted based on the remaining unvisited nodes count, prioritizes nodes that are closer to both the current position and the destination. Additionally, the algorithm considers the direct path to the destination if it is notably shorter than any unvisited node path.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination node based on the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_count = len(unvisited_nodes)\n    \n    weight = 1 / (1 + remaining_nodes_count / 10)  # Adjust weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (1 / (1 + distance_to_node)) * (1 - weight + weight * (distance_to_dest / (1 + distance_to_node)))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate proximity and long-term efficiency using a weighted score mechanism. This score factors in the distance to the node, the distance to the destination, and the remaining nodes, adapting as nodes are visited. It prioritizes nodes that are relatively closer to the destination while considering the path's efficiency and the number of unvisited nodes.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length, ensuring a more adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.63198,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by scoring each unvisited node based on a balance between its proximity to the current node and its distance to the destination, with a higher penalty for longer immediate distances. It prioritizes nodes closer to the destination relative to their immediate distance, using a scoring formula that emphasized these factors. Finally, if the destination is unvisited and notably closer (less than 80% of the distance to the current best node), it directly chooses the destination.",
          "thought": "Design: A new algorithm that scores each unvisited node by balancing its proximity to the current node and distance to the destination, with a heavier penalty for longer immediate distances, and includes a final check to directly choose the destination if it is notably closer.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / (distance_to_node + distance_to_dest)) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.63819,
          "other_inf": null
     }
]