[
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing immediate proximity and long-term efficiency. It uses a weighted scoring system that adjusts based on the number of remaining unvisited nodes, prioritizing nodes closer to the destination when fewer nodes are left. Additionally, the algorithm considers returning to the destination early if it significantly shortens the path compared to continuing with the current best option.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61795,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritizing nodes close to the current node) and long-term efficiency (prioritizing nodes that are closer to the destination), using a weighted score combining these factors. It checks if the destination is closer than the best candidate node (with a 20% margin) and overrides the selection if true, ensuring the path remains efficient. The score is calculated as `(distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))`, where the second term penalizes longer distances to the next node.",
          "thought": "The new algorithm prioritizes nodes by considering the shortest path to the destination while also ensuring that intermediate nodes are as close as possible to the current node, balancing immediate proximity with long-term path efficiency. It calculates a weighted score combining direct distance to the node and the node's potential to lead to the destination, avoiding unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate proximity and long-term efficiency using a weighted score mechanism. This score factors in the distance to the node, the distance to the destination, and the remaining nodes, adapting as nodes are visited. It prioritizes nodes that are relatively closer to the destination while considering the path's efficiency and the number of unvisited nodes.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length, ensuring a more adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.63198,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing exploration (favoring nodes closer to the current node early on) and exploitation (prioritizing nodes closer to the destination later), using a dynamic weight inversely proportional to the number of unvisited nodes. It also penalizes nodes that are far from the average distance to unvisited nodes, ensuring a compromise between local and global decisions. The score prioritizes nodes that minimize the ratio of distance to the destination over the distance from the current node, adjusted by the dynamic weight and average distance penalty. If the destination is close enough, it overrides the selection to ensure efficient completion.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor for the score, where the weight is inversely proportional to the number of unvisited nodes, encouraging exploration early and exploitation later, while also introducing a penalty term based on the average distance to unvisited nodes to balance local and global decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    num_unvisited = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / num_unvisited if num_unvisited > 0 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = 1 / (1 + num_unvisited)\n        score = (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node + (1 - weight) * avg_distance))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.65203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by scoring each unvisited node based on a combination of its proximity to the current node and its distance to the destination node, with a penalty for longer distances to the current node. It prioritizes nodes that are closer to both the current position and the destination, with a slight preference for shorter immediate distances. Additionally, it checks if the destination node can be a better immediate choice if it is significantly closer than the best scored node.",
          "thought": "Common ideas include balancing immediate proximity and long-term efficiency, scoring nodes based on a combination of their distance to the next node and the destination, and checking if the destination can be a better immediate choice. Design idea: Create a new scoring mechanism that combines elements from both algorithms, prioritizing closer nodes while also considering the path to the destination, and incorporating a penalty for longer distances, similar to No.1, while maintaining the emphasis on minimizing combined distances from No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (distance_to_dest / (distance_to_node + distance_to_dest)) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.70117,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance to the destination, the distance from the current node, and a penalty for already visited neighbors. It calculates a score for each unvisited node, prioritizing those closer to the destination while penalizing nodes with many visited neighbors, and returns the highest-scoring node. Additionally, it directly chooses the destination node if it remains unvisited and is closer than the best-scored node.",
          "thought": "This new algorithm prioritizes nodes by considering a combination of distance to the current node, distance to the destination, and a penalty for already visited neighbors, aiming to balance path efficiency and exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        visited_neighbors = [n for n in unvisited_nodes if n in distance_matrix[node] and n != node]\n        penalty = len(visited_neighbors) * 0.1\n        score = (distance_to_dest / (distance_to_node + distance_to_dest)) - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing proximity to the current node and closeness to the destination, favoring nodes that minimize the sum of these distances while maximizing the benefit of reaching the destination. It assigns higher priority to nodes with lower combined distances and checks if the destination itself is a better immediate choice. The score calculation `(1 / (distance_to_node + distance_to_dest)) * distance_to_dest` emphasizes both distance efficiency and destination proximity, with a final check to ensure the destination isn't overlooked.",
          "thought": "The new algorithm prioritizes nodes by considering both the distance to the current node and the potential benefit of visiting the node in relation to the destination, favoring nodes that are closer to the destination while also being close to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = (1 / (distance_to_node + distance_to_dest)) * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.8955,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score that prioritizes a harmonic mean of the distance to the current node and the distance to the destination, while applying a penalty for nodes that are farther from the current node. It iterates through all unvisited nodes, updating the best score and choosing the node with the highest score, and finally checks if the destination node can be visited directly if it is closer than the best-scored node.",
          "thought": "The new algorithm prioritizes nodes by considering a harmonic mean of the distance to the node and the distance to the destination, while also applying a penalty for nodes that are significantly farther from the current node, ensuring a balanced yet efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.89757,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the unvisited node closest to the current node, but always prefers the destination node if it remains unvisited and is closer than any other candidate. The function checks all unvisited nodes, updates the closest one, and overrides this choice if the destination is both unvisited and closer. The code efficiently handles edge cases (empty unvisited nodes) and ensures the destination is prioritized when applicable.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a preference for the destination node if it is unvisited and closer than any other node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing distance from the current node and proximity to the destination node through a weighted heuristic. It dynamically adjusts the weight based on the distance to the destination and the number of unvisited nodes, prioritizing nodes that are closer to both the current node and the destination. The algorithm also considers visiting the destination node directly if it is within the unvisited set and closer than the best candidate node.",
          "thought": "The new algorithm introduces a dynamic priority system that incorporates both distance and a heuristic factor that encourages closer proximity to the destination, with a weight adjustment to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    dest_distance = distance_matrix[current_node][destination_node]\n    weight = dest_distance / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic_factor = distance_matrix[node][destination_node]\n        score = distance + weight * heuristic_factor\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] < min_score:\n        next_node = destination_node\n\n    return next_node",
          "objective": 7.11111,
          "other_inf": null
     }
]