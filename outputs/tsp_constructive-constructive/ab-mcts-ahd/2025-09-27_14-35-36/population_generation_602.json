[
     {
          "algorithm": "The algorithm balances the proximity to the current node and the weighted proximity to the destination node, with a dynamic weight that reduces the influence of destination proximity as more nodes are visited. It calculates a score for each unvisited node, giving higher priority to nodes closer to the current node and those closer to the destination when fewer nodes remain, and selects the node with the best score. Additionally, it checks if the destination node should be prioritized if it is unvisited and is significantly closer than the next best node.",
          "thought": "Common ideas: Balancing proximity to the current node and weighted influence of proximity to the destination node. The No.1 algorithm uses dynamic weighting, where the influence of proximity to the destination decreases as more nodes are visited.\n\nDesign idea: Similar to No.2, balance proximity to both nodes but incorporate a dynamic weight based on the number of unvisited nodes to give more influence to the destination as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight * 0.6) + (destination_influence * 0.4)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.47488,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and influence towards the destination, incorporating a dynamic threshold based on the distance matrix. It calculates a weighted score using the inverse of distance to the current node and proportionally adjusted distance to the destination, prioritizing nodes closer to both. The algorithm also checks if the destination node should be prioritized directly if it is within a certain threshold distance compared to the next best node.",
          "thought": "Common ideas include balancing proximity to the current node and influence towards the destination, with a strict condition for destination prioritization. Design idea: Inspired by No.2, but incorporating a weighted score that balances proximity and destination influence with a dynamic threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = distance_to_dest / (1 + distance_to_node)\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.65:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.48605,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP by considering both the immediate distance to the candidate node and the future distance to the destination node, adjusting the balance with a weight factor that decreases as fewer nodes remain. If returning to the destination node significantly shortens the path, it prioritizes this option. The algorithm prioritizes nodes with shorter immediate distances while also accounting for their proximity to the destination, ensuring a balanced approach to minimizing the total path length.",
          "thought": "The new algorithm dynamically selects the next node by considering both immediate distance and the potential for future distances, adjusting weights as more nodes are visited, and encourages early returns to the destination node if it shortens the path significantly with a different weight and score calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = (remaining_nodes + 5) / (remaining_nodes + 15)  # Adjusted weight factor\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:  # Tightened early return condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.52931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node (via proximity_weight) and influence toward the destination (via destination_influence), while heavily favoring the destination if it's closer than 70% of the next best node's distance (strict threshold). The scoring formula dynamically adjusts weights based on unvisited nodes, and the destination is explicitly checked last to ensure its prioritization.",
          "thought": "The new algorithm combines the dynamic weighting mechanism from No.1 (balancing proximity to current node and destination influence) with the scoring formula from No.2 (prioritizing nodes closer to destination relative to immediate distance), while incorporating a stricter destination prioritization threshold (70% distance reduction).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54599,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity (70%) over destination influence (30%), dynamically adjusting the destination's weight based on remaining nodes, and forces a detour to the destination only if it's significantly closer (within 80% of the minimum distance to other unvisited nodes). The `proximity_weight` is inversely proportional to distance, while `adjusted_dest` scales the destination influence by the ratio of unvisited nodes. The code ensures the destination is chosen early if it's a strong detour, balancing local and global optimization.",
          "thought": "The new algorithm prioritizes nodes by emphasizing proximity (70%) over destination influence (30%), dynamically adjusting the destination influence based on remaining nodes, and forces a detour to the destination only if it's within 20% of the minimum distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        adjusted_dest = (distance_to_dest / distance_to_node) * (unvisited_count / (unvisited_count + 2))\n        score = (proximity_weight * 0.7) + (adjusted_dest * 0.3)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < min([distance_matrix[current_node][node] for node in unvisited_nodes]) * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.59527,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weighted 60%) and the potential to reduce the path length toward the destination (weighted 40%), while dynamically adjusting destination influence based on remaining unvisited nodes. It prioritizes proximity more heavily but includes a special case to quickly return to the destination if it significantly shortens the path. The score combines normalized proximity (inverse distance) and an adjusted destination factor, favoring nodes that efficiently bridge the gap to the destination.",
          "thought": "The new algorithm combines the proximity-based selection of No.1, the balanced scoring mechanism of No.2, and the dynamic destination influence adjustment of No.3, while introducing a novel adaptive weighting that prioritizes nodes based on their proximity and their potential to reduce the total path length, with a stronger emphasis on destination prioritization when it significantly improves the path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    min_distance = min([distance_matrix[current_node][node] for node in unvisited_nodes])\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        adjusted_dest = (distance_to_dest / distance_to_node) * (unvisited_count / (unvisited_count + 1))\n        score = (proximity_weight * 0.6) + (adjusted_dest * 0.4)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < min_distance * 0.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.59709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node and the destination, using a weighted harmonic mean to combine these factors while dynamically adjusting for remaining nodes. It penalizes longer distances and reduces the impact of the destination when many nodes remain unvisited, but ensures the destination is prioritized if it is significantly closer. The score calculation emphasizes short-term efficiency (via harmonic mean) while accounting for long-term efficiency (via remaining nodes factor and penalty).",
          "thought": "The new algorithm combines the dynamic weighting from No.2 with the harmonic mean and penalty-based scoring from No.1, using a weighted harmonic mean to balance proximity and long-term efficiency while dynamically adjusting for remaining nodes and prioritizing the destination when it is significantly closer.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    remaining_nodes_factor = remaining_nodes / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            weight = remaining_nodes / (remaining_nodes + distance_to_node)\n            score = harmonic_mean * penalty * weight * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60252,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes closer to the destination while penalizing long distances more aggressively by combining a dynamic weighting factor (`weight = remaining_nodes / (remaining_nodes + distance_to_node)`) with a score that normalizes distance ratios (`distance_to_dest / distance_to_node`) and applies a distance penalty (`1 / (1 + 2 * distance_to_node)`). It also enforces a tighter margin (15%) for overriding selection when the destination is closer, ensuring efficiency and accuracy in path selection.",
          "thought": "The new algorithm combines the dynamic weighting factor from Algorithm 2 with an enhanced scoring mechanism that prioritizes nodes closer to the destination while penalizing long distances more aggressively, and uses a tighter margin (15%) for overriding selection when the destination is closer.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + distance_to_node)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + 2 * distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60282,
          "other_inf": null
     }
]