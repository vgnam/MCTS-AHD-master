[
     {
          "algorithm": "The algorithm balances the proximity to the current node and the weighted proximity to the destination node, with a dynamic weight that reduces the influence of destination proximity as more nodes are visited. It calculates a score for each unvisited node, giving higher priority to nodes closer to the current node and those closer to the destination when fewer nodes remain, and selects the node with the best score. Additionally, it checks if the destination node should be prioritized if it is unvisited and is significantly closer than the next best node.",
          "thought": "Common ideas: Balancing proximity to the current node and weighted influence of proximity to the destination node. The No.1 algorithm uses dynamic weighting, where the influence of proximity to the destination decreases as more nodes are visited.\n\nDesign idea: Similar to No.2, balance proximity to both nodes but incorporate a dynamic weight based on the number of unvisited nodes to give more influence to the destination as fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight * 0.6) + (destination_influence * 0.4)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.47488,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP by considering both the immediate distance to the candidate node and the future distance to the destination node, adjusting the balance with a weight factor that decreases as fewer nodes remain. If returning to the destination node significantly shortens the path, it prioritizes this option. The algorithm prioritizes nodes with shorter immediate distances while also accounting for their proximity to the destination, ensuring a balanced approach to minimizing the total path length.",
          "thought": "The new algorithm dynamically selects the next node by considering both immediate distance and the potential for future distances, adjusting weights as more nodes are visited, and encourages early returns to the destination node if it shortens the path significantly with a different weight and score calculation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = (remaining_nodes + 5) / (remaining_nodes + 15)  # Adjusted weight factor\n        score = weight * (1 / (1 + distance_to_node)) + (1 - weight) * (distance_to_dest / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:  # Tightened early return condition\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.52931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with a weighted influence of proximity to the destination, decreasing as more nodes are visited. It calculates a score for each unvisited node using a dynamic weighting mechanism where proximity to the current node is inversely proportional to the distance, adjusted by the remaining unvisited nodes. If the destination node is among the unvisited nodes and is sufficiently close compared to the best candidate, it prioritizes visiting the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that balances the priority of proximity to the next node with a variable emphasis on proximity to the destination, influenced by the remaining unvisited nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = proximity_weight + destination_influence\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.75:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.5452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node (via proximity_weight) and influence toward the destination (via destination_influence), while heavily favoring the destination if it's closer than 70% of the next best node's distance (strict threshold). The scoring formula dynamically adjusts weights based on unvisited nodes, and the destination is explicitly checked last to ensure its prioritization.",
          "thought": "The new algorithm combines the dynamic weighting mechanism from No.1 (balancing proximity to current node and destination influence) with the scoring formula from No.2 (prioritizing nodes closer to destination relative to immediate distance), while incorporating a stricter destination prioritization threshold (70% distance reduction).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    unvisited_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        proximity_weight = 1 / (1 + distance_to_node)\n        destination_influence = (unvisited_count / (unvisited_count + 1)) * (distance_to_dest / (1 + distance_to_node))\n        score = (proximity_weight + destination_influence) * (1 / (1 + distance_to_node ** 2))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54599,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (distance to current node) and long-term efficiency (distance to destination), using a harmonic mean to weigh these factors, while also incorporating a penalty based on distance and dynamically adjusting for the number of remaining nodes. It prioritizes nodes with higher scores but checks if the destination is significantly closer (with a threshold of 90%) to potentially override the selection. The code structure iterates through unvisited nodes, calculates a weighted score, and dynamically adjusts priorities based on remaining nodes and destination proximity.",
          "thought": "The new algorithm combines the weighted score mechanism from No.1 (balancing proximity and long-term efficiency) with the harmonic mean and penalty approach from No.2, while adding a dynamic factor for remaining nodes and a threshold check for the destination node. It selects the next node by prioritizing nodes with a high harmonic mean score, applying a penalty based on distance, and adjusting for the number of remaining nodes, then checks if the destination is closer than the best-scored node with a threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes_factor = len(unvisited_nodes) / len(distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            harmonic_mean = 2 / ((1 / distance_to_node) + (1 / distance_to_dest))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty * (1 / (1 + distance_to_node * remaining_nodes_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.56518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor heuristic by introducing a priority score for each unvisited node, which combines the immediate distance to the current node with the average distance to all other unvisited nodes. This score is calculated as the ratio of the immediate distance to the sum of distances to all other unvisited nodes, aiming to balance short-term and long-term path efficiency. The node with the lowest score is selected as the next node to visit, prioritizing nodes that are relatively closer to the current node while also being centrally located among remaining unvisited nodes.",
          "thought": "The new algorithm modifies the nearest neighbor heuristic by introducing a priority score that combines the distance to each node and a factor representing the node's relative proximity to all other unvisited nodes, aiming to balance short-term and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_distances = {node: sum(distance_matrix[node][other] for other in unvisited_nodes) for node in unvisited_nodes}\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / total_distances[node])\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by computing a weighted harmonic mean of the distances to the current and destination nodes, and a penalty based on proximity to the previously visited node. The weight function adjusts the emphasis on proximity, prioritizing nodes that are neither too close to the starting node nor too far from the destination. The algorithm ensures the destination node is considered if it is among the unvisited nodes, prioritizing paths that minimize overall travel distance.",
          "thought": "The new algorithm selects the next node by calculating a weighted harmonic mean of the distance to the current node, the distance to the destination, and a penalty based on the current node's proximity to the previously visited node, using a novel weight function.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, previous_node=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_node == 0:\n            score = float('-inf')\n        else:\n            if previous_node is not None:\n                proximity_to_previous = distance_matrix[current_node][previous_node]\n                weight = 1 / (proximity_to_previous + 1)\n            else:\n                weight = 1\n            harmonic_mean = 3 / ((1 / distance_to_node) + (1 / distance_to_dest) + (1 / (weight + 1)))\n            penalty = 1 / distance_to_node\n            score = harmonic_mean * penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node]:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61297,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate proximity and long-term efficiency by dynamically weighting node selection based on remaining nodes, with closer-to-destination nodes favored when few nodes remain. It uses a refined scoring system combining normalized distances and a stricter early return condition (30% margin) to ensure optimal path selection. The weight parameter adjusts between proximity and destination alignment, while the score calculation ensures efficient exploration of the solution space.",
          "thought": "The new algorithm combines dynamic weighting based on remaining nodes, prioritizes nodes closer to the destination when few nodes remain, and uses a refined scoring system that balances immediate proximity and long-term efficiency, while also incorporating a stricter early return condition (30% margin) to ensure optimal path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 2)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_dest))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.7:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61309,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines three scoring mechanisms (score1, score2, score3) to balance proximity to the current node, distance to the destination, and a penalty for longer immediate distances, then selects the next node based on a weighted average of these scores. It prioritizes nodes that minimize the combined distance to the destination while penalizing longer immediate steps, and dynamically checks if the destination node should be visited next if it offers a significantly shorter path (threshold of 0.7\u00d7 best candidate distance). The destination node is explicitly considered only if it remains unvisited.",
          "thought": "The new algorithm combines the scoring mechanisms from all three algorithms, using a weighted sum of normalized scores that balance proximity to the current node, distance to the destination, and a penalty for longer immediate distances, while incorporating a dynamic threshold for selecting the destination node based on the best candidate's distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Combine scoring mechanisms from all three algorithms\n        score1 = (1 / (distance_to_node + distance_to_dest)) * distance_to_dest\n        score2 = (distance_to_dest / (distance_to_node + distance_to_dest)) * (1 / (1 + distance_to_node))\n        score3 = (distance_to_dest / (distance_to_node + distance_to_dest)) * (1 / (1 + distance_to_node ** 2))\n\n        # Normalize and combine scores\n        combined_score = (score1 + score2 + score3) / 3\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        best_distance = distance_matrix[current_node][next_node]\n        if dest_distance < best_distance * 0.7:  # Slightly stricter threshold\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61646,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing immediate proximity and long-term efficiency. It uses a weighted scoring system that adjusts based on the number of remaining unvisited nodes, prioritizing nodes closer to the destination when fewer nodes are left. Additionally, the algorithm considers returning to the destination early if it significantly shortens the path compared to continuing with the current best option.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts the balance between immediate proximity and long-term efficiency based on the remaining unvisited nodes and the current path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    \n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        # Dynamic weighting factor based on remaining nodes\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * (distance_to_dest / distance_to_node) * (1 / (1 + distance_to_node)) + (1 - weight) * (1 / (1 + distance_to_node))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        dest_distance = distance_matrix[current_node][destination_node]\n        if dest_distance < distance_matrix[current_node][next_node] * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61795,
          "other_inf": null
     }
]