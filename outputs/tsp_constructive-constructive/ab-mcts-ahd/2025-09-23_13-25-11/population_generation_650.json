[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (30% weight early, increasing later) and future cost savings (70% weight early, decreasing later), using linear decay based on remaining nodes. It evaluates each candidate by comparing current distance to the average future distance from that node, prioritizing nodes that reduce future costs while considering immediate proximity. The weights adjust dynamically to shift focus from long-term planning to local optimization as the search progresses.",
          "thought": "The new algorithm prioritizes future cost savings (70% weight) early in the search and shifts to current distance (30% weight) later, using linear decay to adjust weights based on remaining nodes, evaluating each candidate by combining immediate distance with potential future cost reduction relative to the average remaining distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    num_unvisited = len(unvisited_nodes)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight_future = 0.7 * (num_unvisited / (num_unvisited + 5))\n        weight_current = 0.3 * (1 - (num_unvisited / (num_unvisited + 5)))\n        return weight_future * (current_dist - avg_future_dist) + weight_current * current_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44949,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizing high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance. The weight for immediate distance increases as nodes are visited, while the weight for future connectivity decreases, ensuring adaptive path selection. A penalty term further discourages high-distance nodes in the final stages of the tour. The code evaluates each candidate node using these weighted criteria and selects the one with the minimal score.",
          "thought": "The new algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizes high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance, ensuring adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.3 + 0.4 * (1 - min(remaining_count / (len(distance_matrix) - 1), 1))\n    weight_adapt = 1 - weight_immediate\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        penalty = 0.1 * current_dist if remaining_count <= 3 else 0\n        return weight_immediate * current_dist + weight_adapt * (current_dist - avg_future_dist) + penalty\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.46698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances using weights (`weight_current` and `weight_future`), penalizes long detours with a dynamic `penalty_factor`, and prioritizes nodes with high clustering potential (via `clustering_potential`). It selects the next node by minimizing a weighted score that combines current distance, minimum future distance, and clustering benefits, adjusting priorities based on remaining unvisited nodes.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic threshold mechanism that adjusts the balance between immediate and future distances based on the node's potential to reduce the total path length, using a penalty factor for nodes that could create long detours, and prioritizing nodes with high clustering potential to minimize backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    penalty_factor = 0.3 * (1 - weight_current)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        clustering_potential = 1 / (1 + avg_future_dist)\n        weighted_score = weight_current * current_dist + weight_future * min_future_dist\n        penalty = penalty_factor * (current_dist + min_future_dist - avg_future_dist)\n        return weighted_score - penalty + clustering_potential\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.49521,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and long-term adaptability (40% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node. It prioritizes shorter immediate distances while avoiding nodes that offer poor future connectivity, ensuring a trade-off between proximity and long-term path efficiency. The function evaluates each unvisited node using this weighted sum and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and long-term adaptability from No.1 with the exploration-focused scoring of No.2, selecting the node with the lowest weighted sum of current distance and the difference between current and maximum future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term adaptability by computing a weighted sum where the weight adjusts based on remaining node density. Immediate distance is prioritized when node density is high (weight increases with density), while the difference between current and maximum future distance is prioritized when density is low. The evaluation function uses `density_factor` to dynamically adjust the weight, ensuring adaptability to the problem's evolution.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (prioritizing immediate distance as the tour progresses) with the long-term adaptability from No.2 (balancing immediate distance and the difference between current and maximum future distance). It evaluates each unvisited node by computing a weighted sum of the immediate distance and the difference between current distance and maximum future distance, where the weight dynamically adjusts based on the remaining unvisited nodes' density.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.4 + 0.6 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to unvisited nodes and future adaptability by weighting current distance and the difference between current and future distances, adjusting the balance based on remaining nodes and proximity to the destination. It prioritizes nodes closer to the destination while considering node density, with proximity given higher weight when the destination is nearby. The function evaluates nodes by combining weighted current and future distance metrics, ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance and future adaptability) with the proximity-based weighting from No.2 (prioritizing immediate distance near the destination). It evaluates nodes by dynamically weighting the current distance and the difference between current and future distances, while adjusting the balance based on the remaining nodes and proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        proximity_weight = 0.5 + 0.5 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.5\n        weight = 0.4 + 0.6 * density_factor\n        return (proximity_weight * (weight * current_dist + (1 - weight) * (current_dist - max_future_dist)) +\n                (1 - proximity_weight) * current_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.52299,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes short-term gains by aggressively increasing the weight of immediate distance (`weight_immediate`) as nodes are visited, while sharply reducing the influence of future connectivity (`weight_adapt`). It selects the next node by balancing the immediate distance to the candidate node and the difference between the immediate distance and the worst-case future distance from that node, favoring nodes that offer both short-term proximity and strong future connectivity. The weights dynamically adjust based on the remaining unvisited nodes, making the approach more greedy as the tour progresses.",
          "thought": "The new algorithm increases the weight of immediate distance (weight_immediate) more aggressively as nodes are visited, while reducing the influence of future connectivity (weight_adapt) more sharply, creating a more greedy approach that prioritizes short-term gains over long-term adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.4 + 0.4 * (1 - min(remaining_count / (len(distance_matrix) - 1), 1))\n    weight_adapt = 1 - weight_immediate\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return weight_immediate * current_dist + weight_adapt * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.55673,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (70% weight) and adaptability (30% weight), where adaptability is defined as the difference between the current distance and the maximum future distance from the candidate node, adjusted by unvisited node density to ensure a trade-off between short-term efficiency and long-term path optimization. Higher weights are given to proximity (current distance) when unvisited nodes are sparse, while adaptability (future distance) gains more influence in dense scenarios. The evaluation function dynamically adjusts weights based on the number of remaining nodes, ensuring a flexible trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines immediate distance prioritization with future distance evaluation, using a dynamic weight that balances proximity (70% weight) and future adaptability (30% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node, while also adjusting weights based on unvisited node density to ensure a trade-off between proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.7 + 0.3 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.56667,
          "other_inf": null
     }
]