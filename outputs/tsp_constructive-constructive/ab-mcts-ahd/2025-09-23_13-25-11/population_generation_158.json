[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the immediate distance (from current node) to the sum of distances to all other unvisited nodes. This balances short-term proximity (distance to current node) with long-term optimization (sum of distances to remaining nodes), ensuring a trade-off between immediate and future path efficiency. The key design idea is the ratio heuristic, where nodes with smaller ratios are preferred, leveraging both local and global distance considerations.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (60% weight) and long-term adaptability (40% weight) by evaluating each unvisited node as a weighted sum of its current distance from the current node and the difference between its current distance and the minimum future distance to remaining nodes. This prioritizes nodes that offer better future flexibility while maintaining local efficiency. The function iterates over unvisited nodes, computes this weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the balancing of immediate distance (60% weight) and long-term adaptability (40% weight) from No.2, with the idea of subtracting the minimum future distance from the current distance (inspired by No.1) to prioritize nodes that offer better future flexibility while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.91213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate proximity and adaptability, prioritizing adaptability (future path potential) as the path approaches the destination. It calculates weights inversely proportional to the current node's distance to the destination, ensuring adaptability becomes more critical as the path nears the destination. The `evaluate_node` function computes a weighted sum of the current distance and the difference between current and minimum future distances, with weights adjusting based on proximity to the destination.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment between immediate proximity and adaptability, where weights are inversely proportional to the current node's distance to the destination, ensuring adaptability becomes more critical as the path approaches the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        dest_dist = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.45 * (1 - (dest_dist / (dest_dist + current_dist)))\n        return weight * current_dist + (1 - weight) * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.92787,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (70% weight) and long-term adaptability (30% weight), where adaptability is measured by the difference between the current distance to a node and the minimum future distance from that node to remaining unvisited nodes. The function prioritizes nodes that are both close to the current node and likely to lead to efficient future paths, ensuring a trade-off between greedy selection and forward-looking optimization. The weights (0.7 and 0.3) explicitly reflect this prioritization, with distance to the current node dominating the decision.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with a weighted balance between immediate distance (70% weight) and long-term adaptability (30% weight), similar to No.1, to select the next node by evaluating a weighted sum of current distance and the difference between current and minimum future distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.7 * current_dist + 0.3 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.95114,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (65% weight) and long-term adaptability (35% weight) by evaluating each unvisited node based on its direct distance from the current node and the minimum future distance to remaining nodes. The 65-35 split prioritizes short-term efficiency while accounting for potential future costs, ensuring a trade-off between immediate gains and long-term feasibility. The `evaluate_node` function computes a weighted score, and the algorithm selects the node with the lowest score as the next step.",
          "thought": "The new algorithm combines the balanced approach of No.1 (60-40 split) with the prioritization of immediate proximity from No.2 (70-30 split), creating a 65-35 balance to better capture both short-term efficiency and long-term adaptability, while maintaining a focus on immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.65 * current_dist + 0.35 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.95115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization with future distance evaluation, dynamically adjusting weights based on unvisited node density. It prioritizes closer nodes (higher weight for `current_dist`) but balances this with potential future distances (lower weight for `current_dist - min_future_dist`), with the weight itself adapting to problem scale via `density_factor`. The function evaluates each unvisited node by this weighted sum and selects the node with the minimal score.",
          "thought": "This new algorithm combines the proximity prioritization from No.1 with the balanced evaluation of immediate and future distances from No.2, but introduces a dynamic weight adjustment based on the remaining unvisited nodes' density to better adapt to varying problem scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.7 + 0.3 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.97484,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (50% weight) and future adaptability (50% weight) by evaluating each unvisited node as a weighted sum of its current distance from the current node and the difference between its current distance and the minimum future distance to remaining nodes. This ensures local efficiency while anticipating future constraints, with the current distance given equal priority to the future distance factor. The `evaluate_node` function computes this weighted score, and the next node is selected based on the minimum score.",
          "thought": "The new algorithm combines the immediate distance weighting (50%) from No.2 with the adaptive future distance weighting (50%) from No.1, where the future distance factor is the difference between the current distance and the minimum future distance to remaining nodes, ensuring local efficiency and future adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.5 * current_dist + 0.5 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.99647,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node to the current node, using the distance matrix to minimize incremental travel distance. If no unvisited nodes remain, it returns to the destination. The key design choices are prioritizing proximity (via `min` and `distance_matrix`) and handling termination (via `destination_node`).",
          "thought": "The algorithm selects the next node to visit from the unvisited nodes by choosing the node closest to the current node, aiming to minimize the total travel distance incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance and future impact, with weights favoring immediate distance early in the tour and future impact as more nodes remain unvisited. It prioritizes minimizing both the current step's distance and potential future path lengths, with a dynamic weight (`dynamic_weight`) that increases the influence of immediate distance as the tour progresses. The `evaluate_node` function computes a weighted sum of current distance and future impact, where the weight shifts from 0.5 to 0.9 as nodes are visited.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment that prioritizes nodes based on both immediate distance and a forward-looking heuristic that considers the potential impact of choosing a node on the remaining tour length, with weights adjusted based on the proportion of unvisited nodes remaining.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1  # Including current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        future_impact = (current_dist - min_future_dist) if remaining_nodes else 0\n        dynamic_weight = 0.5 + 0.4 * remaining_ratio  # Adjust weight based on remaining nodes\n        return dynamic_weight * current_dist + (1 - dynamic_weight) * future_impact\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.00629,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity and future savings by adjusting weights based on remaining nodes, prioritizing future savings as the tour progresses. It evaluates each unvisited node by combining the direct distance from the current node with a weighted minimum future distance, where the weight decreases as more nodes are visited. The code dynamically adjusts priorities\u2014favoring future savings later in the tour\u2014by scaling the weight of future distances with the proportion of remaining nodes.",
          "thought": "The new algorithm combines the balanced evaluation of immediate proximity and future savings from No.1 with the dynamic weighting approach of No.2, adjusting weights based on the number of remaining nodes to prioritize strategic decisions later in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.02657,
          "other_inf": null
     }
]