importance in the remaining path. It dynamically adjusts selection probabilities based on a weighted combination of distance and promise, using a softmax function to ensure exploration of promising nodes while preserving some randomness for adaptability.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if not remaining_nodes:
            return current_dist

        # Calculate promise: average of min distances to remaining nodes
        promise = sum(min(distance_matrix[node][other] for other in remaining_nodes) for other in remaining_nodes) / len(remaining_nodes)

        # Calculate centrality: average distance to remaining nodes
        centrality = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)

        # Dynamic weight based on remaining nodes and centrality
        exploration_weight = 0.7 * (len(remaining_nodes) / len(unvisited_nodes)) + 0.3 * (centrality / max(centrality, 1e-6))

        # Combine distance and promise with exploration weight
        score = (1 - exploration_weight) * current_dist + exploration_weight * promise

        return score

    # Calculate probabilities using softmax
    scores = [evaluate_node(node) for node in unvisited_nodes]
    exp_scores = [math.exp(-score) for score in scores]
    sum_exp = sum(exp_scores)
    probabilities = [exp_score / sum_exp for exp_score in exp_scores]

    # Select node based on probabilities
    next_node = random.choices(list(unvisited_nodes), weights=probabilities, k=1)[0]
    return next_node
