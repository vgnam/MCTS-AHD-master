def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    weight_immediate = 0.7 if remaining_count > 10 else 0.5
    weight_future = 0.3 if remaining_count > 10 else 0.5

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if not remaining_nodes:
            return current_dist

        # Calculate future potential: sum of distances from node to all remaining nodes
        future_potential = sum(distance_matrix[node][other] for other in remaining_nodes)

        # Calculate average future distance (as in original)
        avg_future_dist = future_potential / len(remaining_nodes)

        # Novel: Combine immediate distance and future potential with adjusted weights
        score = (weight_immediate * current_dist) + (weight_future * (1 / (1 + future_potential)))

        return score

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
