defined as the difference between the current distance and the average distance to remaining nodes, and the weight between these factors is adjusted based on the ratio of remaining nodes to total nodes, favoring exploration when more nodes are left.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if not remaining_nodes:
            return current_dist

        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)
        adaptability = current_dist - avg_future_dist

        exploration_weight = len(remaining_nodes) / len(unvisited_nodes)

        return (1 - exploration_weight) * current_dist + exploration_weight * adaptability

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
