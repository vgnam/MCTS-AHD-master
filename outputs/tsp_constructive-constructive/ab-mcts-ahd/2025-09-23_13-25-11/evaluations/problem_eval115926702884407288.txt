def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if not remaining_nodes:
            return current_dist

        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)
        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)
        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)

        weight = len(remaining_nodes) / len(unvisited_nodes)
        exploration_factor = 0.2 * (max_future_dist - min_future_dist) / (1 + avg_future_dist)

        normalized_evaluation = (1 - weight) * current_dist + weight * (0.7 * min_future_dist + 0.3 * exploration_factor)
        return normalized_evaluation / (1 + min_future_dist)

    candidates = list(unvisited_nodes)
    evaluations = [evaluate_node(node) for node in candidates]

    min_eval = min(evaluations)
    max_eval = max(evaluations)

    if max_eval == min_eval:
        return random.choice(candidates)

    normalized_scores = [(max_eval - eval) / (max_eval - min_eval) for eval in evaluations]
    next_node = random.choices(candidates, weights=normalized_scores, k=1)[0]

    return next_node
