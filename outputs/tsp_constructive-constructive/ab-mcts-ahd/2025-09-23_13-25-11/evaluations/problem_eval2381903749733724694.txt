import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if not remaining_nodes:
            return current_dist

        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)
        exploration_factor = (len(remaining_nodes) ** 2) / (len(unvisited_nodes) ** 2 + 1)
        weighted_score = (1 - exploration_factor) * current_dist + exploration_factor * avg_future_dist
        return weighted_score

    scores = {node: evaluate_node(node) for node in unvisited_nodes}
    min_score = min(scores.values())
    candidates = [node for node, score in scores.items() if score == min_score]

    if len(candidates) == 1:
        return candidates[0]
    else:
        probabilities = [1 / (score - min_score + 1) for score in scores.values()]
        total = sum(probabilities)
        probabilities = [p / total for p in probabilities]
        return next_node
