def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate the average distance from each unvisited node to all other unvisited nodes
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)

    # Dynamic weight based on remaining nodes and centrality of the remaining graph
    remaining_nodes = len(unvisited_nodes)
    weight = remaining_nodes / (remaining_nodes + 1)

    # Penalize nodes that are already close to the current node (avoid revisiting)
    penalty = {node: 1 / (1 + distance_matrix[current_node][node]) for node in unvisited_nodes}

    # Select the node minimizing a weighted sum of distance to current, distance to destination, and centrality
    next_node = min(unvisited_nodes, key=lambda node:
                   weight * distance_matrix[current_node][node] +
                   (1 - weight) * distance_matrix[node][destination_node] +
                   0.5 * centrality[node] - 0.3 * penalty[node])

    return next_node
