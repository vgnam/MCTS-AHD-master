def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    current_to_dest = distance_matrix[current_node][destination_node]
    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)

    def weight_function(node):
        decay_factor = 0.5
        proximity_weight = 0.3 + 0.7 * (decay_factor ** (distance_matrix[current_node][destination_node] / max_distance)) if max_distance > 0 else 0.3
        return (proximity_weight * distance_matrix[current_node][node] +
                (1 - proximity_weight) * distance_matrix[node][destination_node])

    next_node = min(unvisited_nodes, key=weight_function)
    return next_node
