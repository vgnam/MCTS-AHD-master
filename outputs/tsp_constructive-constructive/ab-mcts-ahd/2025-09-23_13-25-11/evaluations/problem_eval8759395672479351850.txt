def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    total_nodes = len(unvisited_nodes) + 1
    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0
    temperature = 1.0 + 0.5 * remaining_ratio
    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if not remaining_nodes:
            return current_dist
        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)
        future_impact = (current_dist - min_future_dist) if remaining_nodes else 0
        dynamic_weight = 0.3 + 0.5 * remaining_ratio
        return dynamic_weight * current_dist + (1 - dynamic_weight) * future_impact
    scores = {node: evaluate_node(node) for node in unvisited_nodes}
    max_score = max(scores.values())
    probabilities = {node: math.exp((max_score - score) / temperature) for node, score in scores.items()}
    total_prob = sum(probabilities.values())
    normalized_probs = {node: prob / total_prob for node, prob in probabilities.items()}
    next_node = random.choices(list(normalized_probs.keys()), weights=list(normalized_probs.values()), k=1)[0]
    return next_node
