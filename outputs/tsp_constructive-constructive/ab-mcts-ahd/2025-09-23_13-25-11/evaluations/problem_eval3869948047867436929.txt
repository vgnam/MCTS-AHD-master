def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    unvisited_count = len(unvisited_nodes)
    exploration_weight = max(0.1, 0.5 - 0.4 * (unvisited_count / len(distance_matrix)))
    lookahead_depth = min(3, unvisited_count)

    def heuristic_weight(node):
        immediate_cost = distance_matrix[current_node][node]
        multi_step_cost = 0
        current = node

        for _ in range(lookahead_depth):
            if not unvisited_nodes:
                break
            next_candidates = [n for n in unvisited_nodes if n != current]
            if not next_candidates:
                break
            next_node = min(next_candidates, key=lambda x: distance_matrix[current][x])
            multi_step_cost += distance_matrix[current][next_node]
            current = next_node

        penalty = 1.0 if node in unvisited_nodes[-3:] else 1.0
        return immediate_cost + exploration_weight * multi_step_cost * penalty

    next_node = min(unvisited_nodes, key=heuristic_weight)
    return next_node
