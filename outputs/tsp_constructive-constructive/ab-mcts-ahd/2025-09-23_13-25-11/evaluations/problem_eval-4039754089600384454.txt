def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}

        if not remaining_nodes:
            return current_dist

        # Calculate average and minimum future distances
        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)
        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)

        # Dynamic weight adjustment with sigmoid function
        total_unvisited = len(unvisited_nodes)
        progress = 1 - 1 / total_unvisited
        immediate_weight = 1 / (1 + np.exp(-10 * (progress - 0.5)))  # Sigmoid-based weight
        future_weight = 1 - immediate_weight

        # Heuristic: blend average and minimum future distances
        future_cost = 0.7 * avg_future_dist + 0.3 * min_future_dist

        return immediate_weight * current_dist + future_weight * future_cost

    # Probabilistic selection to escape local optima
    candidates = list(unvisited_nodes)
    scores = [evaluate_node(node) for node in candidates]
    min_score = min(scores)
    normalized_scores = [np.exp(-(score - min_score)) for score in scores]  # Convert to probabilities
    total = sum(normalized_scores)
    probabilities = [score / total for score in normalized_scores]
    next_node = np.random.choice(candidates, p=probabilities)

    return next_node
