defined as the average distance to all other nodes, to balance exploration and exploitation more effectively. The algorithm adjusts weights dynamically based on the remaining nodes and centrality to prioritize nodes that are both close and well-connected early on, transitioning to a more strategic focus as the tour progresses.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1
    remaining_nodes = len(unvisited_nodes)

    # Calculate dynamic weights
    weight_current = (remaining_nodes / total_nodes) ** 2
    weight_future = (1 - weight_current) * (1 - remaining_nodes / total_nodes)
    weight_centrality = 1 - (weight_current + weight_future)

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]

        # Calculate node centrality (average distance to all other nodes)
        if not unvisited_nodes - {node}:
            centrality = 0
        else:
            centrality = sum(distance_matrix[node][other] for other in unvisited_nodes - {node}) / len(unvisited_nodes - {node})

        if not unvisited_nodes - {node}:
            return current_dist

        max_future_dist = max(distance_matrix[node][other] for other in unvisited_nodes - {node})

        return (weight_current * current_dist +
                weight_future * max_future_dist +
                weight_centrality * centrality)

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
