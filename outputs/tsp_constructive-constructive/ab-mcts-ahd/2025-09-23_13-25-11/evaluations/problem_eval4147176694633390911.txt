def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1
    remaining_nodes = len(unvisited_nodes)

    # Calculate centrality metrics for the current node
    def calculate_centrality(node):
        # Closeness centrality: average distance to all other nodes
        closeness = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes

        # Betweenness centrality approximation: count how many shortest paths pass through this node
        betweenness = 0
        for n1 in unvisited_nodes:
            for n2 in unvisited_nodes:
                if n1 != n2 and n1 != node and n2 != node:
                    if distance_matrix[n1][node] + distance_matrix[node][n2] == distance_matrix[n1][n2]:
                        betweenness += 1
        betweenness /= (remaining_nodes * (remaining_nodes - 1)) if remaining_nodes > 1 else 1

        return closeness, betweenness

    # Dynamic weights based on current node's centrality
    current_closeness, current_betweenness = calculate_centrality(current_node)
    weight_current = (current_closeness / (current_closeness + current_betweenness + 1e-6)) ** 0.5
    weight_future = 1 - weight_current

    # Exploration factor that decays as the algorithm progresses
    exploration_factor = (remaining_nodes / total_nodes) ** 1.5

    def heuristic(node):
        current_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]

        # Combine distance metrics with centrality and exploration
        centrality_score = weight_current * current_dist + weight_future * future_dist

        # Add exploration component to encourage diverse paths
        exploration_score = exploration_factor * (distance_matrix[current_node][node] +
                                                 distance_matrix[node][destination_node])

        return centrality_score + exploration_score

    next_node = min(unvisited_nodes, key=heuristic)
    return next_node
