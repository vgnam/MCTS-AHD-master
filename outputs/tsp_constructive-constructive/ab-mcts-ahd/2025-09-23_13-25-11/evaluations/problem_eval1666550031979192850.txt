import math
import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if not remaining_nodes:
            return current_dist

        future_dists = [distance_matrix[node][other] for other in remaining_nodes]
        min_future_dist = min(future_dists)
        mean_future_dist = sum(future_dists) / len(future_dists)
        var_future_dist = sum((d - mean_future_dist) ** 2 for d in future_dists) / len(future_dists)

        scaling_factor = len(remaining_nodes) / len(unvisited_nodes)
        dynamic_weight = 0.7 * scaling_factor * (1 + var_future_dist)

        temperature = 1.0 - scaling_factor
        prob = math.exp(-dynamic_weight * min_future_dist / temperature)
        return current_dist + prob * min_future_dist

    candidates = list(unvisited_nodes)
    weights = [1 / (1 + evaluate_node(node)) for node in candidates]
    total_weight = sum(weights)
    normalized_weights = [w / total_weight for w in weights]

    next_node = random.choices(candidates, weights=normalized_weights, k=1)[0]
    return next_node
