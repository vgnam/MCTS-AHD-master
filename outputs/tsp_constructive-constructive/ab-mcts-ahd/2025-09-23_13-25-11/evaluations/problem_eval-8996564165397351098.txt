def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = unvisited_nodes - {node}
        if not remaining_nodes:
            return current_dist
        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)
        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1
        weight = 0.3 + 0.7 * density_factor
        score = weight * current_dist + (1 - weight) * avg_future_dist
        return score

    scores = {node: evaluate_node(node) for node in unvisited_nodes}
    min_score = min(scores.values())
    max_score = max(scores.values())
    normalized_scores = {node: (max_score - score) / (max_score - min_score) for node, score in scores.items()}
    probabilities = [normalized_scores[node] for node in unvisited_nodes]
    probabilities = [p / sum(probabilities) for p in probabilities]
    next_node = random.choices(list(unvisited_nodes), weights=probabilities, k=1)[0]
    return next_node
