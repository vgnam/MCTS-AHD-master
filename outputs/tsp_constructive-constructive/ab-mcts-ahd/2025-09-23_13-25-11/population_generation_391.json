[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and long-term adaptability (40% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node. It prioritizes shorter immediate distances while avoiding nodes that offer poor future connectivity, ensuring a trade-off between proximity and long-term path efficiency. The function evaluates each unvisited node using this weighted sum and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and long-term adaptability from No.1 with the exploration-focused scoring of No.2, selecting the node with the lowest weighted sum of current distance and the difference between current and maximum future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term adaptability by computing a weighted sum where the weight adjusts based on remaining node density. Immediate distance is prioritized when node density is high (weight increases with density), while the difference between current and maximum future distance is prioritized when density is low. The evaluation function uses `density_factor` to dynamically adjust the weight, ensuring adaptability to the problem's evolution.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (prioritizing immediate distance as the tour progresses) with the long-term adaptability from No.2 (balancing immediate distance and the difference between current and maximum future distance). It evaluates each unvisited node by computing a weighted sum of the immediate distance and the difference between current distance and maximum future distance, where the weight dynamically adjusts based on the remaining unvisited nodes' density.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.4 + 0.6 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (70% weight) and adaptability (30% weight), where adaptability is defined as the difference between the current distance and the maximum future distance from the candidate node, adjusted by unvisited node density to ensure a trade-off between short-term efficiency and long-term path optimization. Higher weights are given to proximity (current distance) when unvisited nodes are sparse, while adaptability (future distance) gains more influence in dense scenarios. The evaluation function dynamically adjusts weights based on the number of remaining nodes, ensuring a flexible trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines immediate distance prioritization with future distance evaluation, using a dynamic weight that balances proximity (70% weight) and future adaptability (30% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node, while also adjusting weights based on unvisited node density to ensure a trade-off between proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.7 + 0.3 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.56667,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts weights between immediate distance and future connectivity based on the number of remaining unvisited nodes. When few nodes remain, it prioritizes proximity (weight_immediate increases up to 80%) while reducing the influence of future connectivity (weight_adapt decreases to 20%). The evaluation function balances current distance and the maximum potential future distance to the next node, ensuring adaptability to the remaining problem size.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where the weight for immediate distance is increased (up to 80%) when few nodes remain, while adaptability weight is reduced (down to 20%), prioritizing proximity in the final stages while still considering future connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.6 + 0.2 * (1 - min(remaining_count / (len(distance_matrix) - 1), 1))\n    weight_adapt = 1 - weight_immediate\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return weight_immediate * current_dist + weight_adapt * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.56953,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two key factors: immediate proximity (70% weight) and long-term adaptability (30% weight). It prioritizes the shortest current distance to the next node while penalizing choices that leave long, distant future connections, ensuring a balance between short-term efficiency and long-term flexibility. The `evaluate_node` function computes this weighted sum, and the algorithm selects the node with the minimal score.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with a 70% weight and incorporates long-term adaptability from No.1 with a 30% weight, where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node, ensuring a balance between immediate and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.7 * current_dist + 0.3 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.57643,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the immediate distance (from current node) to the sum of distances to all other unvisited nodes. This balances short-term proximity (distance to current node) with long-term optimization (sum of distances to remaining nodes), ensuring a trade-off between immediate and future path efficiency. The key design idea is the ratio heuristic, where nodes with smaller ratios are preferred, leveraging both local and global distance considerations.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on a weighted balance between immediate distance from the current node and the average future distances to remaining unvisited nodes. It dynamically adjusts weights by dividing the immediate distance by the sum of future distances (plus 1 to avoid division by zero), favoring nodes that offer a good short-term/long-term trade-off. The structure ensures the destination node is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines the proximity prioritization of No.1 with the ratio heuristic of No.2, and introduces a dynamic weight adjustment to balance immediate and future distances, ensuring a more adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weights = {node: (distance_matrix[current_node][node] / (sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) + 1)) for node in unvisited_nodes}\n    next_node = min(weights, key=weights.get)\n    return next_node",
          "objective": 6.6581,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term path potential by adjusting weights inversely proportional to node density: closer nodes in dense regions are prioritized, while future distances dominate in sparse areas. The `evaluate_node` function computes a weighted score combining current distance (`current_dist`) and a modified future distance term (`current_dist - avg_future_dist`), with weights (`weight`) inversely scaled by density. The algorithm selects the node with the minimum score, ensuring a trade-off between proximity and future path efficiency.",
          "thought": "The new algorithm prioritizes nodes based on a dynamic balance between immediate distance and long-term path potential, adjusting weights inversely proportional to unvisited node density to favor closer nodes in dense regions while considering future distances in sparse areas.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        density_factor = len(remaining_nodes) / (len(distance_matrix) - 1)\n        weight = 0.5 + 0.5 * (1 - density_factor)\n        return weight * current_dist + (1 - weight) * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.6661,
          "other_inf": null
     }
]