[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the immediate distance (from current node) to the sum of distances to all other unvisited nodes. This balances short-term proximity (distance to current node) with long-term optimization (sum of distances to remaining nodes), ensuring a trade-off between immediate and future path efficiency. The key design idea is the ratio heuristic, where nodes with smaller ratios are preferred, leveraging both local and global distance considerations.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (60% weight) and long-term adaptability (40% weight) by evaluating each unvisited node as a weighted sum of its current distance from the current node and the difference between its current distance and the minimum future distance to remaining nodes. This prioritizes nodes that offer better future flexibility while maintaining local efficiency. The function iterates over unvisited nodes, computes this weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the balancing of immediate distance (60% weight) and long-term adaptability (40% weight) from No.2, with the idea of subtracting the minimum future distance from the current distance (inspired by No.1) to prioritize nodes that offer better future flexibility while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.91213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node to the current node, using the distance matrix to minimize incremental travel distance. If no unvisited nodes remain, it returns to the destination. The key design choices are prioritizing proximity (via `min` and `distance_matrix`) and handling termination (via `destination_node`).",
          "thought": "The algorithm selects the next node to visit from the unvisited nodes by choosing the node closest to the current node, aiming to minimize the total travel distance incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity and future savings by adjusting weights based on remaining nodes, prioritizing future savings as the tour progresses. It evaluates each unvisited node by combining the direct distance from the current node with a weighted minimum future distance, where the weight decreases as more nodes are visited. The code dynamically adjusts priorities\u2014favoring future savings later in the tour\u2014by scaling the weight of future distances with the proportion of remaining nodes.",
          "thought": "The new algorithm combines the balanced evaluation of immediate proximity and future savings from No.1 with the dynamic weighting approach of No.2, adjusting weights based on the number of remaining nodes to prioritize strategic decisions later in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.02657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting weights inversely proportional to the number of remaining unvisited nodes. It prioritizes minimizing immediate distance early in the tour (high `weight_current`) and future savings later (high `weight_future`), ensuring a smooth transition from greedy to strategic node selection. The `evaluate_node` function computes a weighted sum of current distance and minimum future distance to the nearest unvisited node, guiding the selection of the next node.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight adjustment mechanism that balances current distance and future savings, where weights are inversely proportional to the number of remaining unvisited nodes, ensuring a smoother transition from local to global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return weight_current * current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.04196,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting weights based on remaining unvisited nodes: early stages prioritize minimizing current distance (weight_current), while later stages emphasize future savings (weight_future). The `evaluate_node` function computes a weighted sum of current distance and the minimum future distance to the next node, guiding selection toward a trade-off between short-term and long-term optimality.",
          "thought": "The new algorithm adjusts node selection by emphasizing immediate distance early and future connectivity later, using a dynamic weight scheme that prioritizes minimizing current distance with a decaying factor for future savings, ensuring a balance between greediness and strategic planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = (remaining_nodes / total_nodes) ** 2\n    weight_future = 1 - (weight_current ** 0.5)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return weight_current * current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.05017,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm dynamically balances local and global optimization by adjusting weights inversely proportional to the number of remaining unvisited nodes, prioritizing immediate distances when few nodes remain (higher `weight_current`) and future potential (higher `weight_future`) when many nodes are left. It uses a lookahead mechanism (summing the two smallest future distances) to estimate global impact, with `min_future_dist` (60%) and `lookahead_dist` (40%) weighted to balance immediate and long-term considerations. The `evaluate_node` function combines these factors to select the next node, ensuring a trade-off between greedy and forward-looking strategies.",
          "thought": "The new algorithm combines the balanced evaluation of No.1 and No.2 by dynamically adjusting weights inversely proportional to the number of remaining unvisited nodes, while also incorporating a lookahead mechanism to estimate the impact of selecting a node on future path segments, ensuring both local and global optimization throughout the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        lookahead_dist = sum(sorted(distance_matrix[node][other] for other in unvisited_nodes - {node})[:2]) if len(unvisited_nodes) > 2 else min_future_dist\n        return weight_current * current_dist + weight_future * (0.6 * min_future_dist + 0.4 * lookahead_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.06859,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the weight between immediate distance and average future distance, prioritizing immediate distance early (higher weight) and balancing both later (lower immediate weight). The `immediate_weight` increases and `future_weight` decreases as the number of unvisited nodes decreases, ensuring closer nodes are favored initially while considering future costs as the tour progresses. The evaluation function combines weighted distances to select the next node, minimizing the total path cost.",
          "thought": "The new algorithm modifies the provided one by incorporating a dynamic weight adjustment based on the remaining path length, where weights for immediate distance and average future distance are inversely proportional to the number of unvisited nodes, favoring immediate distance in early stages and balancing both in later stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        total_unvisited = len(unvisited_nodes)\n        immediate_weight = 0.6 + 0.4 * (1 - 1 / total_unvisited)\n        future_weight = 0.4 - 0.4 * (1 - 1 / total_unvisited)\n        return immediate_weight * current_dist + future_weight * avg_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.07486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing current distance (prioritized early with 60% weight) and future distance savings (prioritized later with 40% weight), dynamically adjusting weights based on remaining unvisited nodes (using exponential decay). It evaluates each candidate node by combining the immediate distance to it and the potential future cost reduction relative to the best remaining option.",
          "thought": "The new algorithm combines the weighted evaluation of current and future distances from No.1 with the dynamic weight adjustment based on remaining nodes from No.2, using a balance that prioritizes immediate distance early (60% weight) and gradually shifts to future distance difference (40% weight) as unvisited nodes decrease, with exponential decay in weights.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    num_unvisited = len(unvisited_nodes)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        weight_current = 0.6 * (0.9 ** num_unvisited)\n        weight_future = 0.4 * (1 - (0.9 ** num_unvisited))\n        return weight_current * current_dist + weight_future * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.11736,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (minimizing `current_dist`) and long-term adaptability (maximizing `min_future_dist`), prioritizing the latter by subtracting it from the former in the `evaluate_node` function. It ensures the path remains efficient while avoiding future flexibility loss.",
          "thought": "The new algorithm prioritizes minimizing future flexibility (maximizing the minimum distance to remaining unvisited nodes) while also considering immediate proximity, balancing both factors to select the next node that optimizes the trade-off between short-term efficiency and long-term adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist - min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.14415,
          "other_inf": null
     }
]