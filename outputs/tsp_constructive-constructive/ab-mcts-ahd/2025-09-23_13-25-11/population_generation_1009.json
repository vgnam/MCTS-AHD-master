[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and global costs by adjusting weights based on remaining nodes: higher immediate weight (decaying) for short-term savings and higher global weight (increasing) for long-term gains, scaled by the difference between current distance and average future distance. Nodes prioritized reduce future costs by favoring those with lower immediate distances and higher future cost savings. The key design is the weighted sum combining immediate distance and global cost difference, where the balance shifts toward global optimization as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the cost-saving evaluation from No.1, using a decaying immediate weight and an increasing global weight scaled by the number of remaining nodes, while also incorporating the difference between current distance and average future distance to prioritize nodes that reduce future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    weight_immediate = 1 / (1 + remaining_nodes)\n    weight_global = remaining_nodes / (1 + remaining_nodes)\n    next_node = min(unvisited_nodes, key=lambda node: weight_immediate * distance_matrix[current_node][node] + weight_global * (distance_matrix[current_node][node] - sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1 if remaining_nodes > 1 else 1)))\n    return next_node",
          "objective": 6.44051,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance optimization with global path diversity by dynamically balancing immediate distance and adaptability (difference between current and average future distances) using a weighted score, while penalizing nodes with low connectivity to avoid dead-ends. The weight between exploration (adaptability) and exploitation (distance) is adjusted based on remaining nodes and connectivity, with dead-end penalties applied more strongly when few connections exist.",
          "thought": "The new algorithm introduces a hybrid selection mechanism that combines local distance optimization with global path diversity by incorporating a reinforcement learning-inspired exploration-exploitation trade-off, where the weight between immediate distance and adaptability is dynamically adjusted based on node connectivity and remaining path length, while also penalizing nodes that create potential dead-ends.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n\n        if not remaining_nodes:\n            return current_dist\n\n        # Calculate connectivity (number of direct connections to remaining nodes)\n        connectivity = sum(1 for other in remaining_nodes if distance_matrix[node][other] < float('inf'))\n\n        # Calculate potential dead-end penalty (nodes with few connections to remaining nodes)\n        dead_end_penalty = 1 / (1 + connectivity)\n\n        # Calculate adaptability as the difference between current distance and average future distance\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        adaptability = current_dist - avg_future_dist\n\n        # Dynamic weight based on remaining nodes and connectivity\n        exploration_weight = 0.7 * (len(remaining_nodes) / len(unvisited_nodes)) + 0.3 * (connectivity / len(remaining_nodes))\n\n        # Combine metrics with dynamic weighting\n        score = (1 - exploration_weight) * current_dist + exploration_weight * adaptability\n        score += 0.2 * dead_end_penalty  # Penalize dead-ends more when few connections exist\n\n        return score\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44663,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future adaptability by adjusting weights based on the number of remaining unvisited nodes. Early in the process, it prioritizes minimizing the current step's distance (70% weight) but gradually shifts focus to future adaptability (30% weight) as fewer nodes remain. The weight is calculated as `len(remaining_nodes) / len(unvisited_nodes)`, ensuring higher emphasis on immediate distance when many nodes are unvisited and more on future adaptability as the tour nears completion. The `evaluate_node` function computes a weighted score for each candidate node, combining current distance and average future distance, while `min(unvisited_nodes, key=evaluate_node)` selects the optimal next node.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance and future adaptability) with the weighted local-global approach from No.2 (using 70% immediate distance and 30% future distance), but replaces the fixed weights with a dynamic weight that decreases as the number of unvisited nodes decreases, prioritizing immediate distance early and future adaptability later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return 0.7 * (1 - weight) * current_dist + 0.3 * weight * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, future connectivity, and exploration by adjusting weights based on remaining nodes, prioritizing closer nodes early (high `weight_immediate`) and balancing exploration (`exploration_weight`) as the tour progresses. Future connectivity is evaluated via average remaining distances (`avg_future_dist`), while exploration encourages revisiting the destination (`exploration_term`). Weights scale inversely with unvisited nodes, ensuring adaptive behavior.",
          "thought": "The new algorithm combines the ratio heuristic from No.2 with adaptive weights for immediate and future distances from No.1, dynamically adjusting exploration based on remaining nodes. It minimizes a weighted sum of immediate distance, future connectivity, and exploration, with weights scaling with unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    unvisited_count = len(unvisited_nodes)\n    exploration_weight = max(0.1, 0.5 - 0.4 * (unvisited_count / len(distance_matrix)))\n    weight_immediate = 0.3 + 0.4 * (1 - min(unvisited_count / (len(distance_matrix) - 1), 1))\n    weight_future = 1 - weight_immediate\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        exploration_term = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) if sum(distance_matrix[node]) > 0 else 0\n        return weight_immediate * immediate_dist + weight_future * (immediate_dist - avg_future_dist) + exploration_weight * exploration_term\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44895,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (30% weight early, increasing later) and future cost savings (70% weight early, decreasing later), using linear decay based on remaining nodes. It evaluates each candidate by comparing current distance to the average future distance from that node, prioritizing nodes that reduce future costs while considering immediate proximity. The weights adjust dynamically to shift focus from long-term planning to local optimization as the search progresses.",
          "thought": "The new algorithm prioritizes future cost savings (70% weight) early in the search and shifts to current distance (30% weight) later, using linear decay to adjust weights based on remaining nodes, evaluating each candidate by combining immediate distance with potential future cost reduction relative to the average remaining distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    num_unvisited = len(unvisited_nodes)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight_future = 0.7 * (num_unvisited / (num_unvisited + 5))\n        weight_current = 0.3 * (1 - (num_unvisited / (num_unvisited + 5)))\n        return weight_future * (current_dist - avg_future_dist) + weight_current * current_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44949,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future adaptability, with higher priority given to immediate distance when nodes are dense (weighted more heavily) and to future adaptability when sparse (weighted less). The `evaluate_node` function computes a weighted score combining the current distance and the difference between current and average future distances, where the weight dynamically adjusts based on the density of remaining nodes. The `select_next_node` function then picks the node with the minimum score, ensuring a trade-off between short-term efficiency and long-term flexibility.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (based on remaining nodes) with the density-sensitive weighting of No.2, prioritizing immediate distance when nodes are dense and balancing with future adaptability when sparse.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.5 * (1 - density_factor)\n        return weight * current_dist + (1 - weight) * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.45002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance and future connectivity adaptively, with exploration weight decreasing as nodes remain and a penalty for high-distance nodes in final stages. It prioritizes immediate distance early but shifts to future connectivity later, while exploration encourages paths toward the destination, especially when few nodes remain. The weights (`weight_immediate`, `weight_future`, `exploration_weight`) dynamically adjust based on the number of unvisited nodes, and the penalty term discourages long final hops.",
          "thought": "The new algorithm combines dynamic exploration-exploitation balance, adaptive weighting between immediate distance and future connectivity, and penalty terms to discourage high-distance nodes in final stages, similar to No.1, but with a simplified exploration term inspired by No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    unvisited_count = len(unvisited_nodes)\n    exploration_weight = max(0.1, 0.5 - 0.4 * (unvisited_count / len(distance_matrix)))\n    weight_immediate = 0.3 + 0.4 * (1 - min(unvisited_count / (len(distance_matrix) - 1), 1))\n    weight_future = 1 - weight_immediate\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        exploration_term = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) if sum(distance_matrix[node]) > 0 else 0\n        penalty = 0.1 * immediate_dist if unvisited_count <= 3 else 0\n        return weight_immediate * immediate_dist + weight_future * (immediate_dist - avg_future_dist) + exploration_weight * exploration_term + penalty\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.45211,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (balancing immediate distance and global cost savings) with adaptability by weighting the immediate distance and future cost savings, where weights adjust based on remaining nodes. It prioritizes immediate distance when few nodes remain (high `weight_immediate`) and global savings when many nodes remain (high `weight_global`). Centrality is also considered to balance exploration and exploitation, with higher centrality nodes influencing selection more. The `evaluate_node` function computes a weighted sum of immediate distance and global cost, dynamically adjusting weights and exploration factors.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate and global costs) with the adaptability and exploration-exploitation trade-off from No.2, using a weighted sum of immediate distance and future cost savings, where weights adapt based on remaining nodes and node centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_immediate = 1 / (1 + remaining_nodes)\n    weight_global = remaining_nodes / (1 + remaining_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_after_node = unvisited_nodes - {node}\n        if not remaining_after_node:\n            return current_dist\n\n        future_cost_savings = sum(distance_matrix[node][other] for other in remaining_after_node) / len(remaining_after_node)\n        global_cost = current_dist - future_cost_savings\n\n        centrality = sum(distance_matrix[node][other] for other in remaining_after_node) / len(remaining_after_node)\n        exploration_weight = 0.5 * (remaining_nodes / (remaining_nodes + 1)) + 0.5 * (centrality / max(centrality, 1e-6))\n\n        return (1 - exploration_weight) * current_dist + exploration_weight * global_cost\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.45716,
          "other_inf": null
     }
]