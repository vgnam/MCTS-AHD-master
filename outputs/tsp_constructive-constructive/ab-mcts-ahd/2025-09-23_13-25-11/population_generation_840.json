[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future adaptability by adjusting weights based on the number of remaining unvisited nodes. Early in the process, it prioritizes minimizing the current step's distance (70% weight) but gradually shifts focus to future adaptability (30% weight) as fewer nodes remain. The weight is calculated as `len(remaining_nodes) / len(unvisited_nodes)`, ensuring higher emphasis on immediate distance when many nodes are unvisited and more on future adaptability as the tour nears completion. The `evaluate_node` function computes a weighted score for each candidate node, combining current distance and average future distance, while `min(unvisited_nodes, key=evaluate_node)` selects the optimal next node.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance and future adaptability) with the weighted local-global approach from No.2 (using 70% immediate distance and 30% future distance), but replaces the fixed weights with a dynamic weight that decreases as the number of unvisited nodes decreases, prioritizing immediate distance early and future adaptability later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return 0.7 * (1 - weight) * current_dist + 0.3 * weight * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, future connectivity, and exploration by adjusting weights based on remaining nodes, prioritizing closer nodes early (high `weight_immediate`) and balancing exploration (`exploration_weight`) as the tour progresses. Future connectivity is evaluated via average remaining distances (`avg_future_dist`), while exploration encourages revisiting the destination (`exploration_term`). Weights scale inversely with unvisited nodes, ensuring adaptive behavior.",
          "thought": "The new algorithm combines the ratio heuristic from No.2 with adaptive weights for immediate and future distances from No.1, dynamically adjusting exploration based on remaining nodes. It minimizes a weighted sum of immediate distance, future connectivity, and exploration, with weights scaling with unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    unvisited_count = len(unvisited_nodes)\n    exploration_weight = max(0.1, 0.5 - 0.4 * (unvisited_count / len(distance_matrix)))\n    weight_immediate = 0.3 + 0.4 * (1 - min(unvisited_count / (len(distance_matrix) - 1), 1))\n    weight_future = 1 - weight_immediate\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        exploration_term = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) if sum(distance_matrix[node]) > 0 else 0\n        return weight_immediate * immediate_dist + weight_future * (immediate_dist - avg_future_dist) + exploration_weight * exploration_term\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44895,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (30% weight early, increasing later) and future cost savings (70% weight early, decreasing later), using linear decay based on remaining nodes. It evaluates each candidate by comparing current distance to the average future distance from that node, prioritizing nodes that reduce future costs while considering immediate proximity. The weights adjust dynamically to shift focus from long-term planning to local optimization as the search progresses.",
          "thought": "The new algorithm prioritizes future cost savings (70% weight) early in the search and shifts to current distance (30% weight) later, using linear decay to adjust weights based on remaining nodes, evaluating each candidate by combining immediate distance with potential future cost reduction relative to the average remaining distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    num_unvisited = len(unvisited_nodes)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight_future = 0.7 * (num_unvisited / (num_unvisited + 5))\n        weight_current = 0.3 * (1 - (num_unvisited / (num_unvisited + 5)))\n        return weight_future * (current_dist - avg_future_dist) + weight_current * current_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44949,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance and future connectivity adaptively, with exploration weight decreasing as nodes remain and a penalty for high-distance nodes in final stages. It prioritizes immediate distance early but shifts to future connectivity later, while exploration encourages paths toward the destination, especially when few nodes remain. The weights (`weight_immediate`, `weight_future`, `exploration_weight`) dynamically adjust based on the number of unvisited nodes, and the penalty term discourages long final hops.",
          "thought": "The new algorithm combines dynamic exploration-exploitation balance, adaptive weighting between immediate distance and future connectivity, and penalty terms to discourage high-distance nodes in final stages, similar to No.1, but with a simplified exploration term inspired by No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    unvisited_count = len(unvisited_nodes)\n    exploration_weight = max(0.1, 0.5 - 0.4 * (unvisited_count / len(distance_matrix)))\n    weight_immediate = 0.3 + 0.4 * (1 - min(unvisited_count / (len(distance_matrix) - 1), 1))\n    weight_future = 1 - weight_immediate\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        exploration_term = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) if sum(distance_matrix[node]) > 0 else 0\n        penalty = 0.1 * immediate_dist if unvisited_count <= 3 else 0\n        return weight_immediate * immediate_dist + weight_future * (immediate_dist - avg_future_dist) + exploration_weight * exploration_term + penalty\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.45211,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate distance (current_dist) and future adaptability (current_dist - avg_future_dist) by scaling the weight based on remaining unvisited nodes. Early in the process, it prioritizes minimizing immediate distance, while later it shifts focus to reducing the difference between current and average future distances, ensuring a trade-off between short-term efficiency and long-term adaptability. The weight is computed as (remaining_nodes / total_unvisited_nodes)^0.5, ensuring a smooth transition between priorities.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (balancing current distance and future adaptability) with the fixed 70-30 prioritization of No.2, using a weight that scales with remaining nodes (higher weight on current distance early, shifting to future adaptability later).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = (len(remaining_nodes) / len(unvisited_nodes)) ** 0.5\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.45874,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizing high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance. The weight for immediate distance increases as nodes are visited, while the weight for future connectivity decreases, ensuring adaptive path selection. A penalty term further discourages high-distance nodes in the final stages of the tour. The code evaluates each candidate node using these weighted criteria and selects the one with the minimal score.",
          "thought": "The new algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizes high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance, ensuring adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.3 + 0.4 * (1 - min(remaining_count / (len(distance_matrix) - 1), 1))\n    weight_adapt = 1 - weight_immediate\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        penalty = 0.1 * current_dist if remaining_count <= 3 else 0\n        return weight_immediate * current_dist + weight_adapt * (current_dist - avg_future_dist) + penalty\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.46698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future path efficiency by adjusting weights between the current node's distance to unvisited nodes and their average distance to remaining nodes, prioritizing immediate distance when the current path is longer relative to the minimal remaining path. The weight is calculated as the ratio of the current path length to the minimal remaining path length, ensuring adaptability to the remaining problem size. The next node is selected by minimizing a weighted sum of these two factors, favoring shorter-term gains when the current path is longer.",
          "thought": "The new algorithm modifies the ratio heuristic by incorporating a weighted sum of the immediate distance and the average distance to unvisited nodes, where weights are dynamically adjusted based on the ratio of the current path length to the minimal possible remaining path length, promoting a balance between immediate and future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_path_length = sum(distance_matrix[current_node][other] for other in unvisited_nodes) if unvisited_nodes else 0\n    min_remaining_length = min(distance_matrix[node][destination_node] for node in unvisited_nodes) if unvisited_nodes else 0\n    weight = 1.0 if not current_path_length or not min_remaining_length else current_path_length / min_remaining_length\n\n    next_node = min(unvisited_nodes, key=lambda node: (\n        weight * distance_matrix[current_node][node] +\n        (1 - weight) * (sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes))\n    ))\n    return next_node",
          "objective": 6.46822,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances using weights (`weight_current` and `weight_future`), penalizes long detours with a dynamic `penalty_factor`, and prioritizes nodes with high clustering potential (via `clustering_potential`). It selects the next node by minimizing a weighted score that combines current distance, minimum future distance, and clustering benefits, adjusting priorities based on remaining unvisited nodes.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic threshold mechanism that adjusts the balance between immediate and future distances based on the node's potential to reduce the total path length, using a penalty factor for nodes that could create long detours, and prioritizing nodes with high clustering potential to minimize backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    penalty_factor = 0.3 * (1 - weight_current)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        clustering_potential = 1 / (1 + avg_future_dist)\n        weighted_score = weight_current * current_dist + weight_future * min_future_dist\n        penalty = penalty_factor * (current_dist + min_future_dist - avg_future_dist)\n        return weighted_score - penalty + clustering_potential\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.49521,
          "other_inf": null
     }
]