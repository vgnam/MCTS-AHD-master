[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and long-term adaptability (40% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node. It prioritizes shorter immediate distances while avoiding nodes that offer poor future connectivity, ensuring a trade-off between proximity and long-term path efficiency. The function evaluates each unvisited node using this weighted sum and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and long-term adaptability from No.1 with the exploration-focused scoring of No.2, selecting the node with the lowest weighted sum of current distance and the difference between current and maximum future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (70% weight) and adaptability (30% weight), where adaptability is defined as the difference between the current distance and the maximum future distance from the candidate node, adjusted by unvisited node density to ensure a trade-off between short-term efficiency and long-term path optimization. Higher weights are given to proximity (current distance) when unvisited nodes are sparse, while adaptability (future distance) gains more influence in dense scenarios. The evaluation function dynamically adjusts weights based on the number of remaining nodes, ensuring a flexible trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines immediate distance prioritization with future distance evaluation, using a dynamic weight that balances proximity (70% weight) and future adaptability (30% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node, while also adjusting weights based on unvisited node density to ensure a trade-off between proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.7 + 0.3 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.56667,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two key factors: immediate proximity (70% weight) and long-term adaptability (30% weight). It prioritizes the shortest current distance to the next node while penalizing choices that leave long, distant future connections, ensuring a balance between short-term efficiency and long-term flexibility. The `evaluate_node` function computes this weighted sum, and the algorithm selects the node with the minimal score.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with a 70% weight and incorporates long-term adaptability from No.1 with a 30% weight, where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node, ensuring a balance between immediate and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.7 * current_dist + 0.3 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.57643,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the immediate distance (from current node) to the sum of distances to all other unvisited nodes. This balances short-term proximity (distance to current node) with long-term optimization (sum of distances to remaining nodes), ensuring a trade-off between immediate and future path efficiency. The key design idea is the ratio heuristic, where nodes with smaller ratios are preferred, leveraging both local and global distance considerations.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on a weighted balance between immediate distance from the current node and the average future distances to remaining unvisited nodes. It dynamically adjusts weights by dividing the immediate distance by the sum of future distances (plus 1 to avoid division by zero), favoring nodes that offer a good short-term/long-term trade-off. The structure ensures the destination node is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines the proximity prioritization of No.1 with the ratio heuristic of No.2, and introduces a dynamic weight adjustment to balance immediate and future distances, ensuring a more adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weights = {node: (distance_matrix[current_node][node] / (sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) + 1)) for node in unvisited_nodes}\n    next_node = min(weights, key=weights.get)\n    return next_node",
          "objective": 6.6581,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term path potential by adjusting weights inversely proportional to node density: closer nodes in dense regions are prioritized, while future distances dominate in sparse areas. The `evaluate_node` function computes a weighted score combining current distance (`current_dist`) and a modified future distance term (`current_dist - avg_future_dist`), with weights (`weight`) inversely scaled by density. The algorithm selects the node with the minimum score, ensuring a trade-off between proximity and future path efficiency.",
          "thought": "The new algorithm prioritizes nodes based on a dynamic balance between immediate distance and long-term path potential, adjusting weights inversely proportional to unvisited node density to favor closer nodes in dense regions while considering future distances in sparse areas.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        density_factor = len(remaining_nodes) / (len(distance_matrix) - 1)\n        weight = 0.5 + 0.5 * (1 - density_factor)\n        return weight * current_dist + (1 - weight) * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.6661,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by combining immediate distance with a ratio of immediate distance to maximum future distance, where the weight adjusts based on remaining unvisited nodes (prioritizing global optimization early and local optimization later). The `dynamic_weight` (0.6 to 0.9) balances these factors, favoring the ratio (global) when many nodes remain and the immediate distance (local) as fewer nodes are left. The `evaluate_node` function computes a weighted score for each candidate node, and the algorithm selects the node with the minimum score.",
          "thought": "The new algorithm dynamically balances local and global optimization by combining immediate distance and the ratio of immediate to maximum future distance, with the weight adjusted based on the fraction of remaining unvisited nodes to prioritize global optimization early and local optimization later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    dynamic_weight = 0.6 + 0.3 * remaining_ratio\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        ratio = immediate_dist / max_future_dist if max_future_dist > 0 else float('inf')\n        return dynamic_weight * ratio + (1 - dynamic_weight) * immediate_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.77582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a ratio heuristic (balancing immediate distance and future distance ratio) with dynamic weight adjustment (favoring proximity as the tour progresses). It evaluates each unvisited node by computing a weighted sum of the immediate distance and the ratio of immediate distance to average future distances, where the weight is dynamically adjusted based on the remaining unvisited nodes' density. The weight is higher (closer to 1) when fewer nodes remain, prioritizing immediate distance, while it is lower (closer to 0.6) when more nodes remain, emphasizing the ratio heuristic. The next node is selected as the one with the minimum weighted score.",
          "thought": "The new algorithm combines the ratio heuristic from No.1 (balancing immediate distance and future distance ratio) with the dynamic weight adjustment from No.2 (adapting the trade-off based on unvisited node density). It evaluates each node by computing a weighted sum of the immediate distance and the ratio of immediate distance to average future distances, with the weight dynamically adjusted to favor proximity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        ratio = current_dist / avg_future_dist if avg_future_dist != 0 else float('inf')\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.6 + 0.4 * density_factor\n        return weight * current_dist + (1 - weight) * ratio\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.82644,
          "other_inf": null
     }
]