[
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and long-term adaptability (40% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node. It prioritizes shorter immediate distances while avoiding nodes that offer poor future connectivity, ensuring a trade-off between proximity and long-term path efficiency. The function evaluates each unvisited node using this weighted sum and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and long-term adaptability from No.1 with the exploration-focused scoring of No.2, selecting the node with the lowest weighted sum of current distance and the difference between current and maximum future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the ratio of the immediate distance (from current node) to the sum of distances to all other unvisited nodes. This balances short-term proximity (distance to current node) with long-term optimization (sum of distances to remaining nodes), ensuring a trade-off between immediate and future path efficiency. The key design idea is the ratio heuristic, where nodes with smaller ratios are preferred, leveraging both local and global distance considerations.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (immediate distance) and global (ratio of immediate to future distances) optimization by adjusting a weight (`dynamic_weight`) based on the fraction of remaining unvisited nodes, prioritizing global optimization early and local optimization as the tour nears completion. It evaluates each candidate node by combining the weighted ratio and immediate distance, ensuring a trade-off between short-term and long-term path efficiency.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing local and global optimization) with the ratio heuristic from No.2 (minimizing the ratio of immediate distance to sum of future distances). It evaluates each candidate node by dynamically weighting the immediate distance and the ratio of future distances, adjusting the weight based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0\n    dynamic_weight = 0.6 + 0.3 * remaining_ratio\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_dist\n        sum_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes)\n        ratio = immediate_dist / sum_future_dist if sum_future_dist > 0 else float('inf')\n        return dynamic_weight * ratio + (1 - dynamic_weight) * immediate_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.83808,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (60% weight) and long-term adaptability (40% weight) by evaluating each unvisited node as a weighted sum of its current distance from the current node and the difference between its current distance and the minimum future distance to remaining nodes. This prioritizes nodes that offer better future flexibility while maintaining local efficiency. The function iterates over unvisited nodes, computes this weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm combines the balancing of immediate distance (60% weight) and long-term adaptability (40% weight) from No.2, with the idea of subtracting the minimum future distance from the current distance (inspired by No.1) to prioritize nodes that offer better future flexibility while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.91213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate proximity and adaptability, prioritizing adaptability (future path potential) as the path approaches the destination. It calculates weights inversely proportional to the current node's distance to the destination, ensuring adaptability becomes more critical as the path nears the destination. The `evaluate_node` function computes a weighted sum of the current distance and the difference between current and minimum future distances, with weights adjusting based on proximity to the destination.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment between immediate proximity and adaptability, where weights are inversely proportional to the current node's distance to the destination, ensuring adaptability becomes more critical as the path approaches the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        dest_dist = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.45 * (1 - (dest_dist / (dest_dist + current_dist)))\n        return weight * current_dist + (1 - weight) * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.92787,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (70% weight) and long-term adaptability (30% weight), where adaptability is measured by the difference between the current distance to a node and the minimum future distance from that node to remaining unvisited nodes. The function prioritizes nodes that are both close to the current node and likely to lead to efficient future paths, ensuring a trade-off between greedy selection and forward-looking optimization. The weights (0.7 and 0.3) explicitly reflect this prioritization, with distance to the current node dominating the decision.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with a weighted balance between immediate distance (70% weight) and long-term adaptability (30% weight), similar to No.1, to select the next node by evaluating a weighted sum of current distance and the difference between current and minimum future distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.7 * current_dist + 0.3 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.95114,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (65% weight) and long-term adaptability (35% weight) by evaluating each unvisited node based on its direct distance from the current node and the minimum future distance to remaining nodes. The 65-35 split prioritizes short-term efficiency while accounting for potential future costs, ensuring a trade-off between immediate gains and long-term feasibility. The `evaluate_node` function computes a weighted score, and the algorithm selects the node with the lowest score as the next step.",
          "thought": "The new algorithm combines the balanced approach of No.1 (60-40 split) with the prioritization of immediate proximity from No.2 (70-30 split), creating a 65-35 balance to better capture both short-term efficiency and long-term adaptability, while maintaining a focus on immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.65 * current_dist + 0.35 * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.95115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization with future distance evaluation, dynamically adjusting weights based on unvisited node density. It prioritizes closer nodes (higher weight for `current_dist`) but balances this with potential future distances (lower weight for `current_dist - min_future_dist`), with the weight itself adapting to problem scale via `density_factor`. The function evaluates each unvisited node by this weighted sum and selects the node with the minimal score.",
          "thought": "This new algorithm combines the proximity prioritization from No.1 with the balanced evaluation of immediate and future distances from No.2, but introduces a dynamic weight adjustment based on the remaining unvisited nodes' density to better adapt to varying problem scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.7 + 0.3 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - min_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.97484,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized via `distance_matrix[current_node][node]`) and long-term optimization (measured by the ratio of immediate distance to the sum of distances to remaining unvisited nodes). The weighted sum ensures short-term efficiency and long-term adaptability, with the ratio term acting as a global heuristic to avoid local optima. The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm combines proximity prioritization with a global distance ratio heuristic, where the next node is selected by minimizing a weighted sum of the immediate distance and the ratio of the immediate distance to the sum of distances to remaining unvisited nodes, ensuring both short-term efficiency and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + (distance_matrix[current_node][node] / sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)))\n    return next_node",
          "objective": 6.98099,
          "other_inf": null
     }
]