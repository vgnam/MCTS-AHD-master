[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node to the current node, using the distance matrix to minimize incremental travel distance. If no unvisited nodes remain, it returns to the destination. The key design choices are prioritizing proximity (via `min` and `distance_matrix`) and handling termination (via `destination_node`).",
          "thought": "The algorithm selects the next node to visit from the unvisited nodes by choosing the node closest to the current node, aiming to minimize the total travel distance incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity and future savings by adjusting weights based on remaining nodes, prioritizing future savings as the tour progresses. It evaluates each unvisited node by combining the direct distance from the current node with a weighted minimum future distance, where the weight decreases as more nodes are visited. The code dynamically adjusts priorities\u2014favoring future savings later in the tour\u2014by scaling the weight of future distances with the proportion of remaining nodes.",
          "thought": "The new algorithm combines the balanced evaluation of immediate proximity and future savings from No.1 with the dynamic weighting approach of No.2, adjusting weights based on the number of remaining nodes to prioritize strategic decisions later in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.02657,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting weights inversely proportional to the number of remaining unvisited nodes. It prioritizes minimizing immediate distance early in the tour (high `weight_current`) and future savings later (high `weight_future`), ensuring a smooth transition from greedy to strategic node selection. The `evaluate_node` function computes a weighted sum of current distance and minimum future distance to the nearest unvisited node, guiding the selection of the next node.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight adjustment mechanism that balances current distance and future savings, where weights are inversely proportional to the number of remaining unvisited nodes, ensuring a smoother transition from local to global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return weight_current * current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.04196,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting weights based on remaining unvisited nodes: early stages prioritize minimizing current distance (weight_current), while later stages emphasize future savings (weight_future). The `evaluate_node` function computes a weighted sum of current distance and the minimum future distance to the next node, guiding selection toward a trade-off between short-term and long-term optimality.",
          "thought": "The new algorithm adjusts node selection by emphasizing immediate distance early and future connectivity later, using a dynamic weight scheme that prioritizes minimizing current distance with a decaying factor for future savings, ensuring a balance between greediness and strategic planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = (remaining_nodes / total_nodes) ** 2\n    weight_future = 1 - (weight_current ** 0.5)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return weight_current * current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.05017,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm dynamically balances local and global optimization by adjusting weights inversely proportional to the number of remaining unvisited nodes, prioritizing immediate distances when few nodes remain (higher `weight_current`) and future potential (higher `weight_future`) when many nodes are left. It uses a lookahead mechanism (summing the two smallest future distances) to estimate global impact, with `min_future_dist` (60%) and `lookahead_dist` (40%) weighted to balance immediate and long-term considerations. The `evaluate_node` function combines these factors to select the next node, ensuring a trade-off between greedy and forward-looking strategies.",
          "thought": "The new algorithm combines the balanced evaluation of No.1 and No.2 by dynamically adjusting weights inversely proportional to the number of remaining unvisited nodes, while also incorporating a lookahead mechanism to estimate the impact of selecting a node on future path segments, ensuring both local and global optimization throughout the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        lookahead_dist = sum(sorted(distance_matrix[node][other] for other in unvisited_nodes - {node})[:2]) if len(unvisited_nodes) > 2 else min_future_dist\n        return weight_current * current_dist + weight_future * (0.6 * min_future_dist + 0.4 * lookahead_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.06859,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (minimizing `current_dist`) and long-term adaptability (maximizing `min_future_dist`), prioritizing the latter by subtracting it from the former in the `evaluate_node` function. It ensures the path remains efficient while avoiding future flexibility loss.",
          "thought": "The new algorithm prioritizes minimizing future flexibility (maximizing the minimum distance to remaining unvisited nodes) while also considering immediate proximity, balancing both factors to select the next node that optimizes the trade-off between short-term efficiency and long-term adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist - min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.14415,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by weighting the immediate distance (60-100% of the total weight) and the average future distance (40-0%) inversely proportional to the remaining unvisited nodes. The immediate distance is prioritized when few nodes remain, while the average future distance dominates when many nodes are left, ensuring a smooth transition between local and global optimization. The weights are calculated as `weight_current = remaining_nodes / total_nodes` and `weight_future = 1 - weight_current`, and the next node is selected based on the weighted sum of these distances.",
          "thought": "The new algorithm combines the dynamic balancing of No.1 (weighting immediate and future distances inversely proportional to remaining nodes) with the simplicity of No.2 (using a weighted sum of immediate distance and average future distance). It dynamically adjusts weights for immediate distance (60-100%) and average future distance (40-0%) based on remaining nodes, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        return weight_current * current_dist + weight_future * avg_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distance considerations by weighting the current step's distance and the maximum future distance to remaining nodes, with the weight adjusting based on the proportion of remaining nodes. It prioritizes minimizing the weighted sum of these distances to select the next node, ensuring a trade-off between immediate proximity and future exploration. The weight for the current distance increases as fewer nodes remain, while the weight for future distance increases as more nodes remain, dynamically adapting to the problem's state.",
          "thought": "The new algorithm combines the dynamic weight balancing of No.1 with the proximity-exploration balance of No.2, selecting nodes by minimizing the weighted sum of immediate distance and future maximum distance, where the weight adjusts based on the remaining nodes' proportion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return weight_current * current_dist + weight_future * max_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.20027,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity (direct distance from current node) but also considers future flexibility by incorporating the minimum distance to the next unvisited node (weighted by 0.3). It balances short-term efficiency (current distance) with long-term adaptability (future distances) to guide the next node selection. The `evaluate_node` function computes a weighted sum of these factors, and the algorithm selects the node with the minimum value.",
          "thought": "The new algorithm introduces a different weighting scheme by prioritizing future flexibility (maximizing the minimum distance to remaining unvisited nodes) over immediate proximity, balancing these factors with a controlled ratio to ensure both short-term efficiency and long-term adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return current_dist + 0.3 * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization (70-60% weight) with future connectivity (30-40% weight), dynamically adjusting weights based on remaining nodes. It evaluates each unvisited node by balancing current distance and the minimum future distance to the next closest node, selecting the node with the lowest combined score. The weights decrease slightly as nodes are visited, shifting focus from future planning to immediate distances.",
          "thought": "The new algorithm combines the fixed weight balance of No.1 (70% immediate, 30% future) with No.2's dynamic weight adjustment based on remaining nodes, creating a hybrid approach that prioritizes immediate distance when many nodes remain but still considers future connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.7 if remaining_count > 5 else 0.6\n    weight_future = 0.3 if remaining_count > 5 else 0.4\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        return weight_immediate * current_dist + weight_future * min_future_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.34845,
          "other_inf": null
     }
]