[
     {
          "algorithm": "The algorithm balances proximity to the current node and alignment with the final destination, using a dynamic weight that prioritizes local efficiency early (high `proximity_weight`) and global optimization later (lower `proximity_weight`). It evaluates nodes by combining current distance (`current_dist`) and average future distances (`avg_future_dist`) with a weighted sum, where the weight adjusts based on progress toward the destination. The `proximity_weight` is higher when the current-to-destination distance is small relative to the maximum possible, ensuring early-stage efficiency while still considering long-term goals.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the proximity-destination balance from No.2, using a sigmoid-like weight that prioritizes local efficiency early and global optimization later, while also considering the average future distances to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        proximity_weight = 0.6 + 0.4 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.6\n        return (proximity_weight * (1 - weight) * current_dist +\n                (1 - proximity_weight) * weight * (current_dist - avg_future_dist))\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.41887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early in the search (higher weight) but balances it with adaptability to future distances (lower weight) as the number of remaining nodes decreases. It dynamically adjusts weights based on remaining nodes, favoring flexibility initially and efficiency later. The evaluation function combines current distance and the difference between current and average future distances, with the weight determined by the proportion of unvisited nodes.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and future adaptability from No.1, with the dynamic exploration weight from No.2. It evaluates nodes by a weighted sum of current distance and the difference between current and average future distances, where the weight adjusts based on remaining nodes to prioritize flexibility early and efficiency later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44101,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future adaptability by adjusting weights based on the number of remaining unvisited nodes. Early in the process, it prioritizes minimizing the current step's distance (70% weight) but gradually shifts focus to future adaptability (30% weight) as fewer nodes remain. The weight is calculated as `len(remaining_nodes) / len(unvisited_nodes)`, ensuring higher emphasis on immediate distance when many nodes are unvisited and more on future adaptability as the tour nears completion. The `evaluate_node` function computes a weighted score for each candidate node, combining current distance and average future distance, while `min(unvisited_nodes, key=evaluate_node)` selects the optimal next node.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance and future adaptability) with the weighted local-global approach from No.2 (using 70% immediate distance and 30% future distance), but replaces the fixed weights with a dynamic weight that decreases as the number of unvisited nodes decreases, prioritizing immediate distance early and future adaptability later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight = len(remaining_nodes) / len(unvisited_nodes)\n        return 0.7 * (1 - weight) * current_dist + 0.3 * weight * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (30% weight early, increasing later) and future cost savings (70% weight early, decreasing later), using linear decay based on remaining nodes. It evaluates each candidate by comparing current distance to the average future distance from that node, prioritizing nodes that reduce future costs while considering immediate proximity. The weights adjust dynamically to shift focus from long-term planning to local optimization as the search progresses.",
          "thought": "The new algorithm prioritizes future cost savings (70% weight) early in the search and shifts to current distance (30% weight) later, using linear decay to adjust weights based on remaining nodes, evaluating each candidate by combining immediate distance with potential future cost reduction relative to the average remaining distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    num_unvisited = len(unvisited_nodes)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        weight_future = 0.7 * (num_unvisited / (num_unvisited + 5))\n        weight_current = 0.3 * (1 - (num_unvisited / (num_unvisited + 5)))\n        return weight_future * (current_dist - avg_future_dist) + weight_current * current_dist\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.44949,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate distance (current_dist) and future adaptability (current_dist - avg_future_dist) by scaling the weight based on remaining unvisited nodes. Early in the process, it prioritizes minimizing immediate distance, while later it shifts focus to reducing the difference between current and average future distances, ensuring a trade-off between short-term efficiency and long-term adaptability. The weight is computed as (remaining_nodes / total_unvisited_nodes)^0.5, ensuring a smooth transition between priorities.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (balancing current distance and future adaptability) with the fixed 70-30 prioritization of No.2, using a weight that scales with remaining nodes (higher weight on current distance early, shifting to future adaptability later).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n        weight = (len(remaining_nodes) / len(unvisited_nodes)) ** 0.5\n        return (1 - weight) * current_dist + weight * (current_dist - avg_future_dist)\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.45874,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizing high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance. The weight for immediate distance increases as nodes are visited, while the weight for future connectivity decreases, ensuring adaptive path selection. A penalty term further discourages high-distance nodes in the final stages of the tour. The code evaluates each candidate node using these weighted criteria and selects the one with the minimal score.",
          "thought": "The new algorithm dynamically balances immediate distance (30-70% weight) and future connectivity (70-30% weight) based on remaining unvisited nodes, penalizes high-distance nodes when few nodes remain, and selects the next node by minimizing a weighted sum of current distance and the difference between current and average future distance, ensuring adaptive and efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_count = len(unvisited_nodes)\n    weight_immediate = 0.3 + 0.4 * (1 - min(remaining_count / (len(distance_matrix) - 1), 1))\n    weight_adapt = 1 - weight_immediate\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        penalty = 0.1 * current_dist if remaining_count <= 3 else 0\n        return weight_immediate * current_dist + weight_adapt * (current_dist - avg_future_dist) + penalty\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.46698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances using weights (`weight_current` and `weight_future`), penalizes long detours with a dynamic `penalty_factor`, and prioritizes nodes with high clustering potential (via `clustering_potential`). It selects the next node by minimizing a weighted score that combines current distance, minimum future distance, and clustering benefits, adjusting priorities based on remaining unvisited nodes.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic threshold mechanism that adjusts the balance between immediate and future distances based on the node's potential to reduce the total path length, using a penalty factor for nodes that could create long detours, and prioritizing nodes with high clustering potential to minimize backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = remaining_nodes / total_nodes\n    weight_future = 1 - weight_current\n    penalty_factor = 0.3 * (1 - weight_current)\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        min_future_dist = min(distance_matrix[node][other] for other in remaining_nodes)\n        avg_future_dist = sum(distance_matrix[node][other] for other in remaining_nodes) / len(remaining_nodes)\n        clustering_potential = 1 / (1 + avg_future_dist)\n        weighted_score = weight_current * current_dist + weight_future * min_future_dist\n        penalty = penalty_factor * (current_dist + min_future_dist - avg_future_dist)\n        return weighted_score - penalty + clustering_potential\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.49521,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (60% weight) and long-term adaptability (40% weight), where adaptability is measured as the difference between current distance and the maximum future distance from the candidate node. It prioritizes shorter immediate distances while avoiding nodes that offer poor future connectivity, ensuring a trade-off between proximity and long-term path efficiency. The function evaluates each unvisited node using this weighted sum and chooses the node with the lowest score.",
          "thought": "The new algorithm combines the weighted balance of immediate distance and long-term adaptability from No.1 with the exploration-focused scoring of No.2, selecting the node with the lowest weighted sum of current distance and the difference between current and maximum future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        return 0.6 * current_dist + 0.4 * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50439,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term adaptability by computing a weighted sum where the weight adjusts based on remaining node density. Immediate distance is prioritized when node density is high (weight increases with density), while the difference between current and maximum future distance is prioritized when density is low. The evaluation function uses `density_factor` to dynamically adjust the weight, ensuring adaptability to the problem's evolution.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (prioritizing immediate distance as the tour progresses) with the long-term adaptability from No.2 (balancing immediate distance and the difference between current and maximum future distance). It evaluates each unvisited node by computing a weighted sum of the immediate distance and the difference between current distance and maximum future distance, where the weight dynamically adjusts based on the remaining unvisited nodes' density.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        weight = 0.4 + 0.6 * density_factor\n        return weight * current_dist + (1 - weight) * (current_dist - max_future_dist)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.50571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to unvisited nodes and future adaptability by weighting current distance and the difference between current and future distances, adjusting the balance based on remaining nodes and proximity to the destination. It prioritizes nodes closer to the destination while considering node density, with proximity given higher weight when the destination is nearby. The function evaluates nodes by combining weighted current and future distance metrics, ensuring a trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance and future adaptability) with the proximity-based weighting from No.2 (prioritizing immediate distance near the destination). It evaluates nodes by dynamically weighting the current distance and the difference between current and future distances, while adjusting the balance based on the remaining nodes and proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    current_to_dest = distance_matrix[current_node][destination_node]\n    max_distance = max((distance_matrix[current_node][node] + distance_matrix[node][destination_node] for node in unvisited_nodes), default=1)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return current_dist\n\n        max_future_dist = max(distance_matrix[node][other] for other in remaining_nodes)\n        density_factor = 1 / len(remaining_nodes) if remaining_nodes else 1\n        proximity_weight = 0.5 + 0.5 * (1 - (current_to_dest / max_distance)) if max_distance > 0 else 0.5\n        weight = 0.4 + 0.6 * density_factor\n        return (proximity_weight * (weight * current_dist + (1 - weight) * (current_dist - max_future_dist)) +\n                (1 - proximity_weight) * current_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.52299,
          "other_inf": null
     }
]