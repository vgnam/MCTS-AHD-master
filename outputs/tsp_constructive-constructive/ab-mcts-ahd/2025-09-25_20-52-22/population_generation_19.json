[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for the TSP, prioritizing the unvisited node closest to the current node, with an exception: if the destination node is unvisited and closer than the nearest neighbor, it is chosen instead. The function checks all unvisited nodes, compares their distances, and ensures the destination node is selected if it meets the priority condition. The key design priorities are proximity to the current node and the special handling of the destination node.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node closest to the current node, while prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the one with the lowest combined cost of traveling from the current node and returning to the destination, ensuring the destination is chosen if it's the only remaining unvisited node. It balances local optimality (minimizing immediate travel cost) with global consideration (ensuring the path eventually returns to the destination). The destination node is given higher priority when it's the last unvisited node, while other nodes are evaluated based on their immediate cost to the destination. The algorithm efficiently handles edge cases (like an empty unvisited set) and ensures the solution remains feasible.",
          "thought": "This algorithm prioritizes selecting the next node based on the minimum total cost of visiting that node and then returning to the destination, while ensuring the destination is chosen if it's the only remaining unvisited node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_total_cost = float('inf')\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if cost < min_total_cost:\n            min_total_cost = cost\n            next_node = node\n\n    if destination_node in unvisited_nodes and len(unvisited_nodes) == 1:\n        next_node = destination_node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and lookahead strategies: it prioritizes nodes that minimize the sum of the immediate distance to the current node and the next best step from the candidate, while also considering the destination node if it remains unvisited. The immediate distance (`immediate_cost`) is weighted higher than the lookahead cost (`next_best_cost`), with the destination node only selected if its direct distance is better than the best candidate. The structure ensures efficiency by iterating through unvisited nodes and dynamically adjusting the selection based on real-time cost calculations.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with a lookahead mechanism inspired by No.1, prioritizing nodes that minimize the sum of the immediate distance to the current node and the next best step from the candidate.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_total_cost = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][node]\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            next_best_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n            total_cost = immediate_cost + next_best_cost\n        else:\n            total_cost = immediate_cost\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_cost = distance_matrix[current_node][destination_node]\n        if destination_cost <= min_total_cost:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the immediate travel cost (local optimization) while also considering the average distance to remaining unvisited nodes (global optimization), balancing both factors to select the next node. It iterates through unvisited nodes, computes a combined cost of direct travel and average remaining distances, and selects the node with the lowest total cost. The destination node is prioritized if it is the last remaining node.",
          "thought": "This algorithm prioritizes nodes that minimize the immediate travel cost while considering the average distance to all unvisited nodes, creating a balance between local and global optimization. It evaluates each candidate node by combining its direct cost with the average cost to remaining unvisited nodes, ensuring a more holistic path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_total_cost = float('inf')\n\n    for node in unvisited_nodes:\n        current_cost = distance_matrix[current_node][node]\n\n        # Calculate average cost to remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_cost = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            total_cost = current_cost + avg_cost\n        else:\n            total_cost = current_cost\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            next_node = node\n\n    if destination_node in unvisited_nodes and len(unvisited_nodes) == 1:\n        next_node = destination_node\n\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate cost (distance from current node to candidate and back to destination) with a lookahead mechanism (evaluating the next best step from the candidate). It prioritizes minimizing the sum of these two costs, ensuring both short-term and mid-term optimality while avoiding myopic decisions. The `unvisited_nodes` set is central, and the loop iterates over it to evaluate each candidate's potential impact on the path.",
          "thought": "The new algorithm prioritizes nodes that minimize the current path cost while considering the potential impact on future steps by evaluating the sum of costs to the next node and back to the destination, but also incorporates a lookahead mechanism to anticipate the next best step, creating a more balanced approach between immediate and future optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_total_cost = float('inf')\n\n    for node in unvisited_nodes:\n        # Current cost to node and back to destination\n        current_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n\n        # Lookahead: Evaluate the next best step from this node\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            next_best_cost = min(distance_matrix[node][n] + distance_matrix[n][destination_node] for n in remaining_nodes)\n            total_cost = current_cost + next_best_cost\n        else:\n            total_cost = current_cost\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            next_node = node\n\n    if destination_node in unvisited_nodes and len(unvisited_nodes) == 1:\n        next_node = destination_node\n\n    return next_node",
          "objective": 8.96354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by selecting the next node probabilistically, with weights inversely proportional to distance (prioritizing closer nodes) and a 1.5x bias for the destination node if unvisited. This balances efficiency with exploration, ensuring the destination is favored while maintaining stochasticity. The `distance_matrix` and `unvisited_nodes` are critical inputs, while `current_node` and `destination_node` guide the selection process.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a probabilistic selection mechanism, where nodes are chosen with a probability inversely proportional to their distance, weighted by a bias towards the destination node if it remains unvisited. This introduces stochasticity while preserving the original's efficiency and proximity focus.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    candidates = []\n    weights = []\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance == 0:\n            weight = float('inf')\n        else:\n            weight = 1.0 / distance\n        candidates.append(node)\n        weights.append(weight)\n\n    if destination_node in unvisited_nodes:\n        dest_index = candidates.index(destination_node)\n        weights[dest_index] *= 1.5\n\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n\n    next_node = random.choices(candidates, weights=probabilities, k=1)[0]\n\n    return next_node",
          "objective": 19.44109,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the farthest unvisited neighbor from the current node, but always selects the destination node if it is unvisited and at least as far as the farthest neighbor. This ensures progress toward the destination while maximizing distance gains. The function checks all unvisited nodes, updates the farthest neighbor, and overrides the choice if the destination meets the priority condition.",
          "thought": "The new algorithm implements a farthest-neighbor heuristic, prioritizing the unvisited node farthest from the current node, with an exception: if the destination node is unvisited and farther than the farthest neighbor, it is chosen instead. The function checks all unvisited nodes, compares their distances, and ensures the destination node is selected if it meets the priority condition.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_distance = -float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance > max_distance:\n            max_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance >= max_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]