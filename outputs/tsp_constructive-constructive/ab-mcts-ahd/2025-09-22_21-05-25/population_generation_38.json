[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing local optimality by always selecting the closest unvisited node from the current node, using the distance matrix to guide decisions. The function `select_next_node` ensures incremental construction of the path, with `current_node` and `unvisited_nodes` being central to the selection logic. If no unvisited nodes remain, it returns the `destination_node` to complete the cycle.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the solution is constructed incrementally while prioritizing local optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by selecting the farthest node only if its distance is below a dynamically adjusted threshold (1.2 \u00d7 average distance to unvisited nodes), otherwise defaulting to the nearest node. This balances proximity and exploration, prioritizing the farthest node when it is reasonably close, otherwise favoring the nearest node for efficiency. The code structure clearly separates the calculation of key metrics (nearest, farthest, and average distances) before making the selection.",
          "thought": "The new algorithm combines nearest-neighbor with a modified farthest-neighbor heuristic, where the farthest node is selected only if it is within a dynamically adjusted threshold based on the average distance to unvisited nodes, balancing exploration and proximity to improve the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.2 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] < threshold else nearest_node\n    return next_node",
          "objective": 7.1201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the nearest unvisited node if it is at least half as close as the farthest node, otherwise it chooses the farthest node, balancing proximity and exploration. The function uses a distance matrix to evaluate node distances and ensures the path loops back to the destination node when no unvisited nodes remain. The key design ideas are the conditional selection between nearest and farthest nodes based on a distance ratio, with the nearest node given higher priority when it meets the condition.",
          "thought": "The new algorithm prioritizes the farthest node unless the nearest node is at least twice as close, ensuring balance between exploration and proximity, with parameters current_node, unvisited_nodes, and distance_matrix guiding the selection logic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    next_node = nearest_node if distance_matrix[current_node][nearest_node] * 2 <= distance_matrix[current_node][farthest_node] else farthest_node\n    return next_node",
          "objective": 7.32671,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the sum of the distance from the current node to the candidate and from the candidate to its nearest unvisited neighbor, balancing immediate and future path efficiency. It handles the last unvisited node separately by only considering the direct distance to it. The `distance_matrix` is the primary input, and the `unvisited_nodes` set dynamically influences the selection.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering the sum of distances from the current node to the candidate node and from the candidate node to the nearest unvisited node, balancing immediate and future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            return current_to_node + node_to_nearest\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor selection probabilistically, with a temperature parameter balancing exploration (favoring distant nodes) and exploitation (favoring nearby nodes). A dynamically scaled threshold (`dynamic_threshold`) adjusts the bias toward distant nodes based on the current tour length, ensuring adaptive exploration. The farthest node is prioritized when its distance significantly exceeds the nearest node's distance, while the nearest node dominates otherwise. The temperature and threshold mechanisms dynamically adjust selection priorities.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism where the next node is chosen based on a weighted combination of nearest and farthest neighbors, incorporating a temperature parameter to dynamically adjust exploration vs. exploitation, with a novel distance ratio threshold that scales with the current tour length to balance exploration and efficiency.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, temperature=0.5):\n    if not unvisited_nodes:\n        return destination_node\n\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    nearest_dist = distance_matrix[current_node][nearest_node]\n    farthest_dist = distance_matrix[current_node][farthest_node]\n\n    tour_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes)\n    dynamic_threshold = 1.5 * (1 + math.exp(-tour_length / 100))\n\n    if farthest_dist > dynamic_threshold * nearest_dist:\n        prob_farthest = 1 / (1 + math.exp(-(farthest_dist - nearest_dist) / temperature))\n        next_node = farthest_node if random.random() < prob_farthest else nearest_node\n    else:\n        next_node = nearest_node\n\n    return next_node",
          "objective": 30.46597,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by dynamically adjusting a threshold (1.5 \u00d7 average distance) to balance exploration and proximity, prioritizing the farthest node if it exceeds the threshold, otherwise selecting the nearest node. It penalizes revisits by excluding already visited nodes from consideration. The key design choices are the threshold-based decision and the explicit handling of the last node to ensure a complete tour.",
          "thought": "The new algorithm combines nearest-neighbor and farthest-neighbor heuristics with a dynamic threshold that adjusts based on the average distance of unvisited nodes, ensuring a balance between proximity and exploration while penalizing revisits to previously considered nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.5 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] > threshold else nearest_node\n    return next_node",
          "objective": 31.79832,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of the distance from the current node to the candidate (prioritizing closer nodes) to the candidate's distance to its farthest remaining unvisited neighbor (prioritizing nodes that bridge gaps between distant unvisited nodes). This balances immediate and long-term efficiency while avoiding premature isolation of unvisited segments. The function evaluates each unvisited node using this ratio and returns the node with the highest value.",
          "thought": "This algorithm prioritizes selecting the next node by maximizing the ratio of the distance from the current node to the candidate and the candidate's distance to its farthest unvisited neighbor, aiming to balance immediate and long-term path efficiency while avoiding prematurely selecting nodes that may lead to isolated segments in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            farthest_remaining = max(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_farthest = distance_matrix[node][farthest_remaining]\n            return current_to_node / node_to_farthest if node_to_farthest != 0 else float('inf')\n        else:\n            return current_to_node\n    next_node = max(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 35.82816,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between nearest-neighbor and farthest-neighbor selection by adjusting an exploration factor based on the ratio of unvisited nodes to the sum of remaining distances. It prioritizes the farthest node when its distance exceeds a threshold (1.5 + exploration_factor * 0.5) times the nearest neighbor's distance, otherwise defaults to the nearest node. This balances proximity (nearest-neighbor) with controlled exploration (farthest-neighbor) to improve tour diversity without sacrificing efficiency.",
          "thought": "The new algorithm introduces a dynamic exploration factor that adjusts the threshold for selecting the farthest node based on the current tour length and remaining nodes, combining nearest-neighbor preference with controlled farthest-neighbor exploration to balance proximity and diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][node] for node in unvisited_nodes))\n    threshold = 1.5 + exploration_factor * 0.5\n\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] > threshold * distance_matrix[current_node][nearest_node] else nearest_node\n    return next_node",
          "objective": 36.47809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and proximity by comparing the farthest and nearest unvisited nodes from the current node, selecting the farthest only if its distance exceeds a threshold (1.2 + 0.3 * (farthest/nearest ratio)), ensuring adaptability to local and global structures. The threshold prioritizes the nearest node by default but allows occasional far jumps when justified by the distance ratio, avoiding rigid greedy choices. The code efficiently handles edge cases (empty unvisited nodes) and leverages the distance matrix for real-time calculations.",
          "thought": "The new algorithm introduces a dynamic exploration factor that adjusts based on the ratio of the farthest to nearest node distances, selecting the farthest node only if it exceeds a dynamically calculated threshold (1.2 + 0.3 * (farthest_distance / nearest_distance)), ensuring a balance between proximity and exploration that adapts to the current node's neighborhood.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    nearest_distance = distance_matrix[current_node][nearest_node]\n    farthest_distance = distance_matrix[current_node][farthest_node]\n    threshold = 1.2 + 0.3 * (farthest_distance / nearest_distance)\n    next_node = farthest_node if farthest_distance > threshold * nearest_distance else nearest_node\n    return next_node",
          "objective": 36.5288,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimality by prioritizing the nearest unvisited node but occasionally selecting the farthest node if it is significantly farther (1.5\u00d7) than the nearest, ensuring a trade-off between immediate and long-term path efficiency. The function checks the size of unvisited nodes to avoid premature farthest-node selection in small sets, defaulting to the nearest node in such cases. The key parameters are the current and destination nodes, unvisited nodes, and distance matrix, with the heuristic's logic embedded in the conditional choice between nearest and farthest nodes.",
          "thought": "The algorithm uses a combination of nearest-neighbor and farthest-insertion heuristics, where it first selects the nearest unvisited node but also considers the farthest node to balance local and global optimality, aiming to reduce the total path length by strategically choosing nodes that minimize both immediate and long-term distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    if len(unvisited_nodes) > 2:\n        next_node = farthest_node if distance_matrix[current_node][farthest_node] > 1.5 * distance_matrix[current_node][nearest_node] else nearest_node\n    else:\n        next_node = nearest_node\n    return next_node",
          "objective": 36.5465,
          "other_inf": null
     }
]