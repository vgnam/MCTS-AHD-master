[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing local optimality by always selecting the closest unvisited node from the current node, using the distance matrix to guide decisions. The function `select_next_node` ensures incremental construction of the path, with `current_node` and `unvisited_nodes` being central to the selection logic. If no unvisited nodes remain, it returns the `destination_node` to complete the cycle.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the solution is constructed incrementally while prioritizing local optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the sum of the distance from the current node to the candidate and from the candidate to its nearest unvisited neighbor, balancing immediate and future path efficiency. It handles the last unvisited node separately by only considering the direct distance to it. The `distance_matrix` is the primary input, and the `unvisited_nodes` set dynamically influences the selection.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering the sum of distances from the current node to the candidate node and from the candidate node to the nearest unvisited node, balancing immediate and future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            return current_to_node + node_to_nearest\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of the distance from the current node to the candidate (prioritizing closer nodes) to the candidate's distance to its farthest remaining unvisited neighbor (prioritizing nodes that bridge gaps between distant unvisited nodes). This balances immediate and long-term efficiency while avoiding premature isolation of unvisited segments. The function evaluates each unvisited node using this ratio and returns the node with the highest value.",
          "thought": "This algorithm prioritizes selecting the next node by maximizing the ratio of the distance from the current node to the candidate and the candidate's distance to its farthest unvisited neighbor, aiming to balance immediate and long-term path efficiency while avoiding prematurely selecting nodes that may lead to isolated segments in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            farthest_remaining = max(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_farthest = distance_matrix[node][farthest_remaining]\n            return current_to_node / node_to_farthest if node_to_farthest != 0 else float('inf')\n        else:\n            return current_to_node\n    next_node = max(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 35.82816,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimality by prioritizing the nearest unvisited node but occasionally selecting the farthest node if it is significantly farther (1.5\u00d7) than the nearest, ensuring a trade-off between immediate and long-term path efficiency. The function checks the size of unvisited nodes to avoid premature farthest-node selection in small sets, defaulting to the nearest node in such cases. The key parameters are the current and destination nodes, unvisited nodes, and distance matrix, with the heuristic's logic embedded in the conditional choice between nearest and farthest nodes.",
          "thought": "The algorithm uses a combination of nearest-neighbor and farthest-insertion heuristics, where it first selects the nearest unvisited node but also considers the farthest node to balance local and global optimality, aiming to reduce the total path length by strategically choosing nodes that minimize both immediate and long-term distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    if len(unvisited_nodes) > 2:\n        next_node = farthest_node if distance_matrix[current_node][farthest_node] > 1.5 * distance_matrix[current_node][nearest_node] else nearest_node\n    else:\n        next_node = nearest_node\n    return next_node",
          "objective": 36.5465,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics, prioritizing the nearest node unless the farthest node is at least 1.5\u00d7 farther, ensuring balance between proximity and exploration. The function checks unvisited nodes, compares distances, and selects the farthest node only if it significantly outweighs the nearest, otherwise defaulting to the nearest. Key parameters are `current_node`, `unvisited_nodes`, and `distance_matrix`, with the selection logic embedded in the conditional check.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic from No.2 with a conditional check inspired by No.1, selecting the farthest node if it is significantly farther (1.5\u00d7) than the nearest, while prioritizing the nearest node otherwise.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] > 1.5 * distance_matrix[current_node][nearest_node] else nearest_node\n    return next_node",
          "objective": 36.61525,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **farthest-insertion heuristic** for TSP, prioritizing global exploration by always selecting the **unvisited node farthest** from the current node (using the distance matrix) to ensure incremental path construction. The `destination_node` is returned only when no unvisited nodes remain, and the heuristic prioritizes **distance maximization** over other factors, making it a greedy but globally aware approach.",
          "thought": "The new algorithm implements a farthest-insertion heuristic for TSP, prioritizing global exploration by always selecting the farthest unvisited node from the current node, using the distance matrix to guide decisions, and ensuring the path construction is incremental.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]