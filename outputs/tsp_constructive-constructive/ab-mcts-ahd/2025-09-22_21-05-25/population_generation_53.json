[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing local optimality by always selecting the closest unvisited node from the current node, using the distance matrix to guide decisions. The function `select_next_node` ensures incremental construction of the path, with `current_node` and `unvisited_nodes` being central to the selection logic. If no unvisited nodes remain, it returns the `destination_node` to complete the cycle.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the solution is constructed incrementally while prioritizing local optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection based on remaining unvisited nodes, prioritizing immediate distance when few nodes are left and balancing current distance with future connectivity when more nodes remain. It uses a threshold formula (`1.0 + exploration_factor * 2.0`) to weigh current-to-node distance higher when nodes are plentiful and future connectivity higher when nodes are scarce, with `exploration_factor` decreasing as unvisited nodes decrease. The key design idea is balancing local and global optimization through adaptive prioritization.",
          "thought": "The new algorithm modifies the selection criteria by introducing a dynamic threshold that prioritizes nodes with the shortest immediate distance when few nodes remain, but considers a broader view of future connectivity when more nodes are left, using a different exploration factor calculation and threshold formula.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = 1.0 / (1.0 + len(unvisited_nodes))\n            threshold = 1.0 + exploration_factor * 2.0\n            return current_to_node * threshold + node_to_nearest * (1.0 - threshold)\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.03067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by selecting the farthest node only if its distance is below a dynamically adjusted threshold (1.2 \u00d7 average distance to unvisited nodes), otherwise defaulting to the nearest node. This balances proximity and exploration, prioritizing the farthest node when it is reasonably close, otherwise favoring the nearest node for efficiency. The code structure clearly separates the calculation of key metrics (nearest, farthest, and average distances) before making the selection.",
          "thought": "The new algorithm combines nearest-neighbor with a modified farthest-neighbor heuristic, where the farthest node is selected only if it is within a dynamically adjusted threshold based on the average distance to unvisited nodes, balancing exploration and proximity to improve the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.2 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] < threshold else nearest_node\n    return next_node",
          "objective": 7.1201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the nearest unvisited node if it is at least half as close as the farthest node, otherwise it chooses the farthest node, balancing proximity and exploration. The function uses a distance matrix to evaluate node distances and ensures the path loops back to the destination node when no unvisited nodes remain. The key design ideas are the conditional selection between nearest and farthest nodes based on a distance ratio, with the nearest node given higher priority when it meets the condition.",
          "thought": "The new algorithm prioritizes the farthest node unless the nearest node is at least twice as close, ensuring balance between exploration and proximity, with parameters current_node, unvisited_nodes, and distance_matrix guiding the selection logic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    next_node = nearest_node if distance_matrix[current_node][nearest_node] * 2 <= distance_matrix[current_node][farthest_node] else farthest_node\n    return next_node",
          "objective": 7.32671,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances by adjusting a weight based on the number of remaining unvisited nodes, prioritizing shorter current distances when few nodes remain but considering average future distances when more nodes are left. The weight is calculated as `0.5 + exploration_factor * 0.5`, where `exploration_factor` decreases as the number of unvisited nodes grows, thus favoring immediate gains in later stages. The evaluation function combines these weighted distances to guide the selection of the next node.",
          "thought": "The new algorithm combines the weighted balance of immediate and future distances from No.1 with the dynamic exploration factor from No.2, adjusting the weight based on the number of remaining unvisited nodes to prioritize immediate distance when few nodes remain but consider future efficiency when more nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            avg_future = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            weight = 0.5 + exploration_factor * 0.5\n            return weight * current_to_node + (1 - weight) * avg_future\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.42983,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adapts the nearest-neighbor approach by dynamically balancing immediate distance and future connectivity: when few nodes remain, it prioritizes minimizing the next step (70% weight), while when many nodes are left, it considers both the next step (70%) and the node's proximity to the nearest remaining node (30% weighted by a threshold that increases with remaining nodes). The exploration factor adjusts the threshold based on the number of unvisited nodes, favoring closer nodes when options are limited.",
          "thought": "The new algorithm adapts the nearest-neighbor approach by introducing a dynamic exploration factor that prioritizes immediate distance when few nodes remain and balances future connectivity when many nodes are left. It uses a different threshold calculation, favoring closer nodes with a higher weight when unvisited nodes are scarce and considering future steps more when more nodes are available.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            threshold = 1.0 + exploration_factor * 1.0\n            return current_to_node * 0.7 + node_to_nearest * threshold * 0.3\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.8036,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic extends the nearest-neighbor approach by balancing immediate distance (current_node \u2192 next_node) with future connectivity (next_node \u2192 nearest remaining node), using a temperature-based exploration strategy that prioritizes local optimization early (high temperature) and global exploration later (low temperature). The `exploration_weight` adjusts the balance between immediate and future steps, while the score adjustment (`1.0 / (1.0 + temperature * 0.5)`) further refines selection by emphasizing short-term gains when exploration is high. The algorithm dynamically shifts focus from immediate proximity to long-term path efficiency as unvisited nodes decrease.",
          "thought": "The new algorithm extends the nearest-neighbor approach by incorporating a probabilistic selection mechanism that dynamically adjusts the balance between immediate distance and future connectivity, using a temperature-based exploration strategy that cools as the number of unvisited nodes decreases, ensuring a trade-off between greedy optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n\n            # Temperature-based exploration factor\n            temperature = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n            exploration_weight = temperature * 0.7 + 0.3  # More weight to future steps as temperature decreases\n\n            # Probabilistic selection: closer nodes have higher chance when temperature is high\n            distance_score = current_to_node + node_to_nearest * exploration_weight\n            return distance_score * (1.0 / (1.0 + temperature * 0.5))  # Adjust score based on temperature\n        else:\n            return current_to_node\n\n    # Select node with lowest score (or probabilistically if modified)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.27528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the sum of the distance from the current node to the candidate and from the candidate to its nearest unvisited neighbor, balancing immediate and future path efficiency. It handles the last unvisited node separately by only considering the direct distance to it. The `distance_matrix` is the primary input, and the `unvisited_nodes` set dynamically influences the selection.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering the sum of distances from the current node to the candidate node and from the candidate node to the nearest unvisited node, balancing immediate and future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            return current_to_node + node_to_nearest\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance (weighted by `weight`) and the average future distance to remaining unvisited nodes (weighted by `1-weight`). It prioritizes minimizing the immediate distance when `weight` is high, while favoring reducing future path length when `weight` is low. The function uses a distance matrix and dynamically adjusts the selection based on the remaining unvisited nodes.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between minimizing immediate distance and maximizing the reduction in potential future path length, introducing a tunable parameter to adjust the emphasis on either aspect. It first calculates a score for each candidate node as a weighted sum of its direct distance from the current node and the average distance to the remaining unvisited nodes, then selects the node with the minimum score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, weight=0.5):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            avg_future = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            return weight * current_to_node + (1 - weight) * avg_future\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **nearest-neighbor selection** with a **dynamic exploration factor**, prioritizing proximity while balancing future efficiency. It adjusts the selection threshold based on the number of remaining unvisited nodes and their distances, favoring closer nodes when fewer remain but considering future connectivity when more nodes are left. The `exploration_factor` dynamically weights the importance of immediate distance versus future steps, ensuring a balance between greediness and long-term efficiency.",
          "thought": "The new algorithm combines the dynamic exploration factor from No.1 with the nearest-neighbor lookahead from No.2, balancing proximity and future efficiency by adjusting the selection threshold based on remaining nodes and distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            threshold = 1.5 + exploration_factor * 0.5\n            return current_to_node + node_to_nearest * threshold\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 9.88638,
          "other_inf": null
     }
]