[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing local optimality by always selecting the closest unvisited node from the current node, using the distance matrix to guide decisions. The function `select_next_node` ensures incremental construction of the path, with `current_node` and `unvisited_nodes` being central to the selection logic. If no unvisited nodes remain, it returns the `destination_node` to complete the cycle.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the solution is constructed incrementally while prioritizing local optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic threshold adjustment and exploration factor to balance immediate distance and future connectivity. It prioritizes the nearest node when options are limited but considers both current distance (70%) and future nearest-neighbor distance (30%) when more nodes remain, using a threshold that adapts based on the ratio of farthest to average distance. The exploration factor scales the weight of future connectivity based on remaining nodes and current distances.",
          "thought": "The new algorithm combines the dynamic threshold adjustment from No.2 with the exploration factor from No.1, prioritizing the nearest node when options are limited but considering both immediate distance and future connectivity when more nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold_ratio = 1.2 + (distance_matrix[current_node][farthest_node] / avg_distance) * 0.3\n    if len(unvisited_nodes) > 1:\n        remaining_unvisited = [n for n in unvisited_nodes if n != nearest_node]\n        nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[nearest_node][n])\n        node_to_nearest = distance_matrix[nearest_node][nearest_remaining]\n        exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n        threshold = 1.0 + exploration_factor * 1.0\n        nearest_score = distance_matrix[current_node][nearest_node] * 0.7 + node_to_nearest * threshold * 0.3\n        farthest_score = distance_matrix[current_node][farthest_node] * 0.7 + distance_matrix[farthest_node][nearest_remaining] * threshold * 0.3\n        next_node = farthest_node if (distance_matrix[current_node][farthest_node] > threshold_ratio * distance_matrix[current_node][nearest_node] and farthest_score < nearest_score) else nearest_node\n    else:\n        next_node = nearest_node\n    return next_node",
          "objective": 7.02965,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection based on remaining unvisited nodes, prioritizing immediate distance when few nodes are left and balancing current distance with future connectivity when more nodes remain. It uses a threshold formula (`1.0 + exploration_factor * 2.0`) to weigh current-to-node distance higher when nodes are plentiful and future connectivity higher when nodes are scarce, with `exploration_factor` decreasing as unvisited nodes decrease. The key design idea is balancing local and global optimization through adaptive prioritization.",
          "thought": "The new algorithm modifies the selection criteria by introducing a dynamic threshold that prioritizes nodes with the shortest immediate distance when few nodes remain, but considers a broader view of future connectivity when more nodes are left, using a different exploration factor calculation and threshold formula.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = 1.0 / (1.0 + len(unvisited_nodes))\n            threshold = 1.0 + exploration_factor * 2.0\n            return current_to_node * threshold + node_to_nearest * (1.0 - threshold)\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.03067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by selecting the farthest node only if its distance is below a dynamically adjusted threshold (1.2 \u00d7 average distance to unvisited nodes), otherwise defaulting to the nearest node. This balances proximity and exploration, prioritizing the farthest node when it is reasonably close, otherwise favoring the nearest node for efficiency. The code structure clearly separates the calculation of key metrics (nearest, farthest, and average distances) before making the selection.",
          "thought": "The new algorithm combines nearest-neighbor with a modified farthest-neighbor heuristic, where the farthest node is selected only if it is within a dynamically adjusted threshold based on the average distance to unvisited nodes, balancing exploration and proximity to improve the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.2 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] < threshold else nearest_node\n    return next_node",
          "objective": 7.1201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to the next node and a normalized future cost estimate (average distance to remaining unvisited nodes), adjusting the weighting factor inversely with the number of remaining nodes to prioritize immediate proximity early and long-term efficiency later. The `weight` parameter (derived from remaining nodes) determines the trade-off between current distance and future cost, with `current_to_node` dominating early and `future_cost` gaining importance as unvisited nodes decrease. The heuristic ensures robustness by adapting to different stages of path construction.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that combines the immediate distance to the next node with a heuristic that estimates the potential impact of the node on the overall path length, using a weighted sum of the current distance and a normalized future cost estimate. It prioritizes nodes that balance immediate proximity and long-term path efficiency, while dynamically adjusting the weighting factor based on the number of remaining nodes to ensure robustness in both early and late stages of path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            future_cost = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            weight = 1.0 / (1.0 + len(unvisited_nodes))  # Dynamic weighting factor\n            return (1 - weight) * current_to_node + weight * future_cost\n        else:\n            return current_to_node\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP tour probabilistically by balancing proximity to the current node (prioritized via a distance-based weight) and potential to reduce future path length (prioritized via the node's average distance to unvisited nodes). A dynamic bias factor, derived from the standard deviation-to-average distance ratio, adjusts the emphasis on proximity, favoring closer nodes when distances are more uniform. The weighted scores combine these factors, with the node maximizing the score chosen as the next step.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism where nodes are chosen based on a weighted combination of their distance to the current node and their potential to reduce the overall tour length, using a dynamic bias factor that adapts to the distance distribution of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    std_dev = (sum((distance_matrix[current_node][node] - avg_distance) ** 2 for node in unvisited_nodes) / len(unvisited_nodes)) ** 0.5\n    bias_factor = 1.0 + (std_dev / avg_distance) if avg_distance > 0 else 0.0\n    weighted_scores = {\n        node: (1 / (distance_matrix[current_node][node] ** bias_factor)) +\n              (distance_matrix[node][destination_node] / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)))\n        for node in unvisited_nodes\n    }\n    next_node = max(weighted_scores.items(), key=lambda item: item[1])[0]\n    return next_node",
          "objective": 7.24149,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the nearest unvisited node if it is at least half as close as the farthest node, otherwise it chooses the farthest node, balancing proximity and exploration. The function uses a distance matrix to evaluate node distances and ensures the path loops back to the destination node when no unvisited nodes remain. The key design ideas are the conditional selection between nearest and farthest nodes based on a distance ratio, with the nearest node given higher priority when it meets the condition.",
          "thought": "The new algorithm prioritizes the farthest node unless the nearest node is at least twice as close, ensuring balance between exploration and proximity, with parameters current_node, unvisited_nodes, and distance_matrix guiding the selection logic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    next_node = nearest_node if distance_matrix[current_node][nearest_node] * 2 <= distance_matrix[current_node][farthest_node] else farthest_node\n    return next_node",
          "objective": 7.32671,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances by adjusting a weight based on the number of remaining unvisited nodes, prioritizing shorter current distances when few nodes remain but considering average future distances when more nodes are left. The weight is calculated as `0.5 + exploration_factor * 0.5`, where `exploration_factor` decreases as the number of unvisited nodes grows, thus favoring immediate gains in later stages. The evaluation function combines these weighted distances to guide the selection of the next node.",
          "thought": "The new algorithm combines the weighted balance of immediate and future distances from No.1 with the dynamic exploration factor from No.2, adjusting the weight based on the number of remaining unvisited nodes to prioritize immediate distance when few nodes remain but consider future efficiency when more nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            avg_future = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            weight = 0.5 + exploration_factor * 0.5\n            return weight * current_to_node + (1 - weight) * avg_future\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.42983,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adapts the nearest-neighbor approach by dynamically balancing immediate distance and future connectivity: when few nodes remain, it prioritizes minimizing the next step (70% weight), while when many nodes are left, it considers both the next step (70%) and the node's proximity to the nearest remaining node (30% weighted by a threshold that increases with remaining nodes). The exploration factor adjusts the threshold based on the number of unvisited nodes, favoring closer nodes when options are limited.",
          "thought": "The new algorithm adapts the nearest-neighbor approach by introducing a dynamic exploration factor that prioritizes immediate distance when few nodes remain and balances future connectivity when many nodes are left. It uses a different threshold calculation, favoring closer nodes with a higher weight when unvisited nodes are scarce and considering future steps more when more nodes are available.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            threshold = 1.0 + exploration_factor * 1.0\n            return current_to_node * 0.7 + node_to_nearest * threshold * 0.3\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.8036,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic extends the nearest-neighbor approach by balancing immediate distance (current_node \u2192 next_node) with future connectivity (next_node \u2192 nearest remaining node), using a temperature-based exploration strategy that prioritizes local optimization early (high temperature) and global exploration later (low temperature). The `exploration_weight` adjusts the balance between immediate and future steps, while the score adjustment (`1.0 / (1.0 + temperature * 0.5)`) further refines selection by emphasizing short-term gains when exploration is high. The algorithm dynamically shifts focus from immediate proximity to long-term path efficiency as unvisited nodes decrease.",
          "thought": "The new algorithm extends the nearest-neighbor approach by incorporating a probabilistic selection mechanism that dynamically adjusts the balance between immediate distance and future connectivity, using a temperature-based exploration strategy that cools as the number of unvisited nodes decreases, ensuring a trade-off between greedy optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n\n            # Temperature-based exploration factor\n            temperature = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n            exploration_weight = temperature * 0.7 + 0.3  # More weight to future steps as temperature decreases\n\n            # Probabilistic selection: closer nodes have higher chance when temperature is high\n            distance_score = current_to_node + node_to_nearest * exploration_weight\n            return distance_score * (1.0 / (1.0 + temperature * 0.5))  # Adjust score based on temperature\n        else:\n            return current_to_node\n\n    # Select node with lowest score (or probabilistically if modified)\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.27528,
          "other_inf": null
     }
]