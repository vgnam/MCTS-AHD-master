[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing local optimality by always selecting the closest unvisited node from the current node, using the distance matrix to guide decisions. The function `select_next_node` ensures incremental construction of the path, with `current_node` and `unvisited_nodes` being central to the selection logic. If no unvisited nodes remain, it returns the `destination_node` to complete the cycle.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring the solution is constructed incrementally while prioritizing local optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by selecting the farthest node only if its distance is below a dynamically adjusted threshold (1.2 \u00d7 average distance to unvisited nodes), otherwise defaulting to the nearest node. This balances proximity and exploration, prioritizing the farthest node when it is reasonably close, otherwise favoring the nearest node for efficiency. The code structure clearly separates the calculation of key metrics (nearest, farthest, and average distances) before making the selection.",
          "thought": "The new algorithm combines nearest-neighbor with a modified farthest-neighbor heuristic, where the farthest node is selected only if it is within a dynamically adjusted threshold based on the average distance to unvisited nodes, balancing exploration and proximity to improve the objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.2 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] < threshold else nearest_node\n    return next_node",
          "objective": 7.1201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the nearest unvisited node if it is at least half as close as the farthest node, otherwise it chooses the farthest node, balancing proximity and exploration. The function uses a distance matrix to evaluate node distances and ensures the path loops back to the destination node when no unvisited nodes remain. The key design ideas are the conditional selection between nearest and farthest nodes based on a distance ratio, with the nearest node given higher priority when it meets the condition.",
          "thought": "The new algorithm prioritizes the farthest node unless the nearest node is at least twice as close, ensuring balance between exploration and proximity, with parameters current_node, unvisited_nodes, and distance_matrix guiding the selection logic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    next_node = nearest_node if distance_matrix[current_node][nearest_node] * 2 <= distance_matrix[current_node][farthest_node] else farthest_node\n    return next_node",
          "objective": 7.32671,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the sum of the distance from the current node to the candidate and from the candidate to its nearest unvisited neighbor, balancing immediate and future path efficiency. It handles the last unvisited node separately by only considering the direct distance to it. The `distance_matrix` is the primary input, and the `unvisited_nodes` set dynamically influences the selection.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering the sum of distances from the current node to the candidate node and from the candidate node to the nearest unvisited node, balancing immediate and future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            return current_to_node + node_to_nearest\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance (weighted by `weight`) and the average future distance to remaining unvisited nodes (weighted by `1-weight`). It prioritizes minimizing the immediate distance when `weight` is high, while favoring reducing future path length when `weight` is low. The function uses a distance matrix and dynamically adjusts the selection based on the remaining unvisited nodes.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted balance between minimizing immediate distance and maximizing the reduction in potential future path length, introducing a tunable parameter to adjust the emphasis on either aspect. It first calculates a score for each candidate node as a weighted sum of its direct distance from the current node and the average distance to the remaining unvisited nodes, then selects the node with the minimum score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, weight=0.5):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            avg_future = sum(distance_matrix[node][n] for n in remaining_unvisited) / len(remaining_unvisited)\n            return weight * current_to_node + (1 - weight) * avg_future\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **nearest-neighbor selection** with a **dynamic exploration factor**, prioritizing proximity while balancing future efficiency. It adjusts the selection threshold based on the number of remaining unvisited nodes and their distances, favoring closer nodes when fewer remain but considering future connectivity when more nodes are left. The `exploration_factor` dynamically weights the importance of immediate distance versus future steps, ensuring a balance between greediness and long-term efficiency.",
          "thought": "The new algorithm combines the dynamic exploration factor from No.1 with the nearest-neighbor lookahead from No.2, balancing proximity and future efficiency by adjusting the selection threshold based on remaining nodes and distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            exploration_factor = len(unvisited_nodes) / (len(unvisited_nodes) + sum(distance_matrix[current_node][n] for n in unvisited_nodes))\n            threshold = 1.5 + exploration_factor * 0.5\n            return current_to_node + node_to_nearest * threshold\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 9.88638,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the product of the distance from the current node and the distance to the nearest unvisited neighbor, balancing immediate and future path costs. It handles the last unvisited node by directly choosing it, ensuring the solution is constructed efficiently. The key design choices are the product-based evaluation of nodes and the dynamic adjustment for the final node.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the product of the distance from the current node to the candidate and the distance from the candidate to the nearest unvisited neighbor, emphasizing the balance between immediate and future path costs, and handles the last unvisited node by only considering the direct distance to it.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            nearest_remaining = min(remaining_unvisited, key=lambda n: distance_matrix[node][n])\n            node_to_nearest = distance_matrix[node][nearest_remaining]\n            return current_to_node * node_to_nearest\n        else:\n            return current_to_node\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 10.20002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted lookahead of future distances to nearby unvisited nodes, using a tunable parameter (`lookahead_weight`) to prioritize short-term efficiency. It evaluates each candidate node by summing the direct distance and a discounted sum of the top 3 nearest future distances, favoring nodes that minimize both immediate and projected long-term travel costs. The `lookahead_weight` adjusts the trade-off between these priorities.",
          "thought": "The new algorithm introduces a dynamic lookahead mechanism that balances immediate distance with a weighted sum of future distances to multiple unvisited neighbors, using a tunable parameter to adjust the trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, lookahead_weight=0.5):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_to_node = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_unvisited = [n for n in unvisited_nodes if n != node]\n            future_costs = sorted([distance_matrix[node][n] for n in remaining_unvisited])[:3]\n            weighted_future = sum(f * (lookahead_weight ** i) for i, f in enumerate(future_costs))\n            return current_to_node + weighted_future\n        else:\n            return current_to_node\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 10.36583,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor selection probabilistically, with a temperature parameter balancing exploration (favoring distant nodes) and exploitation (favoring nearby nodes). A dynamically scaled threshold (`dynamic_threshold`) adjusts the bias toward distant nodes based on the current tour length, ensuring adaptive exploration. The farthest node is prioritized when its distance significantly exceeds the nearest node's distance, while the nearest node dominates otherwise. The temperature and threshold mechanisms dynamically adjust selection priorities.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism where the next node is chosen based on a weighted combination of nearest and farthest neighbors, incorporating a temperature parameter to dynamically adjust exploration vs. exploitation, with a novel distance ratio threshold that scales with the current tour length to balance exploration and efficiency.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, temperature=0.5):\n    if not unvisited_nodes:\n        return destination_node\n\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    nearest_dist = distance_matrix[current_node][nearest_node]\n    farthest_dist = distance_matrix[current_node][farthest_node]\n\n    tour_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes)\n    dynamic_threshold = 1.5 * (1 + math.exp(-tour_length / 100))\n\n    if farthest_dist > dynamic_threshold * nearest_dist:\n        prob_farthest = 1 / (1 + math.exp(-(farthest_dist - nearest_dist) / temperature))\n        next_node = farthest_node if random.random() < prob_farthest else nearest_node\n    else:\n        next_node = nearest_node\n\n    return next_node",
          "objective": 30.46597,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and farthest-neighbor heuristics by dynamically adjusting a threshold (1.5 \u00d7 average distance) to balance exploration and proximity, prioritizing the farthest node if it exceeds the threshold, otherwise selecting the nearest node. It penalizes revisits by excluding already visited nodes from consideration. The key design choices are the threshold-based decision and the explicit handling of the last node to ensure a complete tour.",
          "thought": "The new algorithm combines nearest-neighbor and farthest-neighbor heuristics with a dynamic threshold that adjusts based on the average distance of unvisited nodes, ensuring a balance between proximity and exploration while penalizing revisits to previously considered nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    threshold = 1.5 * avg_distance\n    next_node = farthest_node if distance_matrix[current_node][farthest_node] > threshold else nearest_node\n    return next_node",
          "objective": 31.79832,
          "other_inf": null
     }
]