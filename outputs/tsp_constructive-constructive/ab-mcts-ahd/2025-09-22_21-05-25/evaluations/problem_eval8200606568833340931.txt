def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    farthest_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    std_dev = (sum((distance_matrix[current_node][node] - avg_distance) ** 2 for node in unvisited_nodes) / len(unvisited_nodes)) ** 0.5
    bias_factor = 1.0 + (std_dev / avg_distance) if avg_distance > 0 else 0.0
    weighted_scores = {
        node: (1 / (distance_matrix[current_node][node] ** bias_factor)) +
              (distance_matrix[node][destination_node] / (sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)))
        for node in unvisited_nodes
    }
    next_node = max(weighted_scores.items(), key=lambda item: item[1])[0]
    return next_node
