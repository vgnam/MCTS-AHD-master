import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate distances and ranks
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    sorted_indices = sorted(range(len(distances)), key=lambda k: distances[k])
    ranks = [0] * len(distances)
    for rank, idx in enumerate(sorted_indices):
        ranks[idx] = rank

    # Compute weighted probabilities
    avg_distance = sum(distances) / len(distances)
    threshold = 1.5 * avg_distance
    probabilities = []
    for i, node in enumerate(unvisited_nodes):
        distance = distances[i]
        rank_score = (len(unvisited_nodes) - ranks[i]) / len(unvisited_nodes)  # Higher for closer nodes
        sigmoid = 1 / (1 + math.exp(-(distance - threshold) / avg_distance))  # Sigmoid based on distance vs threshold
        weight = 0.7 * rank_score + 0.3 * sigmoid  # Balance between rank and sigmoid
        probabilities.append(weight)

    # Normalize probabilities
    total = sum(probabilities)
    if total == 0:
        probabilities = [1.0 / len(probabilities)] * len(probabilities)
    else:
        probabilities = [p / total for p in probabilities]

    # Select node based on probabilities
    next_node = unvisited_nodes[sorted(range(len(probabilities)), key=lambda k: -probabilities[k])[0]]
    return next_node
