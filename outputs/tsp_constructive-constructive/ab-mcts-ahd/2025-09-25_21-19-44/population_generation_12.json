[
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates that minimize the ratio of immediate distance to the current node and the sum of distances from the candidate to all unvisited nodes (excluding itself), balancing short-term and long-term optimization while always considering the destination as a candidate. The destination is given special treatment by checking it separately after evaluating other nodes, ensuring it is only chosen if it provides the best ratio. The algorithm avoids division by zero by using `max(1, total_remaining)`.",
          "thought": "The new algorithm prioritizes selecting nodes that minimize the ratio of immediate distance to the current node and the potential reduction in total remaining path length, computed as the sum of distances from the candidate node to all unvisited nodes, ensuring a balance between short-term and long-term optimization while always considering the destination as a candidate.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        immediate_distance = distance_matrix[current_node][node]\n        total_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)\n        ratio = immediate_distance / max(1, total_remaining)\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][destination_node]\n        total_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node)\n        destination_ratio = immediate_distance / max(1, total_remaining)\n\n        if destination_ratio < min_ratio:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, with the destination node given special consideration if it is unvisited and closer than other options. It ensures the path is built incrementally by always choosing the nearest feasible node, optimizing for minimal distance while ensuring the destination is reached efficiently. The function handles edge cases (empty unvisited nodes) and efficiently determines the next step in the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts between short-term (proximity) and long-term (global connectivity) priorities based on remaining node density. Higher density increases the weight of long-term optimization (avg_distance_to_remaining, 75% of score) to prioritize global connectivity, while lower density increases the weight of immediate proximity (distance_to_current) to avoid detours. The density_weight parameter (1.0 - remaining_nodes/(remaining_nodes+1)) ensures smooth transitions between these priorities.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where higher density increases the weight of long-term optimization (avg_distance_to_remaining) to prioritize global connectivity, while lower density increases the weight of immediate proximity (distance_to_current) to avoid excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    remaining_nodes = len(unvisited_nodes)\n    density_weight = 1.0 - (remaining_nodes / (remaining_nodes + 1))  # Higher density -> higher long-term weight\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n        score = (1.0 - density_weight) * distance_to_current + density_weight * 0.75 * avg_distance_to_remaining\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node) / max(1, remaining_nodes - 1)\n        destination_score = (1.0 - density_weight) * distance_to_destination + density_weight * 0.75 * avg_distance_to_remaining\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.16049,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes closer nodes when few unvisited nodes remain, balancing proximity and average distance otherwise, while penalizing high-average-distance nodes to aggressively optimize toward the destination. It dynamically adjusts weights (higher for distance, lower for average distance) and applies penalties (stronger when nodes are scarce) to guide selection toward shorter paths. The destination is always checked last for potential early inclusion.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight factor that adjusts based on the remaining unvisited nodes, prioritizing closer nodes when fewer nodes remain and balancing proximity and average distance when more nodes are left. It also introduces a penalty term for nodes with high average distances to unvisited nodes, ensuring a more aggressive optimization towards the destination when fewer nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight factor based on remaining nodes\n        weight_factor = 1.0 if remaining_nodes > 2 else 0.7\n        penalty = 0.3 * avg_distance_to_remaining if remaining_nodes <= 3 else 0.0\n\n        score = weight_factor * distance_to_current + (0.5 - penalty) * avg_distance_to_remaining\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node) / max(1, len(unvisited_nodes) - 1)\n\n        weight_factor = 1.0 if remaining_nodes > 2 else 0.7\n        penalty = 0.3 * avg_distance_to_remaining if remaining_nodes <= 3 else 0.0\n\n        destination_score = weight_factor * distance_to_destination + (0.5 - penalty) * avg_distance_to_remaining\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.8547,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate proximity (distance to current node) and long-term optimization (average distance to remaining unvisited nodes), with the former given higher weight (1.0x) and the latter given lower weight (0.5x). It ensures the destination node is always considered as a candidate, and the selection is made by minimizing the combined score. The function handles edge cases (empty unvisited nodes) and efficiently evaluates all possible next nodes to find the optimal choice.",
          "thought": "This algorithm prioritizes nodes that are both close to the current node and have a high probability of leading to a short overall path by considering the sum of distances to the current node and the average distance to remaining unvisited nodes, balancing immediate proximity with long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = distance_to_current + 0.5 * avg_distance_to_remaining\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node) / max(1, len(unvisited_nodes) - 1)\n        destination_score = distance_to_destination + 0.5 * avg_distance_to_remaining\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.85593,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and the potential to minimize the total path length for remaining unvisited nodes, using a weighted combination where the immediate distance is prioritized (1.0 weight) and the total distance from the node is given lower weight (0.3). The destination node is always considered as a candidate and prioritized if it offers a better score. The code efficiently evaluates each unvisited node's potential impact on the overall path while ensuring the destination is reached optimally.",
          "thought": "The new algorithm prioritizes selecting the next node by considering both the immediate distance to the current node and the potential to minimize the total path length by evaluating the impact of each choice on the remaining unvisited nodes, using a weighted combination of these factors to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        total_distance_from_node = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)\n        score = distance_to_current + 0.3 * total_distance_from_node\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        total_distance_from_destination = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node)\n        destination_score = distance_to_destination + 0.3 * total_distance_from_destination\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 13.69296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes long-term optimization by heavily weighting (2.0x) the average distance from a node to remaining unvisited nodes, while giving lower weight (0.3x) to immediate proximity (distance from the current node). It ensures the destination is always selected if its score is minimal, balancing short-term and long-term considerations. The code iterates through unvisited nodes, computes a weighted score for each, and selects the node with the lowest score, with special handling for the destination node.",
          "thought": "\nThe new algorithm prioritizes long-term optimization by giving higher weight (2.0x) to the average distance to remaining unvisited nodes and lower weight (0.3x) to immediate proximity, while ensuring the destination node is always considered as a candidate and selected if its score is minimal.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.3 * distance_to_current + 2.0 * avg_distance_to_remaining\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node) / max(1, len(unvisited_nodes) - 1)\n        destination_score = 0.3 * distance_to_destination + 2.0 * avg_distance_to_remaining\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 16.46659,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes long-term optimization by heavily weighting the average distance to remaining unvisited nodes (2.0x) while giving minimal weight to immediate proximity (0.1x), ensuring the path balances global and local considerations. The `select_next_node` function evaluates each unvisited node by computing a score based on the weighted sum of its distance from the current node and the average distance to all other unvisited nodes, then selects the node with the lowest score. The destination node is explicitly checked at the end to ensure the shortest path back is considered.",
          "thought": "The new algorithm prioritizes long-term optimization by heavily weighting the average distance to remaining unvisited nodes (2.0x) while giving minimal weight to immediate proximity (0.1x), ensuring the path balances global and local considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if node == destination_node:\n            return node\n\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.1 * distance_to_current + 2.0 * avg_distance_to_remaining\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_destination = distance_matrix[current_node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[destination_node][n] for n in unvisited_nodes if n != destination_node) / max(1, len(unvisited_nodes) - 1)\n        destination_score = 0.1 * distance_to_destination + 2.0 * avg_distance_to_remaining\n\n        if destination_score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 23.92857,
          "other_inf": null
     }
]