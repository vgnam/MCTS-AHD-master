[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the nearest unvisited neighbor, but if the destination node is unvisited and closer than other options, it overrides the selection. It uses the `distance_matrix` to compute distances and ensures the destination is always the last node visited if it remains unvisited. The `current_node` and `destination_node` are critical inputs, while `unvisited_nodes` determines the available choices.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node closest to the current node, while prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\n\nThe algorithm is a modified simulated annealing approach that combines dynamic nearest neighbor search with adaptive temperature control to balance exploration and exploitation. It prioritizes closer nodes and uses a novel probability function to occasionally choose a random unvisited node, allowing for a trade-off between greediness and randomness.\n\n## Key Components and Priorities\n\n* The algorithm gives higher priority to closer nodes by using a dynamic nearest neighbor search and a bias towards nodes with shorter distances.\n* The `probability` variable controls the trade-off between exploration and exploitation, with a higher value favoring random node selection.\n* The `temperature` variable is adaptively cooled using a `cooling_rate`, influencing the probability of accepting a node.\n\n## Analysis of the Code\n\nThe code implements the described algorithm in the `select_next_node` function. The function takes into account the current node, destination node, unvisited nodes, and distance matrix to determine the next node to visit. The parameters used, such as `temperature`, `cooling_rate`, and the `probability` function, are crucial in controlling the algorithm's behavior.\n\nThe algorithm's structure, which includes a while loop that continues until the temperature is below a certain threshold, allows for a balance between exploration and exploitation. The use of a novel probability function and adaptive temperature control enables the algorithm to adapt to different problem instances.\n\n## Conclusion\n\nThe modified simulated annealing algorithm is designed to effectively solve the Traveling Salesman Problem by balancing exploration and exploitation. By prioritizing closer nodes and using a novel probability function, the algorithm can efficiently search for good solutions.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search with adaptive temperature control and a novel probability function to balance exploration and exploitation.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n    \n    # Dynamic nearest neighbor search\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    min_distance = distance_matrix[current_node][nearest_neighbors[0]]\n    second_min_distance = distance_matrix[current_node][nearest_neighbors[1]] if len(nearest_neighbors) > 1 else min_distance\n    \n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n    \n    # Simulated annealing with adaptive temperature control\n    while temperature > 1:\n        # Novel probability function to balance exploration and exploitation\n        probability = 1 / (1 + math.exp((temperature - 50) / 10))\n        if random.random() < probability:\n            # Choose a random unvisited node with a bias towards closer nodes\n            next_node = random.choices(list(unvisited_nodes), weights=[1 / distance_matrix[current_node][node] for node in unvisited_nodes])[0]\n        else:\n            # Choose between nearest neighbor and destination node with a bias towards the closer one\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbors[0]\n        \n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        # Accept the chosen node with a certain probability based on the distance difference and temperature\n        distance_diff = second_min_distance - distance_matrix[current_node][next_node]\n        if next_node == destination_node or random.random() < math.exp(distance_diff / temperature):\n            return next_node\n        \n        temperature *= cooling_rate\n    \n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 7.10183,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a constructive heuristic for the Traveling Salesman Problem (TSP) that selects the next node to visit based on a score calculated from a weighted sum of local cost, global cost, and a penalty term, with weights dynamically adjusted using a simulated annealing-inspired mechanism. The score prioritizes nodes that are close to the current node and likely to lead to a shorter overall path, while penalizing nodes with large average distances to other unvisited nodes. The algorithm considers a limited set of k-nearest neighbors to reduce computational complexity.",
          "thought": "The new algorithm modifies the existing one by incorporating a simulated annealing-inspired mechanism to dynamically adjust the weights between local and global cost evaluations, and introduces a penalty term for nodes that are likely to lead to a longer overall path.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Simulated annealing-inspired temperature parameter\n    T = 100 / (1 + len(unvisited_nodes))\n    \n    min_score = float('inf')\n    next_node = None\n    \n    # Find k-nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        \n        # Global cost evaluation with an additional penalty term\n        global_cost = 0\n        penalty = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n                # Penalty term based on the average distance to other unvisited nodes\n                avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n                penalty = max(0, avg_distance - distance_matrix[node][nearest_remaining])\n            else:\n                global_cost = distance_matrix[node][destination_node]\n        \n        # Dynamic weight adjustment inspired by simulated annealing\n        weight_local = 0.7 + (0.3 * (1 - math.exp(-T)))\n        weight_global = 1 - weight_local\n        \n        score = weight_local * local_cost + weight_global * global_cost + 0.1 * penalty\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    # Explicitly check the destination node\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n        penalty = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n            avg_distance = sum(distance_matrix[destination_node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = max(0, avg_distance - distance_matrix[destination_node][nearest_remaining])\n        \n        score = weight_local * local_cost + weight_global * global_cost + 0.1 * penalty\n        \n        if score < min_score:\n            next_node = destination_node\n    \n    return next_node",
          "objective": 7.14883,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with probabilistic randomness, prioritizing the nearest unvisited node but occasionally choosing random nodes with exponentially decreasing probability (controlled by `temperature` and `cooling_rate`). If the destination node is unvisited and closer than the nearest neighbor, it has higher priority in the probabilistic selection. The algorithm accepts a node based on its distance relative to the current best (nearest neighbor) and the temperature, ensuring a balance between local optimization and exploration.",
          "thought": "The new algorithm uses a probabilistic selection between the nearest neighbor and a random node, with the probability of choosing the random node decreasing exponentially with a different cooling rate, and prioritizes the destination node if it's among the unvisited nodes and closer than the nearest neighbor.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Initialize temperature and cooling rate\n    temperature = 50\n    cooling_rate = 0.9\n\n    # Find nearest neighbor\n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n\n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n\n    # Probabilistic selection\n    while temperature > 0.1:\n        if random.random() < math.exp(-temperature / 10):\n            # Choose a random unvisited node\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            # Choose between nearest neighbor and destination node\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbor\n\n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n\n        # Accept the chosen node with a certain probability\n        if next_node == destination_node or random.random() < math.exp((min_distance - distance_matrix[current_node][next_node]) / temperature):\n            return next_node\n\n        temperature *= cooling_rate\n\n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 7.15528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor to the current node, but with a temperature-based probabilistic chance to explore random unvisited nodes (probability decreases exponentially with temperature). If the destination node is unvisited and closer than the nearest neighbor, it is given higher priority. The algorithm uses a cooling schedule (`temperature *= cooling_rate`) to gradually shift from exploration to exploitation.",
          "thought": "The new algorithm design idea is: It uses a temperature-based probabilistic selection between the nearest neighbor and a random unvisited node, with the probability of choosing the random node decreasing exponentially with temperature, and prioritizes the destination node if it's among the unvisited nodes and closer than the nearest neighbor.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    temperature = 50\n    cooling_rate = 0.9\n\n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n\n    while temperature > 0.1:\n        if random.random() < math.exp(-temperature / 10):\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbor\n\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n\n        if next_node == destination_node or random.random() < math.exp((min_distance - distance_matrix[current_node][next_node]) / (temperature * 0.5)):\n            return next_node\n\n        temperature *= cooling_rate\n\n    return next_node",
          "objective": 7.17358,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **k-nearest neighbor selection (local cost prioritized at 70%)** with **global cost evaluation (30%)**, dynamically balancing exploration and exploitation. It first identifies the nearest neighbors (up to 5) from unvisited nodes, then evaluates each candidate by weighting local travel cost (70%) and global future cost (30%), where the latter estimates the shortest path back to the destination. The destination node is also explicitly checked to ensure optimality. The weights (0.7 and 0.3) reflect higher priority on immediate efficiency while still considering long-term connectivity.",
          "thought": "The new algorithm combines the k-nearest neighbor selection from No.1 with the weighted local and global cost evaluation from No.2, prioritizing immediate local costs (70%) while considering global costs (30%) through a dynamic k-nearest neighbor search, allowing for better exploration and exploitation balance.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Find k-nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n\n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.7 * local_cost + 0.3 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.7 * local_cost + 0.3 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.46476,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a constructive heuristic for the Traveling Salesman Problem (TSP) by dynamically adjusting the number of nearest neighbors to consider and using a weighted scoring system that balances local and global costs. The weights are adjusted based on the number of unvisited nodes, prioritizing local cost when there are fewer unvisited nodes and balancing local and global costs when there are many unvisited nodes. The scoring system gives higher priority to nodes with lower local costs and potentially lower global costs, as indicated by the weights (0.8 and 0.6 for local cost when unvisited nodes are less than half of total nodes and otherwise, respectively).",
          "thought": "The new algorithm will dynamically adjust the number of nearest neighbors to consider based on the number of unvisited nodes, using a weighted scoring system that prioritizes local cost more heavily when there are fewer unvisited nodes and balances local and global costs when there are many unvisited nodes, while also ensuring an explicit check for the destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    min_score = float('inf')\n    next_node = None\n    \n    # Dynamically adjust k based on the number of unvisited nodes\n    k = min(max(3, len(unvisited_nodes) // 2), len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n        \n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n        \n        # Adjust weights based on the number of unvisited nodes\n        weight_local = 0.8 if len(unvisited_nodes) < len(distance_matrix) // 2 else 0.6\n        weight_global = 1 - weight_local\n        \n        score = weight_local * local_cost + weight_global * global_cost\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n        \n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n        \n        score = 0.8 * local_cost + 0.2 * global_cost if len(unvisited_nodes) < len(distance_matrix) // 2 else 0.6 * local_cost + 0.4 * global_cost\n        \n        if score < min_score:\n            next_node = destination_node\n    \n    return next_node",
          "objective": 7.73125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a constructive heuristic for the Traveling Salesman Problem (TSP) by selecting the next node to visit based on a weighted score that combines local cost (60% priority) and global cost (40% priority), considering the 3 nearest neighbors to the current node. The local cost is the distance between the current node and the next node, while the global cost estimates the cost of completing the tour from the next node to the destination node. The algorithm prioritizes nodes that balance these two costs.",
          "thought": "The new algorithm combines k-nearest neighbor selection with global cost evaluation, prioritizing local cost at 60% and global cost at 40%, and considers the 3 nearest neighbors for the next node selection.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    min_score = float('inf')\n    next_node = None\n    \n    # Find k-nearest neighbors\n    k = min(3, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n        score = 0.6 * local_cost + 0.4 * global_cost\n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n        score = 0.6 * local_cost + 0.4 * global_cost\n        if score < min_score:\n            next_node = destination_node\n    \n    return next_node",
          "objective": 7.95984,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a greedy approach, prioritizing immediate local costs (60%) while also considering future global costs (40%) to balance exploration and exploitation. It evaluates each unvisited node by computing a weighted score of the direct distance from the current node and the estimated cost to reach the destination via that node, then selects the node with the lowest score. The destination node is also explicitly checked if it remains unvisited.",
          "thought": "This algorithm combines nearest neighbor selection with a greedy approach to minimize the immediate and potential future path costs, using a weighted sum of local and global cost estimates to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.07457,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local and global costs, where local cost is the direct distance from the current node, and global cost estimates the future path's potential by considering the nearest remaining unvisited node and the destination. The balance between local and global costs is dynamically adjusted based on the number of remaining nodes (prioritizing global cost as nodes decrease). The algorithm also penalizes revisiting nodes (1.1 multiplier) and ensures the destination is always considered as a candidate.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting scheme based on the number of remaining nodes, adjusting the balance between local and global costs, and introducing a penalty for revisiting nodes, while preserving the destination node check for completeness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        weight_local = 0.5 + 0.2 * (remaining_count / len(distance_matrix)) if remaining_count > 0 else 0.5\n        weight_global = 1 - weight_local\n\n        score = weight_local * local_cost + weight_global * global_cost\n\n        if node in unvisited_nodes and node != current_node:\n            score *= 1.1\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = weight_local * local_cost + weight_global * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.11001,
          "other_inf": null
     }
]