[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the nearest unvisited neighbor, but if the destination node is unvisited and closer than other options, it overrides the selection. It uses the `distance_matrix` to compute distances and ensures the destination is always the last node visited if it remains unvisited. The `current_node` and `destination_node` are critical inputs, while `unvisited_nodes` determines the available choices.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node closest to the current node, while prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a greedy approach, prioritizing immediate local costs (60%) while also considering future global costs (40%) to balance exploration and exploitation. It evaluates each unvisited node by computing a weighted score of the direct distance from the current node and the estimated cost to reach the destination via that node, then selects the node with the lowest score. The destination node is also explicitly checked if it remains unvisited.",
          "thought": "This algorithm combines nearest neighbor selection with a greedy approach to minimize the immediate and potential future path costs, using a weighted sum of local and global cost estimates to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.07457,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a modified simulated annealing approach that selects the next node to visit from a set of k nearest neighbors to the current node, with a probability based on the relative distances and the current temperature. The temperature is gradually cooled down, and the probability of choosing a farther neighbor decreases as the temperature drops. The algorithm prioritizes exploration at higher temperatures and exploitation at lower temperatures.\n\nTo get a better understanding of the response, let's analyze the given code. The key components are:\n\n- `k` nearest neighbors are considered for the next node, indicating a priority on closer nodes.\n- The `temperature` and `cooling_rate` control the simulated annealing process, with the temperature decreasing over time.\n- The probability of choosing a neighbor is calculated using `math.exp(-distance / temperature)`, giving higher probabilities to closer neighbors at lower temperatures.\n\nOverall, the algorithm balances exploration and exploitation by considering a subset of nearest neighbors and using a temperature-controlled probability function.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search and a novel probability function based on the relative distances and temperature to select the next node to visit in the Traveling Salesman Problem.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n    \n    # Find k nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    # Simulated annealing\n    while temperature > 1:\n        # Calculate probabilities for k nearest neighbors\n        probabilities = []\n        for neighbor in nearest_neighbors:\n            distance = distance_matrix[current_node][neighbor]\n            probability = math.exp(-distance / temperature)\n            probabilities.append(probability)\n        \n        # Normalize probabilities\n        sum_probabilities = sum(probabilities)\n        probabilities = [p / sum_probabilities for p in probabilities]\n        \n        # Choose a node based on the probabilities\n        r = random.random()\n        cumulative_probability = 0\n        for i, probability in enumerate(probabilities):\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = nearest_neighbors[i]\n                break\n        \n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        # Accept the chosen node\n        return next_node\n        \n        # Cool down the temperature\n        temperature *= cooling_rate\n    \n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 13.76555,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\nThe algorithm is a modified simulated annealing approach that combines a dynamic k-nearest neighbor search with a temperature-controlled probability function to select the next node to visit in the Traveling Salesman Problem. The algorithm prioritizes nodes that are closer to the current node and gives higher priority to the destination node, while also allowing for random exploration through the temperature-controlled probability function. \n\n## Key Components of the Algorithm\n- **K-Nearest Neighbors Search**: The algorithm considers a subset of `k` nearest neighbors (where `k` is at most 5) to the current node, as determined by the `distance_matrix`.\n- **Probability Function**: The probability of selecting a neighbor is based on the exponential of the negative distance between the current node and the neighbor, divided by the current `temperature`. The destination node is given twice the probability of other nodes.\n- **Temperature Control**: The `temperature` is gradually decreased by a `cooling_rate` of 0.95 at each iteration, affecting the probability function's sensitivity to distance.\n\n## Analysis of the Code\nThe given code implements the described algorithm through the `select_next_node` function, which takes into account the `current_node`, `destination_node`, `unvisited_nodes`, and `distance_matrix`. It iteratively selects the next node based on the calculated probabilities until it finds a valid `next_node` among the `unvisited_nodes` or exhausts the maximum number of iterations. The function returns the `destination_node` if all nodes have been visited.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search and a novel probability function based on both distance and temperature, to solve the Traveling Salesman Problem.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    temperature = 100\n    cooling_rate = 0.95\n    max_iterations = 1000\n\n    for _ in range(max_iterations):\n        # Find k-nearest neighbors\n        k = min(5, len(unvisited_nodes))\n        nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n\n        # Calculate the probability for each nearest neighbor\n        probabilities = []\n        for neighbor in nearest_neighbors:\n            distance = distance_matrix[current_node][neighbor]\n            probability = math.exp(-distance / temperature)\n            if neighbor == destination_node:\n                probability *= 2  # Give higher priority to destination node\n            probabilities.append(probability)\n\n        # Normalize the probabilities\n        probabilities = [p / sum(probabilities) for p in probabilities]\n\n        # Select the next node based on the probabilities\n        next_node = random.choices(nearest_neighbors, weights=probabilities, k=1)[0]\n\n        # Check if the chosen node is valid\n        if next_node in unvisited_nodes:\n            return next_node\n\n        temperature *= cooling_rate\n\n    # Return a random unvisited node if the temperature is too low\n    return next_node",
          "objective": 13.87674,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\nThe `select_next_node` function implements a modified simulated annealing algorithm to solve the Traveling Salesman Problem (TSP), prioritizing the nearest unvisited node and the destination node while allowing occasional random exploration based on a temperature-controlled probability. The algorithm iteratively updates the temperature using a cooling rate and selects the next node based on a trade-off between the nearest neighbor, the destination node, and random exploration. \n\n## Key Insights from the Code\n- The algorithm starts with a high temperature and gradually cools down using a cooling rate of 0.99.\n- It maintains a balance between choosing the nearest unvisited node (`nearest_neighbor`) and the destination node (`destination_node`) based on their distances from the current node.\n- The probability of choosing a random node is higher at higher temperatures, allowing for more exploration, while at lower temperatures, it tends to choose the nearest neighbor or the destination node.\n- The algorithm ensures that the next node is not revisited by checking if it is in the `unvisited_nodes` set.\n\n## Critical Design Ideas\n- The use of simulated annealing allows the algorithm to avoid getting stuck in local optima by occasionally choosing suboptimal nodes.\n- The prioritization of the nearest neighbor and the destination node guides the algorithm towards more optimal solutions.\n- The cooling schedule and probability calculation control the trade-off between exploration and exploitation.",
          "thought": "The new algorithm, 'select_next_node', implements a modified simulated annealing approach with a different probability calculation and cooling schedule to solve the TSP, prioritizing closer nodes and the destination node while allowing occasional random exploration.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    temperature = 100\n    cooling_rate = 0.99\n    \n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n    \n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n    \n    while temperature > 1:\n        if random.random() < math.exp(-temperature / 100):\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbor\n        \n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        if next_node == destination_node or random.random() < math.exp((min_distance - distance_matrix[current_node][next_node]) / (temperature + 1)):\n            return next_node\n        \n        temperature *= cooling_rate\n    \n    return next_node",
          "objective": 14.2791,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by evaluating both the nearest neighbor and the destination node, prioritizing the one that minimizes the total path length when combined with the remaining unvisited nodes. It iterates through unvisited nodes, calculates the total path cost for each candidate (considering the destination node if applicable), and selects the node that yields the minimum total cost. The destination node is also explicitly checked to ensure it is considered as a potential next node. The algorithm balances local (nearest neighbor) and global (destination-oriented) decisions to approximate the optimal path.",
          "thought": "This algorithm selects the next node by considering both the nearest neighbor and the destination node, prioritizing the one that minimizes the total path length when combined with the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        remaining_nodes = unvisited_nodes - {node}\n        if destination_node in remaining_nodes:\n            remaining_nodes.remove(destination_node)\n\n        if not remaining_nodes:\n            total = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        else:\n            total = distance_matrix[current_node][node]\n            for next_node_candidate in remaining_nodes:\n                total += distance_matrix[node][next_node_candidate]\n            total += distance_matrix[next_node_candidate][destination_node]\n\n        if total < min_total:\n            min_total = total\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_total = distance_matrix[current_node][destination_node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            for node in remaining_nodes:\n                destination_total += distance_matrix[destination_node][node]\n            destination_total += distance_matrix[node][current_node]\n\n        if destination_total < min_total:\n            next_node = destination_node\n\n    return next_node",
          "objective": 21.88632,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines simulated annealing with dynamic cooling and non-linear probabilistic selection to choose the next node in TSP. It prioritizes lower-cost nodes more aggressively by emphasizing them in the probability calculation, while still allowing exploration at higher temperatures. The dynamic cooling rate adapts based on the current temperature and node validity, with the destination node being a special case that is evaluated separately. The algorithm balances exploration and exploitation by adjusting probabilities non-linearly and gradually cooling the temperature.",
          "thought": "The new algorithm modifies the simulated annealing approach by using a dynamic cooling rate that adapts based on the current temperature and a non-linear probability calculation that emphasizes lower-cost nodes more aggressively, while still allowing exploration at higher temperatures.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Initialize temperature and dynamic cooling rate\n    temperature = 1000\n    base_cooling_rate = 0.9\n    dynamic_cooling_rate = 1.0\n\n    # Evaluate total path cost for each candidate node\n    candidate_nodes = list(unvisited_nodes)\n    total_costs = []\n    for node in candidate_nodes:\n        remaining_nodes = unvisited_nodes - {node}\n        if destination_node in remaining_nodes:\n            remaining_nodes.remove(destination_node)\n        if not remaining_nodes:\n            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        else:\n            total_cost = distance_matrix[current_node][node]\n            for next_node_candidate in remaining_nodes:\n                total_cost += distance_matrix[node][next_node_candidate]\n            total_cost += distance_matrix[next_node_candidate][destination_node]\n        total_costs.append(total_cost)\n\n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_total = distance_matrix[current_node][destination_node]\n        remaining_nodes = unvisited_nodes - {destination_node}\n        for node in remaining_nodes:\n            destination_total += distance_matrix[destination_node][node]\n        destination_total += distance_matrix[node][destination_node]\n        candidate_nodes.append(destination_node)\n        total_costs.append(destination_total)\n\n    # Simulated annealing with dynamic cooling and non-linear probabilities\n    while temperature > 0.1:\n        # Calculate probabilities with non-linear emphasis on lower costs\n        min_total_cost = min(total_costs)\n        probabilities = [(1 - (total_cost - min_total_cost) / (max(total_costs) - min_total_cost + 1e-6)) ** (1 + temperature / 1000) for total_cost in total_costs]\n        sum_probabilities = sum(probabilities)\n        probabilities = [p / sum_probabilities for p in probabilities]\n\n        # Choose a node based on probabilities\n        r = random.random()\n        cumulative_probability = 0\n        for i, probability in enumerate(probabilities):\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = candidate_nodes[i]\n                break\n\n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= base_cooling_rate * dynamic_cooling_rate\n            dynamic_cooling_rate *= 0.99\n            continue\n\n        return next_node\n\n    # Return the node with the minimum total cost if the temperature is too low\n    next_node = candidate_nodes[total_costs.index(min(total_costs))]\n    return next_node",
          "objective": 24.77252,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a simulated annealing approach to solve the Traveling Salesman Problem (TSP) by selecting the next node to visit based on a probabilistic choice between the nearest unvisited neighbor and a random unvisited node. The probability of choosing the random node decreases as the temperature decreases, with the cooling rate controlling the rate of this decrease. The algorithm prioritizes nodes that are closer to the current node and gives higher priority to the destination node if it's among the unvisited nodes and is closer than the nearest neighbor.",
          "thought": "The algorithm uses a simulated annealing approach to select the next node by probabilistically choosing between the nearest unvisited neighbor and a random unvisited node, with the probability of choosing the random node decreasing as the temperature decreases.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n    \n    # Find nearest neighbor\n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n    \n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n    \n    # Simulated annealing\n    while temperature > 1:\n        if random.random() < temperature / 100:\n            # Choose a random unvisited node\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            # Choose between nearest neighbor and destination node\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbor\n        \n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        # Accept the chosen node with a certain probability\n        if next_node == destination_node or random.random() < math.exp((min_distance - distance_matrix[current_node][next_node]) / temperature):\n            return next_node\n        \n        temperature *= cooling_rate\n    \n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 25.96287,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a greedy approach with adaptive temperature scaling in simulated annealing to balance exploration and exploitation. It prioritizes nodes with lower estimated total costs while allowing occasional exploration via temperature-based probabilistic selection, where temperature dynamically adjusts based on cost variance. The cooling factor gradually reduces temperature to refine the selection, ensuring convergence toward a near-optimal solution.",
          "thought": "The new algorithm uses a greedy approach with adaptive temperature scaling to balance exploration and exploitation, where temperature is dynamically adjusted based on the variance of total costs to prioritize nodes with lower costs while allowing occasional exploration.",
          "code": "import random\nimport math\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Initialize temperature based on cost variance\n    candidate_nodes = list(unvisited_nodes)\n    total_costs = []\n    for node in candidate_nodes:\n        remaining_nodes = unvisited_nodes - {node}\n        if destination_node in remaining_nodes:\n            remaining_nodes.remove(destination_node)\n        if not remaining_nodes:\n            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        else:\n            total_cost = distance_matrix[current_node][node]\n            for next_node_candidate in remaining_nodes:\n                total_cost += distance_matrix[node][next_node_candidate]\n            total_cost += distance_matrix[next_node_candidate][destination_node]\n        total_costs.append(total_cost)\n\n    if destination_node in unvisited_nodes:\n        destination_total = distance_matrix[current_node][destination_node]\n        remaining_nodes = unvisited_nodes - {destination_node}\n        for node in remaining_nodes:\n            destination_total += distance_matrix[destination_node][node]\n        destination_total += distance_matrix[node][destination_node]\n        candidate_nodes.append(destination_node)\n        total_costs.append(destination_total)\n\n    # Calculate temperature based on cost variance\n    cost_variance = np.var(total_costs)\n    temperature = max(1, cost_variance * 10)\n\n    # Simulated annealing with adaptive cooling\n    cooling_factor = 0.99\n    while temperature > 0.1:\n        min_total_cost = min(total_costs)\n        probabilities = [math.exp((min_total_cost - total_cost) / temperature) for total_cost in total_costs]\n        sum_probabilities = sum(probabilities)\n        probabilities = [p / sum_probabilities for p in probabilities]\n\n        r = random.random()\n        cumulative_probability = 0\n        for i, probability in enumerate(probabilities):\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = candidate_nodes[i]\n                break\n\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_factor\n            continue\n\n        return next_node\n\n    next_node = candidate_nodes[total_costs.index(min(total_costs))]\n    return next_node",
          "objective": 26.00268,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global cost evaluation (with 60% weight on local and 40% on global) and uses simulated annealing to probabilistically select the next node based on these scores, balancing immediate and future costs while allowing exploration of suboptimal paths. The destination node is prioritized if it remains unvisited, and the selection process adapts dynamically with cooling temperature to refine choices.",
          "thought": "The new algorithm combines the local and global cost evaluation from No.1 with the probabilistic selection of No.2, using a weighted score to balance immediate and future costs, and applying simulated annealing to probabilistically select nodes based on these scores.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n\n    # Evaluate weighted scores for each candidate node\n    candidate_nodes = list(unvisited_nodes)\n    scores = []\n    for node in candidate_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        remaining_nodes = unvisited_nodes - {node}\n        if destination_node in remaining_nodes:\n            remaining_nodes.remove(destination_node)\n\n        if remaining_nodes:\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n            global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n        else:\n            global_cost = distance_matrix[node][destination_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n        scores.append(score)\n\n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        remaining_nodes = unvisited_nodes - {destination_node}\n        if remaining_nodes:\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n        candidate_nodes.append(destination_node)\n        scores.append(score)\n\n    # Simulated annealing\n    while temperature > 1:\n        # Calculate probabilities based on scores\n        min_score = min(scores)\n        probabilities = [math.exp((min_score - score) / temperature) for score in scores]\n        sum_probabilities = sum(probabilities)\n        probabilities = [p / sum_probabilities for p in probabilities]\n\n        # Choose a node based on probabilities\n        r = random.random()\n        cumulative_probability = 0\n        for i, probability in enumerate(probabilities):\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = candidate_nodes[i]\n                break\n\n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n\n        return next_node\n\n    # Return the node with the minimum score if the temperature is too low\n    next_node = candidate_nodes[scores.index(min(scores))]\n    return next_node",
          "objective": 26.17449,
          "other_inf": null
     }
]