import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Initial temperature and cooling rate
    temp = 1000
    cooling_rate = 0.95
    
    # Calculate the initial score for each unvisited node
    scores = {}
    for node in unvisited_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        
        if not remaining_nodes:
            total = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        else:
            total = distance_matrix[current_node][node]
            for next_node_candidate in remaining_nodes:
                total += distance_matrix[node][next_node_candidate]
            total += distance_matrix[next_node_candidate][destination_node]
        
        scores[node] = total
    
    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {destination_node}
            for node in remaining_nodes:
                destination_total += distance_matrix[destination_node][node]
            destination_total += distance_matrix[node][current_node]
        scores[destination_node] = destination_total
    
    # Simulated annealing
    while temp > 1:
        # Select two random nodes from unvisited nodes
        node1, node2 = random.sample(list(unvisited_nodes), 2)
        
        # Calculate the probability of choosing node1 or node2 based on their scores
        score1 = scores[node1]
        score2 = scores[node2]
        prob = math.exp((score2 - score1) / temp)
        
        # Choose node1 with probability prob, otherwise choose node2
        if random.random() < prob:
            next_node = node1
        else:
            next_node = node2
        
        # Check if destination node is a better choice
        if destination_node in unvisited_nodes and scores[destination_node] < scores[next_node]:
            next_node = destination_node
        
        # Cool down the temperature
        temp *= cooling_rate
    
    # Return the node with the minimum score after cooling down
    next_node = min(scores, key=scores.get)
    return next_node
