import random
import math
from collections import defaultdict

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate node centrality (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        total_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)
        centrality[node] = total_dist / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0

    # Track visit frequency (simplified for this example)
    visit_frequency = defaultdict(int)
    for node in unvisited_nodes:
        visit_frequency[node] = random.random()  # In practice, track actual visits

    candidates = []
    k = min(5, len(unvisited_nodes))
    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]

    for node in nearest_neighbors:
        local_cost = distance_matrix[current_node][node]
        global_cost = 0

        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {node}
            if destination_node in remaining_nodes:
                remaining_nodes.remove(destination_node)

            if remaining_nodes:
                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])
                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]
            else:
                global_cost = distance_matrix[node][destination_node]

        # Novel scoring: combine cost, centrality, and frequency
        cost_score = 0.7 * local_cost + 0.3 * global_cost
        centrality_score = centrality[node]
        frequency_score = 1 / (1 + visit_frequency[node])  # Less frequent nodes get higher score

        # Combine with weights (adjustable)
        total_score = 0.5 * cost_score + 0.3 * centrality_score + 0.2 * frequency_score
        candidates.append((node, total_score))

    # Probabilistic selection based on scores
    if candidates:
        nodes, scores = zip(*candidates)
        probs = [math.exp(-s) for s in scores]  # Higher score -> lower probability
        total_prob = sum(probs)
        probs = [p/total_prob for p in probs]
        next_node = random.choices(nodes, weights=probs, k=1)[0]
    else:
        next_node = random.choice(list(unvisited_nodes))

    # Explicit destination check
    if destination_node in unvisited_nodes:
        local_cost = distance_matrix[current_node][destination_node]
        global_cost = 0

        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {destination_node}
            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])
            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]

        dest_score = 0.7 * local_cost + 0.3 * global_cost
        dest_centrality = centrality.get(destination_node, 0)
        dest_frequency = 1 / (1 + visit_frequency.get(destination_node, 0))
        total_dest_score = 0.5 * dest_score + 0.3 * dest_centrality + 0.2 * dest_frequency

        # Compare with probabilistic selection
        if total_dest_score < min(scores) * 0.9:  # If significantly better
            next_node = destination_node

    return next_node
