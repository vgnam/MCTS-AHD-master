import random
import math
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize temperature based on cost variance
    candidate_nodes = list(unvisited_nodes)
    total_costs = []
    for node in candidate_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        if not remaining_nodes:
            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        else:
            total_cost = distance_matrix[current_node][node]
            for next_node_candidate in remaining_nodes:
                total_cost += distance_matrix[node][next_node_candidate]
            total_cost += distance_matrix[next_node_candidate][destination_node]
        total_costs.append(total_cost)

    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        remaining_nodes = unvisited_nodes - {destination_node}
        for node in remaining_nodes:
            destination_total += distance_matrix[destination_node][node]
        destination_total += distance_matrix[node][destination_node]
        candidate_nodes.append(destination_node)
        total_costs.append(destination_total)

    # Calculate temperature based on cost variance
    cost_variance = np.var(total_costs)
    temperature = max(1, cost_variance * 10)

    # Simulated annealing with adaptive cooling
    cooling_factor = 0.99
    while temperature > 0.1:
        min_total_cost = min(total_costs)
        probabilities = [math.exp((min_total_cost - total_cost) / temperature) for total_cost in total_costs]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break

        if next_node not in unvisited_nodes:
            temperature *= cooling_factor
            continue

        return next_node

    next_node = candidate_nodes[total_costs.index(min(total_costs))]
    return next_node
