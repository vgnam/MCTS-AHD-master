import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    temperature = 100
    cooling_rate = 0.95
    candidate_nodes = list(unvisited_nodes)

    # Evaluate total path cost for each candidate node
    total_costs = []
    node_degrees = []
    for node in candidate_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        if not remaining_nodes:
            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        else:
            total_cost = distance_matrix[current_node][node]
            for next_node_candidate in remaining_nodes:
                total_cost += distance_matrix[node][next_node_candidate]
            total_cost += distance_matrix[next_node_candidate][destination_node]
        total_costs.append(total_cost)

        # Calculate node degree (number of connections)
        degree = sum(1 for n in candidate_nodes if distance_matrix[node][n] > 0)
        node_degrees.append(degree)

    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        remaining_nodes = unvisited_nodes - {destination_node}
        for node in remaining_nodes:
            destination_total += distance_matrix[destination_node][node]
        destination_total += distance_matrix[node][destination_node]
        candidate_nodes.append(destination_node)
        total_costs.append(destination_total)
        node_degrees.append(len(unvisited_nodes) - 1)

    # Hybrid simulated annealing with cost-weighting
    while temperature > 1:
        min_total_cost = min(total_costs)
        max_degree = max(node_degrees) if node_degrees else 1

        # Calculate cost-weight factors
        cost_weights = []
        for i, cost in enumerate(total_costs):
            degree_factor = node_degrees[i] / max_degree if max_degree > 0 else 1
            distance_factor = 1 / (1 + math.exp(-(cost - min_total_cost) / temperature))
            cost_weight = (1 - degree_factor) * distance_factor
            cost_weights.append(cost_weight)

        # Calculate probabilities
        probabilities = [math.exp(cost_weight / temperature) for cost_weight in cost_weights]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        # Choose a node based on probabilities
        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break

        if next_node not in unvisited_nodes:
            temperature *= cooling_rate
            continue

        return next_node

    # Return the node with the minimum total cost if the temperature is too low
    next_node = candidate_nodes[total_costs.index(min(total_costs))]
    return next_node
