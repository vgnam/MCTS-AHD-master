import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic temperature based on average distance to unvisited nodes
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    temperature = 100 * (1 / (1 + math.exp(-avg_distance / 10)))  # Sigmoid scaling

    # Find nearest neighbor
    min_distance = float('inf')
    nearest_neighbor = None
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if distance < min_distance:
            min_distance = distance
            nearest_neighbor = node

    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        destination_distance = distance_matrix[current_node][destination_node]
    else:
        destination_distance = float('inf')

    # Dynamic probability for random selection
    random_prob = 0.5 * (1 / (1 + math.exp(-temperature / 50)))  # Sigmoid probability

    # Destination bias calculation
    if destination_distance < min_distance * 0.7:  # Destination is significantly closer
        bias_factor = 0.8
    else:
        bias_factor = 0.2

    # Selection process
    if random.random() < random_prob:
        next_node = random.choice(list(unvisited_nodes))
    else:
        if destination_distance < min_distance and random.random() < bias_factor:
            next_node = destination_node
        else:
            next_node = nearest_neighbor

    # Validation and adjustment
    if next_node not in unvisited_nodes:
        next_node = nearest_neighbor if nearest_neighbor in unvisited_nodes else random.choice(list(unvisited_nodes))

    return next_node
