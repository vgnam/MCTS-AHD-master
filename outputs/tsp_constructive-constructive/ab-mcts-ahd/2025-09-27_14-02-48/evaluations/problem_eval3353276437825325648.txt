import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Calculate distances to all unvisited nodes and the destination node
    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}
    destination_distance = distance_matrix[current_node][destination_node]
    
    # Calculate a score for each unvisited node based on its distance and the distance to the destination node
    scores = {node: distance + 0.5 * destination_distance / (1 + math.exp(-(destination_distance - distance) / max(distances.values()))) for node, distance in distances.items()}
    
    # Apply a temperature-based probability to the scores to introduce randomness
    temperature = 0.1 * max(distances.values())
    probabilities = {node: math.exp(-score / temperature) for node, score in scores.items()}
    probabilities = {node: prob / sum(probabilities.values()) for node, prob in probabilities.items()}
    
    # Select the next node based on the probabilities
    next_node = random.choices(list(probabilities.keys()), weights=probabilities.values(), k=1)[0]
    
    # Override the selection with the destination node with a certain probability
    if destination_node in unvisited_nodes and random.random() < (1 - destination_distance / max(distances.values())):
        next_node = destination_node
    
    return next_node
