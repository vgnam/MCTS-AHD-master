import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize parameters
    temperature = 200
    cooling_rate = 0.85
    visit_counts = {node: 0 for node in unvisited_nodes}
    memory_factor = 0.3

    # Calculate distances and find nearest neighbors
    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}
    min_distance = min(distances.values())
    nearest_neighbors = [node for node, distance in distances.items() if distance == min_distance]

    # Destination bias
    if destination_node in unvisited_nodes:
        destination_distance = distance_matrix[current_node][destination_node]
        visit_counts[destination_node] += 1
    else:
        destination_distance = float('inf')

    while temperature > 1:
        # Hybrid selection: nearest-neighbor + probabilistic with memory bias
        weights = {}
        for node in unvisited_nodes:
            distance = distance_matrix[current_node][node]
            # Sigmoid-based exploration-exploitation balance
            sigmoid = 1 / (1 + math.exp(-(distance - min_distance) / temperature))
            # Memory bias: favor nodes visited more often
            memory_bias = (1 + memory_factor * visit_counts[node]) if visit_counts[node] > 0 else 1
            weights[node] = (1 / (distance ** 2)) * sigmoid * memory_bias

        total_weight = sum(weights.values())
        probabilities = {node: weight / total_weight for node, weight in weights.items()}
        next_node = random.choices(list(unvisited_nodes), weights=list(probabilities.values()), k=1)[0]

        # Update visit counts
        visit_counts[next_node] += 1

        # Dynamic acceptance threshold
        acceptance_threshold = 0.5 * (1 - math.exp(-(min_distance - distance_matrix[current_node][next_node]) / temperature))

        if next_node == destination_node or random.random() < acceptance_threshold:
            return next_node

        temperature *= cooling_rate

    return next_node
