def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_scores = {}
    remaining_count = len(unvisited_nodes)
    scaling_factor = 1.0 + 0.1 * (remaining_count - 1)
    destination_factor = 1.0 + 0.05 * (remaining_count - 1)

    for node in unvisited_nodes:
        if node == destination_node:
            base_score = distance_matrix[current_node][node]
            if remaining_count > 1:
                remaining_nodes = unvisited_nodes - {node}
                for next_node in remaining_nodes:
                    base_score += distance_matrix[node][next_node]
                base_score += distance_matrix[next_node][current_node]
            node_scores[node] = base_score * destination_factor
        else:
            base_score = distance_matrix[current_node][node]
            if remaining_count > 1:
                remaining_nodes = unvisited_nodes - {node}
                for next_node in remaining_nodes:
                    base_score += distance_matrix[node][next_node]
                base_score += distance_matrix[next_node][destination_node]
            node_scores[node] = base_score * scaling_factor

    if not node_scores:
        return destination_node

    total_score = sum(node_scores.values())
    probabilities = {node: score / total_score for node, score in node_scores.items()}
    next_node = random.choices(list(probabilities.keys()), weights=list(probabilities.values()), k=1)[0]

    return next_node
