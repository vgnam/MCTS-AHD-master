import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Initialize pheromone trails and temperature
    pheromone_trails = {node: 1.0 for node in unvisited_nodes}
    temperature = 100
    cooling_rate = 0.99
    
    # Calculate initial probabilities
    probabilities = {}
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        probabilities[node] = (pheromone_trails[node] ** 1) * ((1 / distance) ** 2)
    
    # Normalize probabilities
    sum_probabilities = sum(probabilities.values())
    probabilities = {node: prob / sum_probabilities for node, prob in probabilities.items()}
    
    min_total = float('inf')
    next_node = None
    
    while temperature > 1:
        # Select a candidate node based on probabilities
        candidate_nodes = list(unvisited_nodes)
        candidate_node = random.choices(candidate_nodes, weights=[probabilities[node] for node in candidate_nodes])[0]
        
        remaining_nodes = unvisited_nodes - {candidate_node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        
        if not remaining_nodes:
            total = distance_matrix[current_node][candidate_node] + distance_matrix[candidate_node][destination_node]
        else:
            total = distance_matrix[current_node][candidate_node]
            next_node_candidate = min(remaining_nodes, key=lambda node: distance_matrix[candidate_node][node])
            total += distance_matrix[candidate_node][next_node_candidate]
            total += distance_matrix[next_node_candidate][destination_node]
        
        # Update pheromone trails
        pheromone_trails[candidate_node] *= 0.9
        pheromone_trails[candidate_node] += 0.1 * (1 / total)
        
        # Update probabilities
        for node in unvisited_nodes:
            distance = distance_matrix[current_node][node]
            probabilities[node] = (pheromone_trails[node] ** 1) * ((1 / distance) ** 2)
        sum_probabilities = sum(probabilities.values())
        probabilities = {node: prob / sum_probabilities for node, prob in probabilities.items()}
        
        if total < min_total or (random.random() < math.exp((min_total - total) / temperature)):
            min_total = total
            next_node = candidate_node
        
        temperature *= cooling_rate
    
    if next_node is None:
        next_node = max(unvisited_nodes, key=lambda node: probabilities[node])
    
    return next_node
