def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Calculate the score for each unvisited node
    scores = {}
    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_node_to_destination = distance_matrix[node][destination_node]
        # Calculate a penalty factor based on the angle between the current node, the node, and the destination
        penalty_factor = 1 + (distance_to_node + distance_node_to_destination) / (distance_matrix[current_node][destination_node] + 1e-6)
        score = distance_to_node * penalty_factor
        scores[node] = score
    
    # Select the node with the minimum score
    next_node = min(unvisited_nodes, key=lambda node: scores[node])
    
    # If the destination node is unvisited and closer than the selected node, override the selection
    if destination_node in unvisited_nodes:
        destination_distance = distance_matrix[current_node][destination_node]
        if destination_distance < distance_matrix[current_node][next_node]:
            next_node = destination_node
    
    return next_node
