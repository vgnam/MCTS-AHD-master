import random
import math
import networkx as nx

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Create a graph from the distance matrix
    G = nx.Graph()
    num_nodes = len(distance_matrix)
    for i in range(num_nodes):
        for j in range(i+1, num_nodes):
            G.add_edge(i, j, weight=distance_matrix[i][j])
    
    # Calculate node potential based on centrality and connectivity
    node_potentials = nx.closeness_centrality(G)
    
    temperature = 100
    cooling_rate = 0.95
    min_total = float('inf')
    next_node = None
    
    while temperature > 1:
        candidate_nodes = list(unvisited_nodes)
        
        # Calculate a score for each candidate node based on distance and node potential
        scores = {}
        for node in candidate_nodes:
            remaining_nodes = unvisited_nodes - {node}
            if destination_node in remaining_nodes:
                remaining_nodes.remove(destination_node)
            
            if not remaining_nodes:
                total = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
            else:
                total = distance_matrix[current_node][node]
                next_node_candidate = min(remaining_nodes, key=lambda n: distance_matrix[node][n])
                total += distance_matrix[node][next_node_candidate]
                total += distance_matrix[next_node_candidate][destination_node]
            
            score = total - node_potentials[node] * temperature
            scores[node] = score
        
        # Select a node based on the scores and simulated annealing probability
        min_score = min(scores.values())
        for node, score in scores.items():
            if score < min_total or (random.random() < math.exp((min_total - score) / temperature)):
                min_total = score
                next_node = node
        
        if next_node is not None:
            return next_node
        
        temperature *= cooling_rate
    
    if next_node is None:
        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])
    
    return next_node
