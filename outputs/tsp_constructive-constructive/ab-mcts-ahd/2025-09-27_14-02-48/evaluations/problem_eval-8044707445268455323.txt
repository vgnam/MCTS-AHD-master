import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Initialize temperature and cooling rate
    temperature = 100
    cooling_rate = 0.95
    
    # Evaluate total path cost for each candidate node
    candidate_nodes = list(unvisited_nodes)
    total_costs = []
    for node in candidate_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        if not remaining_nodes:
            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        else:
            total_cost = distance_matrix[current_node][node]
            for next_node_candidate in remaining_nodes:
                total_cost += distance_matrix[node][next_node_candidate]
            total_cost += distance_matrix[next_node_candidate][destination_node]
        total_costs.append(total_cost)
    
    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        remaining_nodes = unvisited_nodes - {destination_node}
        for node in remaining_nodes:
            destination_total += distance_matrix[destination_node][node]
        destination_total += distance_matrix[node][destination_node]
        candidate_nodes.append(destination_node)
        total_costs.append(destination_total)
    
    # Simulated annealing
    while temperature > 1:
        # Calculate probabilities based on total costs
        min_total_cost = min(total_costs)
        probabilities = [math.exp((min_total_cost - total_cost) / temperature) for total_cost in total_costs]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]
        
        # Choose a node based on probabilities
        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break
        
        # Check if the chosen node is valid
        if next_node not in unvisited_nodes:
            temperature *= cooling_rate
            continue
        
        return next_node
    
    # Return the node with the minimum total cost if the temperature is too low
    next_node = candidate_nodes[total_costs.index(min(total_costs))]
    return next_node
