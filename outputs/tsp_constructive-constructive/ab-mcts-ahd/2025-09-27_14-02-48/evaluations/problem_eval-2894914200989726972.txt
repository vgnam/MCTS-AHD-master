importance of local and global costs based on the proportion of unvisited nodes and incorporates a penalty term for nodes that are not on the direct path to the destination, thus promoting a more balanced exploration and exploitation.
}

```python
def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    num_unvisited = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    proportion_unvisited = num_unvisited / total_nodes
    
    min_score = float('inf')
    next_node = None
    
    for node in unvisited_nodes:
        local_cost = distance_matrix[current_node][node]
        global_cost = distance_matrix[node][destination_node]
        direct_distance = distance_matrix[current_node][destination_node]
        path_distance = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        penalty_term = max(0, path_distance - direct_distance)
        
        dynamic_local_weight = 0.4 * proportion_unvisited
        dynamic_global_weight = 0.6 * (1 - proportion_unvisited)
        
        score = dynamic_local_weight * local_cost + dynamic_global_weight * global_cost + 0.1 * penalty_term
        
        if score < min_score:
            min_score = score
            next_node = node
    
    if destination_node in unvisited_nodes:
        local_cost = distance_matrix[current_node][destination_node]
        global_cost = 0
        score = 0.4 * local_cost + 0.6 * global_cost
        
        if score < min_score:
            next_node = destination_node
    
    return next_node
