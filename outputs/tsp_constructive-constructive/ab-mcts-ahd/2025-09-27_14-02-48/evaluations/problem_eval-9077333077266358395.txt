import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    temperature = 200
    cooling_rate = 0.9
    visit_memory = {node: 0 for node in unvisited_nodes}

    while temperature > 1:
        # Calculate dynamic weights with power-law decay and memory bias
        weights = {}
        total_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes)
        for node in unvisited_nodes:
            distance = distance_matrix[current_node][node]
            if distance == 0:
                distance = 1e-6  # Avoid division by zero
            inv_dist = 1 / (distance ** 1.5)
            decay = math.exp(-visit_memory[node] / temperature)
            weights[node] = inv_dist * decay

        total_weight = sum(weights.values())
        probabilities = {node: weight / total_weight for node, weight in weights.items()}

        # Two-phase selection
        if random.random() < 0.7:  # Exploitation phase
            next_node = max(unvisited_nodes, key=lambda x: probabilities[x])
        else:  # Exploration phase
            next_node = random.choices(list(unvisited_nodes), weights=list(probabilities.values()), k=1)[0]

        # Adaptive acceptance criterion
        distance_ratio = distance_matrix[current_node][next_node] / total_distance
        memory_ratio = visit_memory[next_node] / (sum(visit_memory.values()) + 1e-6)
        acceptance_prob = math.exp(-(distance_ratio + 0.5 * memory_ratio) / temperature)

        if next_node == destination_node or random.random() < acceptance_prob:
            visit_memory[next_node] += 1
            return next_node

        temperature *= cooling_rate
        visit_memory[next_node] += 0.5

    return next_node
