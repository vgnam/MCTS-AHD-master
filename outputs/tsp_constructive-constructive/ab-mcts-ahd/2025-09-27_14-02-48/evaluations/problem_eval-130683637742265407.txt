import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize temperature and parameters
    temperature = 100
    cooling_rate = 0.95
    exploration_weight = 0.3

    # Evaluate total path cost and entropy for each candidate node
    candidate_nodes = list(unvisited_nodes)
    total_costs = []
    entropies = []

    for node in candidate_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        if not remaining_nodes:
            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
            entropy = 0
        else:
            total_cost = distance_matrix[current_node][node]
            costs_to_remaining = []
            for next_node_candidate in remaining_nodes:
                cost = distance_matrix[node][next_node_candidate]
                total_cost += cost
                costs_to_remaining.append(cost)
            total_cost += distance_matrix[next_node_candidate][destination_node]

            # Calculate entropy based on cost distribution to remaining nodes
            if costs_to_remaining:
                avg_cost = sum(costs_to_remaining) / len(costs_to_remaining)
                variance = sum((cost - avg_cost) ** 2 for cost in costs_to_remaining) / len(costs_to_remaining)
                entropy = math.sqrt(variance) if variance > 0 else 0
            else:
                entropy = 0

        total_costs.append(total_cost)
        entropies.append(entropy)

    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        remaining_nodes = unvisited_nodes - {destination_node}
        costs_to_remaining = []
        for node in remaining_nodes:
            cost = distance_matrix[destination_node][node]
            destination_total += cost
            costs_to_remaining.append(cost)
        destination_total += distance_matrix[node][destination_node]

        # Calculate entropy for destination path
        if costs_to_remaining:
            avg_cost = sum(costs_to_remaining) / len(costs_to_remaining)
            variance = sum((cost - avg_cost) ** 2 for cost in costs_to_remaining) / len(costs_to_remaining)
            destination_entropy = math.sqrt(variance) if variance > 0 else 0
        else:
            destination_entropy = 0

        candidate_nodes.append(destination_node)
        total_costs.append(destination_total)
        entropies.append(destination_entropy)

    # Simulated annealing with hybrid probability calculation
    while temperature > 1:
        # Normalize costs and entropies
        min_cost = min(total_costs)
        max_cost = max(total_costs)
        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs] if max_cost != min_cost else [1.0] * len(total_costs)

        min_entropy = min(entropies)
        max_entropy = max(entropies)
        normalized_entropies = [(entropy - min_entropy) / (max_entropy - min_entropy) for entropy in entropies] if max_entropy != min_entropy else [0.5] * len(entropies)

        # Calculate hybrid probabilities
        probabilities = []
        for i in range(len(candidate_nodes)):
            cost_factor = math.exp(normalized_costs[i] / temperature)
            entropy_factor = 1 - normalized_entropies[i] if normalized_entropies[i] != 0 else 1
            combined_factor = (1 - exploration_weight) * cost_factor + exploration_weight * entropy_factor
            probabilities.append(combined_factor)

        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        # Select node based on probabilities
        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break

        if next_node not in unvisited_nodes:
            temperature *= cooling_rate
            continue

        return next_node

    # Fallback to cost-based selection if temperature is too low
    next_node = candidate_nodes[total_costs.index(min(total_costs))]
    return next_node
