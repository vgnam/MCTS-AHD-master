import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    scores = {}
    for node in unvisited_nodes:
        local_cost = distance_matrix[current_node][node]
        
        global_cost = 0
        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {node}
            if destination_node in remaining_nodes:
                remaining_nodes.remove(destination_node)
            if remaining_nodes:
                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])
                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]
            else:
                global_cost = distance_matrix[node][destination_node]
        
        potential_gain = 0
        if len(unvisited_nodes) > 1:
            alternative_node = min(unvisited_nodes - {node}, key=lambda x: distance_matrix[current_node][x])
            potential_gain = distance_matrix[current_node][alternative_node] + distance_matrix[alternative_node][node] + distance_matrix[node][destination_node]
            potential_gain -= local_cost + global_cost
        
        score = 0.2 * local_cost + 0.6 * global_cost - 0.2 * potential_gain
        scores[node] = score
    
    if destination_node in unvisited_nodes:
        local_cost = distance_matrix[current_node][destination_node]
        global_cost = 0
        if len(unvisited_nodes) > 1:
            remaining_nodes = unvisited_nodes - {destination_node}
            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])
            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]
        score = 0.2 * local_cost + 0.6 * global_cost
        scores[destination_node] = score
    
    total_score = sum([max(0, 1/score) for score in scores.values()])
    selection_probabilities = {node: max(0, 1/score) / total_score for node, score in scores.items()}
    
    next_node = random.choices(list(selection_probabilities.keys()), weights=selection_probabilities.values(), k=1)[0]
    return next_node
