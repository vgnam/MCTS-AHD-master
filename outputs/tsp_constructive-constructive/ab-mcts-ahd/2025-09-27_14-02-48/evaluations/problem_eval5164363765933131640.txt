def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    temperature = 200
    cooling_rate = 0.85

    while temperature > 1:
        weights = {}
        for node in unvisited_nodes:
            distance_to_current = distance_matrix[current_node][node]
            distance_to_destination = distance_matrix[node][destination_node]
            score = (1 / distance_to_current) * distance_to_destination
            weights[node] = score * math.exp(-distance_to_current / temperature)

        total_weight = sum(weights.values())
        probabilities = {node: weight / total_weight for node, weight in weights.items()}
        next_node = random.choices(list(unvisited_nodes), weights=list(probabilities.values()), k=1)[0]

        acceptance_threshold = 0.5 * math.exp((min(distance_matrix[current_node][node] for node in unvisited_nodes) - distance_matrix[current_node][next_node]) / (temperature * 0.7))
        if next_node == destination_node or random.random() < acceptance_threshold:
            return next_node

        temperature *= cooling_rate

    return next_node
