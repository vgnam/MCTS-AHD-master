import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize temperature and dynamic cooling rate
    temperature = 1000
    base_cooling_rate = 0.9
    dynamic_cooling_rate = 1.0

    # Evaluate total path cost for each candidate node
    candidate_nodes = list(unvisited_nodes)
    total_costs = []
    for node in candidate_nodes:
        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)
        if not remaining_nodes:
            total_cost = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
        else:
            total_cost = distance_matrix[current_node][node]
            for next_node_candidate in remaining_nodes:
                total_cost += distance_matrix[node][next_node_candidate]
            total_cost += distance_matrix[next_node_candidate][destination_node]
        total_costs.append(total_cost)

    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        destination_total = distance_matrix[current_node][destination_node]
        remaining_nodes = unvisited_nodes - {destination_node}
        for node in remaining_nodes:
            destination_total += distance_matrix[destination_node][node]
        destination_total += distance_matrix[node][destination_node]
        candidate_nodes.append(destination_node)
        total_costs.append(destination_total)

    # Simulated annealing with dynamic cooling and non-linear probabilities
    while temperature > 0.1:
        # Calculate probabilities with non-linear emphasis on lower costs
        min_total_cost = min(total_costs)
        probabilities = [(1 - (total_cost - min_total_cost) / (max(total_costs) - min_total_cost + 1e-6)) ** (1 + temperature / 1000) for total_cost in total_costs]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        # Choose a node based on probabilities
        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break

        # Check if the chosen node is valid
        if next_node not in unvisited_nodes:
            temperature *= base_cooling_rate * dynamic_cooling_rate
            dynamic_cooling_rate *= 0.99
            continue

        return next_node

    # Return the node with the minimum total cost if the temperature is too low
    next_node = candidate_nodes[total_costs.index(min(total_costs))]
    return next_node
