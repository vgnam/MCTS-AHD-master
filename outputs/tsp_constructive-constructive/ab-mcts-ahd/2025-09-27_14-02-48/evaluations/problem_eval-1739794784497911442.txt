import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    
    # Calculate distances to all unvisited nodes
    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}
    
    # Calculate the distance to the destination node if it's unvisited
    destination_distance = distance_matrix[current_node][destination_node] if destination_node in unvisited_nodes else float('inf')
    
    # Calculate the minimum distance
    min_distance = min(distances.values())
    
    # Create a list of nodes that are within a certain threshold of the minimum distance
    closest_nodes = [node for node, distance in distances.items() if distance <= min_distance * 1.2]
    
    # Assign a score to each of the closest nodes based on their distance, distance to destination, and whether they're the destination node
    scores = {}
    for node in closest_nodes:
        score = 1 / distances[node]
        if node == destination_node:
            score *= 1.5  # Increase the score for the destination node
        else:
            # Consider the distance from the node to the destination node
            score += 0.5 / distance_matrix[node][destination_node]
        scores[node] = score
    
    # Normalize the scores to create a probability distribution
    total_score = sum(scores.values())
    probabilities = {node: score / total_score for node, score in scores.items()}
    
    # Select the next node based on the probability distribution
    next_node = random.choices(list(probabilities.keys()), weights=probabilities.values(), k=1)[0]
    
    # If the destination node is closer than the selected node, override the selection
    if destination_distance < distances[next_node]:
        next_node = destination_node
    
    return next_node
