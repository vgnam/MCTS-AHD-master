import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Initialize temperature and cooling rate
    temperature = 100
    cooling_rate = 0.95

    # Evaluate weighted scores for each candidate node
    candidate_nodes = list(unvisited_nodes)
    scores = []
    for node in candidate_nodes:
        local_cost = distance_matrix[current_node][node]
        global_cost = 0

        remaining_nodes = unvisited_nodes - {node}
        if destination_node in remaining_nodes:
            remaining_nodes.remove(destination_node)

        if remaining_nodes:
            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])
            global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]
        else:
            global_cost = distance_matrix[node][destination_node]

        score = 0.6 * local_cost + 0.4 * global_cost
        scores.append(score)

    # Check if destination node is a valid choice
    if destination_node in unvisited_nodes:
        local_cost = distance_matrix[current_node][destination_node]
        global_cost = 0

        remaining_nodes = unvisited_nodes - {destination_node}
        if remaining_nodes:
            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])
            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]

        score = 0.6 * local_cost + 0.4 * global_cost
        candidate_nodes.append(destination_node)
        scores.append(score)

    # Simulated annealing
    while temperature > 1:
        # Calculate probabilities based on scores
        min_score = min(scores)
        probabilities = [math.exp((min_score - score) / temperature) for score in scores]
        sum_probabilities = sum(probabilities)
        probabilities = [p / sum_probabilities for p in probabilities]

        # Choose a node based on probabilities
        r = random.random()
        cumulative_probability = 0
        for i, probability in enumerate(probabilities):
            cumulative_probability += probability
            if r <= cumulative_probability:
                next_node = candidate_nodes[i]
                break

        # Check if the chosen node is valid
        if next_node not in unvisited_nodes:
            temperature *= cooling_rate
            continue

        return next_node

    # Return the node with the minimum score if the temperature is too low
    next_node = candidate_nodes[scores.index(min(scores))]
    return next_node
