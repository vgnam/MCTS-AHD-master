[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node (inverse distance) and alignment with the path to the destination (direction vector), favoring nodes closer to the current node while slightly favoring those that reduce the remaining distance to the destination. The destination node is given a higher score if it remains unvisited, ensuring the path tends toward the goal.",
          "thought": "The new algorithm modifies the scoring mechanism by combining the inverse distance to the current node with a normalized direction vector towards the destination, favoring nodes that align with the path to the destination while maintaining proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    max_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        if distance_to_current == 0:\n            continue\n\n        direction_vector = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / distance_matrix[current_node][destination_node]\n        score = (1 / distance_to_current) * (1 + direction_vector)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][destination_node]\n        if distance_to_current != 0:\n            score = (1 / distance_to_current) * 2\n\n            if score > max_score:\n                next_node = destination_node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\n\nThe algorithm selects the next node to visit based on a score calculated as the product of the inverse distance to the current node and the distance to the destination node, effectively balancing between proximity to the current node and progress towards the destination. The node with the maximum score is chosen as the next node, with a bias towards selecting the destination node when its score is competitive, as seen in the special handling when the destination node is among the unvisited nodes.\n\n## Key Insights from the Code\n\n* The score function prioritizes nodes that are closer to the current node (due to the inverse distance) and farther from the current node in the direction of the destination node.\n* The code checks if the destination node is among the unvisited nodes and updates the next node if its score is higher than the current maximum score, ensuring that the algorithm makes progress towards the destination when possible.\n* The use of `float('-inf')` for initializing `max_score` ensures that any calculated score will be greater, allowing the algorithm to select the first node as the initial next node.\n\n## Code Review\n\nThe given `select_next_node` function implements the described heuristic algorithm. However, the check for `destination_node in unvisited_nodes` followed by the calculation of its score seems redundant because `distance_to_destination` would be 0 (since `distance_matrix[node][node]` is typically 0), making the score infinite or causing a division by zero error. It is likely that the intention was to handle this case differently or that there's an assumption about the distance matrix that isn't explicitly stated. \n\nA more accurate representation of the algorithm might be achieved by directly comparing the distance to the current node and utilizing a more sophisticated method to handle the case when the destination node is among the unvisited nodes. \n\nHere is a slight rewording of the algorithm in under 3 sentences: \nThe algorithm chooses the next node by maximizing the product of the inverse distance to the current node and the distance to the destination, striking a balance between local proximity and global progress. It iterates through unvisited nodes to find the one with the maximum score. The code handles the destination node as a special case when it is among the unvisited nodes.",
          "thought": "\nThe new algorithm, inspired by the provided nearest neighbor approach, selects the next node by prioritizing the node with the maximum product of the inverse distance to the current node and the distance to the destination node, effectively balancing between proximity to the current node and progress towards the destination.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    max_score = float('-inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = (1 / distance_to_current) * distance_to_destination\n        \n        if score > max_score:\n            max_score = score\n            next_node = node\n    \n    if destination_node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][destination_node]\n        distance_to_destination = distance_matrix[destination_node][destination_node]\n        score = (1 / distance_to_current) * distance_to_destination\n        \n        if score > max_score:\n            next_node = destination_node\n    \n    return next_node",
          "objective": 6.8955,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the nearest unvisited neighbor, but if the destination node is unvisited and closer than other options, it overrides the selection. It uses the `distance_matrix` to compute distances and ensures the destination is always the last node visited if it remains unvisited. The `current_node` and `destination_node` are critical inputs, while `unvisited_nodes` determines the available choices.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node closest to the current node, while prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor search with simulated annealing, dynamically adjusting exploration vs. exploitation via temperature-based probabilistic selection. It prioritizes local proximity (nearest neighbors) when the \"temperature\" is high but shifts to global path evaluation (weighted by remaining nodes) as temperature cools. The cooling rate and probability function ensure adaptive balancing, while the weighted scaling (1.0 + 0.08 * (remaining_count - 1)) emphasizes global optimization as the problem size shrinks.",
          "thought": "The new algorithm combines the dynamic nearest-neighbor search and adaptive temperature control from No.1 with the global path evaluation and weighted scaling from No.2, using a hybrid approach that balances local and global considerations while adaptively adjusting exploration based on remaining nodes.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    temperature = 100\n    cooling_rate = 0.95\n    remaining_count = len(unvisited_nodes)\n    min_total = float('inf')\n    next_node = None\n\n    while temperature > 1:\n        probability = 1 / (1 + math.exp((temperature - 50) / 10))\n        if random.random() < probability:\n            candidate_nodes = list(unvisited_nodes)\n        else:\n            nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n            candidate_nodes = [nearest_neighbors[0]] if nearest_neighbors else []\n\n        for node in candidate_nodes:\n            total = distance_matrix[current_node][node]\n            remaining_nodes = unvisited_nodes - {node}\n\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n                total += distance_matrix[node][destination_node]\n            elif remaining_nodes:\n                total += sum(distance_matrix[node][n] for n in remaining_nodes) + distance_matrix[list(remaining_nodes)[-1]][destination_node]\n\n            if remaining_count > 1:\n                total *= (1.0 + 0.08 * (remaining_count - 1))\n\n            if total < min_total:\n                min_total = total\n                next_node = node\n\n        if next_node is not None and (next_node == destination_node or random.random() < math.exp((min_total - distance_matrix[current_node][next_node]) / temperature)):\n            return next_node\n\n        temperature *= cooling_rate\n\n    return next_node",
          "objective": 7.08486,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\n\nThe algorithm is a modified simulated annealing approach that combines dynamic nearest neighbor search with adaptive temperature control to balance exploration and exploitation. It prioritizes closer nodes and uses a novel probability function to occasionally choose a random unvisited node, allowing for a trade-off between greediness and randomness.\n\n## Key Components and Priorities\n\n* The algorithm gives higher priority to closer nodes by using a dynamic nearest neighbor search and a bias towards nodes with shorter distances.\n* The `probability` variable controls the trade-off between exploration and exploitation, with a higher value favoring random node selection.\n* The `temperature` variable is adaptively cooled using a `cooling_rate`, influencing the probability of accepting a node.\n\n## Analysis of the Code\n\nThe code implements the described algorithm in the `select_next_node` function. The function takes into account the current node, destination node, unvisited nodes, and distance matrix to determine the next node to visit. The parameters used, such as `temperature`, `cooling_rate`, and the `probability` function, are crucial in controlling the algorithm's behavior.\n\nThe algorithm's structure, which includes a while loop that continues until the temperature is below a certain threshold, allows for a balance between exploration and exploitation. The use of a novel probability function and adaptive temperature control enables the algorithm to adapt to different problem instances.\n\n## Conclusion\n\nThe modified simulated annealing algorithm is designed to effectively solve the Traveling Salesman Problem by balancing exploration and exploitation. By prioritizing closer nodes and using a novel probability function, the algorithm can efficiently search for good solutions.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search with adaptive temperature control and a novel probability function to balance exploration and exploitation.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n    \n    # Dynamic nearest neighbor search\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    min_distance = distance_matrix[current_node][nearest_neighbors[0]]\n    second_min_distance = distance_matrix[current_node][nearest_neighbors[1]] if len(nearest_neighbors) > 1 else min_distance\n    \n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n    \n    # Simulated annealing with adaptive temperature control\n    while temperature > 1:\n        # Novel probability function to balance exploration and exploitation\n        probability = 1 / (1 + math.exp((temperature - 50) / 10))\n        if random.random() < probability:\n            # Choose a random unvisited node with a bias towards closer nodes\n            next_node = random.choices(list(unvisited_nodes), weights=[1 / distance_matrix[current_node][node] for node in unvisited_nodes])[0]\n        else:\n            # Choose between nearest neighbor and destination node with a bias towards the closer one\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbors[0]\n        \n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        # Accept the chosen node with a certain probability based on the distance difference and temperature\n        distance_diff = second_min_distance - distance_matrix[current_node][next_node]\n        if next_node == destination_node or random.random() < math.exp(distance_diff / temperature):\n            return next_node\n        \n        temperature *= cooling_rate\n    \n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 7.10183,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor prioritization with probabilistic exploration, using a temperature-based cooling schedule to bias selection toward the destination node if it's unvisited and closer than the nearest neighbor. It gradually shifts from random exploration to deterministic exploitation by reducing temperature over iterations, with higher priority given to the nearest neighbor unless the destination is significantly closer and temperature allows probabilistic selection. The cooling rate and temperature thresholds control the trade-off between exploration and exploitation.",
          "thought": "The new algorithm combines the nearest neighbor prioritization of No.1 with the probabilistic exploration of No.2, but with a temperature-based bias towards the destination node if it is unvisited and closer than the nearest neighbor, and a cooling schedule to gradually shift from exploration to exploitation.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    temperature = 50\n    cooling_rate = 0.9\n\n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n\n    while temperature > 0.1:\n        if random.random() < math.exp(-temperature / 10):\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            if destination_distance < min_distance:\n                if random.random() < math.exp((min_distance - destination_distance) / (temperature * 0.5)):\n                    next_node = destination_node\n                else:\n                    next_node = nearest_neighbor\n            else:\n                next_node = nearest_neighbor\n\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n\n        return next_node\n\n        temperature *= cooling_rate\n\n    return next_node",
          "objective": 7.12877,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and directional alignment toward the destination, using a weighted score combining inverse distance (prioritized) and cosine similarity (secondary). The score is calculated as `(1 / (1 + distance_to_current)) * (0.7 * cosine_sim + 0.3 * distance_to_destination)`, where distance to the current node dominates due to the inversion, while cosine similarity and distance to the destination contribute proportionally. The function iterates through unvisited nodes, computes the score, and returns the node with the highest score.",
          "thought": "The new algorithm modifies the scoring mechanism to prioritize nodes with a balance between minimizing distance to the current node and maximizing the angular progress towards the destination, using a weighted combination of Euclidean distance and directional cosine similarity.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    max_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate directional cosine similarity\n        vec_current = (distance_matrix[current_node][destination_node], 0)\n        vec_node = (distance_to_destination, distance_to_current)\n        dot_product = vec_current[0] * vec_node[0] + vec_current[1] * vec_node[1]\n        norm_current = math.sqrt(vec_current[0]**2 + vec_current[1]**2)\n        norm_node = math.sqrt(vec_node[0]**2 + vec_node[1]**2)\n        cosine_sim = dot_product / (norm_current * norm_node) if (norm_current * norm_node) != 0 else 0\n\n        # Weighted score combining distance and direction\n        score = (1 / (1 + distance_to_current)) * (0.7 * cosine_sim + 0.3 * distance_to_destination)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14481,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a constructive heuristic for the Traveling Salesman Problem (TSP) that selects the next node to visit based on a score calculated from a weighted sum of local cost, global cost, and a penalty term, with weights dynamically adjusted using a simulated annealing-inspired mechanism. The score prioritizes nodes that are close to the current node and likely to lead to a shorter overall path, while penalizing nodes with large average distances to other unvisited nodes. The algorithm considers a limited set of k-nearest neighbors to reduce computational complexity.",
          "thought": "The new algorithm modifies the existing one by incorporating a simulated annealing-inspired mechanism to dynamically adjust the weights between local and global cost evaluations, and introduces a penalty term for nodes that are likely to lead to a longer overall path.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Simulated annealing-inspired temperature parameter\n    T = 100 / (1 + len(unvisited_nodes))\n    \n    min_score = float('inf')\n    next_node = None\n    \n    # Find k-nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        \n        # Global cost evaluation with an additional penalty term\n        global_cost = 0\n        penalty = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n                # Penalty term based on the average distance to other unvisited nodes\n                avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n                penalty = max(0, avg_distance - distance_matrix[node][nearest_remaining])\n            else:\n                global_cost = distance_matrix[node][destination_node]\n        \n        # Dynamic weight adjustment inspired by simulated annealing\n        weight_local = 0.7 + (0.3 * (1 - math.exp(-T)))\n        weight_global = 1 - weight_local\n        \n        score = weight_local * local_cost + weight_global * global_cost + 0.1 * penalty\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    # Explicitly check the destination node\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n        penalty = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n            avg_distance = sum(distance_matrix[destination_node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = max(0, avg_distance - distance_matrix[destination_node][nearest_remaining])\n        \n        score = weight_local * local_cost + weight_global * global_cost + 0.1 * penalty\n        \n        if score < min_score:\n            next_node = destination_node\n    \n    return next_node",
          "objective": 7.14883,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with probabilistic randomness, prioritizing the nearest unvisited node but occasionally choosing random nodes with exponentially decreasing probability (controlled by `temperature` and `cooling_rate`). If the destination node is unvisited and closer than the nearest neighbor, it has higher priority in the probabilistic selection. The algorithm accepts a node based on its distance relative to the current best (nearest neighbor) and the temperature, ensuring a balance between local optimization and exploration.",
          "thought": "The new algorithm uses a probabilistic selection between the nearest neighbor and a random node, with the probability of choosing the random node decreasing exponentially with a different cooling rate, and prioritizes the destination node if it's among the unvisited nodes and closer than the nearest neighbor.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Initialize temperature and cooling rate\n    temperature = 50\n    cooling_rate = 0.9\n\n    # Find nearest neighbor\n    min_distance = float('inf')\n    nearest_neighbor = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            nearest_neighbor = node\n\n    # Check if destination node is a valid choice\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n    else:\n        destination_distance = float('inf')\n\n    # Probabilistic selection\n    while temperature > 0.1:\n        if random.random() < math.exp(-temperature / 10):\n            # Choose a random unvisited node\n            next_node = random.choice(list(unvisited_nodes))\n        else:\n            # Choose between nearest neighbor and destination node\n            if destination_distance < min_distance:\n                next_node = destination_node\n            else:\n                next_node = nearest_neighbor\n\n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n\n        # Accept the chosen node with a certain probability\n        if next_node == destination_node or random.random() < math.exp((min_distance - distance_matrix[current_node][next_node]) / temperature):\n            return next_node\n\n        temperature *= cooling_rate\n\n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 7.15528,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\nThe algorithm implements a constructive heuristic for the Traveling Salesman Problem (TSP) by selecting the next node to visit based on a scoring mechanism that balances proximity to the current node and alignment with the destination node. The scoring mechanism prioritizes nodes that are closer to the current node and more aligned with the direction to the destination node, with a probability-based selection to introduce randomness. The algorithm also gives a higher score to the destination node when it is among the closest nodes, ensuring a more direct path to the destination when possible.\n\n## Key Insights from the Code\n- The `distances` dictionary stores the distances from the current node to all unvisited nodes.\n- The `closest_nodes` list includes nodes that are within 20% of the minimum distance to the current node, ensuring consideration of relatively close nodes.\n- The `score` calculation combines the inverse of the distance to the current node and a direction vector towards the destination node, with a higher weight given to nodes that are more aligned with the destination.\n- The `probabilities` dictionary normalizes the scores to create a probability distribution for selecting the next node, introducing randomness in the selection process.\n- If the destination node is among the unvisited nodes and is closer than the selected next node, the algorithm directly chooses the destination node as the next node.",
          "thought": "The design idea is to modify the No.2 algorithm by incorporating a direction vector-based scoring mechanism, similar to No.1, to balance between proximity and alignment with the destination, while still using a probability-based selection mechanism.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}\n    destination_distance = distance_matrix[current_node][destination_node] if destination_node in unvisited_nodes else float('inf')\n    min_distance = min(distances.values())\n    closest_nodes = [node for node, distance in distances.items() if distance <= min_distance * 1.2]\n    \n    scores = {}\n    for node in closest_nodes:\n        distance_to_current = distances[node]\n        direction_vector = (distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]) / (distance_matrix[current_node][destination_node] + 1e-9)\n        score = (1 / distance_to_current) * (1 + direction_vector)\n        if node == destination_node:\n            score *= 1.5\n        scores[node] = score\n    \n    total_score = sum(scores.values())\n    probabilities = {node: score / total_score for node, score in scores.items()}\n    next_node = random.choices(list(probabilities.keys()), weights=probabilities.values(), k=1)[0]\n    \n    if destination_distance < distances[next_node]:\n        next_node = destination_node\n    \n    return next_node",
          "objective": 7.16543,
          "other_inf": null
     }
]