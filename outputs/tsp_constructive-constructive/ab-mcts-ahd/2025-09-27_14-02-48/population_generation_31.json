[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the nearest unvisited neighbor, but if the destination node is unvisited and closer than other options, it overrides the selection. It uses the `distance_matrix` to compute distances and ensures the destination is always the last node visited if it remains unvisited. The `current_node` and `destination_node` are critical inputs, while `unvisited_nodes` determines the available choices.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node closest to the current node, while prioritizing the destination node if it is unvisited and closer than other options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **k-nearest neighbor selection (local cost prioritized at 70%)** with **global cost evaluation (30%)**, dynamically balancing exploration and exploitation. It first identifies the nearest neighbors (up to 5) from unvisited nodes, then evaluates each candidate by weighting local travel cost (70%) and global future cost (30%), where the latter estimates the shortest path back to the destination. The destination node is also explicitly checked to ensure optimality. The weights (0.7 and 0.3) reflect higher priority on immediate efficiency while still considering long-term connectivity.",
          "thought": "The new algorithm combines the k-nearest neighbor selection from No.1 with the weighted local and global cost evaluation from No.2, prioritizing immediate local costs (70%) while considering global costs (30%) through a dynamic k-nearest neighbor search, allowing for better exploration and exploitation balance.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Find k-nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n\n    for node in nearest_neighbors:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.7 * local_cost + 0.3 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.7 * local_cost + 0.3 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.46476,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a greedy approach, prioritizing immediate local costs (60%) while also considering future global costs (40%) to balance exploration and exploitation. It evaluates each unvisited node by computing a weighted score of the direct distance from the current node and the estimated cost to reach the destination via that node, then selects the node with the lowest score. The destination node is also explicitly checked if it remains unvisited.",
          "thought": "This algorithm combines nearest neighbor selection with a greedy approach to minimize the immediate and potential future path costs, using a weighted sum of local and global cost estimates to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.6 * local_cost + 0.4 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.07457,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local and global costs, where local cost is the direct distance from the current node, and global cost estimates the future path's potential by considering the nearest remaining unvisited node and the destination. The balance between local and global costs is dynamically adjusted based on the number of remaining nodes (prioritizing global cost as nodes decrease). The algorithm also penalizes revisiting nodes (1.1 multiplier) and ensures the destination is always considered as a candidate.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting scheme based on the number of remaining nodes, adjusting the balance between local and global costs, and introducing a penalty for revisiting nodes, while preserving the destination node check for completeness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_count = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        weight_local = 0.5 + 0.2 * (remaining_count / len(distance_matrix)) if remaining_count > 0 else 0.5\n        weight_global = 1 - weight_local\n\n        score = weight_local * local_cost + weight_global * global_cost\n\n        if node in unvisited_nodes and node != current_node:\n            score *= 1.1\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if remaining_count > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = weight_local * local_cost + weight_global * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.11001,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes global costs (60%) over local costs (40%) when selecting the next node in the TSP path, using direct distances to the destination for global cost estimation. It evaluates each unvisited node by combining weighted local and global costs, then returns the node with the lowest total score, ensuring the path tends toward the destination early. The destination node is explicitly checked if it remains unvisited.",
          "thought": "The new algorithm modifies the provided one by adjusting the weighting parameters to prioritize global costs more (40% local, 60% global) and simplifying the global cost estimation by using the direct distance to the destination instead of a two-step path estimate.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = distance_matrix[node][destination_node]\n\n        score = 0.4 * local_cost + 0.6 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        score = 0.4 * local_cost + 0.6 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 8.454,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest-neighbor) and global (destination-oriented) decisions by weighting the selection based on the average distance to the destination and considering remaining unvisited nodes. It prioritizes nodes that minimize both the immediate cost to the next node and the adjusted cost to the destination, while also evaluating potential future steps. The destination node is explicitly checked for potential inclusion in the path, ensuring global progress is maintained.",
          "thought": "The new algorithm modifies the selection strategy by incorporating a dynamic weighting mechanism that adjusts the balance between local (nearest neighbor) and global (destination-oriented) decisions based on the remaining unvisited nodes, while also considering the average distance to the destination to refine the selection criterion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total = float('inf')\n    next_node = None\n    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        remaining_nodes = unvisited_nodes - {node}\n        if destination_node in remaining_nodes:\n            remaining_nodes.remove(destination_node)\n\n        local_cost = distance_matrix[current_node][node]\n        global_cost = distance_matrix[node][destination_node] - avg_distance_to_dest\n\n        if not remaining_nodes:\n            total = local_cost + global_cost\n        else:\n            total = local_cost + global_cost\n            for next_node_candidate in remaining_nodes:\n                total += distance_matrix[node][next_node_candidate] / len(remaining_nodes)\n\n        if total < min_total:\n            min_total = total\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_local = distance_matrix[current_node][destination_node]\n        destination_global = 0\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            destination_global = sum(distance_matrix[destination_node][node] for node in remaining_nodes) / len(remaining_nodes)\n\n        destination_total = destination_local + destination_global\n        if destination_total < min_total:\n            next_node = destination_node\n\n    return next_node",
          "objective": 9.53671,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic modifies the standard nearest-neighbor approach by dynamically adjusting weights between local (current step) and global (future impact) costs, with weights favoring local decisions early and balancing toward global considerations as unvisited nodes decrease. It also penalizes nodes that were skipped earlier to avoid local optima, with penalties increasing as more nodes remain unvisited. The algorithm prioritizes minimizing immediate distance while considering longer-term path quality, with special handling for the destination node when it remains unvisited.",
          "thought": "The new algorithm modifies the provided approach by introducing a dynamic weighting mechanism that adjusts the balance between local and global costs based on the remaining number of unvisited nodes, while also incorporating a penalty for revisiting nodes that were previously considered but skipped, to better handle local optima and improve path quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    local_weight = 0.6\n    global_weight = 0.4\n\n    if len(unvisited_nodes) > 1:\n        remaining_ratio = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        local_weight = 0.7 - 0.1 * remaining_ratio\n        global_weight = 1.0 - local_weight\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        penalty = 1.0\n        if len(unvisited_nodes) > 2:\n            penalty = 1.0 + 0.1 * (len(unvisited_nodes) - 2)\n\n        score = local_weight * local_cost + global_weight * global_cost * penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = local_weight * local_cost + global_weight * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 10.2357,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (30% weight) with a global cost consideration (70% weight), prioritizing long-term path optimization by estimating the cost of connecting to the next node and then to the destination, while still ensuring immediate cost efficiency. The `select_next_node` function evaluates each unvisited node by computing a weighted score (0.3 for local cost and 0.7 for global cost) and selects the node with the minimum score, dynamically adjusting for the destination node if it remains unvisited. This hybrid approach balances immediate proximity with forward-looking path planning.",
          "thought": "The new algorithm combines nearest-neighbor selection with a more aggressive global cost consideration (70% global, 30% local) to prioritize long-term path optimization, while still ensuring immediate cost efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {node}\n            if destination_node in remaining_nodes:\n                remaining_nodes.remove(destination_node)\n\n            if remaining_nodes:\n                nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[node][x])\n                global_cost = distance_matrix[node][nearest_remaining] + distance_matrix[nearest_remaining][destination_node]\n            else:\n                global_cost = distance_matrix[node][destination_node]\n\n        score = 0.3 * local_cost + 0.7 * global_cost\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        local_cost = distance_matrix[current_node][destination_node]\n        global_cost = 0\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = unvisited_nodes - {destination_node}\n            nearest_remaining = min(remaining_nodes, key=lambda x: distance_matrix[destination_node][x])\n            global_cost = distance_matrix[destination_node][nearest_remaining] + distance_matrix[nearest_remaining][current_node]\n\n        score = 0.3 * local_cost + 0.7 * global_cost\n\n        if score < min_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 10.73848,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a modified simulated annealing approach that selects the next node to visit from a set of k nearest neighbors to the current node, with a probability based on the relative distances and the current temperature. The temperature is gradually cooled down, and the probability of choosing a farther neighbor decreases as the temperature drops. The algorithm prioritizes exploration at higher temperatures and exploitation at lower temperatures.\n\nTo get a better understanding of the response, let's analyze the given code. The key components are:\n\n- `k` nearest neighbors are considered for the next node, indicating a priority on closer nodes.\n- The `temperature` and `cooling_rate` control the simulated annealing process, with the temperature decreasing over time.\n- The probability of choosing a neighbor is calculated using `math.exp(-distance / temperature)`, giving higher probabilities to closer neighbors at lower temperatures.\n\nOverall, the algorithm balances exploration and exploitation by considering a subset of nearest neighbors and using a temperature-controlled probability function.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search and a novel probability function based on the relative distances and temperature to select the next node to visit in the Traveling Salesman Problem.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    \n    # Initialize temperature and cooling rate\n    temperature = 100\n    cooling_rate = 0.95\n    \n    # Find k nearest neighbors\n    k = min(5, len(unvisited_nodes))\n    nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n    \n    # Simulated annealing\n    while temperature > 1:\n        # Calculate probabilities for k nearest neighbors\n        probabilities = []\n        for neighbor in nearest_neighbors:\n            distance = distance_matrix[current_node][neighbor]\n            probability = math.exp(-distance / temperature)\n            probabilities.append(probability)\n        \n        # Normalize probabilities\n        sum_probabilities = sum(probabilities)\n        probabilities = [p / sum_probabilities for p in probabilities]\n        \n        # Choose a node based on the probabilities\n        r = random.random()\n        cumulative_probability = 0\n        for i, probability in enumerate(probabilities):\n            cumulative_probability += probability\n            if r <= cumulative_probability:\n                next_node = nearest_neighbors[i]\n                break\n        \n        # Check if the chosen node is valid\n        if next_node not in unvisited_nodes:\n            temperature *= cooling_rate\n            continue\n        \n        # Accept the chosen node\n        return next_node\n        \n        # Cool down the temperature\n        temperature *= cooling_rate\n    \n    # Return the nearest neighbor if the temperature is too low\n    return next_node",
          "objective": 13.76555,
          "other_inf": null
     },
     {
          "algorithm": "## Algorithm Description\nThe algorithm is a modified simulated annealing approach that combines a dynamic k-nearest neighbor search with a temperature-controlled probability function to select the next node to visit in the Traveling Salesman Problem. The algorithm prioritizes nodes that are closer to the current node and gives higher priority to the destination node, while also allowing for random exploration through the temperature-controlled probability function. \n\n## Key Components of the Algorithm\n- **K-Nearest Neighbors Search**: The algorithm considers a subset of `k` nearest neighbors (where `k` is at most 5) to the current node, as determined by the `distance_matrix`.\n- **Probability Function**: The probability of selecting a neighbor is based on the exponential of the negative distance between the current node and the neighbor, divided by the current `temperature`. The destination node is given twice the probability of other nodes.\n- **Temperature Control**: The `temperature` is gradually decreased by a `cooling_rate` of 0.95 at each iteration, affecting the probability function's sensitivity to distance.\n\n## Analysis of the Code\nThe given code implements the described algorithm through the `select_next_node` function, which takes into account the `current_node`, `destination_node`, `unvisited_nodes`, and `distance_matrix`. It iteratively selects the next node based on the calculated probabilities until it finds a valid `next_node` among the `unvisited_nodes` or exhausts the maximum number of iterations. The function returns the `destination_node` if all nodes have been visited.",
          "thought": "The new algorithm is a modified simulated annealing approach that incorporates a dynamic nearest neighbor search and a novel probability function based on both distance and temperature, to solve the Traveling Salesman Problem.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    temperature = 100\n    cooling_rate = 0.95\n    max_iterations = 1000\n\n    for _ in range(max_iterations):\n        # Find k-nearest neighbors\n        k = min(5, len(unvisited_nodes))\n        nearest_neighbors = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:k]\n\n        # Calculate the probability for each nearest neighbor\n        probabilities = []\n        for neighbor in nearest_neighbors:\n            distance = distance_matrix[current_node][neighbor]\n            probability = math.exp(-distance / temperature)\n            if neighbor == destination_node:\n                probability *= 2  # Give higher priority to destination node\n            probabilities.append(probability)\n\n        # Normalize the probabilities\n        probabilities = [p / sum(probabilities) for p in probabilities]\n\n        # Select the next node based on the probabilities\n        next_node = random.choices(nearest_neighbors, weights=probabilities, k=1)[0]\n\n        # Check if the chosen node is valid\n        if next_node in unvisited_nodes:\n            return next_node\n\n        temperature *= cooling_rate\n\n    # Return a random unvisited node if the temperature is too low\n    return next_node",
          "objective": 13.87674,
          "other_inf": null
     }
]