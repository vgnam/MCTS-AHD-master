[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the unvisited node closest to the current node, minimizing incremental distance while ensuring all nodes are eventually visited. The `destination_node` is only returned if no unvisited nodes remain, while `distance_matrix` determines the shortest path choices. The function balances proximity to the current node with completeness, ignoring the destination until the end.",
          "thought": "The algorithm selects the next node by choosing the unvisited node closest to the current node, ensuring progress toward the destination while minimizing total distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with the potential future cost to connect remaining unvisited nodes, prioritizing nodes that minimize both immediate and long-term travel costs. The heuristic combines the direct distance (`immediate_cost`) and the minimum future connection cost (`future_cost`) scaled by a factor (0.3), ensuring a trade-off between short-term and long-term efficiency. The `destination_node` is returned if no unvisited nodes remain, while the `min` function over unvisited nodes determines the optimal next step.",
          "thought": "The new algorithm modifies the original by introducing a dynamic weighting mechanism that balances proximity to the current node with the potential to reduce the overall tour length by considering both the immediate and long-term implications of each choice. It prioritizes nodes that offer the best immediate distance gain while also considering their potential to connect to other unvisited nodes more efficiently, ensuring a more globally optimized path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            return immediate_cost\n        future_cost = min(distance_matrix[node][other] for other in unvisited_nodes - {node})\n        return immediate_cost + 0.3 * future_cost\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (`distance_matrix[current_node][node]`) and closeness to the destination (`0.5 * distance_matrix[node][destination_node]`). The destination is prioritized slightly less than the current node (weight of 0.5), ensuring a smoother transition toward the goal while avoiding excessive detours. The `min` function ensures the node with the smallest combined weighted distance is chosen.",
          "thought": "The new algorithm prioritizes nodes based on a weighted balance between proximity to the current node and closeness to the destination, ensuring a smoother transition towards the destination while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate proximity (60% weight) and future closeness to the destination (40% weight), using a weighted sum of distances from the current node and the candidate node to the destination. This dynamic weighting prioritizes nodes that reduce both immediate travel cost and long-term path length, optimizing the trade-off between greedy and global path considerations. The function iteratively evaluates unvisited nodes, returning the one with the minimal combined weighted distance.",
          "thought": "The new algorithm modifies the selection criteria by introducing a dynamic weighting mechanism that balances proximity to the current node and potential future closeness to the destination, using a weighted sum of distances to prioritize nodes that offer better long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def weighted_score(node):\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        return 0.6 * current_distance + 0.4 * future_distance\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing the product of the distance from the current node and the average distance to all remaining unvisited nodes. This balances proximity to the current position (distance_matrix[current_node][node]) and centrality among unvisited nodes (average distance). The heuristic prioritizes minimizing this product, ensuring efficiency while considering both immediate and long-term connectivity.",
          "thought": "This algorithm selects the next node by prioritizing those that minimize the product of distances to the current node and the average distance to all unvisited nodes, balancing proximity to the current position and centrality in the remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)))\n    return next_node",
          "objective": 7.7792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while also considering the distance to the destination, balancing immediate and future travel costs using the sum of these distances. It ensures all nodes are visited before returning to the destination by minimizing the combined cost of moving to the node and then back to the destination, with the `distance_matrix` providing the necessary distance values. The `unvisited_nodes` set dynamically updates as nodes are visited, and the function defaults to the destination when no nodes remain.",
          "thought": "The new algorithm prioritizes nodes that are closest to the current node while also considering the potential impact on future travel, balancing immediate proximity with the distance to the destination, ensuring all nodes are visited before returning to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and centrality among unvisited nodes, prioritizing nodes with the smallest sum of their distance to the current node and their average distance to all remaining unvisited nodes. This ensures the path is locally optimal while maintaining global balance, with proximity given slightly higher weight than centrality due to the additive structure of the key function.",
          "thought": "The new algorithm combines the proximity-based selection of No.2 with the average-distance balancing of No.1, prioritizing nodes that are both close to the current node and central to the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + (sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)))\n    return next_node",
          "objective": 8.40257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that minimize the maximum distance to any unvisited node, ensuring global coverage over local proximity. It evaluates each unvisited node based on its worst-case distance to other unvisited nodes, favoring nodes that balance tour balance and reduce the longest remaining distances. The `current_node`, `destination_node`, and `unvisited_nodes` are input parameters, while the `distance_matrix` provides distances between nodes. The `key=lambda node: min(...)` ensures the node with the smallest maximum distance to unvisited nodes is chosen.",
          "thought": "This algorithm constructs the path by iteratively selecting the node that minimizes the maximum distance to any unvisited node, ensuring a balanced tour by considering global coverage rather than just local proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: min(distance_matrix[node][other] for other in unvisited_nodes))\n    return next_node",
          "objective": 26.44073,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of distances to all remaining unvisited nodes, ensuring the chosen node is centrally located relative to the unvisited set. It iteratively evaluates each unvisited node based on its total distance to all other unvisited nodes, favoring nodes that reduce the overall tour length by balancing proximity to the remaining nodes. The function uses the `distance_matrix` to compute these sums and selects the node with the minimal total distance.",
          "thought": "The new algorithm selects the next node by prioritizing those that minimize the sum of distances to all unvisited nodes, aiming to reduce the total tour length by focusing on nodes that are central to the remaining unvisited set.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: sum(distance_matrix[node][other] for other in unvisited_nodes))\n    return next_node",
          "objective": 32.0389,
          "other_inf": null
     }
]