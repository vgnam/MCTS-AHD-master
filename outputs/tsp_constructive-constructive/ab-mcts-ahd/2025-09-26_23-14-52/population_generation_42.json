[
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and estimated future distance to the destination, using a dynamic weight factor that prioritizes immediate steps when fewer nodes remain. It resolves ties by choosing the node closer to the destination, ensuring both short-term and long-term optimization while efficiently handling remaining nodes.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts the balance between minimizing the current step's distance and the remaining path's estimated distance, using a heuristic that balances immediate and long-term path optimization while still resolving ties by proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * destination_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm balances short-term distance and node centrality early in the tour, while gradually shifting focus to long-term distance and centrality as the tour progresses. It uses an exploration factor (prioritizing centrality early) and a weight factor (prioritizing future distance later) that increase over time. The algorithm selects the next node by minimizing a weighted score combining current distance, future distance, and centrality, with ties broken in favor of nodes closer to the destination.",
          "thought": "The new algorithm prioritizes immediate distance and node centrality early on, transitioning to favor future distance and centrality as the tour progresses, with exploration and weight factors increasing over time to balance short-term and long-term objectives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.7 * (1 - total_unvisited / (total_unvisited + 1))\n    weight_factor = 0.3 * (1 - total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (1 - exploration_factor) * (current_distance + weight_factor * future_distance) + exploration_factor * centrality\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15972,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate distance with probabilistic factors, where a temperature-based weight adjusts exploration (high temperature) to exploitation (low temperature) as unvisited nodes decrease. It prioritizes nodes with lower current distance, future distance, and centrality in the remaining set, using tie-breaking based on centrality to refine choices. The score combines distance and centrality, with temperature modulating their relative importance.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance with a probabilistic factor that considers both local and global optimization, using a temperature-based weight factor that decreases over time to balance exploration and exploitation, with tie-breaking based on node centrality in the remaining unvisited set.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (future_distance + 0.5 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.21562,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a dynamic weight that prioritizes local optimization early and global optimization as unvisited nodes decrease. The weight factor (`weight_factor`) adjusts based on remaining unvisited nodes, ensuring a smoother transition between local and global considerations. The `weighted_score` combines current distance and future distance (scaled by the weight factor) to guide node selection, with ties resolved by choosing the node closer to the destination.",
          "thought": "The algorithm selects the next node by prioritizing the shortest immediate distance to the current node while also considering the potential future distance to the destination, using a dynamic weight that decreases as the number of unvisited nodes decreases, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a weighted combination where immediate distance has higher priority (1.0 weight) than future distance (0.5 weight). If scores are equal, it prioritizes the node with a shorter future distance. The code efficiently explores unvisited nodes while handling edge cases like an empty set of unvisited nodes.",
          "thought": "The algorithm prioritizes selecting the next node by considering both the immediate distance to the current node and the potential impact on future path length, using a weighted combination of these factors to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.5 * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing the one that minimizes the product of its distance from the current node and its distance to the destination, while breaking ties by favoring the closer node to the current position. This balances efficiency (minimizing total distance) and exploration (avoiding detours). The function uses a distance matrix for node-to-node distances and iterates through unvisited nodes to find the optimal choice.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the product of distances to the current node and the destination node, breaking ties by choosing the node closer to the current node to balance exploration and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_product = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        product = current_distance * destination_distance\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n        elif product == min_product:\n            if distance_matrix[current_node][node] < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing immediate distance (weighted 1.2) and future distance (weighted 0.3), while also considering the average distance to unvisited nodes (weighted 0.1) to balance exploration and exploitation. It iterates through unvisited nodes, computes a weighted score, and chooses the node with the lowest score, breaking ties by preferring nodes with shorter future distances to the destination. The design balances greediness (short-term) and foresight (long-term) with a slight bias toward immediate distances.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight (1.2) and future distance with a lower weight (0.3), while also considering the average distance to all unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        weighted_score = 1.2 * current_distance + 0.3 * future_distance + 0.1 * avg_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.50567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) and future distance (25%) with minimal randomness (15%), adjusting exploration dynamically as unvisited nodes decrease (1.0 - 0.7*(remaining nodes ratio)). It selects the next node by minimizing a weighted score, favoring shorter current paths and closer future returns, while slightly randomizing choices to avoid local optima.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, future distance with a moderate weight, and randomness with a lower weight, adjusting the exploration factor more aggressively as unvisited nodes decrease to balance exploration and exploitation more dynamically.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.7 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = 0.6 * current_distance + 0.25 * future_distance + 0.15 * exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.58271,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (current_distance) early in the process, gradually balancing it with future distance (future_distance) as unvisited nodes decrease, using a weight factor (weight_factor) that linearly decreases from 1.0 to 0.1. The next node is selected based on the weighted score (current_distance + weight_factor * future_distance), with ties broken by preferring nodes closer to the destination. The algorithm ensures the path returns to the destination_node when no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes immediate distance over future distance early in the process, gradually shifting to a more balanced approach as unvisited nodes decrease, using a linear weight factor that decreases over time.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 1.0 - (total_unvisited / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.62704,
          "other_inf": null
     }
]