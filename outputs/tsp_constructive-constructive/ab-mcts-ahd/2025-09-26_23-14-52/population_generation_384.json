[
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest ratio of the current distance (from the current node) to the destination distance (from the node to the destination), breaking ties by choosing the node closer to the destination. This balances proximity to the current node and directness to the destination, favoring nodes that reduce the ratio while minimizing detours. The `distance_matrix` provides node distances, and the function iterates over unvisited nodes to compute and compare ratios.",
          "thought": "The new algorithm prioritizes the next node by selecting the unvisited node with the smallest ratio of the current distance to the destination distance, breaking ties by choosing the node closer to the destination, aiming to balance proximity to the current node and the destination more directly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / destination_distance if destination_distance != 0 else float('inf')\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n        elif ratio == min_ratio:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (current_distance) heavily early on (weighted at 0.6) but shifts to balance centrality (average distance to unvisited nodes) and future distance (distance to destination) later (weighted at 0.5 each). Temperature adjusts dynamically based on remaining nodes to balance exploration and exploitation, with ties broken by proximity to the destination. The scoring function combines these factors with weighted adjustments to guide node selection.",
          "thought": "The new algorithm prioritizes immediate distance (weighted at 0.6) over node centrality (weighted at 0.4) early on, shifting to favor centrality (weighted at 0.5) and future distance (weighted at 0.5) as the tour progresses, with temperature dynamically adjusted based on remaining unvisited nodes to balance exploration and exploitation, and ties broken by selecting the node closest to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.6 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality)\n        else:\n            weighted_score = current_distance + temperature * (0.5 * centrality + 0.5 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.81199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with lower immediate distance (exploitation) and higher centrality (exploration), balancing them using a decaying temperature that shifts focus from exploration to exploitation as unvisited nodes decrease. Centrality and node degree are weighted more heavily in later stages, while immediate distance dominates early on. The temperature dynamically adjusts the balance between short-term gains (distance) and long-term gains (centrality/degree), with tie-breaking favoring nodes closer to the destination.",
          "thought": "The new algorithm prioritizes nodes with lower immediate distance and higher centrality, using a decaying temperature to shift from exploration to exploitation, with tie-breaking based on future distance and node degree to balance exploration and exploitation dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 2)))\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < float('inf'))\n        weighted_score = (1 - temperature) * (-current_distance) + temperature * (centrality + 0.3 * degree)\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.85847,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adaptation between immediate and future distances, normalizes scores to ensure fairness, and resolves ties by minimizing both current and future distances, prioritizing global optimization as the tour progresses. The `weight_factor` decreases over time, reducing the influence of future distances early in the tour, while the weighted score balances immediate and future distances. The algorithm selects the next node by minimizing a normalized score, breaking ties based on total distance to the destination.",
          "thought": "The new algorithm combines dynamic weight adaptation from No.1 and No.2, normalizes scores for fairness, resolves ties by minimizing both immediate and future distances, and prioritizes global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.5 * (1 - (total_unvisited / (total_unvisited + 1)) ** 2)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = (current_distance + weight_factor * future_distance) / (1 + future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance + future_distance < distance_matrix[current_node][next_node] + distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.89218,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines dynamic weight adjustment between current distance, centrality, and future distance with a multi-phase approach, using a temperature-based exploration factor that decays over time to balance exploitation and exploration. It prioritizes current distance early on, shifts to balancing centrality and future distance later, and refines candidate selection with neighborhood analysis before using a stochastic tournament for final node selection. The weighted scores dynamically adjust based on the remaining unvisited nodes, with temperature controlling exploration intensity.",
          "thought": "The new algorithm combines the No.1 algorithm's dynamic weight adjustment between current distance, centrality, and future distance with the No.2 algorithm's multi-phase approach, using a temperature-based exploration factor that decays over time to balance exploitation and exploration, with refined candidate selection and stochastic tournament for final node selection.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.6 * (total_unvisited / (total_unvisited + 1))\n\n    # Phase 1: Initial candidate selection with weighted scoring\n    candidates = []\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality)\n        else:\n            weighted_score = current_distance + temperature * (0.5 * centrality + 0.5 * future_distance)\n\n        candidates.append((node, weighted_score))\n\n    # Phase 2: Neighborhood refinement of top candidates\n    refined_candidates = []\n    for node, score in sorted(candidates, key=lambda x: x[1])[:min(3, len(candidates))]:\n        neighborhood_scores = []\n        for neighbor in unvisited_nodes:\n            if neighbor != node:\n                neighborhood_score = (distance_matrix[node][neighbor] + distance_matrix[neighbor][destination_node]) / 2\n                neighborhood_scores.append(neighborhood_score)\n        avg_neighborhood = sum(neighborhood_scores) / len(neighborhood_scores) if neighborhood_scores else 0\n        refined_score = score + 0.2 * avg_neighborhood\n        refined_candidates.append((node, refined_score))\n\n    # Phase 3: Stochastic tournament selection\n    tournament_size = min(3, len(refined_candidates))\n    tournament = random.sample(refined_candidates, tournament_size)\n    next_node = min(tournament, key=lambda x: x[1])[0]\n\n    return next_node",
          "objective": 6.91149,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting a temperature parameter based on remaining unvisited nodes. Early on, it prioritizes immediate distance (weighted 0.6) over centrality (0.4), shifting later toward minimizing future distance (0.3), with ties broken by proximity to the destination. The weighted scoring ensures a compromise between short-term gains and long-term efficiency.",
          "thought": "The new algorithm balances exploration and exploitation by dynamically adjusting a temperature parameter based on the remaining unvisited nodes, prioritizing immediate distance (weighted at 0.6) over centrality (weighted at 0.4) early on, then shifting toward minimizing future distance as the tour progresses, with ties broken by selecting the node closest to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality + 0.3 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.99946,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic temperature adjustment with a weighted score that prioritizes centrality early in the process (higher exploration factor) and future distance later (higher weight factor), while using a tie-breaker to prefer nodes closer to the destination. The exploration factor decreases as more nodes are visited, balancing exploration and exploitation, and the temperature dynamically adjusts based on the remaining unvisited nodes. The weighted score balances current distance, centrality, and future distance, with future distance gaining more weight as the search progresses.",
          "thought": "The new algorithm combines dynamic temperature adjustment from No.2 with the balanced exploration-exploitation strategy from No.1, using a weighted score that prioritizes centrality early and future distance later, while incorporating a tie-breaker that favors nodes closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n    exploration_factor = 0.7 * (1 - total_unvisited / (total_unvisited + 1))\n    weight_factor = 0.3 * (1 - total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (exploration_factor * centrality - weight_factor * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.02747,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic temperature adjustment with a weighted scoring system that prioritizes immediate distance and centrality in early stages, shifting to balance centrality and future distance in later stages, using centrality as a tiebreaker. Early stages (when unvisited nodes > 50% of total) favor minimizing current distance and centrality (0.6:0.4 weighting), while later stages (\u226450% unvisited) balance centrality and future distance (0.5:0.5 weighting). Temperature scales the influence of these weights, ensuring adaptability.",
          "thought": "The new algorithm combines dynamic temperature adjustment from No.2 with balanced weighting of current distance, centrality, and future distance from No.1, where early stages prioritize immediate distance and centrality, and later stages balance centrality and future distance, using tie-breaking based on centrality for refined choices.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = current_distance + temperature * (0.6 * current_distance + 0.4 * centrality)\n        else:\n            weighted_score = current_distance + temperature * (0.5 * centrality + 0.5 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.0741,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing the current distance to the next node while balancing it with a dynamic temperature-adjusted trade-off between node centrality (average distance to unvisited nodes) and future distance to the destination. A tie-breaker ensures closer nodes are preferred when scores are equal. The temperature parameter dynamically adjusts the balance between local and global considerations based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm combines the No.1's dynamic temperature adjustment and weighted score balancing current distance, centrality, and future distance with No.2's prioritization of minimizing distance to the destination, while using a tie-breaker to prefer nodes closer to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (centrality - future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.0811,
          "other_inf": null
     }
]