[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a dynamic weight that prioritizes local optimization early and global optimization as unvisited nodes decrease. The weight factor (`weight_factor`) adjusts based on remaining unvisited nodes, ensuring a smoother transition between local and global considerations. The `weighted_score` combines current distance and future distance (scaled by the weight factor) to guide node selection, with ties resolved by choosing the node closer to the destination.",
          "thought": "The algorithm selects the next node by prioritizing the shortest immediate distance to the current node while also considering the potential future distance to the destination, using a dynamic weight that decreases as the number of unvisited nodes decreases, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a weighted combination where immediate distance has higher priority (1.0 weight) than future distance (0.5 weight). If scores are equal, it prioritizes the node with a shorter future distance. The code efficiently explores unvisited nodes while handling edge cases like an empty set of unvisited nodes.",
          "thought": "The algorithm prioritizes selecting the next node by considering both the immediate distance to the current node and the potential impact on future path length, using a weighted combination of these factors to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.5 * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) and future distance (25%) with minimal randomness (15%), adjusting exploration dynamically as unvisited nodes decrease (1.0 - 0.7*(remaining nodes ratio)). It selects the next node by minimizing a weighted score, favoring shorter current paths and closer future returns, while slightly randomizing choices to avoid local optima.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, future distance with a moderate weight, and randomness with a lower weight, adjusting the exploration factor more aggressively as unvisited nodes decrease to balance exploration and exploitation more dynamically.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.7 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = 0.6 * current_distance + 0.25 * future_distance + 0.15 * exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.58271,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node with the smallest combined distance to the current node and the destination node, breaking ties by choosing the node closer to the destination. It uses a distance matrix to compute distances and ensures the destination is returned when no unvisited nodes remain. The key design prioritizes minimizing the total path length while handling ties by favoring nodes closer to the destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination node if there are multiple options with the same distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + destination_distance\n\n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n        elif total_distance == min_distance:\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing **immediate distance** (weighted higher early) and **future distance** (weighted higher later) while incorporating **dynamic exploration** via a probabilistic element. It adjusts weights based on unvisited nodes, favoring closer nodes early and optimizing for return distance later, with exploration encouraged by randomness. The `exploration_factor` and `current_weight`/`future_weight` dynamically shift priorities, ensuring a mix of greedy and explorative node selection.",
          "thought": "The new algorithm combines the weighted balance of immediate and future distances from No.1 with the dynamic exploration factor and probabilistic element from No.2, adjusting weights based on unvisited nodes to prioritize immediate distance early and future distance later while maintaining exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.5 * (total_unvisited / (total_unvisited + 1)))\n    current_weight = 1.0\n    future_weight = 0.5 + (0.3 * (1.0 - exploration_factor))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_weight * current_distance + future_weight * future_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 10.26443,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, future distance, and a probabilistic factor, with the exploration factor decreasing as the number of unvisited nodes decreases to prioritize exploitation. The weighted score combines current distance (high priority), future distance (medium priority), and randomness (low priority), with a dynamic weight that adjusts based on remaining nodes. The exploration factor ensures exploration early, favoring global optimization as the tour progresses.",
          "thought": "My algorithm selects the next node by combining immediate distance, future distance, and a probabilistic factor to balance exploration and exploitation, using a dynamic weight that increases as the tour progresses to favor global optimization over time.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.3 * future_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 10.31744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation using a sigmoid-weighted distance metric, where exploitation favors closer current nodes and exploration favors nodes closer to the destination, adjusted by node popularity (simulated reinforcement learning) and random noise. The sigmoid parameter (-0.5) and popularity weight (0.2) prioritize exploitation early, with exploration increasing as unvisited nodes decrease. The base score combines current and future distances, while popularity and randomness refine selection.",
          "thought": "The new algorithm introduces a dynamic exploration-exploitation balance using a sigmoid function to adjust weights, incorporates a node popularity metric based on historical selections, and employs a reinforcement learning-inspired score adjustment to favor nodes that frequently appear in high-scoring paths.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    exploration_weight = 1.0 / (1.0 + math.exp(-0.5 * (total_unvisited - 5)))\n    exploitation_weight = 1.0 - exploration_weight\n\n    best_score = float('-inf')\n    next_node = None\n    node_popularity = {node: 0 for node in unvisited_nodes}\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        # Base score with dynamic weights\n        base_score = (exploitation_weight * current_distance) - (exploration_weight * future_distance)\n\n        # Popularity adjustment (simulated reinforcement learning effect)\n        popularity_score = node_popularity[node] * 0.2\n        weighted_score = base_score + popularity_score + random.uniform(-0.1, 0.1)\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n            node_popularity[node] += 1  # Simulate learning\n\n    return next_node",
          "objective": 21.03435,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances, prioritizing future distance (70%) over current distance (20%), while adding an exploration factor (0.5\u20131.0) that increases as unvisited nodes decrease, favoring exploitation in later stages. It selects the next node by maximizing a weighted score, with randomness introduced to avoid local optima early on. If scores are tied, the node with the shorter immediate distance is chosen.",
          "thought": "The new algorithm prioritizes future distance over immediate distance with a dynamic exploration factor that increases as unvisited nodes decrease, favoring exploitation in later stages while maintaining exploration early on.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.5 + (0.5 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = 0.2 * current_distance + 0.7 * future_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 25.48425,
          "other_inf": null
     }
]