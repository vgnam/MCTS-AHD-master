[
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting a weight factor that prioritizes immediate distance (current_distance) early in the process and future potential (future_distance + centrality) later, while using temperature and centrality to refine node selection. It normalizes scores to avoid bias and ensures better tour construction by considering both proximity and node centrality, with higher priority given to minimizing the weighted combination of these factors. The algorithm also handles ties by preferring nodes with lower centrality.",
          "thought": "The new algorithm combines the distance normalization from No.1 with the adaptive temperature and centrality balancing from No.2, using a dynamic weight factor that prioritizes local optimization early and global optimization later, while accounting for node centrality and normalized scores to ensure better tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.8 * (total_unvisited / (total_unvisited + 1))\n    temperature = max(0.1, (1.0 - (total_unvisited / (total_unvisited + 1))) * 0.5)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (weight_factor * current_distance + (1 - weight_factor) * (future_distance + 0.5 * centrality)) / (current_distance + future_distance + centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.51452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP path by balancing proximity to the current node, future distance to the destination, and exploration bonuses based on node centrality and distance variance, using a weighted scoring system. Higher priority is given to exploration bonuses and future distance when fewer nodes remain, while proximity dominates in early stages. The dynamic weight factor adjusts based on remaining nodes and centrality, ensuring adaptability between exploration and exploitation.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight factor based on both the number of remaining nodes and the current node's centrality (average distance to other nodes), while introducing a novel \"exploration bonus\" that rewards nodes with higher variance in distances to unvisited nodes, ensuring a balance between proximity and diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (average distance to other nodes)\n    centrality = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        if remaining_nodes > 5:\n            weight = 0.3 * (1 - centrality / max(centrality, 1e-10))\n        elif remaining_nodes > 2:\n            weight = 0.5 * (1 - centrality / max(centrality, 1e-10))\n        else:\n            weight = 0.8 * (1 - centrality / max(centrality, 1e-10))\n\n        # Exploration bonus: variance of distances to unvisited nodes\n        exploration_bonus = sum((distance_matrix[node][other] - current_distance) ** 2 for other in unvisited_nodes) / remaining_nodes\n\n        weighted_score = weight * future_distance - current_distance + exploration_bonus\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance > distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.57823,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance (`current_distance`) and future distance (`future_distance`) with a weight inversely proportional to remaining nodes (`weight_factor`) and a penalty term scaling with the ratio of future to current distances (`penalty`). It prioritizes nodes with lower combined weighted scores, favoring those that reduce future distance to the destination while penalizing overly distant future nodes. The weight and penalty terms dynamically adjust based on remaining nodes, ensuring a balance between short-term and long-term path optimization.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that prioritizes nodes based on both immediate and future distances, with weights inversely proportional to the remaining nodes and a novel penalty term that scales with the ratio of future to current distances, promoting more balanced path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        weight_factor = 1.0 - (remaining_nodes / (remaining_nodes + 5)) ** 0.5\n        weight = weight_factor * (1 - min(future_distance / (current_distance + 1e-10), 1))\n\n        penalty = 0.5 * (future_distance / (current_distance + 1e-10)) ** 1.5\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.59545,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate and future distances, with dynamic weights that prioritize future distances more as the number of remaining nodes decreases. It incorporates a variance-based exploration bonus to favor nodes reducing future distance variance and applies a penalty based on future distance relative to current distance. Higher weights and penalties are applied when fewer nodes remain, emphasizing future distance minimization. The weighted score combines current distance, weighted future distance, exploration bonus, and penalty to determine the optimal next node.",
          "thought": "The new algorithm combines No.1's exploration bonus and dynamic weight adjustment with No.2's weighted scoring and penalty mechanism, dynamically balancing immediate and future distances while incorporating variance-based exploration bonuses to prioritize nodes that reduce variance in future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.5 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        elif remaining_nodes > 2:\n            weight = 0.3 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        else:\n            weight = 0.1 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n\n        exploration_bonus = sum((distance_matrix[node][other] - future_distance) ** 2 for other in unvisited_nodes) / remaining_nodes\n        penalty = 0.4 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * future_distance - exploration_bonus / 10 - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.59841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and future distances, prioritizing closer nodes early while becoming more flexible as fewer nodes remain. It uses a weight that decreases with remaining nodes (0.8 for >5, 0.5 for >2, 0.3 otherwise) to shift focus, and penalizes high future distances more aggressively (cubed term). The selection prioritizes lower weighted scores, breaking ties by preferring nodes closer to the destination.",
          "thought": "The new algorithm prioritizes immediate distances with a fixed weight, penalizes nodes with high future distances more aggressively, and adjusts selection flexibility based on remaining nodes, favoring closer options early and becoming more flexible as the process progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.8\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.3\n\n        penalty = 0.5 * (future_distance / (current_distance + 1e-10)) ** 3\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.60971,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes future distances (weighted by dynamic weights: 0.3 for >5 nodes, 0.5 for >2, and 0.8 for \u22642) while penalizing nodes with very low current distances, balancing these with a tiebreaker favoring longer current distances. The weighted score combines future distance, current distance, and a penalty term to select the next node, ensuring a trade-off between immediate and long-term efficiency.",
          "thought": "The new algorithm prioritizes future distance over immediate distance with dynamically adjusted weights (0.3 for >5 nodes, 0.5 for >2, 0.8 for \u22642), while penalizing nodes with disproportionately low current distances, selecting the next node by balancing these weighted scores and breaking ties in favor of nodes with longer current distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.3\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.8\n\n        penalty = 0.2 * (current_distance / (future_distance + 1e-10)) ** 2\n        weighted_score = weight * future_distance - current_distance - penalty\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance > distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.61162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (current step) and future distance (to destination) with weights adjusting based on remaining nodes (higher early emphasis, lower later), incorporates a memory factor to favor historically good choices, penalizes disproportionately high future distances, and resolves ties by preferring nodes closer to the destination. The `alpha` and `beta` parameters control the trade-off between immediate and future distances, while the `weight` and `normalized_penalty` adjust the focus on future optimization as the tour progresses.",
          "thought": "This new algorithm combines the weighted balancing of immediate and future distances from all three algorithms, uses dynamic weights based on remaining nodes (with higher emphasis on immediate steps early and long-term optimization later), incorporates a memory-based factor to favor historically good choices, and includes a penalty for disproportionately high future distances, while prioritizing nodes with shorter future distances to the destination in case of ties.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None, alpha=0.6, beta=0.4):\n    if not unvisited_nodes:\n        return destination_node\n\n    if memory is None:\n        memory = {node: 0 for node in unvisited_nodes}\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.9\n        elif remaining_nodes > 2:\n            weight = 0.6\n        else:\n            weight = 0.4\n\n        normalized_penalty = (future_distance / (current_distance + 1e-10)) ** 1.5\n        memory_factor = memory[node] * 0.15\n        weighted_score = alpha * current_distance + beta * (weight * future_distance - normalized_penalty) + memory_factor\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    if next_node is not None:\n        memory[next_node] += 1\n\n    return next_node",
          "objective": 6.61184,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with balanced current and future distances, adjusting weights dynamically (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and penalizing nodes with disproportionately high future distances. It scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, favoring shorter-term gains while avoiding long-term detours. The penalty term reduces the score for nodes where future distances are much larger than current distances.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the ratio-based scoring from No.1, prioritizing nodes that balance immediate distance with future distance while penalizing nodes with disproportionately high future distances. It adjusts weights (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, ensuring efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.8\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.3\n\n        ratio = current_distance / (future_distance + 1e-10)\n        penalty = 0.2 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * ratio - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.6163,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing immediate distances over future distances, with higher weights given to future distances early in the process (decreasing as remaining nodes shrink). It penalizes nodes with disproportionately high future distances more aggressively, using a weighted scoring mechanism that balances current and future costs. Early nodes favor closer options, while later stages become more flexible, ensuring a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on the ratio of immediate to future distances, penalizes nodes with high future distances relative to immediate distances more aggressively, and uses a novel scoring mechanism that combines these factors with an adaptive weight that decreases as the number of remaining nodes decreases, favoring closer nodes early while maintaining flexibility for future steps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.6 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        elif remaining_nodes > 2:\n            weight = 0.4 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        else:\n            weight = 0.2 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n\n        penalty = 0.3 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.62045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances using adaptive weights: closer nodes are prioritized early (weighted more heavily), while disproportionately high future distances are penalized more aggressively. The weight decreases as the number of remaining nodes decreases, and the penalty scales with the ratio of future to current distance, favoring nodes that reduce the overall path length while avoiding long detours. The hybrid scoring mechanism combines current distance, weighted future distance, and penalty to select the next node, ensuring both local and global optimality.",
          "thought": "This new algorithm dynamically balances immediate and future distances with adaptive weights, prioritizing closer nodes early while penalizing disproportionately high future distances more aggressively, and uses a hybrid scoring mechanism that combines the strengths of all three algorithms to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.5 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        elif remaining_nodes > 2:\n            weight = 0.3 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        else:\n            weight = 0.1 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n\n        penalty = 0.4 * (future_distance / (current_distance + 1e-10)) ** 1.5\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.62694,
          "other_inf": null
     }
]