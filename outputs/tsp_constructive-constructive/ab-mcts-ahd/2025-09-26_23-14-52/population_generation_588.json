[
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting a weight factor that prioritizes immediate distance (current_distance) early in the process and future potential (future_distance + centrality) later, while using temperature and centrality to refine node selection. It normalizes scores to avoid bias and ensures better tour construction by considering both proximity and node centrality, with higher priority given to minimizing the weighted combination of these factors. The algorithm also handles ties by preferring nodes with lower centrality.",
          "thought": "The new algorithm combines the distance normalization from No.1 with the adaptive temperature and centrality balancing from No.2, using a dynamic weight factor that prioritizes local optimization early and global optimization later, while accounting for node centrality and normalized scores to ensure better tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.8 * (total_unvisited / (total_unvisited + 1))\n    temperature = max(0.1, (1.0 - (total_unvisited / (total_unvisited + 1))) * 0.5)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (weight_factor * current_distance + (1 - weight_factor) * (future_distance + 0.5 * centrality)) / (current_distance + future_distance + centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.51452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distance minimization by prioritizing nodes with a weighted score combining the ratio of current-to-future distance and a current-distance component, where the weight factor increases as fewer nodes remain unvisited. It uses a tie-breaker favoring nodes closer to the current node when scores are equal. The design ensures a smooth transition from early-stage distance minimization to later-stage destination-focused routing.",
          "thought": "The new algorithm prioritizes immediate distance minimization early on but gradually shifts focus to future distance minimization, using a dynamic weight that increases with the number of unvisited nodes, ensuring a smooth transition toward the destination with a tie-breaker favoring nodes closer to the current node when scores are equal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = min(0.9, (total_unvisited / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        weighted_score = ratio + weight_factor * current_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.65047,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest ratio of the current distance (from the current node) to the destination distance (from the node to the destination), breaking ties by choosing the node closer to the destination. This balances proximity to the current node and directness to the destination, favoring nodes that reduce the ratio while minimizing detours. The `distance_matrix` provides node distances, and the function iterates over unvisited nodes to compute and compare ratios.",
          "thought": "The new algorithm prioritizes the next node by selecting the unvisited node with the smallest ratio of the current distance to the destination distance, breaking ties by choosing the node closer to the destination, aiming to balance proximity to the current node and the destination more directly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / destination_distance if destination_distance != 0 else float('inf')\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n        elif ratio == min_ratio:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing the ratio of current to future distances, current distance, and centrality, with temperature scaling the influence of these factors. Early stages prioritize minimizing the ratio and current distance (0.7:0.3), while later stages balance the ratio and centrality (0.6:0.4). Centrality is used as a tiebreaker, ensuring adaptability and efficiency in path construction.",
          "thought": "The new algorithm combines dynamic temperature adjustment with a ratio-based scoring system that prioritizes minimizing the ratio of current distance to future distance, while also considering centrality as a tiebreaker. Early stages favor minimizing the ratio and current distance (0.7:0.3 weighting), while later stages balance the ratio and centrality (0.6:0.4 weighting). Temperature scales the influence of these weights, ensuring adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = ratio + temperature * (0.7 * current_distance + 0.3 * ratio)\n        else:\n            weighted_score = ratio + temperature * (0.6 * ratio + 0.4 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.66711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection with dynamic weight adaptation, prioritizing nodes that balance immediate and future distances while normalizing for fairness. It uses a weighted ratio score where the weight factor decreases as more nodes are visited, giving higher priority to immediate distances early on and balancing both later. Ties are resolved by minimizing the sum of current and future distances to prioritize global optimization. The `weight_factor` dynamically adjusts the balance between current and future distances, while the `normalized_score` ensures fair comparison across nodes.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the dynamic weight adaptation from No.2, using a weighted ratio score that balances immediate and future distances while normalizing for fairness, and resolving ties by minimizing both current and future distances to prioritize global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.5 * (1 - (total_unvisited / (total_unvisited + 1)) ** 2)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_ratio = (current_distance / (1 + future_distance)) + weight_factor * (future_distance / (1 + current_distance))\n        normalized_score = weighted_ratio / (1 + future_distance)\n\n        if normalized_score < best_score:\n            best_score = normalized_score\n            next_node = node\n        elif normalized_score == best_score:\n            if current_distance + future_distance < distance_matrix[current_node][next_node] + distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.67909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances distance ratios and centrality, prioritizing efficient path construction by dynamically adjusting weights between immediate distance ratios and node centrality, with higher weights on distance ratios early and centrality later. It uses temperature and exploration factors to adaptively explore promising nodes, favoring closer nodes with good future potential while ensuring diversity in path selection. The weighted score combines these factors, favoring nodes with lower immediate-future distance ratios and higher centrality when fewer nodes remain, with tie-breaking based on normalized centrality.",
          "thought": "The new algorithm combines the dynamic balancing of distance ratios and centrality from No.1 with the temperature-driven exploration and normalized centrality from No.2, adjusting weights based on remaining nodes to prioritize efficient path construction while maintaining adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    exploration_factor = 1.0 / (1.0 + 0.5 * (total_unvisited - 1))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        normalized_centrality = centrality / (sum(distance_matrix[n][destination_node] for n in unvisited_nodes) / total_unvisited + 1e-6)\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = ratio + temperature * (0.7 * current_distance + 0.3 * ratio)\n        else:\n            weighted_score = ratio + temperature * (0.6 * ratio + 0.4 * normalized_centrality)\n\n        weighted_score += exploration_factor * normalized_centrality\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if normalized_centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited / (sum(distance_matrix[n][destination_node] for n in unvisited_nodes) / total_unvisited + 1e-6):\n                next_node = node\n\n    return next_node",
          "objective": 6.79656,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (current_distance) heavily early on (weighted at 0.6) but shifts to balance centrality (average distance to unvisited nodes) and future distance (distance to destination) later (weighted at 0.5 each). Temperature adjusts dynamically based on remaining nodes to balance exploration and exploitation, with ties broken by proximity to the destination. The scoring function combines these factors with weighted adjustments to guide node selection.",
          "thought": "The new algorithm prioritizes immediate distance (weighted at 0.6) over node centrality (weighted at 0.4) early on, shifting to favor centrality (weighted at 0.5) and future distance (weighted at 0.5) as the tour progresses, with temperature dynamically adjusted based on remaining unvisited nodes to balance exploration and exploitation, and ties broken by selecting the node closest to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.6 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality)\n        else:\n            weighted_score = current_distance + temperature * (0.5 * centrality + 0.5 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.81199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two criteria: minimizing the ratio of current distance to destination distance (70% weight) and minimizing the sum of current and destination distances (30% weight). It prioritizes nodes that reduce the ratio while also keeping future distances short, breaking ties by preferring nodes closer to the destination. The weighted combination ensures a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted distance approach from No.2, favoring nodes that minimize the ratio of current distance to destination distance while also considering a weighted balance between immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_weighted_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / destination_distance if destination_distance != 0 else float('inf')\n        weighted_ratio = 0.7 * ratio + 0.3 * (current_distance + destination_distance)\n\n        if weighted_ratio < min_weighted_ratio:\n            min_weighted_ratio = weighted_ratio\n            next_node = node\n        elif weighted_ratio == min_weighted_ratio:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.84365,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by combining immediate distance (prioritized when temperature is low) with centrality, degree, novelty, and diversity (prioritized when temperature is high). It uses a non-linear temperature decay to adjust weights, giving higher priority to centrality, degree, and novelty while slightly penalizing diversity. The weighted score is calculated as `(1 - temperature) * (-current_distance) + temperature * (centrality + 0.3 * degree + 0.2 * novelty - 0.1 * diversity)`, with ties broken by proximity to the destination node.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic priority system that combines immediate distance, centrality, and degree with a novelty score based on node uniqueness and a path diversity factor, using a non-linear temperature decay to balance exploration and exploitation more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 2)) ** 2)\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < float('inf'))\n        novelty = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < current_distance) / total_unvisited\n        diversity = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / total_unvisited\n\n        weighted_score = (1 - temperature) * (-current_distance) + temperature * (centrality + 0.3 * degree + 0.2 * novelty - 0.1 * diversity)\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.84729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing dynamic weights between current and destination distances, adjusted by remaining nodes, while prioritizing centrality (lower distance sums to unvisited nodes) and degree (higher connectivity) to guide selection, favoring nodes that are centrally located and highly connected in early stages. The score combines these factors, with current distance weighted more heavily early on, while centrality and degree contribute negatively to the score. The weight factor decreases as nodes are visited, shifting emphasis toward destination proximity.",
          "thought": "The new algorithm combines dynamic weight balancing from No.2 with centrality and degree considerations from No.1, adjusting the weight factor inversely with remaining nodes while incorporating node centrality and degree to guide selection, favoring nodes that are centrally located and highly connected in early stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes\n        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < float('inf'))\n\n        # Weighted score combining current and destination distances, with centrality and degree\n        score = (1 - weight_factor) * current_distance + weight_factor * destination_distance - 0.2 * centrality - 0.1 * degree\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85292,
          "other_inf": null
     }
]