[
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and estimated future distance to the destination, using a dynamic weight factor that prioritizes immediate steps when fewer nodes remain. It resolves ties by choosing the node closer to the destination, ensuring both short-term and long-term optimization while efficiently handling remaining nodes.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts the balance between minimizing the current step's distance and the remaining path's estimated distance, using a heuristic that balances immediate and long-term path optimization while still resolving ties by proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * destination_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm balances short-term distance and node centrality early in the tour, while gradually shifting focus to long-term distance and centrality as the tour progresses. It uses an exploration factor (prioritizing centrality early) and a weight factor (prioritizing future distance later) that increase over time. The algorithm selects the next node by minimizing a weighted score combining current distance, future distance, and centrality, with ties broken in favor of nodes closer to the destination.",
          "thought": "The new algorithm prioritizes immediate distance and node centrality early on, transitioning to favor future distance and centrality as the tour progresses, with exploration and weight factors increasing over time to balance short-term and long-term objectives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.7 * (1 - total_unvisited / (total_unvisited + 1))\n    weight_factor = 0.3 * (1 - total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (1 - exploration_factor) * (current_distance + weight_factor * future_distance) + exploration_factor * centrality\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15972,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate steps when fewer nodes remain by dynamically adjusting a weight factor (`weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)`), balancing between minimizing the current distance to the next node and the sum of squared distances to the destination. It selects the next node by evaluating a weighted score combining these factors, favoring nodes closer to the current node when many nodes remain but also considering proximity to the destination when fewer nodes are left. The tiebreaker ensures the node closer to the destination is chosen if scores are equal.",
          "thought": "The new algorithm combines the dynamic weight factor from No.1 with the squared distance optimization from No.2, using a weight factor that prioritizes immediate steps when fewer nodes remain, while minimizing the sum of squared distances to both the current node and the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        squared_sum = current_distance**2 + destination_distance**2\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * squared_sum)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.19628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the next node with future distance to the destination and node centrality, using a dynamic temperature to adjust exploration-exploitation trade-off. It prioritizes nodes with lower combined scores (weighted by current distance, future distance, and centrality) and breaks ties based on centrality, favoring nodes that are more central to the remaining unvisited nodes. The temperature decreases as the number of unvisited nodes decreases, shifting from exploration to exploitation.",
          "thought": "The new algorithm balances immediate distance with future distance and centrality, using a dynamic temperature to adjust exploration-exploitation trade-off, prioritizing nodes with lower combined scores and tie-breaking based on centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (future_distance + 0.3 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.21272,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing immediate distance with probabilistic factors, where a temperature-based weight adjusts exploration (high temperature) to exploitation (low temperature) as unvisited nodes decrease. It prioritizes nodes with lower current distance, future distance, and centrality in the remaining set, using tie-breaking based on centrality to refine choices. The score combines distance and centrality, with temperature modulating their relative importance.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance with a probabilistic factor that considers both local and global optimization, using a temperature-based weight factor that decreases over time to balance exploration and exploitation, with tie-breaking based on node centrality in the remaining unvisited set.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (future_distance + 0.5 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.21562,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting a temperature parameter based on remaining unvisited nodes, prioritizing centrality (weighted at 0.7) over future distance (weighted at 0.3) early on, then shifting toward minimizing future distance as the tour progresses. The weighted score combines immediate distance with a temperature-adjusted trade-off between node centrality and proximity to the destination, with ties broken in favor of nodes closer to the destination. The temperature starts high (favoring exploration) and decreases as unvisited nodes dwindle (favoring exploitation).",
          "thought": "The new algorithm combines the weighted scoring approach of No.2 with the temperature-adjustable balance between centrality and future distance from No.1, dynamically adjusting the temperature based on the number of unvisited nodes to prioritize exploration early and exploitation later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weighted_score = current_distance + temperature * (0.7 * centrality - 0.3 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.3308,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by combining immediate distance with future connectivity, weighted by a decaying temperature factor. It prioritizes nodes with lower current and future distances while introducing randomness based on node centrality, favoring less central nodes early on. The weighted score combines these factors, with temperature adjusting the balance between exploitation (distance-based) and exploration (randomness-based), and centrality influencing node selection probabilities.",
          "thought": "The new algorithm dynamically adjusts exploration and exploitation by combining distance-based selection with a decaying temperature factor, favoring nodes with better immediate and future connectivity while introducing randomness based on node centrality and remaining exploration potential.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = 1.0 - math.exp(-0.3 * (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(1 for neighbor in unvisited_nodes if distance_matrix[node][neighbor] < float('inf')) / total_unvisited\n        exploration_factor = temperature * (1 - centrality) * random.uniform(0.5, 1.5)\n        weighted_score = (current_distance + 0.3 * future_distance) * (1 - temperature) + exploration_factor\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (70%) and future distance (20%) while using a decaying exploration factor (10%) based on node centrality to balance greedy and exploratory choices. It selects the next node by minimizing a weighted score of these factors, with exploration decreasing linearly as unvisited nodes are reduced. If scores are tied, it prefers nodes with shorter future distances to the destination.",
          "thought": "The new algorithm prioritizes immediate distance (70%) and future distance (20%) with a fixed exploration factor (10%) based on node centrality, using a linear decay of exploration over remaining nodes, ensuring a balance between greedy and exploratory choices without temperature-driven adaptation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.1 * (total_unvisited / (total_unvisited + 1))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(1 for neighbor in unvisited_nodes if distance_matrix[node][neighbor] < float('inf')) / total_unvisited\n        weighted_score = 0.7 * current_distance + 0.2 * future_distance + exploration_factor * (1 - centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.4238,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a dynamic weight that prioritizes local optimization early and global optimization as unvisited nodes decrease. The weight factor (`weight_factor`) adjusts based on remaining unvisited nodes, ensuring a smoother transition between local and global considerations. The `weighted_score` combines current distance and future distance (scaled by the weight factor) to guide node selection, with ties resolved by choosing the node closer to the destination.",
          "thought": "The algorithm selects the next node by prioritizing the shortest immediate distance to the current node while also considering the potential future distance to the destination, using a dynamic weight that decreases as the number of unvisited nodes decreases, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     }
]