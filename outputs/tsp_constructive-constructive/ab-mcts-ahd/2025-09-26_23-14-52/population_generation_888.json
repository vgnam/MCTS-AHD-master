[
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting a weight factor that prioritizes immediate distance (current_distance) early in the process and future potential (future_distance + centrality) later, while using temperature and centrality to refine node selection. It normalizes scores to avoid bias and ensures better tour construction by considering both proximity and node centrality, with higher priority given to minimizing the weighted combination of these factors. The algorithm also handles ties by preferring nodes with lower centrality.",
          "thought": "The new algorithm combines the distance normalization from No.1 with the adaptive temperature and centrality balancing from No.2, using a dynamic weight factor that prioritizes local optimization early and global optimization later, while accounting for node centrality and normalized scores to ensure better tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.8 * (total_unvisited / (total_unvisited + 1))\n    temperature = max(0.1, (1.0 - (total_unvisited / (total_unvisited + 1))) * 0.5)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (weight_factor * current_distance + (1 - weight_factor) * (future_distance + 0.5 * centrality)) / (current_distance + future_distance + centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.51452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes future distances (weighted by dynamic weights: 0.3 for >5 nodes, 0.5 for >2, and 0.8 for \u22642) while penalizing nodes with very low current distances, balancing these with a tiebreaker favoring longer current distances. The weighted score combines future distance, current distance, and a penalty term to select the next node, ensuring a trade-off between immediate and long-term efficiency.",
          "thought": "The new algorithm prioritizes future distance over immediate distance with dynamically adjusted weights (0.3 for >5 nodes, 0.5 for >2, 0.8 for \u22642), while penalizing nodes with disproportionately low current distances, selecting the next node by balancing these weighted scores and breaking ties in favor of nodes with longer current distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.3\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.8\n\n        penalty = 0.2 * (current_distance / (future_distance + 1e-10)) ** 2\n        weighted_score = weight * future_distance - current_distance - penalty\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance > distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.61162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance (current step) and future distance (to destination) with weights adjusting based on remaining nodes (higher early emphasis, lower later), incorporates a memory factor to favor historically good choices, penalizes disproportionately high future distances, and resolves ties by preferring nodes closer to the destination. The `alpha` and `beta` parameters control the trade-off between immediate and future distances, while the `weight` and `normalized_penalty` adjust the focus on future optimization as the tour progresses.",
          "thought": "This new algorithm combines the weighted balancing of immediate and future distances from all three algorithms, uses dynamic weights based on remaining nodes (with higher emphasis on immediate steps early and long-term optimization later), incorporates a memory-based factor to favor historically good choices, and includes a penalty for disproportionately high future distances, while prioritizing nodes with shorter future distances to the destination in case of ties.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None, alpha=0.6, beta=0.4):\n    if not unvisited_nodes:\n        return destination_node\n\n    if memory is None:\n        memory = {node: 0 for node in unvisited_nodes}\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.9\n        elif remaining_nodes > 2:\n            weight = 0.6\n        else:\n            weight = 0.4\n\n        normalized_penalty = (future_distance / (current_distance + 1e-10)) ** 1.5\n        memory_factor = memory[node] * 0.15\n        weighted_score = alpha * current_distance + beta * (weight * future_distance - normalized_penalty) + memory_factor\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    if next_node is not None:\n        memory[next_node] += 1\n\n    return next_node",
          "objective": 6.61184,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with balanced current and future distances, adjusting weights dynamically (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and penalizing nodes with disproportionately high future distances. It scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, favoring shorter-term gains while avoiding long-term detours. The penalty term reduces the score for nodes where future distances are much larger than current distances.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the ratio-based scoring from No.1, prioritizing nodes that balance immediate distance with future distance while penalizing nodes with disproportionately high future distances. It adjusts weights (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, ensuring efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.8\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.3\n\n        ratio = current_distance / (future_distance + 1e-10)\n        penalty = 0.2 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * ratio - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.6163,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing immediate distances over future distances, with higher weights given to future distances early in the process (decreasing as remaining nodes shrink). It penalizes nodes with disproportionately high future distances more aggressively, using a weighted scoring mechanism that balances current and future costs. Early nodes favor closer options, while later stages become more flexible, ensuring a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on the ratio of immediate to future distances, penalizes nodes with high future distances relative to immediate distances more aggressively, and uses a novel scoring mechanism that combines these factors with an adaptive weight that decreases as the number of remaining nodes decreases, favoring closer nodes early while maintaining flexibility for future steps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.6 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        elif remaining_nodes > 2:\n            weight = 0.4 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        else:\n            weight = 0.2 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n\n        penalty = 0.3 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.62045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate and future distances with dynamic weighting, prioritizing nodes based on a weighted score that balances current-to-future distance ratios, weighted current distances, and exploration-driven randomness. As unvisited nodes decrease, the weight factor adjusts to favor future distances more, while the exploration factor ensures diversity in selections. The best node is chosen by minimizing the weighted score, with tie-breakers favoring nodes closer to the destination.",
          "thought": "The new algorithm combines the dynamic balancing of immediate and future distances from No.1 with the weighted scoring and exploration factor from No.2, using a weighted score that adjusts priorities based on remaining nodes and incorporates randomness to balance short-term and long-term objectives while ensuring exploration through a weighted ratio of current-to-future distance and a dynamic weight factor that increases as fewer nodes remain unvisited.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = min(0.9, (total_unvisited / len(distance_matrix)))\n    exploration_factor = 0.3 * (1.0 - (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        weighted_score = ratio + weight_factor * current_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.63283,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing current and future distances, prioritizing nodes that minimize a weighted combination of current distance and a ratio of current-to-future distance (with a fixed weight of 0.5), while penalizing nodes with disproportionately high future distances. It breaks ties by preferring nodes with smaller weighted distances (0.6 * current + 0.4 * future) and further breaks ties by choosing the node closer to the destination. The penalty term (0.2 * (future/current)^2) discourages nodes with very high future distances relative to current distances.",
          "thought": "The new algorithm combines the balanced scoring approach from No.1 by prioritizing nodes that minimize a weighted combination of current distance and a ratio of current-to-future distance (with a fixed weight of 0.5), while also penalizing nodes with disproportionately high future distances. The algorithm selects the next node by minimizing this weighted score, breaking ties by preferring nodes with smaller weighted distances, and further breaking ties by choosing the node closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / (future_distance + 1e-10)\n        penalty = 0.2 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = 0.5 * current_distance + ratio - penalty\n        weighted_distance = 0.6 * current_distance + 0.4 * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n            min_weighted = weighted_distance\n        elif weighted_score == best_score:\n            if weighted_distance < min_weighted:\n                next_node = node\n                min_weighted = weighted_distance\n            elif weighted_distance == min_weighted:\n                if future_distance < distance_matrix[next_node][destination_node]:\n                    next_node = node\n\n    return next_node",
          "objective": 6.64364,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distance minimization by prioritizing nodes with a weighted score combining the ratio of current-to-future distance and a current-distance component, where the weight factor increases as fewer nodes remain unvisited. It uses a tie-breaker favoring nodes closer to the current node when scores are equal. The design ensures a smooth transition from early-stage distance minimization to later-stage destination-focused routing.",
          "thought": "The new algorithm prioritizes immediate distance minimization early on but gradually shifts focus to future distance minimization, using a dynamic weight that increases with the number of unvisited nodes, ensuring a smooth transition toward the destination with a tie-breaker favoring nodes closer to the current node when scores are equal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = min(0.9, (total_unvisited / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        weighted_score = ratio + weight_factor * current_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.65047,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, future distance to the destination, memory-based novelty, and exploration, with higher priority given to immediate distance (60%), followed by future distance (30%) and memory (10%), while dynamically adjusting exploration via exponential decay. It penalizes disproportionately high future distances and resolves ties by preferring nodes closer to the destination. The weight of future distance decreases as nodes are visited, and memory tracks node selection frequency to avoid repetition.",
          "thought": "The new algorithm combines dynamic balancing of immediate and future distances with probabilistic selection, exponential decay of exploration, and memory-based novelty, while penalizing disproportionately high future distances and resolving ties by preferring nodes closer to the destination.",
          "code": "import random\nimport math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    if memory is None:\n        memory = {node: 0 for node in unvisited_nodes}\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.5 * math.exp(-total_unvisited / 10)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if total_unvisited > 5:\n            weight = 0.9\n        elif total_unvisited > 2:\n            weight = 0.6\n        else:\n            weight = 0.4\n\n        normalized_penalty = (future_distance / (current_distance + 1e-10)) ** 1.5\n        memory_factor = memory[node] * 0.15\n        weighted_score = 0.6 * current_distance + 0.3 * (weight * future_distance - normalized_penalty) + 0.1 * memory_factor + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    if next_node is not None:\n        memory[next_node] += 1\n\n    return next_node",
          "objective": 6.65846,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm balances immediate and future distances with dynamic weights, prioritizing short-term distances while adaptively penalizing nodes with high future costs, especially early in the process. It uses a weighted score (1.5\u00d7 current distance + weighted future distance - penalty) to select the next node, adjusting weights (0.5, 0.3, or 0.1) based on remaining nodes. A tiebreaker favors nodes with longer future distances to the destination.",
          "thought": "The new algorithm combines the weighted balance of immediate and future distances from No.2 with the dynamic adjustment of weights and penalties based on remaining nodes from No.1. It prioritizes immediate distances while adaptively penalizing nodes with high future costs, especially early in the process, and uses a tiebreaker to favor nodes with longer future distances to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.5\n        elif remaining_nodes > 2:\n            weight = 0.3\n        else:\n            weight = 0.1\n\n        penalty = 0.4 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = 1.5 * current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance > distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66309,
          "other_inf": null
     }
]