[
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest ratio of the current distance (from the current node) to the destination distance (from the node to the destination), breaking ties by choosing the node closer to the destination. This balances proximity to the current node and directness to the destination, favoring nodes that reduce the ratio while minimizing detours. The `distance_matrix` provides node distances, and the function iterates over unvisited nodes to compute and compare ratios.",
          "thought": "The new algorithm prioritizes the next node by selecting the unvisited node with the smallest ratio of the current distance to the destination distance, breaking ties by choosing the node closer to the destination, aiming to balance proximity to the current node and the destination more directly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / destination_distance if destination_distance != 0 else float('inf')\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n        elif ratio == min_ratio:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (current_distance) heavily early on (weighted at 0.6) but shifts to balance centrality (average distance to unvisited nodes) and future distance (distance to destination) later (weighted at 0.5 each). Temperature adjusts dynamically based on remaining nodes to balance exploration and exploitation, with ties broken by proximity to the destination. The scoring function combines these factors with weighted adjustments to guide node selection.",
          "thought": "The new algorithm prioritizes immediate distance (weighted at 0.6) over node centrality (weighted at 0.4) early on, shifting to favor centrality (weighted at 0.5) and future distance (weighted at 0.5) as the tour progresses, with temperature dynamically adjusted based on remaining unvisited nodes to balance exploration and exploitation, and ties broken by selecting the node closest to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.6 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality)\n        else:\n            weighted_score = current_distance + temperature * (0.5 * centrality + 0.5 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.81199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting a temperature parameter based on remaining unvisited nodes. Early on, it prioritizes immediate distance (weighted 0.6) over centrality (0.4), shifting later toward minimizing future distance (0.3), with ties broken by proximity to the destination. The weighted scoring ensures a compromise between short-term gains and long-term efficiency.",
          "thought": "The new algorithm balances exploration and exploitation by dynamically adjusting a temperature parameter based on the remaining unvisited nodes, prioritizing immediate distance (weighted at 0.6) over centrality (weighted at 0.4) early on, then shifting toward minimizing future distance as the tour progresses, with ties broken by selecting the node closest to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weighted_score = current_distance + temperature * (0.6 * current_distance - 0.4 * centrality + 0.3 * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.99946,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic temperature adjustment with a weighted score that prioritizes centrality early in the process (higher exploration factor) and future distance later (higher weight factor), while using a tie-breaker to prefer nodes closer to the destination. The exploration factor decreases as more nodes are visited, balancing exploration and exploitation, and the temperature dynamically adjusts based on the remaining unvisited nodes. The weighted score balances current distance, centrality, and future distance, with future distance gaining more weight as the search progresses.",
          "thought": "The new algorithm combines dynamic temperature adjustment from No.2 with the balanced exploration-exploitation strategy from No.1, using a weighted score that prioritizes centrality early and future distance later, while incorporating a tie-breaker that favors nodes closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    temperature = 0.5 * (total_unvisited / (total_unvisited + 1))\n    exploration_factor = 0.7 * (1 - total_unvisited / (total_unvisited + 1))\n    weight_factor = 0.3 * (1 - total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (exploration_factor * centrality - weight_factor * future_distance)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.02747,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and estimated future distance to the destination, using a dynamic weight factor that prioritizes immediate steps when fewer nodes remain. It resolves ties by choosing the node closer to the destination, ensuring both short-term and long-term optimization while efficiently handling remaining nodes.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts the balance between minimizing the current step's distance and the remaining path's estimated distance, using a heuristic that balances immediate and long-term path optimization while still resolving ties by proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * destination_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm balances short-term distance and node centrality early in the tour, while gradually shifting focus to long-term distance and centrality as the tour progresses. It uses an exploration factor (prioritizing centrality early) and a weight factor (prioritizing future distance later) that increase over time. The algorithm selects the next node by minimizing a weighted score combining current distance, future distance, and centrality, with ties broken in favor of nodes closer to the destination.",
          "thought": "The new algorithm prioritizes immediate distance and node centrality early on, transitioning to favor future distance and centrality as the tour progresses, with exploration and weight factors increasing over time to balance short-term and long-term objectives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 0.7 * (1 - total_unvisited / (total_unvisited + 1))\n    weight_factor = 0.3 * (1 - total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (1 - exploration_factor) * (current_distance + weight_factor * future_distance) + exploration_factor * centrality\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15972,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate steps when fewer nodes remain by dynamically adjusting a weight factor (`weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)`), balancing between minimizing the current distance to the next node and the sum of squared distances to the destination. It selects the next node by evaluating a weighted score combining these factors, favoring nodes closer to the current node when many nodes remain but also considering proximity to the destination when fewer nodes are left. The tiebreaker ensures the node closer to the destination is chosen if scores are equal.",
          "thought": "The new algorithm combines the dynamic weight factor from No.1 with the squared distance optimization from No.2, using a weight factor that prioritizes immediate steps when fewer nodes remain, while minimizing the sum of squared distances to both the current node and the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        squared_sum = current_distance**2 + destination_distance**2\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * squared_sum)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.19628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines distance-based selection with dynamic temperature and centrality considerations, prioritizing nodes that are both close to the current node and central to remaining unvisited nodes, while adjusting the balance between exploration and exploitation as the number of unvisited nodes decreases. The temperature parameter (decreasing with fewer unvisited nodes) reduces the influence of future and centrality factors, while the weight factor (0.6 for current distance vs. 0.4 for future distance and 0.2 for centrality) ensures proximity is prioritized. The algorithm also handles ties by selecting the more central node.",
          "thought": "The new algorithm combines the balanced weighting of distances from No.2 with the dynamic temperature and centrality consideration from No.1, adjusting exploration-exploitation trade-off as the number of unvisited nodes decreases to prioritize nodes that are both close and central to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n    weight_factor = 0.6\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (weight_factor * current_distance) + (temperature * (0.4 * future_distance + 0.2 * centrality))\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.1967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the next node with future distance to the destination and node centrality, using a dynamic temperature to adjust exploration-exploitation trade-off. It prioritizes nodes with lower combined scores (weighted by current distance, future distance, and centrality) and breaks ties based on centrality, favoring nodes that are more central to the remaining unvisited nodes. The temperature decreases as the number of unvisited nodes decreases, shifting from exploration to exploitation.",
          "thought": "The new algorithm balances immediate distance with future distance and centrality, using a dynamic temperature to adjust exploration-exploitation trade-off, prioritizing nodes with lower combined scores and tie-breaking based on centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = current_distance + temperature * (future_distance + 0.3 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 7.21272,
          "other_inf": null
     }
]