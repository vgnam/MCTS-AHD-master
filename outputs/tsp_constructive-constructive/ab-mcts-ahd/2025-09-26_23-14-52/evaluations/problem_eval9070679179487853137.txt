importance, using a penalty-based scoring system that reduces the influence of nodes with high future distances relative to their current distance, and introduces a temperature-based probabilistic selection to balance exploration and exploitation as the search progresses.}

```python
import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = 1.0 / (1.0 + total_unvisited)  # Decreases as search progresses

    # Calculate dynamic centrality weights
    centrality_weights = []
    for node in unvisited_nodes:
        local_centrality = np.mean(distance_matrix[node])
        global_centrality = np.mean([distance_matrix[node][n] for n in unvisited_nodes if n != node])
        combined_centrality = 0.7 * local_centrality + 0.3 * global_centrality
        centrality_weights.append(combined_centrality)

    # Normalize and apply temperature scaling
    if centrality_weights:
        max_centrality = max(centrality_weights)
        centrality_weights = [w / max_centrality for w in centrality_weights]
        centrality_weights = [w ** (1.0 / temperature) for w in centrality_weights]

    scores = []
    for idx, node in enumerate(unvisited_nodes):
        current_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]
        centrality = centrality_weights[idx]

        # Penalty for high future distance relative to current distance
        distance_ratio = future_dist / (current_dist + 1e-6)
        penalty = max(0, distance_ratio - 1.0)

        # Dynamic weighting with temperature
        weight_factor = 0.5 * (1.0 - temperature)
        score = (0.5 * current_dist +
                 0.2 * future_dist +
                 weight_factor * centrality +
                 0.3 * penalty)

        scores.append(score)

    # Temperature-based probabilistic selection
    if scores:
        min_score = min(scores)
        adjusted_scores = [min_score / (s + 1e-6) for s in scores]
        total = sum(adjusted_scores)
        probabilities = [s / total for s in adjusted_scores]
        next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]
    else:
        next_node = unvisited_nodes[0]

    return next_node
