def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    base_weight = 0.5 ** (1 / (remaining_nodes + 1))  # Base exponential decay

    # Calculate normalized probabilities for future distances
    future_distances = [distance_matrix[node][destination_node] for node in unvisited_nodes]
    min_future = min(future_distances)
    max_future = max(future_distances)

    if min_future == max_future:
        normalized_probs = [1.0] * len(unvisited_nodes)
    else:
        normalized_probs = [(max_future - d) / (max_future - min_future) for d in future_distances]

    best_score = float('-inf')
    next_node = None

    for i, node in enumerate(unvisited_nodes):
        current_distance = distance_matrix[current_node][node]
        weighted_score = current_distance + base_weight * normalized_probs[i] * future_distances[i]

        if weighted_score > best_score:
            best_score = weighted_score
            next_node = node
        elif weighted_score == best_score:
            if future_distances[i] < distance_matrix[next_node][destination_node]:
                next_node = node

    return next_node
