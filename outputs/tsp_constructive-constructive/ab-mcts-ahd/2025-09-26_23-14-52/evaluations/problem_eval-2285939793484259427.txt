def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    if remaining_nodes == 0:
        return destination_node

    # Calculate current node's centrality (average distance to unvisited nodes)
    centrality = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes

    # Dynamic future weight based on remaining nodes and centrality
    future_weight = 0.5 ** (1 / (remaining_nodes + 1)) * (1 + centrality / sum(sum(row) for row in distance_matrix) / (len(distance_matrix) ** 2))

    scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        weighted_score = current_distance + future_weight * future_distance
        scores.append((node, weighted_score))

    # Normalize scores and select probabilistically
    total_score = sum(score for _, score in scores)
    if total_score == 0:
        return min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])

    probabilities = [score / total_score for _, score in scores]
    selected_index = np.random.choice(len(scores), p=probabilities)
    return next_node
