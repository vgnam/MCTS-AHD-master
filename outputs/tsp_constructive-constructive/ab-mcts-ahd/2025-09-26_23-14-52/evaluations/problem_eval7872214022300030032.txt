def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('-inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    weight_factor = 1.0 - (remaining_nodes / (remaining_nodes + 2))  # Modified dynamic weight
    current_distance = distance_matrix[current_node][destination_node]  # Reference distance

    for node in unvisited_nodes:
        immediate_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

        # Novel scoring components
        proximity_pressure = (current_distance - immediate_dist) / (future_dist + 1e-6)
        exploration_term = 1 / (immediate_dist + 1e-6)
        exploitation_term = 1 / (future_dist + 1e-6)

        # Combined score with weighted balance
        score = (weight_factor * proximity_pressure +
                 (1 - weight_factor) * (0.6 * exploration_term + 0.4 * exploitation_term) -
                 0.2 * centrality)

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
