def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    base_weight = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))
    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))

    # Calculate node centrality and distance entropy
    centralities = []
    entropies = []
    for node in unvisited_nodes:
        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        centrality = sum(distances) / (len(distances) or 1)
        entropy = -sum(d * np.log(d + 1e-10) for d in distances) / (len(distances) or 1)
        centralities.append(centrality)
        entropies.append(entropy)

    # Adaptive weight factors
    centrality_weight = 1.0 - (total_unvisited / (total_unvisited + 1))
    entropy_weight = 0.3 * (total_unvisited / (total_unvisited + 1))

    # Calculate weighted scores with probabilistic selection
    scores = []
    for i, node in enumerate(unvisited_nodes):
        current_dist = distance_matrix[current_node][node]
        future_dist = distance_matrix[node][destination_node]
        centrality = centralities[i]
        entropy = entropies[i]

        weighted_score = (current_dist +
                         base_weight * future_dist +
                         centrality_weight * centrality +
                         entropy_weight * entropy)
        scores.append(weighted_score)

    # Temperature-controlled probabilistic selection
    probabilities = np.exp(-np.array(scores) / temperature)
    probabilities /= probabilities.sum()
    selected_idx = np.random.choice(len(unvisited_nodes), p=probabilities)

    return next_node
