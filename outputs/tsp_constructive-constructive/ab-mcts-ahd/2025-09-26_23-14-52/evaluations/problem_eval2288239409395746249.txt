def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_score = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)

    # Calculate centrality for each unvisited node
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]

        # Dynamic weight adjustment
        weight_current = 0.5 + 0.5 * (1 - centrality[node] / max(centrality.values()) if centrality else 0.5)
        weight_destination = 1.0 - weight_current

        # Path potential metric (estimates future connectivity)
        path_potential = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

        # Novel scoring function combining all factors
        score = (weight_current * current_distance) + \
                (weight_destination * destination_distance * (1 + 0.5 / remaining_nodes)) + \
                (0.3 * path_potential)

        if score < min_score:
            min_score = score
            next_node = node
        elif score == min_score:
            if destination_distance < distance_matrix[next_node][destination_node]:
                next_node = node

    return next_node
