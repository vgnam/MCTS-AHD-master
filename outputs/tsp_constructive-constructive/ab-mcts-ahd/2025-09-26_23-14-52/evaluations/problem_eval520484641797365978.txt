import math
import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = math.exp(-0.5 * total_unvisited)  # Exponential decay of exploration

    candidates = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        weighted_score = (0.3 * current_distance + 0.6 * future_distance) + temperature * random.uniform(0, 1)
        candidates.append((node, weighted_score, current_distance))

    # Select top 3 candidates based on weighted score
    candidates.sort(key=lambda x: -x[1])
    top_candidates = candidates[:min(3, len(candidates))]

    # Probabilistic selection with bias towards shorter immediate paths
    total_weight = sum(math.exp(-x[2] / (1 + 0.1 * (total_unvisited + 1))) for x in top_candidates)
    probabilities = [math.exp(-x[2] / (1 + 0.1 * (total_unvisited + 1))) / total_weight for x in top_candidates]

    selected_idx = random.choices(range(len(top_candidates)), weights=probabilities)[0]
    return next_node
