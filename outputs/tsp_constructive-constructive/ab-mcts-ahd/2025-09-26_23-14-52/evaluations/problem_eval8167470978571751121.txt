import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = math.exp(-0.5 * total_unvisited)  # Decaying temperature

    scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        score = (0.3 * current_distance + 0.6 * future_distance) * (1 + temperature * random.uniform(-0.2, 0.2))
        scores.append((node, score))

    # Normalize scores to probabilities
    min_score = min(score for _, score in scores)
    max_score = max(score for _, score in scores)
    normalized_scores = [(node, (score - min_score) / (max_score - min_score + 1e-10)) for node, score in scores]

    # Probabilistic selection
    nodes, probs = zip(*normalized_scores)
    next_node = random.choices(nodes, weights=probs, k=1)[0]

    # Tie-breaker: prefer shorter immediate distance
    if any(score == probs[nodes.index(next_node)] for _, score in normalized_scores):
        candidates = [node for node, score in normalized_scores if score == probs[nodes.index(next_node)]]
        next_node = min(candidates, key=lambda x: distance_matrix[current_node][x])

    return next_node
