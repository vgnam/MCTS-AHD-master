def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('inf')
    next_node = None
    current_to_dest = distance_matrix[current_node][destination_node]
    total_nodes = len(distance_matrix)

    # Dynamic weight decay based on proximity to destination
    weight_decay = max(0.1, 1.0 - (current_to_dest / (sum(distance_matrix[current_node]) / total_nodes)))

    # Novel centrality metric: harmonic mean of immediate and long-term connectivity
    def compute_centrality(node):
        immediate_avg = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0
        long_term_avg = sum(distance_matrix[node]) / total_nodes
        return 1 / (0.5 * (1/immediate_avg + 1/long_term_avg))  # Harmonic mean

    candidates = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        weighted_score = current_distance + weight_decay * future_distance
        centrality = compute_centrality(node)
        candidates.append((node, weighted_score, centrality))

    # Stochastic selection: prefer lower scores but allow some randomness
    if candidates:
        scores = [score for (_, score, _) in candidates]
        min_score = min(scores)
        normalized_scores = [max(0.1, 1.0 - (score - min_score) / (max(scores) - min_score + 1e-6)) for score in scores]

        # Combine weighted score and centrality, with randomness
        combined_scores = [normalized_scores[i] * 0.7 + (centrality / (max(c[2] for c in candidates) + 1e-6)) * 0.3 for i, (_, _, centrality) in enumerate(candidates)]
        next_node = random.choices([c[0] for c in candidates], weights=combined_scores, k=1)[0]

    return next_node
