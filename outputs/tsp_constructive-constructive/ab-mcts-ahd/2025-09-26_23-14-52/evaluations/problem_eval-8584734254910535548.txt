def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / total_unvisited
    weight_factor = 1.0 - (avg_distance / (avg_distance + max(distance_matrix[current_node][node] for node in unvisited_nodes))) ** 1.5

    node_scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        score = (current_distance + weight_factor * future_distance) / (1 + current_distance * future_distance)
        node_scores.append((node, score))

    node_scores.sort(key=lambda x: (-x[1], distance_matrix[current_node][x[0]]))

    if len(node_scores) > 1 and total_unvisited > 2:
        top_nodes = [node for node, _ in node_scores[:3]]
        probabilities = [1.0 / (i + 1) for i in range(len(top_nodes))]
        probabilities = [p / sum(probabilities) for p in probabilities]
        selected = random.choices(top_nodes, weights=probabilities, k=1)[0]
        return selected
    else:
        return next_node
