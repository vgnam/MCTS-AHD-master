import math
import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = 1 / (1 + math.exp(-0.3 * (total_unvisited - 7)))

    novelty_scores = []
    centrality_scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        degree_centrality = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < float('inf')) / total_unvisited
        path_centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited

        novelty = math.log(1 + (current_distance + future_distance) / (2 * np.mean(distance_matrix)))
        centrality = 0.7 * degree_centrality + 0.3 * path_centrality

        novelty_scores.append(novelty)
        centrality_scores.append(centrality)

    novelty_scores = np.array(novelty_scores)
    centrality_scores = np.array(centrality_scores)

    combined_scores = temperature * novelty_scores + (1 - temperature) * centrality_scores

    if np.all(combined_scores == combined_scores[0]):
        selected_indices = [i for i, x in enumerate(unvisited_nodes) if x == unvisited_nodes[0]]
    else:
        selected_indices = np.where(combined_scores == np.max(combined_scores))[0]

    if len(selected_indices) > 1:
        selection_weights = np.exp(centrality_scores[selected_indices] + 0.5 * novelty_scores[selected_indices])
        selection_weights = selection_weights / np.sum(selection_weights)
        next_node = unvisited_nodes[random.choices(selected_indices, weights=selection_weights, k=1)[0]]
    else:
        next_node = unvisited_nodes[selected_indices[0]]

    return next_node
