import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    remaining_path_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) if unvisited_nodes else 0

    # Dynamic weighting based on remaining path and unvisited nodes
    immediate_weight = max(0.4, 0.8 - 0.05 * total_unvisited)
    future_weight = min(0.5, 0.3 + 0.03 * total_unvisited)
    novelty_weight = 1.0 - immediate_weight - future_weight

    # Exploration factor with adaptive decay
    exploration_factor = 0.3 * math.exp(-total_unvisited / 5) * (1 + 0.1 * (remaining_path_length / (len(unvisited_nodes) + 1)))

    best_score = float('inf')
    next_node = None
    visit_counts = {node: random.uniform(0.5, 1.5) for node in unvisited_nodes}  # Initial random visit counts

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Reinforcement learning-inspired novelty bonus
        novelty_bonus = 1.0 / (1.0 + math.log(1 + visit_counts.get(node, 0)))
        weighted_score = (immediate_weight * current_distance +
                         future_weight * future_distance +
                         novelty_weight * novelty_bonus +
                         exploration_factor * random.uniform(0, 1))

        if weighted_score < best_score:
            best_score = weighted_score
            next_node = node
        elif weighted_score == best_score:
            # Probabilistic tie-breaker based on future potential
            future_potential = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)
            if random.random() < 0.5 or future_potential < sum(distance_matrix[next_node][n] for n in unvisited_nodes if n != next_node):
                next_node = node

    # Update visit counts (simulated reinforcement learning)
    if next_node in visit_counts:
        visit_counts[next_node] += 1

    return next_node
