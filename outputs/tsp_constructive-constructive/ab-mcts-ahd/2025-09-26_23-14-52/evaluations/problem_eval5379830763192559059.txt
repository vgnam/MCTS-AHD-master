def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    future_weight = min(0.9, 0.5 + 0.4 * (1 - remaining_nodes / len(distance_matrix)))
    current_weight = 1 - future_weight

    best_score = float('inf')
    next_node = None

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        distances_to_node = [distance_matrix[n][node] for n in unvisited_nodes if n != node]
        if distances_to_node:
            mean_distance = sum(distances_to_node) / len(distances_to_node)
            std_dev = (sum((d - mean_distance) ** 2 for d in distances_to_node) / len(distances_to_node)) ** 0.5
            penalty = 0.1 * (current_distance - mean_distance) / (std_dev + 1e-6) if std_dev > 0 else 0
        else:
            penalty = 0

        weighted_score = current_weight * current_distance + future_weight * future_distance + penalty

        if weighted_score < best_score:
            best_score = weighted_score
            next_node = node
        elif weighted_score == best_score:
            if current_distance < distance_matrix[current_node][next_node]:
                next_node = node

    return next_node
