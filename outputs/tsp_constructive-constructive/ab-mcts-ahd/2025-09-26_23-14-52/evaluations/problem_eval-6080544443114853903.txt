import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, history=None, decay_factor=0.9):
    if not unvisited_nodes:
        return destination_node

    if history is None:
        history = []

    best_score = float('inf')
    next_node = None
    total_unvisited = len(unvisited_nodes)
    exploration_factor = 1.0 - (0.8 * (total_unvisited / (total_unvisited + 1)) ** 2)

    # Dynamic decay of exploration factor based on history
    if history:
        exploration_factor *= (decay_factor ** len(history))

    # Calculate momentum term based on recent choices
    momentum = 0.0
    if len(history) >= 2:
        prev_node = history[-1]
        prev_prev_node = history[-2]
        momentum = 0.3 * distance_matrix[prev_prev_node][prev_node] + 0.7 * distance_matrix[prev_node][current_node]

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        weighted_score = 0.6 * current_distance + 0.2 * future_distance + 0.1 * momentum + exploration_factor * random.uniform(0, 1)

        if weighted_score < best_score:
            best_score = weighted_score
            next_node = node
        elif weighted_score == best_score:
            if future_distance < distance_matrix[next_node][destination_node]:
                next_node = node

    return next_node
