import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    max_distance = max(max(row) for row in distance_matrix)
    temperature = 0.5 * (1.0 - (total_unvisited / (total_unvisited + 1)))
    scores = []

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited
        normalized_centrality = centrality / max_distance
        exploration_weight = math.exp(-current_distance / (temperature * max_distance))
        exploitation_weight = math.exp(-future_distance / (temperature * max_distance))
        score = (exploration_weight * current_distance) + (exploitation_weight * future_distance) + (1 - temperature) * normalized_centrality
        scores.append((node, score))

    if not scores:
        return random.choice(unvisited_nodes)

    scores.sort(key=lambda x: x[1])
    top_candidates = [node for node, score in scores[:3]]
    return next_node
