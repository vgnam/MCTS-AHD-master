import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    proximity_to_destination = 1 - (total_unvisited / len(distance_matrix))

    # Dynamic weighting based on proximity to destination
    immediate_weight = 0.7 + 0.2 * (1 - proximity_to_destination)
    future_weight = 0.2 + 0.2 * proximity_to_destination

    # Temperature for probabilistic selection
    temperature = 1.0 / (1 + math.exp(-10 * (proximity_to_destination - 0.5)))

    scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        weighted_score = immediate_weight * current_distance + future_weight * future_distance
        scores.append((node, weighted_score))

    # Probabilistic selection with temperature
    if temperature > 0:
        # Softmax-like selection
        exp_scores = [math.exp(-score / temperature) for (_, score) in scores]
        sum_exp = sum(exp_scores)
        probabilities = [exp_score / sum_exp for exp_score in exp_scores]
        next_node = random.choices([node for (node, _) in scores], weights=probabilities, k=1)[0]
    else:
        # Deterministic selection if temperature is very low
        next_node = min(scores, key=lambda x: x[1])[0]

    return next_node
