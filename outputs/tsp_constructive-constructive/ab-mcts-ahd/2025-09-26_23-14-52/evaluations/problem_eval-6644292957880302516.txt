import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))
    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))

    scores = []
    centralities = []

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]

        # Dynamic centrality: weighted by current distance and future alignment
        proximity_factor = current_distance / (sum(distance_matrix[current_node]) + 1e-6)
        future_vector = np.array([distance_matrix[node][n] for n in unvisited_nodes])
        current_vector = np.array([distance_matrix[current_node][n] for n in unvisited_nodes])
        alignment_factor = np.dot(future_vector, current_vector) / (np.linalg.norm(future_vector) * np.linalg.norm(current_vector) + 1e-6)

        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited
        adjusted_centrality = centrality * (1 - proximity_factor) * alignment_factor

        weighted_score = current_distance + weight_factor * future_distance + temperature * adjusted_centrality
        scores.append(weighted_score)
        centralities.append(adjusted_centrality)

    # Probabilistic selection based on Boltzmann distribution
    exp_scores = np.exp(-np.array(scores) / temperature)
    probabilities = exp_scores / np.sum(exp_scores)
    selected_idx = np.random.choice(len(unvisited_nodes), p=probabilities)
    next_node = unvisited_nodes[selected_idx]

    # Tie-breaker using adjusted centrality
    if any(np.isclose(scores, scores[selected_idx])):
        tie_indices = [i for i, s in enumerate(scores) if np.isclose(s, scores[selected_idx])]
        min_centrality = min(centralities[i] for i in tie_indices)
        next_node = unvisited_nodes[tie_indices[centralities[tie_indices].index(min_centrality)]]

    return next_node
