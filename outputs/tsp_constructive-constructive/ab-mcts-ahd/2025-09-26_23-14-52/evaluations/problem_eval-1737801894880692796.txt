def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 2)))
    candidates = []

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited
        degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < float('inf'))

        # Novel utility function with probabilistic selection
        utility = (1 - temperature) * (-current_distance) + temperature * (centrality + 0.5 * degree)
        utility += 0.2 * (future_distance - current_distance)  # Bias toward nodes that reduce future distance

        candidates.append((node, utility, current_distance, future_distance))

    # Sort candidates by utility in descending order
    candidates.sort(key=lambda x: x[1], reverse=True)

    # Select top candidates with probability proportional to their rank
    top_candidates = candidates[:min(3, len(candidates))]
    selected = None

    if top_candidates:
        total_utility = sum(util for _, util, _, _ in top_candidates)
        rand_val = random.random() * total_utility
        cumulative = 0

        for node, util, curr_dist, fut_dist in top_candidates:
            cumulative += util
            if rand_val <= cumulative:
                selected = node
                break

    # Fallback to greedy selection if probabilistic selection fails
    if selected is None:
        selected = max(top_candidates, key=lambda x: x[1])[0]

    return next_node
