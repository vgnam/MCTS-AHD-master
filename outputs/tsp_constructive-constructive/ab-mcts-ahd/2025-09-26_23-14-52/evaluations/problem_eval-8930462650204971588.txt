def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    centrality_weights = []
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]

        # Calculate node centrality as inverse of average distance to all nodes
        avg_distance = sum(distance_matrix[node]) / len(distance_matrix[node])
        centrality = 1.0 / avg_distance if avg_distance > 0 else 1.0

        # Dynamic weight adjustment combining distance and centrality
        weight_current = (1.0 - (remaining_nodes / (remaining_nodes + 1))) * centrality
        weight_destination = 1.0 - weight_current

        score = (weight_current * current_distance) + (weight_destination * destination_distance)
        scores.append(score)
        centrality_weights.append(centrality)

    # Normalize scores and apply probabilistic selection
    min_score = min(scores)
    max_score = max(scores)
    normalized_scores = [(max_score - s) / (max_score - min_score) if max_score != min_score else 1.0 for s in scores]

    # Combine with centrality weights
    combined_scores = [normalized_scores[i] * centrality_weights[i] for i in range(len(unvisited_nodes))]

    # Select node with highest combined score
    next_node_index = combined_scores.index(max(combined_scores))
    return next_node
