importance metric that considers both proximity and centrality, and a probabilistic selection mechanism to balance exploration and exploitation.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    best_score = float('inf')
    next_node = None
    node_importance = {}

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        ratio = current_distance / (future_distance + 1e-10)

        if remaining_nodes > 5:
            weight = 0.6 * (1 + ratio)
        elif remaining_nodes > 2:
            weight = 0.4 * (1 + ratio)
        else:
            weight = 0.2 * (1 + ratio)

        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / (len(unvisited_nodes) + 1e-10)
        importance = (1 - ratio) * centrality
        node_importance[node] = importance

        score = current_distance + weight * future_distance - 0.1 * importance

        if score < best_score:
            best_score = score
            next_node = node
        elif score == best_score:
            if node_importance[node] > node_importance[next_node]:
                next_node = node

    if remaining_nodes > 3 and len(unvisited_nodes) > 1:
        candidates = [node for node in unvisited_nodes if node_importance[node] > 0.5 * max(node_importance.values())]
        if candidates:
            next_node = candidates[0]

    return next_node
