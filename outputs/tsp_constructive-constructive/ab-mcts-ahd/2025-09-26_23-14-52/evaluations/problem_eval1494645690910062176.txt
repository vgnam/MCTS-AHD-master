import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    temperature = 1.0 - (total_unvisited / (total_unvisited + 1))  # Decreases as more nodes are visited
    exploration_factor = 0.3 * temperature

    # Calculate centrality for each node (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)
        centrality[node] = avg_distance

    # Normalize centrality
    max_centrality = max(centrality.values()) if centrality else 1.0
    min_centrality = min(centrality.values()) if centrality else 0.0
    normalized_centrality = {node: (val - min_centrality) / (max_centrality - min_centrality + 1e-9)
                           for node, val in centrality.items()}

    scores = []
    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        future_distance = distance_matrix[node][destination_node]
        centrality_score = normalized_centrality[node]

        # Weighted score: prioritize central nodes early, balance with distances
        weighted_score = (0.4 * current_distance + 0.6 * future_distance) * (1.0 - 0.5 * centrality_score)
        weighted_score += exploration_factor * random.uniform(0, 1)

        scores.append((node, weighted_score))

    # Probabilistic selection based on scores (lower is better)
    if scores:
        nodes, score_values = zip(*scores)
        max_score = max(score_values)
        min_score = min(score_values)
        normalized_scores = [(max_score - score + 1e-9) / (max_score - min_score + 1e-9) for score in score_values]

        # Apply softmax with temperature
        exp_scores = [math.exp(score / (temperature + 1e-9)) for score in normalized_scores]
        sum_exp = sum(exp_scores)
        probabilities = [exp / sum_exp for exp in exp_scores]

        next_node = random.choices(nodes, weights=probabilities, k=1)[0]
        return next_node
    else:
        return next_node
