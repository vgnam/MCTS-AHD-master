[
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting a weight factor that prioritizes immediate distance (current_distance) early in the process and future potential (future_distance + centrality) later, while using temperature and centrality to refine node selection. It normalizes scores to avoid bias and ensures better tour construction by considering both proximity and node centrality, with higher priority given to minimizing the weighted combination of these factors. The algorithm also handles ties by preferring nodes with lower centrality.",
          "thought": "The new algorithm combines the distance normalization from No.1 with the adaptive temperature and centrality balancing from No.2, using a dynamic weight factor that prioritizes local optimization early and global optimization later, while accounting for node centrality and normalized scores to ensure better tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.8 * (total_unvisited / (total_unvisited + 1))\n    temperature = max(0.1, (1.0 - (total_unvisited / (total_unvisited + 1))) * 0.5)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        weighted_score = (weight_factor * current_distance + (1 - weight_factor) * (future_distance + 0.5 * centrality)) / (current_distance + future_distance + centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.51452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes future distances (weighted by dynamic weights: 0.3 for >5 nodes, 0.5 for >2, and 0.8 for \u22642) while penalizing nodes with very low current distances, balancing these with a tiebreaker favoring longer current distances. The weighted score combines future distance, current distance, and a penalty term to select the next node, ensuring a trade-off between immediate and long-term efficiency.",
          "thought": "The new algorithm prioritizes future distance over immediate distance with dynamically adjusted weights (0.3 for >5 nodes, 0.5 for >2, 0.8 for \u22642), while penalizing nodes with disproportionately low current distances, selecting the next node by balancing these weighted scores and breaking ties in favor of nodes with longer current distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.3\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.8\n\n        penalty = 0.2 * (current_distance / (future_distance + 1e-10)) ** 2\n        weighted_score = weight * future_distance - current_distance - penalty\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance > distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.61162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with balanced current and future distances, adjusting weights dynamically (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and penalizing nodes with disproportionately high future distances. It scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, favoring shorter-term gains while avoiding long-term detours. The penalty term reduces the score for nodes where future distances are much larger than current distances.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the ratio-based scoring from No.1, prioritizing nodes that balance immediate distance with future distance while penalizing nodes with disproportionately high future distances. It adjusts weights (0.8 for >5 nodes, 0.5 for >2, 0.3 for \u22642) and scores nodes using a weighted combination of current distance and a ratio of current-to-future distance, ensuring efficient path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.8\n        elif remaining_nodes > 2:\n            weight = 0.5\n        else:\n            weight = 0.3\n\n        ratio = current_distance / (future_distance + 1e-10)\n        penalty = 0.2 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * ratio - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.6163,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing immediate distances over future distances, with higher weights given to future distances early in the process (decreasing as remaining nodes shrink). It penalizes nodes with disproportionately high future distances more aggressively, using a weighted scoring mechanism that balances current and future costs. Early nodes favor closer options, while later stages become more flexible, ensuring a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm introduces a dynamic weight adjustment based on the ratio of immediate to future distances, penalizes nodes with high future distances relative to immediate distances more aggressively, and uses a novel scoring mechanism that combines these factors with an adaptive weight that decreases as the number of remaining nodes decreases, favoring closer nodes early while maintaining flexibility for future steps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 5:\n            weight = 0.6 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        elif remaining_nodes > 2:\n            weight = 0.4 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n        else:\n            weight = 0.2 * (1 - min(current_distance / (future_distance + 1e-10), 1))\n\n        penalty = 0.3 * (future_distance / (current_distance + 1e-10)) ** 2\n        weighted_score = current_distance + weight * future_distance - penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.62045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate and future distances with dynamic weighting, prioritizing nodes based on a weighted score that balances current-to-future distance ratios, weighted current distances, and exploration-driven randomness. As unvisited nodes decrease, the weight factor adjusts to favor future distances more, while the exploration factor ensures diversity in selections. The best node is chosen by minimizing the weighted score, with tie-breakers favoring nodes closer to the destination.",
          "thought": "The new algorithm combines the dynamic balancing of immediate and future distances from No.1 with the weighted scoring and exploration factor from No.2, using a weighted score that adjusts priorities based on remaining nodes and incorporates randomness to balance short-term and long-term objectives while ensuring exploration through a weighted ratio of current-to-future distance and a dynamic weight factor that increases as fewer nodes remain unvisited.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = min(0.9, (total_unvisited / len(distance_matrix)))\n    exploration_factor = 0.3 * (1.0 - (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        weighted_score = ratio + weight_factor * current_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.63283,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distance minimization by prioritizing nodes with a weighted score combining the ratio of current-to-future distance and a current-distance component, where the weight factor increases as fewer nodes remain unvisited. It uses a tie-breaker favoring nodes closer to the current node when scores are equal. The design ensures a smooth transition from early-stage distance minimization to later-stage destination-focused routing.",
          "thought": "The new algorithm prioritizes immediate distance minimization early on but gradually shifts focus to future distance minimization, using a dynamic weight that increases with the number of unvisited nodes, ensuring a smooth transition toward the destination with a tie-breaker favoring nodes closer to the current node when scores are equal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = min(0.9, (total_unvisited / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n        weighted_score = ratio + weight_factor * current_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.65047,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic balancing of current and future distances with centrality, using temperature scaling and exploration factors to prioritize closer-to-destination nodes early, while balancing centrality and exploration as the problem progresses. It weights future-distance ratios heavily early, then shifts to centrality and exploration, with temperature and exploration factor adapting to remaining unvisited nodes. The code balances exploitation (current/future distances) and exploration (centrality/exploration factor) through weighted scoring, dynamically adjusting priorities based on remaining nodes.",
          "thought": "The new algorithm combines the dynamic balancing of No.1 (current distance, future distance ratio, and centrality) with the aggressive exploitation and adaptive exploration of No.2, while using temperature scaling and exponential exploration factor to refine node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    exploration_factor = 0.1 * (1.0 - (total_unvisited / (total_unvisited + 1))) ** 2\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = ratio + temperature * (0.6 * current_distance + 0.3 * ratio + 0.1 * centrality)\n        else:\n            weighted_score = ratio + temperature * (0.5 * ratio + 0.3 * centrality + 0.2 * exploration_factor)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.66368,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest ratio of the current distance (from the current node) to the destination distance (from the node to the destination), breaking ties by choosing the node closer to the destination. This balances proximity to the current node and directness to the destination, favoring nodes that reduce the ratio while minimizing detours. The `distance_matrix` provides node distances, and the function iterates over unvisited nodes to compute and compare ratios.",
          "thought": "The new algorithm prioritizes the next node by selecting the unvisited node with the smallest ratio of the current distance to the destination distance, breaking ties by choosing the node closer to the destination, aiming to balance proximity to the current node and the destination more directly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        ratio = current_distance / destination_distance if destination_distance != 0 else float('inf')\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n        elif ratio == min_ratio:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing the ratio of current to future distances, current distance, and centrality, with temperature scaling the influence of these factors. Early stages prioritize minimizing the ratio and current distance (0.7:0.3), while later stages balance the ratio and centrality (0.6:0.4). Centrality is used as a tiebreaker, ensuring adaptability and efficiency in path construction.",
          "thought": "The new algorithm combines dynamic temperature adjustment with a ratio-based scoring system that prioritizes minimizing the ratio of current distance to future distance, while also considering centrality as a tiebreaker. Early stages favor minimizing the ratio and current distance (0.7:0.3 weighting), while later stages balance the ratio and centrality (0.6:0.4 weighting). Temperature scales the influence of these weights, ensuring adaptability.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    temperature = max(0.1, 1.0 - (total_unvisited / (total_unvisited + 1)))\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited\n        ratio = current_distance / future_distance if future_distance != 0 else float('inf')\n\n        if total_unvisited > len(unvisited_nodes) * 0.5:\n            weighted_score = ratio + temperature * (0.7 * current_distance + 0.3 * ratio)\n        else:\n            weighted_score = ratio + temperature * (0.6 * ratio + 0.4 * centrality)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if centrality < sum(distance_matrix[next_node][n] for n in unvisited_nodes) / total_unvisited:\n                next_node = node\n\n    return next_node",
          "objective": 6.66711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection with dynamic weight adaptation, prioritizing nodes that balance immediate and future distances while normalizing for fairness. It uses a weighted ratio score where the weight factor decreases as more nodes are visited, giving higher priority to immediate distances early on and balancing both later. Ties are resolved by minimizing the sum of current and future distances to prioritize global optimization. The `weight_factor` dynamically adjusts the balance between current and future distances, while the `normalized_score` ensures fair comparison across nodes.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the dynamic weight adaptation from No.2, using a weighted ratio score that balances immediate and future distances while normalizing for fairness, and resolving ties by minimizing both current and future distances to prioritize global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 0.5 * (1 - (total_unvisited / (total_unvisited + 1)) ** 2)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_ratio = (current_distance / (1 + future_distance)) + weight_factor * (future_distance / (1 + current_distance))\n        normalized_score = weighted_ratio / (1 + future_distance)\n\n        if normalized_score < best_score:\n            best_score = normalized_score\n            next_node = node\n        elif normalized_score == best_score:\n            if current_distance + future_distance < distance_matrix[current_node][next_node] + distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.67909,
          "other_inf": null
     }
]