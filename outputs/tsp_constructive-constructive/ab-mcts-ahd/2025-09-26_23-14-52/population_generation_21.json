[
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and estimated future distance to the destination, using a dynamic weight factor that prioritizes immediate steps when fewer nodes remain. It resolves ties by choosing the node closer to the destination, ensuring both short-term and long-term optimization while efficiently handling remaining nodes.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts the balance between minimizing the current step's distance and the remaining path's estimated distance, using a heuristic that balances immediate and long-term path optimization while still resolving ties by proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * destination_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a dynamic weight that prioritizes local optimization early and global optimization as unvisited nodes decrease. The weight factor (`weight_factor`) adjusts based on remaining unvisited nodes, ensuring a smoother transition between local and global considerations. The `weighted_score` combines current distance and future distance (scaled by the weight factor) to guide node selection, with ties resolved by choosing the node closer to the destination.",
          "thought": "The algorithm selects the next node by prioritizing the shortest immediate distance to the current node while also considering the potential future distance to the destination, using a dynamic weight that decreases as the number of unvisited nodes decreases, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a weighted combination where immediate distance has higher priority (1.0 weight) than future distance (0.5 weight). If scores are equal, it prioritizes the node with a shorter future distance. The code efficiently explores unvisited nodes while handling edge cases like an empty set of unvisited nodes.",
          "thought": "The algorithm prioritizes selecting the next node by considering both the immediate distance to the current node and the potential impact on future path length, using a weighted combination of these factors to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.5 * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing the one that minimizes the product of its distance from the current node and its distance to the destination, while breaking ties by favoring the closer node to the current position. This balances efficiency (minimizing total distance) and exploration (avoiding detours). The function uses a distance matrix for node-to-node distances and iterates through unvisited nodes to find the optimal choice.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the product of distances to the current node and the destination node, breaking ties by choosing the node closer to the current node to balance exploration and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_product = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        product = current_distance * destination_distance\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n        elif product == min_product:\n            if distance_matrix[current_node][node] < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing immediate distance (weighted 1.2) and future distance (weighted 0.3), while also considering the average distance to unvisited nodes (weighted 0.1) to balance exploration and exploitation. It iterates through unvisited nodes, computes a weighted score, and chooses the node with the lowest score, breaking ties by preferring nodes with shorter future distances to the destination. The design balances greediness (short-term) and foresight (long-term) with a slight bias toward immediate distances.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight (1.2) and future distance with a lower weight (0.3), while also considering the average distance to all unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        weighted_score = 1.2 * current_distance + 0.3 * future_distance + 0.1 * avg_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.50567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) and future distance (25%) with minimal randomness (15%), adjusting exploration dynamically as unvisited nodes decrease (1.0 - 0.7*(remaining nodes ratio)). It selects the next node by minimizing a weighted score, favoring shorter current paths and closer future returns, while slightly randomizing choices to avoid local optima.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, future distance with a moderate weight, and randomness with a lower weight, adjusting the exploration factor more aggressively as unvisited nodes decrease to balance exploration and exploitation more dynamically.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.7 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = 0.6 * current_distance + 0.25 * future_distance + 0.15 * exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.58271,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the weight between immediate and future distances to balance local and global optimization. It prioritizes nodes that minimize a weighted sum of current distance and future potential, with the future weight increasing as more nodes remain unvisited. The dynamic adjustment (`weight_future`) ensures the algorithm shifts from local (early stages) to global (later stages) optimization, while ties are resolved by preferring nodes closer to the destination.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for future distance increases as more nodes are left to visit, promoting a more global optimization approach while still prioritizing immediate distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_future = min(1.0, 0.5 + (remaining_nodes / (remaining_nodes + 10)))  # Adjusts weight dynamically\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_future * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.9577,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node with the smallest combined distance to the current node and the destination node, breaking ties by choosing the node closer to the destination. It uses a distance matrix to compute distances and ensures the destination is returned when no unvisited nodes remain. The key design prioritizes minimizing the total path length while handling ties by favoring nodes closer to the destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination node if there are multiple options with the same distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + destination_distance\n\n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n        elif total_distance == min_distance:\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future distance to the destination, adjusting weights based on remaining nodes (higher weight for future distance when more nodes remain). It prioritizes nodes with lower current and future distances while also considering centrality (average distance to unvisited nodes) to avoid local optima, with centrality having a lower priority (0.3 weight) compared to distance terms. The weighting factor (`weight_factor`) and centrality measure are key design elements.",
          "thought": "The new algorithm extends the weighted approach by incorporating a dynamic weighting factor that adapts based on the remaining unvisited nodes, prioritizing immediate distance when few nodes remain and balancing future distance when more nodes are left, while also considering the node's centrality in the remaining graph to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting factor based on remaining nodes\n        weight_factor = 1.0 if remaining_nodes <= 3 else 0.7\n\n        # Centrality measure: average distance to other unvisited nodes\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n\n        # Combined score with centrality adjustment\n        weighted_score = (current_distance + weight_factor * future_distance) + 0.3 * centrality\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 8.15085,
          "other_inf": null
     }
]