[
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node closest to the destination. It iterates through unvisited nodes, comparing distances to the current node first, then to the destination if distances are equal. The code efficiently handles the selection by updating the next node only when a better candidate is found.",
          "thought": "The new algorithm prioritizes selecting the next node based on the smallest distance to the current node, breaking ties by choosing the node with the smallest distance to the destination, while the original algorithm prioritizes the sum of distances to the current node and destination, breaking ties by the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n        elif current_distance == min_distance:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and estimated future distance to the destination, using a dynamic weight factor that prioritizes immediate steps when fewer nodes remain. It resolves ties by choosing the node closer to the destination, ensuring both short-term and long-term optimization while efficiently handling remaining nodes.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts the balance between minimizing the current step's distance and the remaining path's estimated distance, using a heuristic that balances immediate and long-term path optimization while still resolving ties by proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic weight based on remaining nodes\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = (weight_factor * current_distance) + ((1 - weight_factor) * destination_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if destination_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a dynamic weight that prioritizes local optimization early and global optimization as unvisited nodes decrease. The weight factor (`weight_factor`) adjusts based on remaining unvisited nodes, ensuring a smoother transition between local and global considerations. The `weighted_score` combines current distance and future distance (scaled by the weight factor) to guide node selection, with ties resolved by choosing the node closer to the destination.",
          "thought": "The algorithm selects the next node by prioritizing the shortest immediate distance to the current node while also considering the potential future distance to the destination, using a dynamic weight that decreases as the number of unvisited nodes decreases, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + weight_factor * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, using a weighted combination where immediate distance has higher priority (1.0 weight) than future distance (0.5 weight). If scores are equal, it prioritizes the node with a shorter future distance. The code efficiently explores unvisited nodes while handling edge cases like an empty set of unvisited nodes.",
          "thought": "The algorithm prioritizes selecting the next node by considering both the immediate distance to the current node and the potential impact on future path length, using a weighted combination of these factors to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.5 * future_distance\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing the one that minimizes the product of its distance from the current node and its distance to the destination, while breaking ties by favoring the closer node to the current position. This balances efficiency (minimizing total distance) and exploration (avoiding detours). The function uses a distance matrix for node-to-node distances and iterates through unvisited nodes to find the optimal choice.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the product of distances to the current node and the destination node, breaking ties by choosing the node closer to the current node to balance exploration and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_product = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        product = current_distance * destination_distance\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n        elif product == min_product:\n            if distance_matrix[current_node][node] < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) and future distance (25%) with minimal randomness (15%), adjusting exploration dynamically as unvisited nodes decrease (1.0 - 0.7*(remaining nodes ratio)). It selects the next node by minimizing a weighted score, favoring shorter current paths and closer future returns, while slightly randomizing choices to avoid local optima.",
          "thought": "The new algorithm prioritizes immediate distance with a higher weight, future distance with a moderate weight, and randomness with a lower weight, adjusting the exploration factor more aggressively as unvisited nodes decrease to balance exploration and exploitation more dynamically.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.7 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = 0.6 * current_distance + 0.25 * future_distance + 0.15 * exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.58271,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node with the smallest combined distance to the current node and the destination node, breaking ties by choosing the node closer to the destination. It uses a distance matrix to compute distances and ensures the destination is returned when no unvisited nodes remain. The key design prioritizes minimizing the total path length while handling ties by favoring nodes closer to the destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination node if there are multiple options with the same distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + destination_distance\n\n        if total_distance < min_distance:\n            min_distance = total_distance\n            next_node = node\n        elif total_distance == min_distance:\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the sum of squared distances to both the current node and the destination, while using the straight-line distance to the destination as a tiebreaker. This geometric approach balances proximity to the current position and alignment with the destination path, optimizing the trade-off between immediate and long-term path efficiency. The code iterates through unvisited nodes, computes the squared sum of distances, and updates the selection based on these values.",
          "thought": "The new algorithm modifies the selection criterion to prioritize nodes that minimize the sum of squared distances to the current node and destination node, while also considering the straight-line distance to the destination to break ties, introducing a more geometric approach to path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        squared_sum = current_distance**2 + destination_distance**2\n        straight_line = distance_matrix[node][destination_node]\n\n        if squared_sum < min_score:\n            min_score = squared_sum\n            next_node = node\n        elif squared_sum == min_score:\n            if straight_line < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 9.10777,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing **immediate distance** (weighted higher early) and **future distance** (weighted higher later) while incorporating **dynamic exploration** via a probabilistic element. It adjusts weights based on unvisited nodes, favoring closer nodes early and optimizing for return distance later, with exploration encouraged by randomness. The `exploration_factor` and `current_weight`/`future_weight` dynamically shift priorities, ensuring a mix of greedy and explorative node selection.",
          "thought": "The new algorithm combines the weighted balance of immediate and future distances from No.1 with the dynamic exploration factor and probabilistic element from No.2, adjusting weights based on unvisited nodes to prioritize immediate distance early and future distance later while maintaining exploration.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.5 * (total_unvisited / (total_unvisited + 1)))\n    current_weight = 1.0\n    future_weight = 0.5 + (0.3 * (1.0 - exploration_factor))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_weight * current_distance + future_weight * future_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 10.26443,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, future distance, and a probabilistic factor, with the exploration factor decreasing as the number of unvisited nodes decreases to prioritize exploitation. The weighted score combines current distance (high priority), future distance (medium priority), and randomness (low priority), with a dynamic weight that adjusts based on remaining nodes. The exploration factor ensures exploration early, favoring global optimization as the tour progresses.",
          "thought": "My algorithm selects the next node by combining immediate distance, future distance, and a probabilistic factor to balance exploration and exploitation, using a dynamic weight that increases as the tour progresses to favor global optimization over time.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    exploration_factor = 1.0 - (0.5 * (total_unvisited / (total_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weighted_score = current_distance + 0.3 * future_distance + exploration_factor * random.uniform(0, 1)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n        elif weighted_score == best_score:\n            if future_distance < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 10.31744,
          "other_inf": null
     }
]