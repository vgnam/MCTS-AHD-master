[
     {
          "algorithm": "The algorithm combines proximity and lookahead heuristics to select the next node in the TSP, with a sophisticated proximity-weighted lookahead and dynamic weight adjustment based on the number of remaining nodes. It calculates a total score for each candidate node, balancing the distance to the destination and the shortest lookahead route, and prioritizes nodes that have a high score. Additionally, it checks if the destination node is within a stringent distance threshold and prioritizes it if unvisited, balancing the need for early returns with proximity considerations.",
          "thought": "Common ideas include proximity and lookahead heuristics, dynamic adjustment of weights, and an early return condition based on reasonable distance thresholds. The new algorithm will combine these ideas similarly to No.2 but incorporate a more sophisticated proximity-weighted lookahead and a tighter early return condition based on No.1.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.5 + 0.1 * (len(unvisited_nodes) / 10)  # Adjust weight more dynamically\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) * 0.6 + (lookahead_dist / (distance + 1e-10)) * weight * 0.4\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a stringent distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Strict threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization (prioritizing nearby nodes) with a weighted lookahead mechanism (considering future steps) while dynamically adjusting weights based on remaining unvisited nodes, favoring proximity when many nodes remain and lookahead when few remain. It evaluates each candidate node by balancing direct distance to the destination and potential future steps, dynamically adjusting the weight between these factors. The algorithm also prioritizes returning to the destination if it is close, ensuring efficiency in the final stages.",
          "thought": "The new algorithm combines the proximity prioritization of Algorithm 1 with the weighted lookahead scoring of Algorithm 2, while dynamically adjusting the weights based on the remaining unvisited nodes to ensure efficient path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57028,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (70% weight) with long-term efficiency (30%) by evaluating both the direct distance to the next node and the best possible detour to the destination, while dynamically checking if returning to the destination is feasible. It prioritizes minimizing immediate travel distance while ensuring the path remains efficient for the remaining route. The score calculation (`total_score`) combines these factors to select the optimal next node, with a dynamic check for returning to the destination if it's nearby.",
          "thought": "The new algorithm prioritizes immediate proximity with a higher weight (0.7) while slightly considering long-term efficiency (0.3), balancing immediate distance and potential detours to reduce total path length, and includes a dynamic check for returning to the destination if it's nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.7\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58398,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node in the Traveling Salesman Problem (TSP) by combining immediate proximity and a lookahead strategy, adjusted dynamically based on the number of unvisited nodes. It calculates a score for each potential next node, weighing closer nodes more heavily early on and balancing with closer lookahead nodes as fewer nodes remain unvisited. Additionally, it considers returning to the destination node if it is unvisited and within a reasonable distance, ensuring a balanced approach between local and global considerations.",
          "thought": "The new algorithm prioritizes nodes based on a reduced immediate proximity factor and increased lookahead weight, prioritizing closer nodes early and balancing with more distant lookahead as fewer nodes remain unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.8 if len(unvisited_nodes) > 3 else 0.6\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58888,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score for each unvisited node, combining the direct distance to it and a weighted lookahead distance that considers future steps. The weight is dynamically adjusted based on the number of remaining unvisited nodes, balancing immediate proximity and future efficiency. If the destination node is unvisited and within a reasonable distance, it is prioritized.",
          "thought": "Common ideas: Dynamic weight adjustment, lookahead mechanism, and a balance between proximity and future steps.\n\nDesign idea: A modified version of algorithm No.2 that incorporates a lookahead mechanism with a dynamic weight based on the number of remaining unvisited nodes, balancing proximity and future steps to select the next node.\n\nMain steps: For each unvisited node, calculate a score combining the distance to the node and a weighted lookahead distance, dynamically adjusting the weight based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.6 if len(unvisited_nodes) > 4 else 0.4\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60098,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead (50% weight), adjusting the lookahead distance using centrality-based weights and an exponential decay factor based on average remaining distance to the destination. It prioritizes immediate proximity while balancing long-term optimization and exploration through probabilistic adjustments. The code evaluates each node by computing a weighted sum of the current distance and adjusted lookahead distance, with higher weights given to nodes that are closer and more centrally located in the remaining graph.",
          "thought": "The new algorithm combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead mechanism (50% weight), where the lookahead distance is adjusted by a centrality-based weight and an exponential decay factor based on the average remaining distance to the destination, while incorporating probabilistic exploration to balance immediate proximity, long-term optimization, and exploration of better paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 2:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            # 3-step lookahead\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + min(\n                distance_matrix[n][k] + distance_matrix[k][destination_node] for k in remaining_nodes if k != n))\n            lookahead_dist = distance_matrix[node][best_lookahead] + min(\n                distance_matrix[best_lookahead][k] + distance_matrix[k][destination_node] for k in remaining_nodes if k != best_lookahead)\n            # Centrality-based adjustment\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            efficiency_factor = (avg_remaining_distance / centrality) ** 0.5\n            adjusted_lookahead_dist = lookahead_dist * efficiency_factor * (avg_remaining_distance / lookahead_dist) ** 2\n            # Probabilistic component\n            random_factor = 1.0 + 0.2 * (1 - (current_dist / (current_dist + lookahead_dist)))\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n            random_factor = 1.0\n        return (current_dist + 0.5 * adjusted_lookahead_dist) * random_factor\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.60554,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (60% weight) and long-term efficiency (40% weight) by scoring each unvisited node based on its direct distance from the current node and the best possible path to the destination from that node. It prioritizes returning to the destination early when fewer than 3 nodes remain, ensuring the solution remains efficient. The scoring mechanism normalizes distances to avoid division by zero and checks for viability when near the end of the tour.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.6) while slightly emphasizing long-term efficiency (weight 0.4) in its scoring mechanism, with a heuristic to check if returning to the destination is viable when fewer than 3 unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        proximity_weight = 0.6\n        efficiency_weight = 0.4\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - efficiency_weight) + (lookahead_dist / (distance + 1e-10)) * efficiency_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if len(unvisited_nodes) < 3 and destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60614,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection (prioritizing nodes with a favorable distance ratio to the destination) with centrality-based weighting (considering how central a node is in the remaining graph) and a 2-step lookahead (evaluating the best subsequent move to the destination). It balances immediate proximity (via the ratio) with long-term efficiency (via centrality and lookahead), favoring nodes that optimize both short-term and future steps while ensuring the destination is prioritized if it offers a sufficiently direct path. The `score` variable integrates these factors, with higher scores indicating better candidates, and the algorithm dynamically adjusts based on the remaining unvisited nodes.",
          "thought": "The new algorithm combines the ratio-based selection of No.2 with the centrality-based weighting and 2-step lookahead of No.1, prioritizing nodes that balance immediate proximity with long-term efficiency while considering centrality in the remaining graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            score = ratio * (centrality / lookahead_dist)\n        else:\n            score = ratio\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60673,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and lookahead heuristics with a weighted balance (0.4 for proximity, 0.6 for lookahead) to select the next node, while also incorporating an early return condition to the destination if the direct distance is within twice the minimum distance. The proximity term prioritizes closer nodes, while the lookahead term optimizes future steps by evaluating the best remaining path from each candidate node to the destination. The code structure iteratively evaluates all unvisited nodes, computes weighted scores, and selects the node with the highest score, with a special check for the destination node.",
          "thought": "The new algorithm combines the weighted balance of proximity and lookahead from No.2 with the early return condition from No.1, using a 0.6 weight for lookahead and 0.4 for proximity, and returning to the destination if the direct distance is within twice the minimum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.6\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61075,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate proximity (distance from current node) and long-term efficiency (lookahead to the destination), using a weighted combination of these factors. It emphasizes immediate proximity (with a weight of 0.5) and lookahead distance (with a weight of 0.5) in its scoring mechanism, while also checking if returning to the destination is a viable option. The code iterates through unvisited nodes, computes a score for each, and selects the node with the highest score, ensuring the path remains efficient.",
          "thought": "The common ideas in No.1 algorithm that may give good performances are: ratio-based selection, nearest-neighbor lookahead, and weighted Euclidean factor. The new algorithm will prioritize the closest unvisited node while incorporating a lookahead mechanism to balance immediate and long-term path efficiency, using a weighted combination of proximity and future distance considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.5\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.6186,
          "other_inf": null
     }
]