[
     {
          "algorithm": "The algorithm combines a balanced heuristic (weighting current distance and lookahead) with a scoring mechanism that prioritizes nodes with favorable remaining distance while penalizing high future costs. It dynamically adjusts weights based on node proximity to the destination and the number of remaining nodes, favoring shorter current paths and minimizing future penalties. The algorithm prioritizes minimizing `balanced_dist` (a weighted combination of current and lookahead distances) while reducing `future_penalty` (average future costs), with a slight bias toward direct paths when the destination is still unvisited.",
          "thought": "The new algorithm combines the balanced heuristic from No.1 (weighting current distance and lookahead) with the scoring mechanism from No.2 (prioritizing nodes with favorable remaining distance while penalizing high future costs), dynamically adjusting weights based on node proximity to the destination and the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = remaining_dist\n\n        euclidean_weight = (remaining_dist / sum(distance_matrix[node])) * 0.7\n        balanced_dist = (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n        future_cost = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_cost == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_cost / len(unvisited_nodes)\n\n        score = balanced_dist - 0.3 * future_penalty\n\n        if score < best_score or next_node is None:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_dist = distance_matrix[current_node][destination_node]\n        if direct_dist <= best_score * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.69157,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, the ratio of remaining distance to current distance, and future distance penalties, with a dynamic threshold prioritizing the destination when it's close. Nodes are scored based on these factors (ratio weighted highest, followed by current distance and future penalty), and the destination is prioritized if its direct distance meets a dynamic threshold. The algorithm dynamically adjusts the threshold based on the number of remaining nodes, favoring the destination when few nodes remain.",
          "thought": "This new algorithm combines the proximity balancing from No.1, the ratio-based selection from No.2, and the future distance penalty from No.3, while introducing a dynamic threshold that adapts to the remaining nodes' density and the destination's proximity. It calculates a weighted score for each node, prioritizing nodes that are close to the current node, have a favorable remaining distance ratio, and have low average future distances, with a dynamic threshold for destination prioritization based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        future_distance = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_distance == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_distance / len(unvisited_nodes)\n\n        score = ratio - 0.3 * future_penalty - 0.1 * current_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        threshold = 0.9 - 0.05 * (total_unvisited / (total_unvisited + 1))\n        if direct_distance <= best_score * threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.7944,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (100% weight) with a dynamic 2-step lookahead mechanism (50% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination, balancing immediate proximity and long-term optimization. The `current_dist` (distance from current node) is prioritized over the adjusted `lookahead_dist` (weighted by 50%), with the latter scaled by `(avg_remaining_distance / lookahead_dist)^2` to dynamically adjust its influence.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic 2-step lookahead mechanism, prioritizing immediate distance (100% weight) and a weighted 2-step lookahead distance (50% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination to balance short-term proximity and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            adjusted_lookahead_dist = lookahead_dist * (avg_remaining_distance / lookahead_dist) ** 2\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n        return current_dist + 0.5 * adjusted_lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.82372,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by evaluating a weighted scoring system that balances proximity to the current node and potential reductions in future travel costs, dynamically adjusting the threshold based on the remaining distance to the destination and the number of unvisited nodes. Proximity and bonus scores are prioritized, while the system adaptively modifies the threshold to make more informed decisions. If no suitable node is found, it defaults to the closest unvisited node or the destination if it is closer than any other node.",
          "thought": "The new algorithm introduces a weighted scoring system that balances proximity, remaining distance to the destination, and a potential bonus for nodes that reduce future travel costs, using a more adaptive dynamic threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    num_unvisited = len(unvisited_nodes)\n    remaining_distance_to_destination = distance_matrix[current_node][destination_node]\n    base_threshold = 1.5 - (remaining_distance_to_destination / (num_unvisited * 100 + 1))\n\n    for node in unvisited_nodes:\n        proximity_score = 1 / distance_matrix[current_node][node]\n        bonus_score = sum(distance_matrix[node][dest] - distance_matrix[current_node][dest] for dest in unvisited_nodes if dest != node) / num_unvisited\n        threshold = base_threshold * (1 + bonus_score)\n        score = proximity_score * threshold\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] < min(distance_matrix[current_node][node] for node in unvisited_nodes):\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.85433,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a combined score for each unvisited node, prioritizing nodes with a favorable remaining distance to the destination relative to the current distance, while also penalizing nodes that have high average subsequent distances to other unvisited nodes. This encourages balanced exploration and reduced future travel costs. Additionally, it directly chooses the destination node if the remaining distance to it is significantly shorter than the best calculated score.",
          "thought": "The new algorithm prioritizes nodes based on a combined score that includes a weighted ratio of remaining distance to the destination over current distance, enhanced by a penalty for nodes that lead to high subsequent distances, encouraging balanced exploration and reduced future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        \n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n        \n        future_distance = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_distance == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_distance / len(unvisited_nodes)\n        \n        score = ratio - 0.5 * future_penalty\n        \n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.86954,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with the highest ratio of remaining distance to destination (from the candidate node) over the current distance (from the current node), balancing exploration and destination proximity. It defaults to the destination node if its direct distance is \u226490% of the best ratio, ensuring efficiency and flexibility. The heuristic emphasizes maximizing the ratio while occasionally overriding to the destination for optimal path efficiency.",
          "thought": "The new algorithm prioritizes nodes with the highest ratio of remaining distance to the current node's distance, balancing exploration and destination proximity, and uses a more flexible threshold (90%) for destination prioritization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_ratio = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_ratio * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead mechanism (30% weight), where the lookahead distance is exponentially decayed based on the average remaining distance to the destination, dynamically balancing immediate proximity and long-term optimization by scaling the lookahead influence with the ratio of current distance to average remaining distance. The nearest-neighbor component prioritizes immediate proximity, while the lookahead adjusts based on both the distance structure and remaining path length, with the 3-step lookahead weighted lower to prevent excessive computational overhead. The exponential decay and scaling ensure the algorithm adapts to the problem's scale, favoring short-term gains early and long-term optimization later.",
          "thought": "A new algorithm that combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead mechanism (30% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination, and the lookahead influence is further scaled by the ratio of the current distance to the average remaining distance to dynamically balance immediate proximity and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 2:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + min(\n                distance_matrix[n][m] + distance_matrix[m][destination_node] for m in remaining_nodes if m != n))\n            lookahead_dist = distance_matrix[node][best_lookahead] + min(\n                distance_matrix[best_lookahead][m] + distance_matrix[m][destination_node] for m in remaining_nodes if m != best_lookahead)\n            adjusted_lookahead_dist = lookahead_dist * (avg_remaining_distance / lookahead_dist) ** 2 * (current_dist / avg_remaining_distance)\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n        return current_dist + 0.3 * adjusted_lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.94289,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamic two-step lookahead mechanism to balance immediate proximity and long-term optimization. The lookahead distance is adaptively decayed based on the nearest unvisited node's distance, enhancing the heuristic's adaptability to the problem's landscape. The algorithm prioritizes nodes evaluated by a weighted sum of current and adjusted lookahead distances, with higher weight on immediate proximity but also considering future travel efficiency.",
          "thought": "Combine nearest-neighbor selection with a dynamic 2-step lookahead mechanism, where the lookahead distance is adjusted using an adaptive decay factor based on the distance to the nearest unvisited node, balancing immediate proximity and long-term optimization while adapting to the problem's changing landscape.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    nearest_unvisited_distance = min(distance_matrix[current_node][node] for node in unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            adjusted_lookahead_dist = lookahead_dist * (nearest_unvisited_distance / lookahead_dist) ** 2\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n        return current_dist + 0.5 * adjusted_lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.97116,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a weighted distance that balances the current distance to the node and the exponential decay-adjusted remaining distance to the destination. It uses an average shortest path to the destination as a dynamic threshold, prioritizing nodes closer to the destination earlier in the journey. The algorithm also directly considers the destination if it is within a dynamic threshold of the current node, ensuring an early return if possible.",
          "thought": "The new algorithm introduces a dynamic threshold based on the average shortest path to the destination from unvisited nodes and uses an exponential decay factor to prioritize nodes closer to the destination earlier in the journey.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate average shortest path to destination from unvisited nodes\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        # Introduce an exponential decay factor\n        total_distance = current_distance + remaining_distance * (avg_remaining_distance / remaining_distance) ** 2\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is within a dynamic threshold\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        dynamic_threshold = avg_remaining_distance * 0.8\n        if direct_distance <= dynamic_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.98744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a 2-step lookahead mechanism to balance short-term proximity and long-term optimization, prioritizing nodes that minimize immediate distance while also considering their potential impact on reaching the destination efficiently. The decision-making process dynamically weighs the current distance to a node against the total travel distance including a subsequent node chosen by the lookahead, with the weight adjusted based on the node's proximity to the destination. The function `select_next_node` evaluates each unvisited node using this balanced heuristic to determine the optimal next step in the tour.",
          "thought": "The new algorithm combines the nearest-neighbor selection with a 2-step lookahead mechanism, prioritizing immediate distance and the best 2-step path using a dynamic weighting based on the node's proximity to the destination to balance short-term proximity and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5\n        return (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.9984,
          "other_inf": null
     }
]