def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = [n for n in unvisited_nodes if n != node]
        k = min(3, len(remaining_nodes))  # Dynamic k based on remaining nodes

        if k == 0:
            lookahead_dist = distance_matrix[node][destination_node]
        else:
            # Recursive lookahead for k steps
            def best_path(nodes, steps_left):
                if steps_left == 1 or not nodes:
                    return min(nodes, key=lambda x: distance_matrix[x][destination_node], default=0)
                best_node = None
                best_score = float('inf')
                for n in nodes:
                    next_nodes = [x for x in nodes if x != n]
                    next_node = best_path(next_nodes, steps_left - 1)
                    if next_node is not None:
                        score = distance_matrix[n][next_node] + best_path([next_node], steps_left - 1)
                    else:
                        score = distance_matrix[n][destination_node]
                    if score < best_score:
                        best_score = score
                        best_node = n
                return best_node

            best_k_step = best_path(remaining_nodes, k)
            lookahead_dist = distance_matrix[node][best_k_step] + best_path([best_k_step], k - 1)

        # Adaptive weighting based on remaining nodes
        weight = 0.5 if len(unvisited_nodes) > 2 else 0.3
        return current_dist + weight * lookahead_dist

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
