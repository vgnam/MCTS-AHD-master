def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate weights for each unvisited node (inverse of distance)
    weights = {}
    total_weight = 0.0
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if distance == 0:
            weight = float('inf')
        else:
            weight = 1.0 / distance
        weights[node] = weight
        total_weight += weight

    # Calculate average distance to unvisited nodes
    total_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes)
    avg_distance = total_distance / len(unvisited_nodes) if unvisited_nodes else 0

    # Normalize weights and apply dynamic threshold
    candidates = []
    for node in unvisited_nodes:
        normalized_weight = weights[node] / total_weight
        if node == destination_node:
            threshold = avg_distance * 2.0
            if distance_matrix[current_node][node] <= threshold:
                normalized_weight *= 2.0  # Boost destination weight
        candidates.append((node, normalized_weight))

    # Select node based on weighted probability
    if candidates:
        nodes, probs = zip(*candidates)
        next_node = random.choices(nodes, weights=probs, k=1)[0]
    else:
        # Fallback to closest node if no candidates
        next_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])

    return next_node
