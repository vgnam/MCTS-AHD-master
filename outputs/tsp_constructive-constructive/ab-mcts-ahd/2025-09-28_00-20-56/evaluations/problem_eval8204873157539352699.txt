def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        lookahead_depth = min(2, len(unvisited_nodes) - 1)
        if lookahead_depth > 0:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            lookahead_scores = []
            for _ in range(lookahead_depth):
                if not remaining_nodes:
                    break
                next_node = min(remaining_nodes, key=lambda n: distance_matrix[node][n])
                lookahead_scores.append(distance_matrix[node][next_node])
                node, remaining_nodes = next_node, [n for n in remaining_nodes if n != next_node]
            lookahead_dist = sum(lookahead_scores) if lookahead_scores else 0
        else:
            lookahead_dist = distance_matrix[node][destination_node]
        return current_dist + 0.3 * lookahead_dist

    scores = [evaluate_node(node) for node in unvisited_nodes]
    min_score = min(scores)
    normalized_scores = [min_score / (score + 1e-10) for score in scores]
    total_weight = sum(normalized_scores)
    probabilities = [score / total_weight for score in normalized_scores]
    next_node = unvisited_nodes[np.random.choice(len(unvisited_nodes), p=probabilities)]
    return next_node
