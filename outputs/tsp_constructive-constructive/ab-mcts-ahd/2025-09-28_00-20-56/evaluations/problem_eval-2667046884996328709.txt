def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic threshold based on average distance to unvisited nodes
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)
    threshold = avg_distance * 1.2  # Adjustable multiplier

    # Collect candidate nodes within threshold
    candidates = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= threshold]

    if not candidates:
        # Fallback: nearest node if no candidates
        min_distance = min(distance_matrix[current_node][node] for node in unvisited_nodes)
        candidates = [node for node in unvisited_nodes if distance_matrix[current_node][node] == min_distance]

    # Prioritize destination with probability based on distance
    if destination_node in candidates:
        dest_distance = distance_matrix[current_node][destination_node]
        if dest_distance <= threshold * 1.3:  # Higher threshold for destination
            if dest_distance <= min(distance_matrix[current_node][node] for node in candidates if node != destination_node):
                return destination_node
            else:
                # Probabilistic selection
                if random.random() < 0.7:  # Higher chance to pick destination
                    return destination_node

    # Select randomly from candidates
    return next_node
