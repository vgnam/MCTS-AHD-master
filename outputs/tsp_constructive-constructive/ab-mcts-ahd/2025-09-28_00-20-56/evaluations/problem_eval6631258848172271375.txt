def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        # Immediate distance (70% weight)
        current_dist = distance_matrix[current_node][node]

        # Adaptive multi-step lookahead (30% weight)
        lookahead_radius = min(3, len(unvisited_nodes))  # Dynamic radius based on remaining nodes
        if lookahead_radius > 1:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            lookahead_path = [node]
            for _ in range(lookahead_radius - 1):
                if not remaining_nodes:
                    break
                next_step = min(remaining_nodes, key=lambda n: distance_matrix[lookahead_path[-1]][n])
                lookahead_path.append(next_step)
                remaining_nodes.remove(next_step)
            lookahead_dist = sum(distance_matrix[lookahead_path[i]][lookahead_path[i+1]] for i in range(len(lookahead_path)-1))
            lookahead_dist += distance_matrix[lookahead_path[-1]][destination_node]
        else:
            lookahead_dist = distance_matrix[node][destination_node]

        # Local congestion penalty (avoid dense clusters)
        local_density = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * min(distance_matrix[node][n] for n in unvisited_nodes if n != node))
        congestion_penalty = 0.2 * local_density

        # Combine with weights
        return 0.7 * current_dist + 0.3 * lookahead_dist + congestion_penalty

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
