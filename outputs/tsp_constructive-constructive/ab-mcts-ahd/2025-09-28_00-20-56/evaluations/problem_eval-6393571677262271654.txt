def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_score = float('inf')
    next_node = None

    for node in unvisited_nodes:
        direct_dist = distance_matrix[current_node][node]
        destination_dist = distance_matrix[node][destination_node]

        # Dynamic penalty for nodes far from both current and destination
        penalty = max(direct_dist, destination_dist) - min(direct_dist, destination_dist)

        # Logarithmic adjustment for heuristic weight based on remaining nodes
        weight = 0.5 * (1 + (len(unvisited_nodes) / (len(unvisited_nodes) + 10)))
        penalty_weight = 0.3

        score = (direct_dist + destination_dist) * (1 - weight) + penalty * penalty_weight

        if score < min_score:
            min_score = score
            next_node = node

    # Prioritize destination node if it's unvisited and within a close range
    if destination_node in unvisited_nodes:
        if distance_matrix[current_node][destination_node] <= min_score * 1.3:
            next_node = destination_node

    return next_node
