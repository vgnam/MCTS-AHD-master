def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        lookahead_dist = 0
        angular_weight = 0.3

        if len(unvisited_nodes) > 2:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])
            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]

            # Calculate angular deviation penalty
            vec1 = (distance_matrix[current_node][node], 0)
            vec2 = (distance_matrix[node][best_lookahead], 0)
            if vec1[0] != 0 and vec2[0] != 0:
                angle = math.acos((vec1[0] * vec2[0]) / (vec1[0] * vec2[0]))
                angular_penalty = angle * angular_weight
            else:
                angular_penalty = 0
        elif len(unvisited_nodes) == 2:
            remaining_node = [n for n in unvisited_nodes if n != node][0]
            lookahead_dist = distance_matrix[node][remaining_node] + distance_matrix[remaining_node][destination_node]
            angular_penalty = 0
        else:
            lookahead_dist = distance_matrix[node][destination_node]
            angular_penalty = 0

        # Dynamic weight adjustment based on remaining nodes
        distance_weight = 1.0 - (0.1 * (len(unvisited_nodes) - 1))
        lookahead_weight = 0.5 + (0.1 * (len(unvisited_nodes) - 1))

        return (distance_weight * current_dist) + (lookahead_weight * lookahead_dist) + angular_penalty

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
