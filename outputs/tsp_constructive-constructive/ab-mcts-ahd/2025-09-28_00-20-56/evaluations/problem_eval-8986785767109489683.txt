import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    recency_bonus = {node: 1 for node in unvisited_nodes}
    recent_nodes = []
    recency_penalty = 0.8

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        lookahead_dist = 0
        remaining_nodes = [n for n in unvisited_nodes if n != node]
        if remaining_nodes:
            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])
            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]
        score = current_dist + lookahead_dist * 0.5
        score /= recency_bonus[node]
        return score

    scores = [evaluate_node(node) for node in unvisited_nodes]
    total_score = sum(scores)
    probabilities = [score / total_score for score in scores]

    next_node = random.choices(unvisited_nodes, probabilities)[0]

    # Update recency bonus
    recent_nodes.append(next_node)
    if len(recent_nodes) > 3:  # Only consider the last 3 nodes
        recent_nodes.pop(0)
    for node in recent_nodes:
        recency_bonus[node] *= recency_penalty

    return next_node
