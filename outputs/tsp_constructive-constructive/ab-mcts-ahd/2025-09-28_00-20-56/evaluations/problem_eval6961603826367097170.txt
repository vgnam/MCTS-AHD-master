def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_total_distance = float('inf')
    next_node = None
    destination_in_unvisited = destination_node in unvisited_nodes
    num_unvisited = len(unvisited_nodes)

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        remaining_distance = distance_matrix[node][destination_node]
        total_distance = current_distance + remaining_distance

        # Dynamic threshold based on remaining nodes
        threshold_factor = 0.8 + 0.2 * (num_unvisited / len(distance_matrix))

        if destination_in_unvisited and node == destination_node:
            if current_distance <= min_total_distance * threshold_factor:
                next_node = node
                min_total_distance = current_distance
        else:
            if total_distance < min_total_distance:
                min_total_distance = total_distance
                next_node = node

    # Penalize nodes that disrupt the path to destination
    if destination_in_unvisited and next_node != destination_node:
        disruption_penalty = distance_matrix[next_node][destination_node] - distance_matrix[current_node][destination_node]
        if disruption_penalty > 0:
            for node in unvisited_nodes:
                if node != destination_node:
                    alternative_distance = distance_matrix[current_node][node] + distance_matrix[node][destination_node]
                    if alternative_distance < min_total_distance + disruption_penalty:
                        min_total_distance = alternative_distance
                        next_node = node

    return next_node
