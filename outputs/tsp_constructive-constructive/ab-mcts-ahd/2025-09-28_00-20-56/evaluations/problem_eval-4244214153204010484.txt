def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        # Immediate distance (70% weight)
        current_dist = distance_matrix[current_node][node] * 0.7

        # Cluster density (15% weight)
        cluster_density = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node)
        cluster_weight = cluster_density / len(unvisited_nodes) if unvisited_nodes else 0

        # Proximity to nearest cluster (15% weight)
        nearest_cluster = min(unvisited_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])
        proximity_dist = distance_matrix[node][nearest_cluster] + distance_matrix[nearest_cluster][destination_node]
        proximity_weight = 0.15

        # Dynamic weight adjustment for fewer remaining nodes
        dynamic_weight = 0.15 if len(unvisited_nodes) < 4 else 0.05

        return current_dist + proximity_weight * proximity_dist + dynamic_weight * cluster_weight

    # Probabilistic decision-making mechanism
    probabilities = {node: evaluate_node(node) for node in unvisited_nodes}
    total_weight = sum(probabilities.values())
    next_node = max(probabilities, key=lambda node: probabilities[node] / total_weight)

    return next_node
