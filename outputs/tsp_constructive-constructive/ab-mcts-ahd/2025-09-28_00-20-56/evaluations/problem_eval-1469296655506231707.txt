def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        immediate_dist = distance_matrix[current_node][node]
        remaining_nodes = [n for n in unvisited_nodes if n != node]

        if not remaining_nodes:
            return immediate_dist

        # Randomly select lookahead depth between 1 and 3
        lookahead_depth = min(3, len(remaining_nodes))
        lookahead_weight = 1.0 / len(unvisited_nodes)

        # Recursive lookahead evaluation
        def lookahead(node, depth):
            if depth == 0 or not remaining_nodes:
                return distance_matrix[node][destination_node]
            next_nodes = [n for n in remaining_nodes if n != node]
            if not next_nodes:
                return distance_matrix[node][destination_node]
            best_next = min(next_nodes, key=lambda n: distance_matrix[node][n] + lookahead(n, depth-1))
            return distance_matrix[node][best_next] + lookahead(best_next, depth-1)

        lookahead_dist = lookahead(node, lookahead_depth)
        return immediate_dist + lookahead_weight * lookahead_dist

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
