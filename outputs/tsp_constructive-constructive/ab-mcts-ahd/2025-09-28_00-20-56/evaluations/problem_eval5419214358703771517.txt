def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_count = len(unvisited_nodes)
    decay_factor = remaining_count / (remaining_count + 1)

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        if len(unvisited_nodes) > 2:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            second_nodes = []
            for n in remaining_nodes:
                second_remaining = [m for m in remaining_nodes if m != n]
                third_nodes = []
                for m in second_remaining:
                    third_remaining = [k for k in second_remaining if k != m]
                    best_third = min(third_remaining, key=lambda k: distance_matrix[m][k] + distance_matrix[k][destination_node])
                    third_nodes.append((m, distance_matrix[m][best_third] + distance_matrix[best_third][destination_node]))
                best_second = min(second_remaining, key=lambda m: distance_matrix[n][m] + min(d for (_, d) in third_nodes if d != float('inf')))
                second_nodes.append((n, distance_matrix[n][best_second] + min(d for (_, d) in third_nodes if d != float('inf'))))
            best_lookahead = min(remaining_nodes, key=lambda n: min(d for (m, d) in second_nodes if m == n))
            lookahead_dist = min(d for (m, d) in second_nodes if m == best_lookahead)
            adjusted_lookahead_dist = lookahead_dist * decay_factor
        else:
            adjusted_lookahead_dist = distance_matrix[node][destination_node]
        return 0.7 * current_dist + 0.3 * adjusted_lookahead_dist

    next_node = max(unvisited_nodes, key=evaluate_node)
    return next_node
