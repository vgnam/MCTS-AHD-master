def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        lookahead_dist = 0
        remaining_nodes = [n for n in unvisited_nodes if n != node]

        if len(remaining_nodes) >= 2:
            best_paths = []
            for n1 in remaining_nodes:
                remaining_after_n1 = [n for n in remaining_nodes if n != n1]
                if remaining_after_n1:
                    best_n2 = min(remaining_after_n1, key=lambda n: distance_matrix[n1][n] + distance_matrix[n][destination_node])
                    best_paths.append(distance_matrix[n1][best_n2] + distance_matrix[best_n2][destination_node])
            lookahead_dist = min(best_paths) if best_paths else distance_matrix[node][destination_node]
        else:
            lookahead_dist = distance_matrix[node][destination_node] if remaining_nodes else 0

        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0
        return 0.8 * current_dist + 0.2 * lookahead_dist + 0.1 * centrality

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
