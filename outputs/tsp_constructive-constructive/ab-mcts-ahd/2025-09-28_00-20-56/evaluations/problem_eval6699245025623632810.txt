def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        if len(unvisited_nodes) > 1:
            remaining_nodes = [n for n in unvisited_nodes if n != node]
            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])
            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]
        else:
            lookahead_dist = distance_matrix[node][destination_node]

        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5
        total_score = (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist
        scores.append((total_score, node))

    if not scores:
        return destination_node

    min_score = min(score for score, _ in scores)
    max_score = max(score for score, _ in scores)
    temperature = max_score - min_score

    if temperature == 0:
        return min(scores, key=lambda x: x[0])[1]

    exp_scores = [(score, node) for score, node in scores]
    exp_scores = [(math.exp((min_score - score) / temperature), node) for score, node in exp_scores]
    total_exp = sum(exp for exp, _ in exp_scores)

    if total_exp == 0:
        return min(scores, key=lambda x: x[0])[1]

    probabilities = [(exp / total_exp, node) for exp, node in exp_scores]
    rand_val = random.random()
    cumulative_prob = 0.0

    for prob, node in probabilities:
        cumulative_prob += prob
        if rand_val <= cumulative_prob:
            return node

    return next_node
