def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        immediate_dist = distance_matrix[current_node][node]

        if len(unvisited_nodes) == 1:
            lookahead_dist = distance_matrix[node][destination_node]
        else:
            lookahead_depth = max(1, int(0.5 * len(unvisited_nodes)))
            remaining_nodes = [n for n in unvisited_nodes if n != node]

            def evaluate_path(start, depth):
                if depth == 0 or len(remaining_nodes) == 0:
                    return distance_matrix[start][destination_node]
                next_nodes = remaining_nodes[:depth]
                best_path = min(next_nodes, key=lambda n: distance_matrix[start][n] + evaluate_path(n, depth-1))
                return distance_matrix[start][best_path] + evaluate_path(best_path, depth-1)

            lookahead_dist = evaluate_path(node, lookahead_depth)

        return 0.7 * immediate_dist + 0.3 * lookahead_dist

    next_node = min(unvisited_nodes, key=evaluate_node)
    return next_node
