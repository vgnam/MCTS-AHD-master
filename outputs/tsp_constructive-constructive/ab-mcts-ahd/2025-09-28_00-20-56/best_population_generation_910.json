"def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.5 + 0.1 * (len(unvisited_nodes) / 10)  # Adjust weight more dynamically\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) * 0.6 + (lookahead_dist / (distance + 1e-10)) * weight * 0.4\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a stringent distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Strict threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node"