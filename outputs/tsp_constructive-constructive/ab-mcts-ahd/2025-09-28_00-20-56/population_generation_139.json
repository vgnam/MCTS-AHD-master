[
     {
          "algorithm": "The algorithm prioritizes nodes with the highest ratio of remaining distance to destination (from the candidate node) over the current distance (from the current node), balancing exploration and destination proximity. It defaults to the destination node if its direct distance is \u226490% of the best ratio, ensuring efficiency and flexibility. The heuristic emphasizes maximizing the ratio while occasionally overriding to the destination for optimal path efficiency.",
          "thought": "The new algorithm prioritizes nodes with the highest ratio of remaining distance to the current node's distance, balancing exploration and destination proximity, and uses a more flexible threshold (90%) for destination prioritization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_ratio = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_ratio * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a weighted distance that balances the current distance to the node and the exponential decay-adjusted remaining distance to the destination. It uses an average shortest path to the destination as a dynamic threshold, prioritizing nodes closer to the destination earlier in the journey. The algorithm also directly considers the destination if it is within a dynamic threshold of the current node, ensuring an early return if possible.",
          "thought": "The new algorithm introduces a dynamic threshold based on the average shortest path to the destination from unvisited nodes and uses an exponential decay factor to prioritize nodes closer to the destination earlier in the journey.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate average shortest path to destination from unvisited nodes\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        # Introduce an exponential decay factor\n        total_distance = current_distance + remaining_distance * (avg_remaining_distance / remaining_distance) ** 2\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is within a dynamic threshold\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        dynamic_threshold = avg_remaining_distance * 0.8\n        if direct_distance <= dynamic_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.98744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP by balancing the immediate distance from the current node with a strategically weighted future distance to the destination node, using a dynamic weighting based on Euclidean distance. Specifically, it calculates an evaluation score for each unvisited node that combines the current distance with an estimated lookahead distance, prioritizing paths that are both short-term efficient and strategically advantageous. The Euclidean weight adjusts this balance, giving more importance to nodes closer to the destination while still considering the direct path distance.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism based on the Euclidean distance to the destination node to balance short-term distance and long-term strategic path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        lookahead_dist = min([distance_matrix[node][n] + distance_matrix[n][destination_node] for n in unvisited_nodes])\n        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5\n        return (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.00115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node, but if the destination node is still unvisited and within 1.5 times the distance to the nearest node, it overrides the selection to ensure progress toward the destination. The function balances proximity and destination prioritization using a distance threshold.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and within a certain threshold distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing the current distance to the node and an exponentially decayed remaining distance to the destination, ensuring closer nodes are preferred while adaptively adjusting the threshold to potentially visit the destination early if it's within a dynamic threshold. The dynamic threshold (70% of the minimum total distance) allows direct visits to the destination if feasible, optimizing the path by prioritizing proximity and efficiency.",
          "thought": "The new algorithm combines the proximity-based selection of No.2 with the dynamic threshold and exponential decay adjustment of No.1, prioritizing nodes closer to the destination while balancing current and remaining distances with an adaptive threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + remaining_distance * (1.0 / (1.0 + remaining_distance)) ** 2\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        dynamic_threshold = min_total_distance * 0.7\n        if direct_distance <= dynamic_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.21342,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing immediate distance (70% weight) and the best 2-step path (30% weight), with the latter adjusted dynamically by a density factor based on unvisited nodes. The density factor, calculated as the ratio of remaining nodes to total nodes, moderates the lookahead component, ensuring a balance between proximity and future optimization. The code evaluates each candidate node by combining these weighted components and selects the one with the minimal score.",
          "thought": "The new algorithm modifies the selection criteria by emphasizing immediate distance (70% weight) and the best 2-step path (30% weight), while incorporating a dynamic lookahead factor that adjusts based on the remaining unvisited nodes' density, aiming to balance proximity and future optimization more adaptively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n        density_factor = len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))\n        return 0.7 * current_dist + 0.3 * (density_factor * lookahead_dist)\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.23648,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing proximity to the current node and the destination, with a penalty for potential detours, adjusting these weights based on the number of remaining unvisited nodes. The `calculate_score` function assigns higher priority to being closer to the current node and destination, while the detour penalty, weighted inversely by the number of unvisited nodes, discourages selecting nodes that would significantly increase the overall path length. The node with the lowest calculated score is chosen as the next node to visit.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between proximity to the current node, proximity to the destination, and detour penalty based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        num_unvisited = len(unvisited_nodes)\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = sum(max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) for other_node in unvisited_nodes if other_node != node)\n        return (num_unvisited * current_distance + remaining_distance) + (1 / num_unvisited) * detour_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.25424,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends the nearest-neighbor approach by dynamically balancing immediate distance (100% weight) with a 3-step lookahead to the destination (30% weight), while penalizing revisits to recently visited nodes (20% weight) using exponential decay. The `evaluate_node` function prioritizes immediate distance, followed by long-term path optimization and historical penalties, with the `decay_factor` ensuring penalties fade over time. The `visited_history` dictionary tracks and decays recent visits to avoid cycles.",
          "thought": "The new algorithm extends the nearest-neighbor approach by incorporating a dynamic 3-step lookahead mechanism that evaluates potential paths based on immediate distance (100% weight) and the best 3-step path to the destination (30% weight), while penalizing revisits to recently visited nodes to avoid cycles, using an exponential decay factor for historical visits.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    visited_history = {node: 1.0 for node in unvisited_nodes}  # Initialize visit history\n    decay_factor = 0.9  # Exponential decay for historical visits\n\n    def evaluate_node(node):\n        # Immediate distance\n        current_dist = distance_matrix[current_node][node]\n\n        # Dynamic lookahead based on remaining steps\n        if len(unvisited_nodes) > 2:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            # Evaluate 3-step paths\n            best_lookahead = None\n            best_score = float('inf')\n            for n1 in remaining_nodes:\n                remaining_after_n1 = [n for n in remaining_nodes if n != n1]\n                for n2 in remaining_after_n1:\n                    score = (distance_matrix[node][n1] +\n                             distance_matrix[n1][n2] +\n                             distance_matrix[n2][destination_node])\n                    if score < best_score:\n                        best_score = score\n                        best_lookahead = score\n            lookahead_dist = best_lookahead if best_lookahead is not None else distance_matrix[node][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Apply historical penalty\n        historical_penalty = visited_history[node]\n        visited_history[node] *= decay_factor  # Decay historical visits\n\n        # Combine metrics with weights\n        return current_dist + 0.3 * lookahead_dist + 0.2 * historical_penalty\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    visited_history[next_node] = 1.0  # Mark as recently visited\n    return next_node",
          "objective": 7.30221,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the next node with a lookahead to the distance from potential next nodes to the destination, while penalizing nodes with many nearby unvisited neighbors. The scoring function prioritizes both proximity to the destination and minimizing future travel costs, using a weighted balance that gives higher importance to minimizing remaining distance as the path progresses. The structure of the code emphasizes calculating a composite score for each unvisited node, incorporating penalties for nearby neighbors to avoid dead-ends.",
          "thought": "Common ideas: Balancing immediate distance with future lookahead, weighting based on proximity to the destination.\nDesign idea: Integrate lookahead distance similar to No.1 while penalizing nearby unvisited neighbors as in No.2 for a balanced approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        lookahead_distance = min([distance_matrix[node][n] + distance_matrix[n][destination_node] for n in unvisited_nodes])\n        nearby_unvisited_penalty = sum(1 for other_node in unvisited_nodes if other_node != node and distance_matrix[node][other_node] < 2)\n        remaining_distance = distance_matrix[node][destination_node]\n        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5\n        return (1 - euclidean_weight) * (current_distance + nearby_unvisited_penalty) + euclidean_weight * lookahead_distance\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.30436,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the greedy approach by dynamically balancing direct distance to the destination (70% weight) with a detour penalty (30% weight) that penalizes nodes further away from unvisited nodes, ensuring a trade-off between immediate proximity and future detour risks. The `calculate_score` function computes a weighted sum of the current distance, remaining distance to the destination, and detour penalty, prioritizing nodes that minimize this combined score.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic detour penalty that considers the proximity of unvisited nodes to the current path and a heuristic that balances direct distance to the destination with the potential to reduce future detours, using a weighted combination of these factors to select the next node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += (distance_matrix[current_node][other_node] - distance_matrix[node][other_node]) ** 2\n        return current_distance + 0.7 * remaining_distance + 0.3 * detour_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.39682,
          "other_inf": null
     }
]