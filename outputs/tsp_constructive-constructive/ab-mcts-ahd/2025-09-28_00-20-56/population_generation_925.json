[
     {
          "algorithm": "The algorithm combines proximity and lookahead heuristics to select the next node in the TSP, with a sophisticated proximity-weighted lookahead and dynamic weight adjustment based on the number of remaining nodes. It calculates a total score for each candidate node, balancing the distance to the destination and the shortest lookahead route, and prioritizes nodes that have a high score. Additionally, it checks if the destination node is within a stringent distance threshold and prioritizes it if unvisited, balancing the need for early returns with proximity considerations.",
          "thought": "Common ideas include proximity and lookahead heuristics, dynamic adjustment of weights, and an early return condition based on reasonable distance thresholds. The new algorithm will combine these ideas similarly to No.2 but incorporate a more sophisticated proximity-weighted lookahead and a tighter early return condition based on No.1.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.5 + 0.1 * (len(unvisited_nodes) / 10)  # Adjust weight more dynamically\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) * 0.6 + (lookahead_dist / (distance + 1e-10)) * weight * 0.4\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a stringent distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Strict threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization (prioritizing nearby nodes) with a weighted lookahead mechanism (considering future steps) while dynamically adjusting weights based on remaining unvisited nodes, favoring proximity when many nodes remain and lookahead when few remain. It evaluates each candidate node by balancing direct distance to the destination and potential future steps, dynamically adjusting the weight between these factors. The algorithm also prioritizes returning to the destination if it is close, ensuring efficiency in the final stages.",
          "thought": "The new algorithm combines the proximity prioritization of Algorithm 1 with the weighted lookahead scoring of Algorithm 2, while dynamically adjusting the weights based on the remaining unvisited nodes to ensure efficient path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57028,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node and potential future progress toward the destination, using a dynamic weight (higher for fewer unvisited nodes) and a tighter threshold (1.2x) to aggressively guide the path toward the destination while still considering local optimality through a lookahead mechanism. The score combines normalized ratios of remaining distance and lookahead distance, with weights adjusted based on the number of unvisited nodes. The destination is prioritized if its distance is within 120% of the best candidate's distance.",
          "thought": "The new algorithm combines the proximity-based selection, dynamic weight adjustment from the second algorithm, and a more aggressive destination prioritization with a tighter threshold to balance efficiency and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        weight = 0.7 if len(unvisited_nodes) > 4 else 0.5\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57063,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance to the destination with future connectivity, using a weighted combination of direct distance and lookahead estimates. It dynamically adjusts weights (higher for direct distance when many nodes remain) and enforces a strict threshold to prioritize the destination only when significantly closer than alternatives. The key design choices are the dynamic weighting, lookahead estimation, and tight destination prioritization.",
          "thought": "The new algorithm prioritizes immediate distance to the destination and future connectivity by combining a static weight for direct distance and a dynamic weight for lookahead based on remaining nodes, while also enforcing a strict threshold on the destination node's distance to ensure it's only considered when significantly closer than alternatives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Static weight for direct distance and dynamic for lookahead\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * 0.4 + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Strict destination prioritization with a tight threshold\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Tighter threshold\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57146,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (70% weight) with long-term efficiency (30%) by evaluating both the direct distance to the next node and the best possible detour to the destination, while dynamically checking if returning to the destination is feasible. It prioritizes minimizing immediate travel distance while ensuring the path remains efficient for the remaining route. The score calculation (`total_score`) combines these factors to select the optimal next node, with a dynamic check for returning to the destination if it's nearby.",
          "thought": "The new algorithm prioritizes immediate proximity with a higher weight (0.7) while slightly considering long-term efficiency (0.3), balancing immediate distance and potential detours to reduce total path length, and includes a dynamic check for returning to the destination if it's nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.7\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58398,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the next node in the Traveling Salesman Problem (TSP) by combining immediate proximity and a lookahead strategy, adjusted dynamically based on the number of unvisited nodes. It calculates a score for each potential next node, weighing closer nodes more heavily early on and balancing with closer lookahead nodes as fewer nodes remain unvisited. Additionally, it considers returning to the destination node if it is unvisited and within a reasonable distance, ensuring a balanced approach between local and global considerations.",
          "thought": "The new algorithm prioritizes nodes based on a reduced immediate proximity factor and increased lookahead weight, prioritizing closer nodes early and balancing with more distant lookahead as fewer nodes remain unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.8 if len(unvisited_nodes) > 3 else 0.6\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58888,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a score for each unvisited node, combining the direct distance to it and a weighted lookahead distance that considers future steps. The weight is dynamically adjusted based on the number of remaining unvisited nodes, balancing immediate proximity and future efficiency. If the destination node is unvisited and within a reasonable distance, it is prioritized.",
          "thought": "Common ideas: Dynamic weight adjustment, lookahead mechanism, and a balance between proximity and future steps.\n\nDesign idea: A modified version of algorithm No.2 that incorporates a lookahead mechanism with a dynamic weight based on the number of remaining unvisited nodes, balancing proximity and future steps to select the next node.\n\nMain steps: For each unvisited node, calculate a score combining the distance to the node and a weighted lookahead distance, dynamically adjusting the weight based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.6 if len(unvisited_nodes) > 4 else 0.4\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60098,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead (50% weight), adjusting the lookahead distance using centrality-based weights and an exponential decay factor based on average remaining distance to the destination. It prioritizes immediate proximity while balancing long-term optimization and exploration through probabilistic adjustments. The code evaluates each node by computing a weighted sum of the current distance and adjusted lookahead distance, with higher weights given to nodes that are closer and more centrally located in the remaining graph.",
          "thought": "The new algorithm combines nearest-neighbor selection (100% weight) with a dynamic 3-step lookahead mechanism (50% weight), where the lookahead distance is adjusted by a centrality-based weight and an exponential decay factor based on the average remaining distance to the destination, while incorporating probabilistic exploration to balance immediate proximity, long-term optimization, and exploration of better paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 2:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            # 3-step lookahead\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + min(\n                distance_matrix[n][k] + distance_matrix[k][destination_node] for k in remaining_nodes if k != n))\n            lookahead_dist = distance_matrix[node][best_lookahead] + min(\n                distance_matrix[best_lookahead][k] + distance_matrix[k][destination_node] for k in remaining_nodes if k != best_lookahead)\n            # Centrality-based adjustment\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            efficiency_factor = (avg_remaining_distance / centrality) ** 0.5\n            adjusted_lookahead_dist = lookahead_dist * efficiency_factor * (avg_remaining_distance / lookahead_dist) ** 2\n            # Probabilistic component\n            random_factor = 1.0 + 0.2 * (1 - (current_dist / (current_dist + lookahead_dist)))\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n            random_factor = 1.0\n        return (current_dist + 0.5 * adjusted_lookahead_dist) * random_factor\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.60554,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (60% weight) and long-term efficiency (40% weight) by scoring each unvisited node based on its direct distance from the current node and the best possible path to the destination from that node. It prioritizes returning to the destination early when fewer than 3 nodes remain, ensuring the solution remains efficient. The scoring mechanism normalizes distances to avoid division by zero and checks for viability when near the end of the tour.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.6) while slightly emphasizing long-term efficiency (weight 0.4) in its scoring mechanism, with a heuristic to check if returning to the destination is viable when fewer than 3 unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        proximity_weight = 0.6\n        efficiency_weight = 0.4\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - efficiency_weight) + (lookahead_dist / (distance + 1e-10)) * efficiency_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if len(unvisited_nodes) < 3 and destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60614,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection (prioritizing nodes with a favorable distance ratio to the destination) with centrality-based weighting (considering how central a node is in the remaining graph) and a 2-step lookahead (evaluating the best subsequent move to the destination). It balances immediate proximity (via the ratio) with long-term efficiency (via centrality and lookahead), favoring nodes that optimize both short-term and future steps while ensuring the destination is prioritized if it offers a sufficiently direct path. The `score` variable integrates these factors, with higher scores indicating better candidates, and the algorithm dynamically adjusts based on the remaining unvisited nodes.",
          "thought": "The new algorithm combines the ratio-based selection of No.2 with the centrality-based weighting and 2-step lookahead of No.1, prioritizing nodes that balance immediate proximity with long-term efficiency while considering centrality in the remaining graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            score = ratio * (centrality / lookahead_dist)\n        else:\n            score = ratio\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60673,
          "other_inf": null
     }
]