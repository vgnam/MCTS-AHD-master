[
     {
          "algorithm": "The algorithm selects the next node by calculating a weighted distance that balances the current distance to the node and the exponential decay-adjusted remaining distance to the destination. It uses an average shortest path to the destination as a dynamic threshold, prioritizing nodes closer to the destination earlier in the journey. The algorithm also directly considers the destination if it is within a dynamic threshold of the current node, ensuring an early return if possible.",
          "thought": "The new algorithm introduces a dynamic threshold based on the average shortest path to the destination from unvisited nodes and uses an exponential decay factor to prioritize nodes closer to the destination earlier in the journey.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate average shortest path to destination from unvisited nodes\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        # Introduce an exponential decay factor\n        total_distance = current_distance + remaining_distance * (avg_remaining_distance / remaining_distance) ** 2\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is within a dynamic threshold\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        dynamic_threshold = avg_remaining_distance * 0.8\n        if direct_distance <= dynamic_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.98744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node, but if the destination node is still unvisited and within 1.5 times the distance to the nearest node, it overrides the selection to ensure progress toward the destination. The function balances proximity and destination prioritization using a distance threshold.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and within a certain threshold distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in the Traveling Salesman Problem by balancing proximity to the current node and the destination, with a penalty for potential detours, adjusting these weights based on the number of remaining unvisited nodes. The `calculate_score` function assigns higher priority to being closer to the current node and destination, while the detour penalty, weighted inversely by the number of unvisited nodes, discourages selecting nodes that would significantly increase the overall path length. The node with the lowest calculated score is chosen as the next node to visit.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between proximity to the current node, proximity to the destination, and detour penalty based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        num_unvisited = len(unvisited_nodes)\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = sum(max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) for other_node in unvisited_nodes if other_node != node)\n        return (num_unvisited * current_distance + remaining_distance) + (1 / num_unvisited) * detour_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.25424,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node while incorporating a detour penalty and proximity bonus to the destination. The detour penalty penalizes nodes that introduce longer paths to other unvisited nodes, whereas the proximity bonus rewards nodes closer to the destination, balancing immediate and long-term considerations. The algorithm also gives a priority to the destination node if it is unvisited and within a reasonable distance threshold, ensuring the final path returns to the starting point efficiently.",
          "thought": "Common ideas: Balancing immediate distance with future considerations, penalizing detours, and prioritizing proximity to the destination. Design idea: Select the next node by prioritizing the closest unvisited node while incorporating a detour penalty and proximity bonus to the destination, inspired by No.1 but maintaining the simplicity of No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n        normalized_penalty = detour_penalty / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        proximity_bonus = (1.0 - (remaining_distance / max(distance_matrix[node]))) * 0.5\n        score = current_distance + normalized_penalty - proximity_bonus\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_score * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.60097,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a 2-step lookahead mechanism, prioritizing immediate distance (100% weight) and the best 2-step path (50% weight) to balance short-term proximity and long-term optimization, using a distance matrix for evaluations. The function evaluates each unvisited node by summing its direct distance from the current node and the best 2-step path to the destination, then selects the node with the lowest combined score.",
          "thought": "This new algorithm uses a hybrid approach that combines nearest-neighbor selection with a lookahead mechanism that evaluates potential paths of length 2 ahead to find the most promising next node, balancing immediate proximity and longer-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        # Immediate distance\n        current_dist = distance_matrix[current_node][node]\n        # Lookahead to next node\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n        # Combine immediate and lookahead distances\n        return current_dist + 0.5 * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.66071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the greedy approach by dynamically balancing immediate distance (prioritized) with future detours (weighted by remaining nodes) via a scoring mechanism that includes a normalized detour penalty and a proximity bonus to the destination. The `weight_factor` decreases as nodes are visited, reducing reliance on immediate distance in favor of minimizing future detours. The score prioritizes minimizing `current_distance` and `normalized_penalty` while balancing `remaining_distance` and `proximity_bonus`.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, balancing immediate distance to the next node with the potential impact on future detours through a novel scoring mechanism that includes a normalized detour penalty term and a proximity bonus for nodes closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (remaining_nodes + 1)\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n\n        normalized_penalty = detour_penalty / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        proximity_bonus = (1.0 - (remaining_distance / max(distance_matrix[node]))) * 0.5\n\n        score = (current_distance * (1 - weight_factor)) + (remaining_distance * weight_factor) + (normalized_penalty * (1 - weight_factor)) - proximity_bonus\n        return score\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.77238,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (70% weight) and a detour penalty (30% weight), where the penalty measures the increase in total distance caused by visiting a node first. The detour penalty is computed by summing squared differences between the direct distance and the path via the candidate node for all remaining unvisited nodes. The node with the lowest combined score is chosen, prioritizing both proximity and future detour minimization.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with the detour penalty mechanism of No.1, selecting the next node by balancing immediate distance (weighted 0.7) and a detour penalty (weighted 0.3) that considers the impact on future unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += (distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) ** 2\n        return (current_distance * 0.7) + (detour_penalty * 0.3)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.81305,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing direct distance (60%) and remaining distance (30%) while penalizing detours (10%) calculated as squared detour costs, emphasizing larger deviations more strongly. The `calculate_score` function computes a weighted sum of these factors, and the next node is selected based on the minimum score. The detour penalty ensures the algorithm avoids significant deviations from the direct path.",
          "thought": "The new algorithm prioritizes minimizing direct distance (weight 0.6) and remaining distance (weight 0.3), while using a detour penalty (weight 0.1) calculated as the sum of squared detour costs, which emphasizes larger detours more strongly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = sum((max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])) ** 2 for other_node in unvisited_nodes if other_node != node)\n        return current_distance * 0.6 + remaining_distance * 0.3 + detour_penalty * 0.1\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.90863,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to unvisited nodes and the destination, prioritizing the destination when it's close enough to avoid detours. It iterates through unvisited nodes, calculates the sum of the current distance and the estimated remaining distance to the destination, and chooses the node with the smallest sum. If the destination is unvisited and its direct distance is within 80% of the smallest sum, it prioritizes the destination.",
          "thought": "This algorithm selects the next node by considering both the closest unvisited node and the destination node, choosing the one that minimizes the sum of the current distance and the estimated remaining distance to the destination, favoring the destination when it's close enough to prevent detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + remaining_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is not too long\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= min_total_distance * 0.8:  # More aggressive threshold\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies a greedy TSP heuristic by dynamically balancing proximity to the destination (weighted 0.4) and immediate distance (weighted 0.6), while incorporating a detour penalty (weighted 0.3) that penalizes nodes causing long-term detours by considering their impact on future unvisited nodes. The detour penalty is calculated as the squared difference between the direct path and the path via the candidate node, emphasizing detour prevention. The scoring mechanism prioritizes immediate efficiency while mitigating future inefficiencies.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic detour penalty that considers both immediate and long-term detour effects, using a weighted combination of distances and a heuristic that balances proximity to the destination with detour minimization through a novel scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += (distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) ** 2\n        return (current_distance * 0.6 + remaining_distance * 0.4) + detour_penalty * 0.3\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.00392,
          "other_inf": null
     }
]