[
     {
          "algorithm": "The algorithm combines proximity prioritization (prioritizing nearby nodes) with a weighted lookahead mechanism (considering future steps) while dynamically adjusting weights based on remaining unvisited nodes, favoring proximity when many nodes remain and lookahead when few remain. It evaluates each candidate node by balancing direct distance to the destination and potential future steps, dynamically adjusting the weight between these factors. The algorithm also prioritizes returning to the destination if it is close, ensuring efficiency in the final stages.",
          "thought": "The new algorithm combines the proximity prioritization of Algorithm 1 with the weighted lookahead scoring of Algorithm 2, while dynamically adjusting the weights based on the remaining unvisited nodes to ensure efficient path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57028,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (70% weight) with long-term efficiency (30%) by evaluating both the direct distance to the next node and the best possible detour to the destination, while dynamically checking if returning to the destination is feasible. It prioritizes minimizing immediate travel distance while ensuring the path remains efficient for the remaining route. The score calculation (`total_score`) combines these factors to select the optimal next node, with a dynamic check for returning to the destination if it's nearby.",
          "thought": "The new algorithm prioritizes immediate proximity with a higher weight (0.7) while slightly considering long-term efficiency (0.3), balancing immediate distance and potential detours to reduce total path length, and includes a dynamic check for returning to the destination if it's nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.7\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58398,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate proximity (distance from current node) and long-term efficiency (lookahead to the destination), using a weighted combination of these factors. It emphasizes immediate proximity (with a weight of 0.5) and lookahead distance (with a weight of 0.5) in its scoring mechanism, while also checking if returning to the destination is a viable option. The code iterates through unvisited nodes, computes a score for each, and selects the node with the highest score, ensuring the path remains efficient.",
          "thought": "The common ideas in No.1 algorithm that may give good performances are: ratio-based selection, nearest-neighbor lookahead, and weighted Euclidean factor. The new algorithm will prioritize the closest unvisited node while incorporating a lookahead mechanism to balance immediate and long-term path efficiency, using a weighted combination of proximity and future distance considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.5\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.6186,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection (prioritizing nodes that maximize the ratio of remaining distance to current distance) with a nearest-neighbor lookahead mechanism (considering the best immediate and future connections), balancing these with a weighted Euclidean factor to refine node selection. Higher priority is given to the ratio and lookahead distance, while the Euclidean weight adjusts the influence of immediate vs. long-term path efficiency. The code dynamically evaluates each unvisited node's potential, defaulting to the destination if it offers a significantly shorter direct path.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the nearest-neighbor and lookahead mechanism from No.2, prioritizing nodes that maximize the ratio of remaining distance to current distance while also considering their immediate and future impact on the path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if current_dist == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_dist / current_dist\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = (remaining_dist / sum(distance_matrix[node])) * 0.5\n        total_score = ratio * (1 - euclidean_weight) + (lookahead_dist / (current_dist + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.66153,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a balanced heuristic (weighting current distance and lookahead) with a scoring mechanism that prioritizes nodes with favorable remaining distance while penalizing high future costs. It dynamically adjusts weights based on node proximity to the destination and the number of remaining nodes, favoring shorter current paths and minimizing future penalties. The algorithm prioritizes minimizing `balanced_dist` (a weighted combination of current and lookahead distances) while reducing `future_penalty` (average future costs), with a slight bias toward direct paths when the destination is still unvisited.",
          "thought": "The new algorithm combines the balanced heuristic from No.1 (weighting current distance and lookahead) with the scoring mechanism from No.2 (prioritizing nodes with favorable remaining distance while penalizing high future costs), dynamically adjusting weights based on node proximity to the destination and the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = remaining_dist\n\n        euclidean_weight = (remaining_dist / sum(distance_matrix[node])) * 0.7\n        balanced_dist = (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n        future_cost = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_cost == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_cost / len(unvisited_nodes)\n\n        score = balanced_dist - 0.3 * future_penalty\n\n        if score < best_score or next_node is None:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_dist = distance_matrix[current_node][destination_node]\n        if direct_dist <= best_score * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.69157,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in TSP by combining dynamic threshold prioritization (adjusting the threshold based on remaining nodes) with ratio-based selection (prioritizing nodes that balance current and remaining distances). It gives higher priority to nodes with lower ratios (remaining/current distance) and dynamically adjusts the destination threshold to favor closer returns when few nodes remain, while penalizing nodes that exceed the ratio threshold. The score calculation weighs current distance more heavily when fewer nodes remain, ensuring efficiency.",
          "thought": "The new algorithm combines dynamic threshold prioritization from No.2 with the ratio-based selection from No.1, using a weighted score that balances current distance, remaining distance, and a ratio-based penalty, while dynamically adjusting the destination threshold based on the number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        num_unvisited = len(unvisited_nodes)\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        threshold = 0.9 - 0.05 * (num_unvisited / (num_unvisited + 1))\n        if node == destination_node and current_distance <= ratio * threshold:\n            return -float('inf')\n\n        score = (num_unvisited * current_distance + remaining_distance) * (1 / ratio)\n        return score\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 6.77737,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, the ratio of remaining distance to current distance, and future distance penalties, with a dynamic threshold prioritizing the destination when it's close. Nodes are scored based on these factors (ratio weighted highest, followed by current distance and future penalty), and the destination is prioritized if its direct distance meets a dynamic threshold. The algorithm dynamically adjusts the threshold based on the number of remaining nodes, favoring the destination when few nodes remain.",
          "thought": "This new algorithm combines the proximity balancing from No.1, the ratio-based selection from No.2, and the future distance penalty from No.3, while introducing a dynamic threshold that adapts to the remaining nodes' density and the destination's proximity. It calculates a weighted score for each node, prioritizing nodes that are close to the current node, have a favorable remaining distance ratio, and have low average future distances, with a dynamic threshold for destination prioritization based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        future_distance = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_distance == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_distance / len(unvisited_nodes)\n\n        score = ratio - 0.3 * future_penalty - 0.1 * current_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        threshold = 0.9 - 0.05 * (total_unvisited / (total_unvisited + 1))\n        if direct_distance <= best_score * threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.7944,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection (100% weight) with a dynamic 2-step lookahead mechanism (50% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination, balancing immediate proximity and long-term optimization. The `current_dist` (distance from current node) is prioritized over the adjusted `lookahead_dist` (weighted by 50%), with the latter scaled by `(avg_remaining_distance / lookahead_dist)^2` to dynamically adjust its influence.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic 2-step lookahead mechanism, prioritizing immediate distance (100% weight) and a weighted 2-step lookahead distance (50% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination to balance short-term proximity and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            adjusted_lookahead_dist = lookahead_dist * (avg_remaining_distance / lookahead_dist) ** 2\n        else:\n            adjusted_lookahead_dist = distance_matrix[node][destination_node]\n        return current_dist + 0.5 * adjusted_lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.82372,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by evaluating a weighted scoring system that balances proximity to the current node and potential reductions in future travel costs, dynamically adjusting the threshold based on the remaining distance to the destination and the number of unvisited nodes. Proximity and bonus scores are prioritized, while the system adaptively modifies the threshold to make more informed decisions. If no suitable node is found, it defaults to the closest unvisited node or the destination if it is closer than any other node.",
          "thought": "The new algorithm introduces a weighted scoring system that balances proximity, remaining distance to the destination, and a potential bonus for nodes that reduce future travel costs, using a more adaptive dynamic threshold.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    num_unvisited = len(unvisited_nodes)\n    remaining_distance_to_destination = distance_matrix[current_node][destination_node]\n    base_threshold = 1.5 - (remaining_distance_to_destination / (num_unvisited * 100 + 1))\n\n    for node in unvisited_nodes:\n        proximity_score = 1 / distance_matrix[current_node][node]\n        bonus_score = sum(distance_matrix[node][dest] - distance_matrix[current_node][dest] for dest in unvisited_nodes if dest != node) / num_unvisited\n        threshold = base_threshold * (1 + bonus_score)\n        score = proximity_score * threshold\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n\n    if destination_node in unvisited_nodes and distance_matrix[current_node][destination_node] < min(distance_matrix[current_node][node] for node in unvisited_nodes):\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.85433,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a combined score for each unvisited node, prioritizing nodes with a favorable remaining distance to the destination relative to the current distance, while also penalizing nodes that have high average subsequent distances to other unvisited nodes. This encourages balanced exploration and reduced future travel costs. Additionally, it directly chooses the destination node if the remaining distance to it is significantly shorter than the best calculated score.",
          "thought": "The new algorithm prioritizes nodes based on a combined score that includes a weighted ratio of remaining distance to the destination over current distance, enhanced by a penalty for nodes that lead to high subsequent distances, encouraging balanced exploration and reduced future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        \n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n        \n        future_distance = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_distance == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_distance / len(unvisited_nodes)\n        \n        score = ratio - 0.5 * future_penalty\n        \n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.86954,
          "other_inf": null
     }
]