"def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = remaining_dist\n\n        euclidean_weight = (remaining_dist / sum(distance_matrix[node])) * 0.7\n        balanced_dist = (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n        future_cost = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_cost == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_cost / len(unvisited_nodes)\n\n        score = balanced_dist - 0.3 * future_penalty\n\n        if score < best_score or next_node is None:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_dist = distance_matrix[current_node][destination_node]\n        if direct_dist <= best_score * 0.8:\n            next_node = destination_node\n\n    return next_node"