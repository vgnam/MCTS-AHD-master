[
     {
          "algorithm": "The algorithm combines proximity prioritization (prioritizing nearby nodes) with a weighted lookahead mechanism (considering future steps) while dynamically adjusting weights based on remaining unvisited nodes, favoring proximity when many nodes remain and lookahead when few remain. It evaluates each candidate node by balancing direct distance to the destination and potential future steps, dynamically adjusting the weight between these factors. The algorithm also prioritizes returning to the destination if it is close, ensuring efficiency in the final stages.",
          "thought": "The new algorithm combines the proximity prioritization of Algorithm 1 with the weighted lookahead scoring of Algorithm 2, while dynamically adjusting the weights based on the remaining unvisited nodes to ensure efficient path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57028,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (70% weight) with long-term efficiency (30%) by evaluating both the direct distance to the next node and the best possible detour to the destination, while dynamically checking if returning to the destination is feasible. It prioritizes minimizing immediate travel distance while ensuring the path remains efficient for the remaining route. The score calculation (`total_score`) combines these factors to select the optimal next node, with a dynamic check for returning to the destination if it's nearby.",
          "thought": "The new algorithm prioritizes immediate proximity with a higher weight (0.7) while slightly considering long-term efficiency (0.3), balancing immediate distance and potential detours to reduce total path length, and includes a dynamic check for returning to the destination if it's nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.7\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58398,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (60% weight) and long-term efficiency (40% weight) by scoring each unvisited node based on its direct distance from the current node and the best possible path to the destination from that node. It prioritizes returning to the destination early when fewer than 3 nodes remain, ensuring the solution remains efficient. The scoring mechanism normalizes distances to avoid division by zero and checks for viability when near the end of the tour.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.6) while slightly emphasizing long-term efficiency (weight 0.4) in its scoring mechanism, with a heuristic to check if returning to the destination is viable when fewer than 3 unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        proximity_weight = 0.6\n        efficiency_weight = 0.4\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - efficiency_weight) + (lookahead_dist / (distance + 1e-10)) * efficiency_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if len(unvisited_nodes) < 3 and destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.60614,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and lookahead heuristics with a weighted balance (0.4 for proximity, 0.6 for lookahead) to select the next node, while also incorporating an early return condition to the destination if the direct distance is within twice the minimum distance. The proximity term prioritizes closer nodes, while the lookahead term optimizes future steps by evaluating the best remaining path from each candidate node to the destination. The code structure iteratively evaluates all unvisited nodes, computes weighted scores, and selects the node with the highest score, with a special check for the destination node.",
          "thought": "The new algorithm combines the weighted balance of proximity and lookahead from No.2 with the early return condition from No.1, using a 0.6 weight for lookahead and 0.4 for proximity, and returning to the destination if the direct distance is within twice the minimum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.6\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.61075,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate proximity (distance from current node) and long-term efficiency (lookahead to the destination), using a weighted combination of these factors. It emphasizes immediate proximity (with a weight of 0.5) and lookahead distance (with a weight of 0.5) in its scoring mechanism, while also checking if returning to the destination is a viable option. The code iterates through unvisited nodes, computes a score for each, and selects the node with the highest score, ensuring the path remains efficient.",
          "thought": "The common ideas in No.1 algorithm that may give good performances are: ratio-based selection, nearest-neighbor lookahead, and weighted Euclidean factor. The new algorithm will prioritize the closest unvisited node while incorporating a lookahead mechanism to balance immediate and long-term path efficiency, using a weighted combination of proximity and future distance considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.5\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.6186,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing proximity to the current node and lookahead to the destination, dynamically adjusting weights based on remaining nodes. It combines closest-node selection with a weighted score incorporating direct distance, remaining distance to destination, and lookahead distances, while using a dynamic threshold to prioritize the destination when within range. Higher priority is given to proximity early in the search, shifting to lookahead as nodes decrease, ensuring efficient progress toward the destination.",
          "thought": "The new algorithm combines the closest node prioritization from No.1, the weighted balance of proximity and lookahead from No.2, and adds a dynamic threshold adjustment based on the number of remaining nodes to ensure efficient progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    # Dynamic threshold based on remaining nodes\n    threshold_factor = 1.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))  # Adjusts dynamically\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Weighted score with dynamic adjustment\n        proximity_weight = 0.6 - 0.1 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))  # More lookahead as nodes decrease\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - proximity_weight) + (lookahead_dist / (distance + 1e-10)) * proximity_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n        if distance < min_distance:\n            min_distance = distance\n\n    # Prioritize destination with dynamic threshold\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * threshold_factor:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.62296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the influence of immediate proximity and lookahead distance based on tour progress, incorporating a penalty for recent node revisits to encourage exploration. It calculates a total score for each unvisited node by weighing the remaining distance, lookahead distance, and recent penalty, selecting the node with the highest score. The algorithm also checks if returning to the destination node is favorable, especially when it is nearly the end of the tour.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism based on the progress of the tour, adjusting the influence of immediate proximity versus lookahead distance, and incorporates a penalty for revisiting recent nodes to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    progress = 1 - len(unvisited_nodes) / len(distance_matrix)\n    euclidean_weight = 0.25 + 0.75 * progress\n    recent_nodes = set()\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        recent_penalty = 1 if node in recent_nodes else 0\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight - recent_penalty\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min(distance_matrix[current_node][n] for n in unvisited_nodes) * 1.5:\n            next_node = destination_node\n\n    for _ in range(min(3, len(unvisited_nodes))):\n        if next_node in recent_nodes:\n            recent_nodes.remove(next_node)\n        recent_nodes.add(next_node)\n\n    return next_node",
          "objective": 6.62394,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the Traveling Salesman Problem by balancing immediate proximity with a strong emphasis on longer-term efficiency (lookahead to the destination), using a weighted score with 0.7 weight for lookahead and 0.3 for proximity. It considers both the direct distance from the current node and the optimal remaining path to the destination, and includes a condition to return early to the destination if the direct distance is relatively short.",
          "thought": "The new algorithm prioritizes selecting the next node by emphasizing longer-term efficiency (lookahead to the destination) more strongly than immediate proximity, using a weighted combination of these factors with a weight of 0.7 for lookahead distance and 0.3 for immediate proximity, while also checking for an early return to the destination under more relaxed conditions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.6242,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm selects the next node by balancing proximity to the current node and considering the remaining distance to the destination, adjusted by a dynamic threshold. The score for each unvisited node is calculated based on a ratio of the remaining distance to the current distance, penalized by the current distance. Additionally, if the destination node is close enough relative to the best score and remains unvisited, it is prioritized for selection.",
          "thought": "Common ideas: Balancing proximity to the current node, prioritizing the destination when it's close, considering the remaining distance to the destination, and dynamically adjusting thresholds.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        score = ratio - 0.2 * current_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        threshold = 0.85 - 0.05 * (total_unvisited / (total_unvisited + 1))\n        if direct_distance <= best_score * threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.64195,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines ratio-based selection (prioritizing nodes that maximize the ratio of remaining distance to current distance) with a nearest-neighbor lookahead mechanism (considering the best immediate and future connections), balancing these with a weighted Euclidean factor to refine node selection. Higher priority is given to the ratio and lookahead distance, while the Euclidean weight adjusts the influence of immediate vs. long-term path efficiency. The code dynamically evaluates each unvisited node's potential, defaulting to the destination if it offers a significantly shorter direct path.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the nearest-neighbor and lookahead mechanism from No.2, prioritizing nodes that maximize the ratio of remaining distance to current distance while also considering their immediate and future impact on the path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if current_dist == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_dist / current_dist\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = (remaining_dist / sum(distance_matrix[node])) * 0.5\n        total_score = ratio * (1 - euclidean_weight) + (lookahead_dist / (current_dist + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.66153,
          "other_inf": null
     }
]