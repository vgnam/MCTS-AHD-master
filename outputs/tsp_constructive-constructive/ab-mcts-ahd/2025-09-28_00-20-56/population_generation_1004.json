[
     {
          "algorithm": "The algorithm combines a proximity ratio with a temperature-based scoring mechanism to select the next node in the Traveling Salesman Problem, balancing local and global optimization. It calculates a proximity score based on the ratio of remaining distance to current distance and adjusts it with a predictive factor that considers the centrality and lookahead distance of remaining unvisited nodes. The temperature parameter dynamically influences the scoring to prioritize shorter paths as fewer nodes remain unvisited, and it directly selects the destination node if a shorter direct path becomes advantageous.",
          "thought": "The new algorithm introduces a hybrid scoring mechanism that combines a revised proximity ratio with a temperature-based decision-making approach to guide the selection of the next node, aiming to balance local optimization with global path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -float('inf')\n    next_node = None\n    temperature = 1.5 / (1 + len(unvisited_nodes))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            lookahead_dist = min(distance_matrix[node][n] + distance_matrix[n][destination_node] for n in remaining_nodes)\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            predictive_factor = (1 / (1 + lookahead_dist)) * (centrality ** 0.7)\n            proximity_score = (ratio ** 1.3)\n            score = (proximity_score * predictive_factor) * (1 + temperature)\n        else:\n            score = (ratio ** 1.5)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.49526,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by considering a ratio-based scoring mechanism that weighs the current distance against the remaining distance to the destination, along with lookahead distance and centrality of each unvisited node. This ratio is adjusted dynamically using a predictive factor that prioritizes nodes with fewer total distances to remaining unvisited nodes, emphasizing aggressive prioritization towards the destination when the direct distance is sufficiently small compared to the best score. The algorithm also incorporates a direct comparison to ensure the destination node is chosen if it becomes highly favorable.",
          "thought": "Ideas: Ratio-based scoring, lookahead, centrality, aggressive prioritization of the destination with dynamic threshold adjustment",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            lookahead_dist = min(distance_matrix[node][n] + distance_matrix[n][destination_node] for n in remaining_nodes)\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            predictive_factor = (1 / (1 + lookahead_dist)) * (centrality ** 0.6)\n            score = (ratio ** 1.4) * predictive_factor\n        else:\n            score = ratio\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.85:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.51708,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a weighted balance of immediate proximity (via ratio-based scoring) and long-term path feasibility (via predictive lookahead and centrality factors), with a dynamic adjustment for returning to the destination when it becomes the most efficient choice. The ratio of remaining distance to current distance is emphasized (with an exponent of 1.2) to favor nodes that reduce future travel costs, while the predictive factor (derived from minimal lookahead distances and node centrality) ensures strategic path planning. The destination node is prioritized only if its direct distance is significantly shorter than the best candidate, ensuring global optimality.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic prioritization mechanism that combines a modified ratio-based score with a predictive lookahead factor, where nodes are scored based on their potential to improve the path while considering both immediate and long-term path optimization through a weighted balance of proximity, centrality, and future path feasibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            lookahead_dist = min(distance_matrix[node][n] + distance_matrix[n][destination_node] for n in remaining_nodes)\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            predictive_factor = (1 / (1 + lookahead_dist)) * (centrality ** 0.5)\n            score = (ratio ** 1.2) * predictive_factor\n        else:\n            score = ratio\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.52366,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and lookahead heuristics to select the next node in the TSP, with a sophisticated proximity-weighted lookahead and dynamic weight adjustment based on the number of remaining nodes. It calculates a total score for each candidate node, balancing the distance to the destination and the shortest lookahead route, and prioritizes nodes that have a high score. Additionally, it checks if the destination node is within a stringent distance threshold and prioritizes it if unvisited, balancing the need for early returns with proximity considerations.",
          "thought": "Common ideas include proximity and lookahead heuristics, dynamic adjustment of weights, and an early return condition based on reasonable distance thresholds. The new algorithm will combine these ideas similarly to No.2 but incorporate a more sophisticated proximity-weighted lookahead and a tighter early return condition based on No.1.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.5 + 0.1 * (len(unvisited_nodes) / 10)  # Adjust weight more dynamically\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) * 0.6 + (lookahead_dist / (distance + 1e-10)) * weight * 0.4\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a stringent distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Strict threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54257,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm for the Traveling Salesman Problem prioritizes node selection based on a weighted score combining the remaining distance to the destination, lookahead distance to the nearest remaining node, and centrality of the current node among unvisited nodes. The score is adjusted dynamically depending on the number of unvisited nodes, with a higher emphasis on predictive lookahead for larger sets. The algorithm also considers a direct return to the destination if it is nearly as optimal as visiting another node.",
          "thought": "Common ideas: Ratio-based scoring, predictive lookahead, centrality factors, dynamic adjustment for returning to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            lookahead_dist = min(distance_matrix[node][n] + distance_matrix[n][destination_node] for n in remaining_nodes)\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            predictive_factor = (1 / (1 + lookahead_dist)) * (centrality ** 0.5)\n            ratio = remaining_distance / (current_distance + 1e-10)\n            weight = 0.6 if len(unvisited_nodes) > 4 else 0.4\n            score = (ratio ** 1.2) * predictive_factor * (1 - weight) + (lookahead_dist / (current_distance + 1e-10)) * weight\n        else:\n            score = remaining_distance / (current_distance + 1e-10)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization (prioritizing nearby nodes) with a weighted lookahead mechanism (considering future steps) while dynamically adjusting weights based on remaining unvisited nodes, favoring proximity when many nodes remain and lookahead when few remain. It evaluates each candidate node by balancing direct distance to the destination and potential future steps, dynamically adjusting the weight between these factors. The algorithm also prioritizes returning to the destination if it is close, ensuring efficiency in the final stages.",
          "thought": "The new algorithm combines the proximity prioritization of Algorithm 1 with the weighted lookahead scoring of Algorithm 2, while dynamically adjusting the weights based on the remaining unvisited nodes to ensure efficient path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57028,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the current node and potential future progress toward the destination, using a dynamic weight (higher for fewer unvisited nodes) and a tighter threshold (1.2x) to aggressively guide the path toward the destination while still considering local optimality through a lookahead mechanism. The score combines normalized ratios of remaining distance and lookahead distance, with weights adjusted based on the number of unvisited nodes. The destination is prioritized if its distance is within 120% of the best candidate's distance.",
          "thought": "The new algorithm combines the proximity-based selection, dynamic weight adjustment from the second algorithm, and a more aggressive destination prioritization with a tighter threshold to balance efficiency and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        weight = 0.7 if len(unvisited_nodes) > 4 else 0.5\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - weight) + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57063,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance to the destination with future connectivity, using a weighted combination of direct distance and lookahead estimates. It dynamically adjusts weights (higher for direct distance when many nodes remain) and enforces a strict threshold to prioritize the destination only when significantly closer than alternatives. The key design choices are the dynamic weighting, lookahead estimation, and tight destination prioritization.",
          "thought": "The new algorithm prioritizes immediate distance to the destination and future connectivity by combining a static weight for direct distance and a dynamic weight for lookahead based on remaining nodes, while also enforcing a strict threshold on the destination node's distance to ensure it's only considered when significantly closer than alternatives.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        # Static weight for direct distance and dynamic for lookahead\n        weight = 0.7 if len(unvisited_nodes) > 3 else 0.3\n        total_score = (remaining_dist / (distance + 1e-10)) * 0.4 + (lookahead_dist / (distance + 1e-10)) * weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    # Strict destination prioritization with a tight threshold\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:  # Tighter threshold\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57146,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a dynamic scoring system that balances direct distance to the destination, lookahead potential, and centrality, with the destination being aggressively prioritized if its direct path is sufficiently shorter than the best-scored alternative. The score combines a ratio of remaining distance to current distance (higher priority) with weighted contributions from lookahead distance and centrality (lower priority), adjusting weights based on the number of unvisited nodes. The destination is explicitly checked last to ensure its direct path is not unnecessarily penalized.",
          "thought": "The new algorithm combines aggressive prioritization of the destination with dynamic weight-based selection and lookahead, scoring nodes based on the ratio of remaining distance to current distance, adjusted by a dynamically weighted lookahead factor and centrality, while prioritizing the destination if its direct path is sufficiently shorter than the best-scored node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            centrality = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            weight = 0.6 if len(unvisited_nodes) > 4 else 0.4\n            score = ratio * (centrality / lookahead_dist) * (1 - weight) + (remaining_distance / (current_distance + 1e-10)) * weight\n        else:\n            score = ratio\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.8:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.57606,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity (70% weight) with long-term efficiency (30%) by evaluating both the direct distance to the next node and the best possible detour to the destination, while dynamically checking if returning to the destination is feasible. It prioritizes minimizing immediate travel distance while ensuring the path remains efficient for the remaining route. The score calculation (`total_score`) combines these factors to select the optimal next node, with a dynamic check for returning to the destination if it's nearby.",
          "thought": "The new algorithm prioritizes immediate proximity with a higher weight (0.7) while slightly considering long-term efficiency (0.3), balancing immediate distance and potential detours to reduce total path length, and includes a dynamic check for returning to the destination if it's nearby.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    best_score = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        remaining_dist = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n\n        euclidean_weight = 0.7\n        total_score = (remaining_dist / (distance + 1e-10)) * (1 - euclidean_weight) + (lookahead_dist / (distance + 1e-10)) * euclidean_weight\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.2:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58398,
          "other_inf": null
     }
]