[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node, but if the destination node is still unvisited and within 1.5 times the distance to the nearest node, it overrides the selection to ensure progress toward the destination. The function balances proximity and destination prioritization using a distance threshold.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and within a certain threshold distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node while incorporating a detour penalty and proximity bonus to the destination. The detour penalty penalizes nodes that introduce longer paths to other unvisited nodes, whereas the proximity bonus rewards nodes closer to the destination, balancing immediate and long-term considerations. The algorithm also gives a priority to the destination node if it is unvisited and within a reasonable distance threshold, ensuring the final path returns to the starting point efficiently.",
          "thought": "Common ideas: Balancing immediate distance with future considerations, penalizing detours, and prioritizing proximity to the destination. Design idea: Select the next node by prioritizing the closest unvisited node while incorporating a detour penalty and proximity bonus to the destination, inspired by No.1 but maintaining the simplicity of No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n        normalized_penalty = detour_penalty / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        proximity_bonus = (1.0 - (remaining_distance / max(distance_matrix[node]))) * 0.5\n        score = current_distance + normalized_penalty - proximity_bonus\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_score * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.60097,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a 2-step lookahead mechanism, prioritizing immediate distance (100% weight) and the best 2-step path (50% weight) to balance short-term proximity and long-term optimization, using a distance matrix for evaluations. The function evaluates each unvisited node by summing its direct distance from the current node and the best 2-step path to the destination, then selects the node with the lowest combined score.",
          "thought": "This new algorithm uses a hybrid approach that combines nearest-neighbor selection with a lookahead mechanism that evaluates potential paths of length 2 ahead to find the most promising next node, balancing immediate proximity and longer-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        # Immediate distance\n        current_dist = distance_matrix[current_node][node]\n        # Lookahead to next node\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n        # Combine immediate and lookahead distances\n        return current_dist + 0.5 * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.66071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the greedy approach by dynamically balancing immediate distance (prioritized) with future detours (weighted by remaining nodes) via a scoring mechanism that includes a normalized detour penalty and a proximity bonus to the destination. The `weight_factor` decreases as nodes are visited, reducing reliance on immediate distance in favor of minimizing future detours. The score prioritizes minimizing `current_distance` and `normalized_penalty` while balancing `remaining_distance` and `proximity_bonus`.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, balancing immediate distance to the next node with the potential impact on future detours through a novel scoring mechanism that includes a normalized detour penalty term and a proximity bonus for nodes closer to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (remaining_nodes + 1)\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n\n        normalized_penalty = detour_penalty / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        proximity_bonus = (1.0 - (remaining_distance / max(distance_matrix[node]))) * 0.5\n\n        score = (current_distance * (1 - weight_factor)) + (remaining_distance * weight_factor) + (normalized_penalty * (1 - weight_factor)) - proximity_bonus\n        return score\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 7.77238,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to unvisited nodes and the destination, prioritizing the destination when it's close enough to avoid detours. It iterates through unvisited nodes, calculates the sum of the current distance and the estimated remaining distance to the destination, and chooses the node with the smallest sum. If the destination is unvisited and its direct distance is within 80% of the smallest sum, it prioritizes the destination.",
          "thought": "This algorithm selects the next node by considering both the closest unvisited node and the destination node, choosing the one that minimizes the sum of the current distance and the estimated remaining distance to the destination, favoring the destination when it's close enough to prevent detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        total_distance = current_distance + remaining_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is not too long\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= min_total_distance * 0.8:  # More aggressive threshold\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies a greedy TSP heuristic by dynamically balancing proximity to the destination (weighted 0.4) and immediate distance (weighted 0.6), while incorporating a detour penalty (weighted 0.3) that penalizes nodes causing long-term detours by considering their impact on future unvisited nodes. The detour penalty is calculated as the squared difference between the direct path and the path via the candidate node, emphasizing detour prevention. The scoring mechanism prioritizes immediate efficiency while mitigating future inefficiencies.",
          "thought": "The new algorithm modifies the greedy approach by incorporating a dynamic detour penalty that considers both immediate and long-term detour effects, using a weighted combination of distances and a heuristic that balances proximity to the destination with detour minimization through a novel scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += (distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) ** 2\n        return (current_distance * 0.6 + remaining_distance * 0.4) + detour_penalty * 0.3\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.00392,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes closer to the destination while slightly penalizing those that increase the total path length, balancing proximity to the destination and overall path efficiency. It calculates a score for each unvisited node based on the current distance to the node, the remaining distance to the destination, and a penalty for additional travel to other unvisited nodes. The node with the lowest score is chosen as the next node to visit.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while slightly penalizing nodes that result in greater total traveled distance, aiming to balance between proximity to the destination and the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        total_distance_penalty = sum(distance_matrix[current_node][other_node] for other_node in unvisited_nodes if other_node != node)\n        return remaining_distance + 0.1 * total_distance_penalty + current_distance\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.17876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the balance between proximity to the current node and the destination, while penalizing potential detours, using a weighting mechanism that evolves with the number of remaining unvisited nodes. The current node proximity and remaining distance to the destination are given higher priority, while detour penalties are decreased as fewer nodes remain to visit, ensuring a balanced approach to node selection. The `calculate_score` function computes a weighted score for each candidate node, guiding the selection of the next node to visit in the TSP.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between proximity to the current node, proximity to the destination, and detour penalty based on the remaining number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        num_unvisited = len(unvisited_nodes)\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n        # Dynamic weighting\n        weight_current = 1.0\n        weight_remaining = 1.0\n        weight_detour = max(0.1, 1.0 - (num_unvisited / len(distance_matrix)))\n        return (weight_current * current_distance) + (weight_remaining * remaining_distance) + (weight_detour * detour_penalty)\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.28123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three key factors: direct distance from the current node (weighted 0.5), remaining distance to the destination (weighted 0.3), and a detour penalty (weighted 0.2) that accounts for potential additional travel costs to unvisited nodes, with lower weights prioritizing efficiency over detours. The detour penalty is calculated as the sum of positive detour costs for each unvisited node, where detour cost is defined as the difference between the path through the candidate node and the direct path. The algorithm prioritizes minimizing direct and remaining distances while mitigating detours.",
          "thought": "The new algorithm selects the next node by balancing the direct distance to the current node and the remaining distance to the destination, while also incorporating a detour penalty that considers the potential detour cost to other unvisited nodes, but with a different weighting and calculation approach compared to the provided algorithm.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = sum(max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node]) for other_node in unvisited_nodes if other_node != node)\n        return current_distance * 0.5 + remaining_distance * 0.3 + detour_penalty * 0.2\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.32062,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP using a greedy approach that calculates a score for each unvisited node, combining the distance from the current node, the distance to the destination, and a detour penalty. This score prioritizes nodes that are closer to both the current location and the destination while penalizing detours to other unvisited nodes. The node with the smallest score is chosen as the next to visit.",
          "thought": "The algorithm selects the next node by using a two-step greedy approach: first, it calculates a score for each node based on the weighted sum of the distance to the current node and the distance to the destination node, applying a penalty for detours, then it selects the node with the smallest score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def calculate_score(node):\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        detour_penalty = 0\n        for other_node in unvisited_nodes:\n            if other_node != node:\n                detour_penalty += max(0, distance_matrix[current_node][node] + distance_matrix[node][other_node] - distance_matrix[current_node][other_node])\n        return current_distance + remaining_distance + detour_penalty\n\n    next_node = min(unvisited_nodes, key=calculate_score)\n    return next_node",
          "objective": 8.37611,
          "other_inf": null
     }
]