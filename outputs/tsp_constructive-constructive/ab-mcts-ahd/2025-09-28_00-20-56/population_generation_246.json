[
     {
          "algorithm": "The algorithm selects the next node by calculating a combined score for each unvisited node, prioritizing nodes with a favorable remaining distance to the destination relative to the current distance, while also penalizing nodes that have high average subsequent distances to other unvisited nodes. This encourages balanced exploration and reduced future travel costs. Additionally, it directly chooses the destination node if the remaining distance to it is significantly shorter than the best calculated score.",
          "thought": "The new algorithm prioritizes nodes based on a combined score that includes a weighted ratio of remaining distance to the destination over current distance, enhanced by a penalty for nodes that lead to high subsequent distances, encouraging balanced exploration and reduced future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        \n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n        \n        future_distance = sum(distance_matrix[node][neighbor] for neighbor in unvisited_nodes if neighbor != node)\n        if future_distance == 0:\n            future_penalty = 0\n        else:\n            future_penalty = future_distance / len(unvisited_nodes)\n        \n        score = ratio - 0.5 * future_penalty\n        \n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_score * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.86954,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with the highest ratio of remaining distance to destination (from the candidate node) over the current distance (from the current node), balancing exploration and destination proximity. It defaults to the destination node if its direct distance is \u226490% of the best ratio, ensuring efficiency and flexibility. The heuristic emphasizes maximizing the ratio while occasionally overriding to the destination for optimal path efficiency.",
          "thought": "The new algorithm prioritizes nodes with the highest ratio of remaining distance to the current node's distance, balancing exploration and destination proximity, and uses a more flexible threshold (90%) for destination prioritization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_ratio = -1\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        if current_distance == 0:\n            ratio = float('inf')\n        else:\n            ratio = remaining_distance / current_distance\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        if direct_distance <= best_ratio * 0.9:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by calculating a weighted distance that balances the current distance to the node and the exponential decay-adjusted remaining distance to the destination. It uses an average shortest path to the destination as a dynamic threshold, prioritizing nodes closer to the destination earlier in the journey. The algorithm also directly considers the destination if it is within a dynamic threshold of the current node, ensuring an early return if possible.",
          "thought": "The new algorithm introduces a dynamic threshold based on the average shortest path to the destination from unvisited nodes and uses an exponential decay factor to prioritize nodes closer to the destination earlier in the journey.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate average shortest path to destination from unvisited nodes\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        remaining_distance = distance_matrix[node][destination_node]\n        # Introduce an exponential decay factor\n        total_distance = current_distance + remaining_distance * (avg_remaining_distance / remaining_distance) ** 2\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    # Prioritize destination if it's unvisited and the path to it is within a dynamic threshold\n    if destination_node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][destination_node]\n        dynamic_threshold = avg_remaining_distance * 0.8\n        if direct_distance <= dynamic_threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.98744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a 2-step lookahead mechanism to balance short-term proximity and long-term optimization, prioritizing nodes that minimize immediate distance while also considering their potential impact on reaching the destination efficiently. The decision-making process dynamically weighs the current distance to a node against the total travel distance including a subsequent node chosen by the lookahead, with the weight adjusted based on the node's proximity to the destination. The function `select_next_node` evaluates each unvisited node using this balanced heuristic to determine the optimal next step in the tour.",
          "thought": "The new algorithm combines the nearest-neighbor selection with a 2-step lookahead mechanism, prioritizing immediate distance and the best 2-step path using a dynamic weighting based on the node's proximity to the destination to balance short-term proximity and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n        else:\n            lookahead_dist = distance_matrix[node][destination_node]\n        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5\n        return (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 6.9984,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP by balancing the immediate distance from the current node with a strategically weighted future distance to the destination node, using a dynamic weighting based on Euclidean distance. Specifically, it calculates an evaluation score for each unvisited node that combines the current distance with an estimated lookahead distance, prioritizing paths that are both short-term efficient and strategically advantageous. The Euclidean weight adjusts this balance, giving more importance to nodes closer to the destination while still considering the direct path distance.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism based on the Euclidean distance to the destination node to balance short-term distance and long-term strategic path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        lookahead_dist = min([distance_matrix[node][n] + distance_matrix[n][destination_node] for n in unvisited_nodes])\n        euclidean_weight = (distance_matrix[node][destination_node] / sum(distance_matrix[node])) * 0.5\n        return (1 - euclidean_weight) * current_dist + euclidean_weight * lookahead_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.00115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node, but if the destination node is still unvisited and within 1.5 times the distance to the nearest node, it overrides the selection to ensure progress toward the destination. The function balances proximity and destination prioritization using a distance threshold.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and within a certain threshold distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:  # Threshold to balance proximity and destination\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamic lookahead mechanism, prioritizing immediate distance (100% weight) while balancing it with a weighted lookahead distance to the destination (50% weight). The lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination, ensuring the algorithm adapts to the remaining path length dynamically. The `evaluate_node` function calculates a weighted sum of immediate and adjusted lookahead distances, and the next node is selected as the one minimizing this sum.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic lookahead mechanism that balances immediate distance (100% weight) and a weighted lookahead distance to the destination (50% weight), where the lookahead distance is adjusted by an exponential decay factor based on the average remaining distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate average shortest path to destination from unvisited nodes\n    total_remaining_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_remaining_distance = total_remaining_distance / len(unvisited_nodes)\n\n    def evaluate_node(node):\n        # Immediate distance\n        current_dist = distance_matrix[current_node][node]\n        # Lookahead distance with exponential decay adjustment\n        remaining_dist = distance_matrix[node][destination_node]\n        adjusted_remaining_dist = remaining_dist * (avg_remaining_distance / remaining_dist) ** 2\n        # Combine immediate and adjusted lookahead distances\n        return current_dist + 0.5 * adjusted_remaining_dist\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.06854,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity prioritization with a dynamic lookahead factor to select the next node in the TSP. It calculates a normalized score for each unvisited node, balancing immediate and future travel costs, and selects the node with the lowest score. Additionally, it prioritizes the destination node if it\u2019s unvisited and within a reasonable distance from the current node.",
          "thought": "Common ideas: Dynamic weighting, lookahead, and balanced proximity-prioritization. Design idea: Combine No.2's proximity prioritization with a dynamic lookahead factor inspired by No.1 to balance immediate and future costs better.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    weight_factor = 1.0 / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n\n        if remaining_nodes:\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            normalized_score = (current_dist + weight_factor * lookahead_dist) / (1 + weight_factor)\n        else:\n            normalized_score = current_dist + distance_matrix[node][destination_node]\n\n        if normalized_score < min_distance:\n            min_distance = normalized_score\n            next_node = node\n\n    # Prioritize destination node if it's unvisited and within a reasonable distance\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance <= min_distance * 1.5:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.07254,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamic 2-step lookahead, prioritizing immediate distance (100% weight) while adaptively weighting the best 2-step path (0.5/remaining_nodes) to balance short-term and long-term optimization. The destination node receives an 80% weight reduction to encourage early selection, and the lookahead factor scales inversely with remaining nodes to adjust flexibility. The code evaluates nodes by combining direct distance and a weighted 2-step lookahead, then selects the node with the minimal combined score.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic lookahead mechanism that balances immediate distance (100% weight) and the best 2-step path (adaptive weight based on remaining nodes) to optimize both short-term proximity and long-term performance, while also incorporating a prioritization of the destination node when it is unvisited and within a reasonable distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n            lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n            weight_factor = 0.5 / len(unvisited_nodes)\n            combined_score = current_dist + weight_factor * lookahead_dist\n        else:\n            combined_score = current_dist + distance_matrix[node][destination_node]\n\n        if node == destination_node:\n            combined_score *= 0.8\n        return combined_score\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.08377,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future lookahead by adjusting weights based on remaining unvisited nodes, prioritizing nodes with better local connectivity while using a normalized scoring system to maintain optimization. It evaluates each candidate node by combining its direct distance from the current node with a weighted lookahead estimate to the destination, dynamically adjusting the weight factor to reflect the remaining problem size. The structure ensures that nodes with shorter term gains and better long-term potential are favored, with the weight factor decreasing as the problem shrinks, refining the decision-making process.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weighting mechanism that adjusts the influence of immediate distance and lookahead based on the remaining unvisited nodes, using a heuristic that prioritizes nodes with better local connectivity while maintaining a balance between short-term and long-term optimization through a normalized scoring system.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n\n        if not remaining_nodes:\n            return current_dist + distance_matrix[node][destination_node]\n\n        # Dynamic weighting factor based on remaining nodes\n        weight_factor = 1.0 / len(remaining_nodes)\n\n        # Evaluate best 2-step path with dynamic weight\n        best_lookahead = min(remaining_nodes, key=lambda n: distance_matrix[node][n] + distance_matrix[n][destination_node])\n        lookahead_dist = distance_matrix[node][best_lookahead] + distance_matrix[best_lookahead][destination_node]\n\n        # Normalized scoring with dynamic weight\n        normalized_score = (current_dist + weight_factor * lookahead_dist) / (1 + weight_factor)\n        return normalized_score\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 7.09763,
          "other_inf": null
     }
]