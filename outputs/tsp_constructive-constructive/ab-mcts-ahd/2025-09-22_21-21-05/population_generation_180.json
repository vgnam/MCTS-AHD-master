[
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality measures, prioritizing nodes that balance short-term distance (distance from current node) with long-term centrality (average distance to other unvisited nodes). The weight for centrality decreases as the tour progresses (via `weight = 0.5 * (total_unvisited / (total_unvisited + 1))`), while the combined score favors nodes with shorter immediate distances and better centrality. The final selection is based on a normalized score, where centrality contributes 40% and immediate distance 60% of the weight.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the centrality measure of No.1, prioritizing nodes that balance short-term distance with long-term centrality, where the centrality weight decreases as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 0.5 * (total_unvisited / (total_unvisited + 1))\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_weight = weight * 0.6 + centrality_factor * 0.4\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88765,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes destination proximity (weighted by `heuristic_factor = 0.5`) while heavily penalizing revisits (memory factor of `+0.2` per visit) and encouraging moderate-distance exploration (via `exploration_bonus = 0.8`). The score combines these factors to select the next node, balancing immediate distance, destination alignment, and exploration.",
          "thought": "The new algorithm prioritizes destination proximity more aggressively (heuristic factor 0.5) and uses higher memory penalties (0.2 per visit) to strongly discourage revisits, while also introducing a dynamic exploration bonus for nodes with moderate distances to encourage balanced exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    heuristic_factor = 0.5\n    memory = {}\n    exploration_bonus = 0.8\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if node == destination_node:\n            weighted_score = distance_to_current * (1 - heuristic_factor)\n        else:\n            weighted_score = distance_to_current * (1 + heuristic_factor)\n\n        memory_factor = 1 + 0.2 * memory.get(node, 0)\n        exploration_factor = 1 - (distance_to_destination / max(distance_matrix[node])) * exploration_bonus\n        score = weighted_score * memory_factor * exploration_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    memory[next_node] = memory.get(next_node, 0) + 1\n    return next_node",
          "objective": 6.93514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted combination of proximity to the destination and centrality in the remaining graph. It prioritizes central nodes (those with low average distance to other unvisited nodes) with a 30% weight, while the remaining 70% weight adjusts dynamically based on the number of unvisited nodes to ensure exploration. The score function combines these factors to find the most promising next node, favoring nodes that reduce path length while encouraging centrality.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting scheme that combines immediate distance with both destination proximity and a novel \"exploration factor\" based on node centrality, which encourages visiting nodes that are central in the remaining graph to reduce total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    # Calculate average distance to all unvisited nodes for centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))  # Avoid division by zero\n        combined_weight = weight * 0.7 + centrality_factor * 0.3\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate proximity to the current node and long-term efficiency toward the destination, using a dynamic weight that decreases as unvisited nodes decrease, while penalizing revisits to recently visited nodes to avoid cycles. The `combined_score` prioritizes proximity (`distance_to_current`) over future efficiency (`distance_to_destination`) with a weight that adjusts dynamically, and a penalty discourages revisiting nodes. The `penalty` is higher for recently visited nodes, ensuring the algorithm avoids cycles.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between immediate proximity and long-term path efficiency, while also penalizing revisits to recently visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 0.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        penalty = 1.0 if node in unvisited_nodes else 1.5\n        combined_score = (distance_to_current + dynamic_weight * distance_to_destination) * penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local optimization (minimizing distance from the current node) and global optimization (minimizing distance to the destination) by dynamically weighting the two distances. The weight for the current distance decreases as the number of unvisited nodes decreases, while the weight for the destination distance increases, ensuring the algorithm prioritizes proximity to the current node early on and gradually shifts toward minimizing the total path length.",
          "thought": "The new algorithm prioritizes minimizing the immediate distance to the current node while considering the remaining path length to the destination, using a dynamic weight that increases with the number of unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_current = remaining_nodes / (remaining_nodes + 1)\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance (prioritizing shorter-term gains) and a growing weight for destination proximity (focusing on long-term goals), while penalizing frequently revisited nodes to avoid local optima. The memory factor adjusts weights based on past selections, and the `immediate_weight` and `destination_weight` are inversely proportional, ensuring the algorithm adapts to remaining unvisited nodes. The score combines these factors to select the next node, with memory updated to influence future choices.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance and a growing weight for destination proximity, while also incorporating a memory factor based on past selections to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    if memory is None:\n        memory = {}\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weights with memory influence\n        immediate_weight = 0.8 * (total_unvisited / (total_unvisited + 1)) + 0.2 * (1 - memory.get(node, 0))\n        destination_weight = 1 - immediate_weight\n\n        # Memory factor to avoid revisiting poor choices\n        memory_factor = 1 + 0.1 * memory.get(node, 0)\n\n        score = (immediate_weight * distance_to_current + destination_weight * distance_to_destination) * memory_factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # Update memory for the selected node\n    memory[next_node] = memory.get(next_node, 0) + 1\n\n    return next_node",
          "objective": 7.15296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance from the current node and long-term potential (proximity to the destination), using a dynamic weight adjustment that prioritizes immediate distance when few nodes remain. It normalizes scores using the distance matrix to avoid bias, with weights favoring proximity when nodes are scarce. The function iterates through unvisited nodes, calculates a weighted score, and returns the node with the lowest score.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining nodes' proximity to the destination, favoring nodes that balance immediate distance and potential future path efficiency through a normalized scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        remaining_nodes = len(unvisited_nodes)\n        weight = 0.5 if remaining_nodes > 1 else 0.8  # Prioritize proximity as fewer nodes remain\n\n        # Normalized score to balance immediate and long-term distance\n        normalized_score = (distance_to_current / max(1, sum(distance_matrix[current_node]))) * weight + \\\n                          (distance_to_destination / max(1, sum(distance_matrix[node]))) * (1 - weight)\n\n        if normalized_score < best_score:\n            best_score = normalized_score\n            next_node = node\n\n    return next_node",
          "objective": 7.19276,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance to the current node and the weighted future distance to the destination, where the weight factor decreases as more nodes are visited, prioritizing immediate efficiency early on and long-term optimization later. The weight factor is calculated as `max(0.1, 0.5 * (remaining_nodes / total_nodes))`, ensuring a minimum weight of 0.1 to avoid excessive bias. The `combined_score` combines the current distance and the weighted future distance, with the best-scoring node chosen iteratively.",
          "thought": "The new algorithm modifies the selection criteria by introducing a dynamic weight factor that adjusts based on the remaining number of unvisited nodes, ensuring a balance between immediate efficiency and long-term path optimization, while also incorporating a penalty for revisiting nodes that were previously considered but not chosen.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (remaining_nodes / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + weight_factor * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.20128,
          "other_inf": null
     }
]