[
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic destination bias and centrality-based node evaluation. It prioritizes nodes closer to the current node while adjusting selection based on the fraction of remaining nodes (destination bias) and node centrality (average distance to unvisited nodes). The `destination_bias` increases as the tour progresses, favoring the destination node, while `centrality_factor` (weighted by 0.3) encourages selecting nodes with lower average distances to other unvisited nodes. The combined score balances distance and centrality, dynamically shifting focus between exploration and exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic destination bias and centrality-based selection inspired by No.1, where the centrality is adjusted by the fraction of remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.41797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local distance optimization** (via dynamic penalties) with **global centrality consideration** (weighted by centrality factors) to balance immediate and long-term path efficiency. It prioritizes **distance penalties** (scaled by remaining nodes) over **centrality factors** (weighted by 0.5) to select the next node, ensuring both short-term proximity and strategic node selection. The dynamic penalty adjusts based on unvisited nodes, while centrality balances by normalizing average distances across candidates.",
          "thought": "The new algorithm combines the balanced approach of No.1 (using centrality and dynamic penalties) with the efficiency of No.2 (weighted distance calculation), selecting nodes that minimize a combined score of immediate distance, weighted centrality, and a dynamic penalty based on remaining nodes to ensure both local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5  # Balanced weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43339,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, destination proximity, and exploration bonuses, with weights adjusted based on the number of unvisited nodes and the current node's centrality. It prioritizes minimizing the distance to the current node while also considering the node's closeness to the destination and encouraging less traversed paths, with the exploration bonus given lower weight (0.1) compared to the other factors. The centrality of the current node and the number of unvisited nodes influence the dynamic weight (0.3 and 0.2 respectively), shaping the trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance, destination proximity, and a novel \"exploration bonus\" that encourages visiting less frequently traversed paths, with weights that evolve based on the number of unvisited nodes and the current node's centrality in the graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on unvisited nodes and centrality\n        weight = 0.3 * (1 / (1 + 0.05 * total_unvisited)) + 0.2 * centrality\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight * distance_to_destination + 0.1 * exploration_bonus\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.53939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global proximity by adjusting weights based on the number of unvisited nodes: early in the search, it prioritizes proximity to the current node (`weight_current = 2.0 - visited_ratio`), while later it shifts focus to proximity to the destination (`weight_destination = 0.5 * visited_ratio`). It also penalizes nodes with many nearby unvisited neighbors (`penalty` term) to avoid revisiting regions, ensuring a trade-off between immediate and long-term optimization. The best node is selected based on the lowest weighted score combining these factors.",
          "thought": "The new algorithm prioritizes local proximity early in the search while gradually shifting focus to global proximity, using a dynamic weight adjustment based on the number of unvisited nodes and incorporating a penalty for nodes with many nearby unvisited neighbors to prevent revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node (weighted higher early) and proximity to the destination (weighted higher later) while penalizing nodes with high average distances to remaining unvisited nodes. It adjusts weights inversely with remaining nodes (current priority decreases, destination priority increases) and applies a penalty to discourage detours. The scoring mechanism prioritizes closer nodes early but gradually shifts focus toward the destination.",
          "thought": "The new algorithm combines the proximity prioritization of No.1 (closer nodes get higher scores) with the dynamic weight adjustment and penalty mechanism of No.2 (balancing current and destination proximity while penalizing detours). It dynamically adjusts weights for current and destination proximity, prioritizes closer nodes early, and penalizes nodes with high average distances to remaining unvisited nodes to optimize the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = 0.7 - (0.1 * (remaining_nodes / (remaining_nodes + 1)))\n    weight_destination = 0.3 + (0.1 * (remaining_nodes / (remaining_nodes + 1)))\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        avg_distance_to_unvisited = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        penalty = 0.2 * avg_distance_to_unvisited\n\n        combined_score = (weight_current * (-distance_to_current)) + (weight_destination * distance_to_destination) - penalty\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64214,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization (weighted by `weight`) with destination proximity (weighted by `weight_destination`), dynamically adjusting weights based on progress. It also penalizes nodes with nearby unvisited neighbors to avoid detours, with penalties increasing as the algorithm progresses. Early in the search, local optimization (distance to current node) dominates, while later stages emphasize global optimization (distance to destination). The `penalty` term discourages revisiting nearby nodes, especially as the tour progresses.",
          "thought": "The new algorithm combines the high weight on immediate distance from No.2 with the dynamic weight adjustment and destination proximity emphasis from No.1, while also incorporating a penalty for nearby revisits to avoid detours. It prioritizes local optimization early (high weight on distance_to_current) and balances with global considerations (weighted destination proximity and dynamic penalty) as progress increases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_count = len(unvisited_nodes)\n    progress = (total_nodes - remaining_count) / total_nodes\n    weight = 0.5 * (1 - progress)\n    weight_destination = progress\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64346,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing both remaining nodes and path length) with exploration bonuses (favoring less traversed paths) and centrality considerations (preferring nodes with high centrality in the graph), balancing short-term and long-term optimization while dynamically adjusting weights based on the remaining nodes and current path length. The code prioritizes minimizing immediate distance (`-distance_to_current`), balancing long-term destination proximity (`weight_factor * distance_to_destination`), and adding small bonuses for exploration and centrality (`exploration_bonus` and `centrality`). The dynamic `weight_factor` scales with remaining nodes and path length, while fixed weights (0.1) are applied to exploration and centrality terms.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes and path length (inspired by No.2) with exploration bonuses and centrality considerations (inspired by No.1) to balance short-term and long-term optimization while encouraging less traversed paths.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    path_length = sum(distance_matrix[current_node][destination_node] for _ in range(remaining_nodes))\n\n    # Dynamic weight factor with logarithmic scaling and path length consideration\n    weight_factor = max(0.1, 0.5 * (math.log(remaining_nodes + 1) / math.log(total_nodes + 1)) + 0.2 * (path_length / total_nodes))\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / total_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight_factor * distance_to_destination + 0.1 * exploration_bonus + 0.1 * centrality\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64359,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and long-term path potential by scaling exploration with the square root of remaining nodes, penalizing nodes too close to the current node to encourage diversity, and prioritizing nodes that minimize distance to the destination while maximizing average distance to unvisited nodes. The exploration factor (`exploration_factor`) increases with fewer remaining nodes, while the penalty (`penalty`) discourages revisiting nearby nodes, and the combined score (`combined_score`) integrates these factors to select the next node.",
          "thought": "The new algorithm modifies the selection process by incorporating a dynamic exploration factor that scales with the square root of remaining nodes, while using a probabilistic approach to balance immediate distance and long-term path potential, with penalties for nodes that are too close to encourage diversity in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    num_unvisited = len(unvisited_nodes)\n    exploration_factor = (num_unvisited ** 0.5) / (num_unvisited + 1)  # Dynamic exploration scaling\n    penalty_threshold = 0.3 * sum(distance_matrix[0]) / len(distance_matrix)  # Adjusted penalty threshold\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / num_unvisited if num_unvisited else 0\n\n        # Probabilistic penalty for close nodes\n        penalty = 1.5 if distance_to_current < penalty_threshold else 1.0\n\n        # Balanced score combining immediate and long-term potential\n        combined_score = (distance_to_destination + exploration_factor * avg_distance_to_remaining) / (distance_to_current + 1e-6) * penalty\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64876,
          "other_inf": null
     }
]