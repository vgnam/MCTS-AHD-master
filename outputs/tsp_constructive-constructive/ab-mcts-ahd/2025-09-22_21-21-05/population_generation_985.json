[
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic destination bias and centrality-based node evaluation. It prioritizes nodes closer to the current node while adjusting selection based on the fraction of remaining nodes (destination bias) and node centrality (average distance to unvisited nodes). The `destination_bias` increases as the tour progresses, favoring the destination node, while `centrality_factor` (weighted by 0.3) encourages selecting nodes with lower average distances to other unvisited nodes. The combined score balances distance and centrality, dynamically shifting focus between exploration and exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic destination bias and centrality-based selection inspired by No.1, where the centrality is adjusted by the fraction of remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.41797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimization by dynamically weighting the distance from the current node and the distance to the destination, while also favoring nodes with high centrality (low average distance to unvisited nodes). The weight for the remaining unvisited nodes (`remaining_nodes_factor`) decreases as more nodes are visited, prioritizing local decisions early and global decisions later. The centrality factor (`centrality_factor`) further refines choices by favoring nodes well-connected to unvisited nodes, with a fixed `weight_factor` (0.3) balancing its influence.",
          "thought": "The new algorithm combines the dynamic balance of local and global optimization from No.2 with the centrality-based node evaluation from No.1, using a smoothly transitioning weight that incorporates both distance to current and destination nodes while favoring nodes with lower average distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    if remaining_unvisited == 0:\n        return destination_node\n\n    remaining_nodes_factor = 1.0 / (remaining_unvisited ** 2)\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        weight = remaining_nodes_factor\n\n        combined_score = (1 - weight) * distance_to_current + weight * distance_to_destination + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local distance optimization** (via dynamic penalties) with **global centrality consideration** (weighted by centrality factors) to balance immediate and long-term path efficiency. It prioritizes **distance penalties** (scaled by remaining nodes) over **centrality factors** (weighted by 0.5) to select the next node, ensuring both short-term proximity and strategic node selection. The dynamic penalty adjusts based on unvisited nodes, while centrality balances by normalizing average distances across candidates.",
          "thought": "The new algorithm combines the balanced approach of No.1 (using centrality and dynamic penalties) with the efficiency of No.2 (weighted distance calculation), selecting nodes that minimize a combined score of immediate distance, weighted centrality, and a dynamic penalty based on remaining nodes to ensure both local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5  # Balanced weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43339,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors, while penalizing nodes with many nearby unvisited neighbors to avoid revisiting regions. It dynamically adjusts weights based on the visited ratio and remaining nodes, balancing local (distance to current node) and global (distance to destination) considerations, with centrality and penalty terms to guide selection. The best candidate is chosen based on a combined score, with ties resolved randomly.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors from No.2, while adding a penalty for nodes with many nearby unvisited neighbors to avoid revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n    centrality_weight = 0.5\n\n    remaining_nodes = len(unvisited_nodes)\n    time_decay = 0.9 ** (remaining_nodes - 1) if remaining_nodes > 0 else 0.5\n    dynamic_weight = time_decay * (1.0 / (remaining_nodes + 1))\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    best_score = float('inf')\n    candidates = []\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        combined_score = (weight_current * distance_to_current + weight_destination * distance_to_destination + centrality_weight * centrality_factor + penalty) * dynamic_weight\n\n        if combined_score < best_score:\n            best_score = combined_score\n            candidates = [node]\n        elif combined_score == best_score:\n            candidates.append(node)\n\n    if candidates:\n        next_node = np.random.choice(candidates) if len(candidates) > 1 else candidates[0]\n        return next_node\n    else:\n        return next_node",
          "objective": 6.48933,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, destination proximity, and exploration bonuses, with weights adjusted based on the number of unvisited nodes and the current node's centrality. It prioritizes minimizing the distance to the current node while also considering the node's closeness to the destination and encouraging less traversed paths, with the exploration bonus given lower weight (0.1) compared to the other factors. The centrality of the current node and the number of unvisited nodes influence the dynamic weight (0.3 and 0.2 respectively), shaping the trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance, destination proximity, and a novel \"exploration bonus\" that encourages visiting less frequently traversed paths, with weights that evolve based on the number of unvisited nodes and the current node's centrality in the graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on unvisited nodes and centrality\n        weight = 0.3 * (1 / (1 + 0.05 * total_unvisited)) + 0.2 * centrality\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight * distance_to_destination + 0.1 * exploration_bonus\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.53939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance minimization (prioritized by `distance_to_current`) with centrality consideration (weighted by `weight_factor` and `centrality_factor`), where centrality's influence grows as the tour progresses (via `weight_factor = 0.3 * (1 - remaining_nodes / total_nodes)`). Centrality is measured by how close a node's average distance to others is to the overall average, with nodes closer to the average given higher priority. The weight of centrality increases as fewer nodes remain unvisited, ensuring the tour becomes more \"centralized\" toward the end.",
          "thought": "The new algorithm combines the immediate distance minimization from No.2 with dynamic centrality consideration inspired by No.1, using a weighted sum where centrality's influence grows as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3 * (1 - (remaining_nodes / len(distance_matrix)))  # Dynamic weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.61128,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global proximity by adjusting weights based on the number of unvisited nodes: early in the search, it prioritizes proximity to the current node (`weight_current = 2.0 - visited_ratio`), while later it shifts focus to proximity to the destination (`weight_destination = 0.5 * visited_ratio`). It also penalizes nodes with many nearby unvisited neighbors (`penalty` term) to avoid revisiting regions, ensuring a trade-off between immediate and long-term optimization. The best node is selected based on the lowest weighted score combining these factors.",
          "thought": "The new algorithm prioritizes local proximity early in the search while gradually shifting focus to global proximity, using a dynamic weight adjustment based on the number of unvisited nodes and incorporating a penalty for nodes with many nearby unvisited neighbors to prevent revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (current node) and global (destination node) distances, adjusting weights based on the visited ratio, while incorporating centrality (weighted 0.4) and distance penalties to prioritize nodes that are both locally efficient and globally strategic, with penalties increasing as fewer nodes remain. Current distances are prioritized early (higher weight), while destination distances and centrality become more influential as the tour progresses. The centrality factor (1 - normalized average distance) ensures nodes are chosen for strategic positioning, and penalties dynamically discourage long detours as the tour nears completion.",
          "thought": "The new algorithm combines dynamic weighting of current and destination distances (adjusting weights based on visited ratio) with a centrality consideration (weighted by 0.4) to balance local and global efficiency, while dynamically penalizing distances based on remaining nodes to prioritize strategic node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_centrality = 0.4\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / total_nodes))\n        combined_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + weight_centrality * centrality_factor + distance_penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.6226,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     }
]