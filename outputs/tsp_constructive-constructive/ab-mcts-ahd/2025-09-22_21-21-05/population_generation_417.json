[
     {
          "algorithm": "The algorithm dynamically balances local and global proximity by adjusting weights based on the number of unvisited nodes: early in the search, it prioritizes proximity to the current node (`weight_current = 2.0 - visited_ratio`), while later it shifts focus to proximity to the destination (`weight_destination = 0.5 * visited_ratio`). It also penalizes nodes with many nearby unvisited neighbors (`penalty` term) to avoid revisiting regions, ensuring a trade-off between immediate and long-term optimization. The best node is selected based on the lowest weighted score combining these factors.",
          "thought": "The new algorithm prioritizes local proximity early in the search while gradually shifting focus to global proximity, using a dynamic weight adjustment based on the number of unvisited nodes and incorporating a penalty for nodes with many nearby unvisited neighbors to prevent revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with a ratio-based balance, selecting the next node by minimizing a score that adds the direct distance from the current node to a candidate node and a ratio of that distance to the candidate's distance to the destination. This balances short-term efficiency (distance to current node) with long-term efficiency (distance to destination), ensuring a trade-off between immediate and future steps. The ratio term helps avoid getting stuck in local optima by considering the candidate's proximity to the final destination.",
          "thought": "The new algorithm combines the ideas of prioritizing immediate distance (like No.2) while incorporating a ratio-based balance (like No.1) for better efficiency. It calculates a score as the immediate distance plus a weighted ratio of the distance to the destination, ensuring a trade-off between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        combined_score = distance_to_current + ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: minimizing the distance from the current node (weighted heavily when few nodes remain) and minimizing the ratio of current distance to destination distance (weighted more when many nodes remain). The weights adjust dynamically based on the number of unvisited nodes, ensuring a trade-off between local and global optimization. The function evaluates each unvisited node using this weighted sum and returns the one with the lowest score.",
          "thought": "The new algorithm combines the ratio-based balance from No.1 (avoiding local optima by considering distance to destination) with No.2's dynamic weighting (adjusting trade-off based on remaining nodes). It selects the next node by minimizing a weighted sum of the distance to the current node and a ratio of that distance to the distance to the destination, with weights inversely proportional to the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * ratio)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.6832,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weighted heavily early) and proximity to the destination (weighted more heavily later), using an exponential decay factor. It also penalizes nodes with many nearby unvisited neighbors to encourage exploration of less crowded regions, with weights dynamically adjusted based on the visited ratio. The weighted score combines these factors to prioritize efficient local moves early and strategic destination approaches later.",
          "thought": "The new algorithm modifies the original by using an exponential decay factor for weights, increasing destination proximity influence early, and adding a bonus for nodes with few nearby unvisited neighbors to encourage exploration of less crowded regions while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    decay_factor = 0.5\n    weight_current = (1.0 - visited_ratio) ** decay_factor\n    weight_destination = visited_ratio ** (1.0 / decay_factor)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        bonus = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] > distance_to_current * 1.5:\n                bonus -= 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + bonus\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70376,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between minimizing immediate travel distance (weighted by `weight_current`) and prioritizing proximity to the destination (weighted by `weight_destination`), while penalizing nodes with densely clustered unvisited neighbors. Centrality (average distance to unvisited nodes) is also factored in, with higher weights given to early-stage decisions (via `visited_ratio`). The code iterates through unvisited nodes, computes a weighted score combining these factors, and selects the node with the lowest score.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts based on the node's centrality (measured by average distance to all unvisited nodes) and a penalty for nodes with high clustering of unvisited neighbors, while also incorporating a progressive bias toward destination proximity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.15\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + (0.3 * centrality) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.71852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (with decreasing priority as the tour progresses) and proximity to the destination (with increasing priority), while penalizing nodes in dense local regions and accounting for connectivity to unvisited nodes. The weighted scoring mechanism prioritizes direct distances early, gradually shifting toward destination proximity, with local density and connectivity acting as secondary and tertiary factors respectively. The weights (`weight_current` and `weight_destination`) dynamically adjust based on tour completion ratio, and the penalty and predictive factor refine selection by discouraging isolated or poorly connected nodes.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic penalty based on both the node's local density and its potential impact on future path optimality, using a novel scoring mechanism that combines direct distances with a predictive factor derived from unvisited node connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate local density penalty\n        local_density = sum(1 for neighbor in unvisited_nodes if distance_matrix[node][neighbor] < distance_to_current * 1.2)\n        penalty = 0.2 * local_density\n\n        # Calculate predictive factor based on connectivity\n        predictive_factor = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty + (0.3 * predictive_factor)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.76316,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm dynamically balances local and global optimization by combining immediate distance to the current node with an exploration potential metric, weighted by a decaying factor. The exploration potential prioritizes nodes closer to the destination while accounting for average distances, with the decaying factor reducing exploration emphasis as the number of unvisited nodes decreases. The algorithm selects the next node by minimizing a combined score of direct distance and exploration-adjusted potential, ensuring a trade-off between proximity and long-term path efficiency.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance with a novel \"exploration potential\" metric, where nodes are scored based on the ratio of their distance to the current node and the average distance to the destination, weighted by a decaying exploration factor that balances local and global optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 0.8 ** (1 / (remaining_nodes + 1))  # Decays from 0.8 to ~0.5\n    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        exploration_potential = (distance_to_current / (distance_to_destination + 1e-6)) * exploration_factor\n        combined_score = distance_to_current + exploration_potential * avg_distance_to_dest\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.81616,
          "other_inf": null
     }
]