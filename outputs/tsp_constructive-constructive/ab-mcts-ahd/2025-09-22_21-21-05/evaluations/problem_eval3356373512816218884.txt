def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('inf')
    next_node = None
    num_unvisited = len(unvisited_nodes)
    temperature = 0.5 * (num_unvisited / (num_unvisited + 1))  # Temperature for probabilistic selection
    penalty_threshold = 0.15 * sum(distance_matrix[0]) / len(distance_matrix)  # Adjusted penalty threshold
    history_penalty = 0.2  # Penalty for recently visited nodes

    # Track visited nodes (simplified for this example)
    visited_history = set()

    scores = []
    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / num_unvisited if num_unvisited else 0

        # Penalty for nodes too close to current node
        proximity_penalty = 1.0 if distance_to_current < penalty_threshold else 1.0
        # Additional penalty for recently visited nodes
        history_penalty_factor = 1.0 + history_penalty if node in visited_history else 1.0

        combined_score = (distance_to_current + distance_to_destination + temperature * avg_distance_to_remaining) * proximity_penalty * history_penalty_factor
        scores.append(combined_score)

    # Probabilistic selection based on scores
    if scores:
        min_score = min(scores)
        max_score = max(scores)
        normalized_scores = [(max_score - s + 1e-6) / (max_score - min_score + 1e-6) for s in scores]  # Avoid division by zero
        probabilities = [s / sum(normalized_scores) for s in normalized_scores]
        next_node = np.random.choice(unvisited_nodes, p=probabilities)

    return next_node
