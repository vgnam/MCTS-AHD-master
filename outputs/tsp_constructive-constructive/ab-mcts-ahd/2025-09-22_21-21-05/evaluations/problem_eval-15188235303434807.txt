def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_distance = float('inf')
    next_node = None
    candidate_nodes = []

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if distance < min_distance:
            min_distance = distance
            next_node = node
        candidate_nodes.append((node, distance))

    if destination_node in unvisited_nodes:
        remaining_ratio = len(unvisited_nodes) / len(distance_matrix)
        decay_factor = 0.5 ** (1 - remaining_ratio)
        dynamic_threshold = decay_factor * distance_matrix[current_node][destination_node]

        if distance_matrix[current_node][destination_node] <= dynamic_threshold:
            next_node = destination_node
        else:
            # Add probabilistic exploration
            if len(unvisited_nodes) > 2 and remaining_ratio < 0.3:
                candidate_nodes = [n for n in candidate_nodes if n[0] != destination_node]
                if candidate_nodes:
                    next_node = min(candidate_nodes, key=lambda x: x[1])[0]

    return next_node
