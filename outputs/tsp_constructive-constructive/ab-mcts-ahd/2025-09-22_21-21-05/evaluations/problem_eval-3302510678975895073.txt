def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    phase_factor = 1 - (total_unvisited / (total_unvisited + 1))  # 0 to 1 as tour progresses
    phase_threshold = 0.5  # Transition point between early and late phases

    best_score = float('inf')
    next_node = None

    # Precompute centrality metrics
    centrality_scores = []
    for node in unvisited_nodes:
        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited
        centrality_scores.append(avg_dist)

    min_centrality = min(centrality_scores) if centrality_scores else 0
    max_centrality = max(centrality_scores) if centrality_scores else 1

    for i, node in enumerate(unvisited_nodes):
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Dynamic weights based on phase
        if phase_factor < phase_threshold:  # Early phase: focus on immediate distance
            distance_weight = 0.8 - 0.3 * phase_factor
            centrality_weight = 0.2 + 0.3 * phase_factor
        else:  # Late phase: focus on centrality
            distance_weight = 0.3 * (1 - phase_factor)
            centrality_weight = 0.7 + 0.3 * phase_factor

        # Normalized centrality factor (0 to 1)
        if max_centrality != min_centrality:
            normalized_centrality = (centrality_scores[i] - min_centrality) / (max_centrality - min_centrality)
        else:
            normalized_centrality = 0.5  # Neutral if all equal

        # Phase-specific scoring
        if phase_factor < phase_threshold:
            combined_score = (distance_weight * distance_to_current +
                            centrality_weight * (1 - normalized_centrality) * distance_to_destination)
        else:
            combined_score = (distance_weight * distance_to_current +
                           centrality_weight * normalized_centrality * distance_to_destination)

        if combined_score < best_score:
            best_score = combined_score
            next_node = node

    return next_node
