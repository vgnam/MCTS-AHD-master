importance" factor, which is calculated as the average distance from the node to all other unvisited nodes. This factor helps in identifying critical nodes that serve as good hubs, balancing proximity and centrality in the selection process. The weight for the current node is adjusted based on the remaining nodes, while the weight for the destination remains inversely proportional to the importance factor, ensuring a smooth transition between local and global planning.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Calculate node importance: average distance to all other unvisited nodes
        importance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0

        # Dynamic weights: current node prioritized when few nodes remain, importance considered otherwise
        weight_current = 1.0 / (remaining_nodes ** 2)
        weight_destination = (1.0 - weight_current) * (1.0 / (1 + importance))

        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)

        if weighted_score < best_score:
            best_score = weighted_score
            next_node = node

    return next_node
