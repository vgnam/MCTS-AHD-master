def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    num_unvisited = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    exploration_rate = 0.2 * (num_unvisited / total_nodes)  # Dynamic exploration rate
    exploitation_weight = 1.0 - exploration_rate  # Exploitation weight

    # Dynamic threshold for penalizing nodes too close to current node
    proximity_threshold = 0.2 * sum(distance_matrix[current_node]) / total_nodes

    # Calculate node rewards and penalties
    rewards = []
    total_reward = 0.0
    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / num_unvisited if num_unvisited else 0

        # Immediate reward (exploitation)
        immediate_reward = -distance_to_current - 0.5 * distance_to_destination

        # Long-term reward (exploration)
        long_term_reward = -avg_distance_to_remaining

        # Proximity penalty
        proximity_penalty = 0.0 if distance_to_current > proximity_threshold else -0.5 * distance_to_current

        # Combined reward
        combined_reward = (exploitation_weight * immediate_reward) + (exploration_rate * long_term_reward) + proximity_penalty
        rewards.append(combined_reward)
        total_reward += combined_reward

    # Probabilistic selection based on normalized rewards
    if total_reward == 0:
        probabilities = [1.0 / num_unvisited] * num_unvisited
    else:
        probabilities = [max(0, r / total_reward) for r in rewards]

    # Ensure probabilities sum to 1
    prob_sum = sum(probabilities)
    if prob_sum > 0:
        probabilities = [p / prob_sum for p in probabilities]
    else:
        probabilities = [1.0 / num_unvisited] * num_unvisited

    # Select next node probabilistically
    next_node = unvisited_nodes[np.random.choice(range(num_unvisited), p=probabilities)]
    return next_node
