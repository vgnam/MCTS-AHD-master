importance" metric derived from the average distances to remaining nodes. It also employs a non-linear global weight that grows exponentially with remaining nodes to prioritize strategic transitions early in the search.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('-inf')
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    global_weight = 0.5 * (1 - (0.9 ** remaining_nodes))  # Exponential decay for strategic early decisions

    for node in unvisited_nodes:
        # Local distance components (squared for emphasis)
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Global exploration component: node importance (centrality)
        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)
        node_importance = 1 / (1 + avg_distance_to_remaining)  # Higher importance for nodes closer to others

        # Hybrid scoring: balance local proximity with global importance
        combined_score = (distance_to_current + distance_to_destination) * (1 - global_weight) + node_importance * global_weight

        if combined_score > best_score:
            best_score = combined_score
            next_node = node

    return next_node
