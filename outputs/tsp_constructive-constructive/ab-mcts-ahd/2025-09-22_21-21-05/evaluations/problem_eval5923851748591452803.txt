def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_unvisited = len(unvisited_nodes)
    scores = []
    frequency_penalty = {}

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Dynamic weight for destination influence with time decay
        time_decay = 0.5 ** (1 / (total_unvisited + 1))
        destination_weight = 0.7 * time_decay

        # Adaptive novelty factor based on historical traversal
        traversal_history = frequency_penalty.get(node, 0)
        novelty_factor = 1 / (1 + traversal_history ** 1.5)

        # Distance-based priority with probabilistic bias
        base_score = distance_to_current + destination_weight * distance_to_destination
        adjusted_score = base_score / novelty_factor

        # Add randomness to avoid local optima
        random_bias = 0.1 * np.random.random()
        final_score = adjusted_score * (1 - random_bias)

        scores.append((node, final_score))

    # Select node with lowest score (probabilistic selection)
    nodes, scores = zip(*scores)
    probabilities = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))
    next_node = np.random.choice(nodes, p=probabilities)

    # Update frequency for the selected node
    if next_node in frequency_penalty:
        frequency_penalty[next_node] += 1
    else:
        frequency_penalty[next_node] = 1

    return next_node
