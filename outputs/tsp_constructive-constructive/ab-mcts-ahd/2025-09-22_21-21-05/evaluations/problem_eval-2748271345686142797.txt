def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_cost = float('inf')
    remaining_nodes = len(unvisited_nodes)

    # Calculate centrality and opportunity cost
    centrality_scores = []
    opportunity_costs = []

    for node in unvisited_nodes:
        # Centrality: inverse of average distance to other unvisited nodes
        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes
        centrality = 1.0 / (avg_dist + 1e-6)

        # Opportunity cost: sum of distances to other unvisited nodes
        opportunity_cost = sum(distance_matrix[node][other] for other in unvisited_nodes)

        centrality_scores.append(centrality)
        opportunity_costs.append(opportunity_cost)

    max_centrality = max(centrality_scores) if centrality_scores else 1.0
    min_opportunity_cost = min(opportunity_costs) if opportunity_costs else 1.0

    for i, node in enumerate(unvisited_nodes):
        distance = distance_matrix[current_node][node]

        # Normalize centrality and opportunity cost
        normalized_centrality = centrality_scores[i] / max_centrality if max_centrality > 0 else 0
        normalized_opportunity_cost = 1.0 - (opportunity_costs[i] / (min_opportunity_cost + 1e-6))

        # Combined score: distance + centrality + opportunity cost
        combined_score = distance + (1.0 - normalized_centrality) * 100 + normalized_opportunity_cost * 50

        if combined_score < min_cost:
            min_cost = combined_score
            next_node = node

    # Special case for destination node
    if destination_node in unvisited_nodes:
        destination_distance = distance_matrix[current_node][destination_node]
        if destination_distance < min_cost * 1.2:
            next_node = destination_node

    return next_node
