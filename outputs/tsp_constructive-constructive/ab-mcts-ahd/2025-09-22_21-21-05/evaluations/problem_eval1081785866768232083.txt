def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate distances to all unvisited nodes
    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}

    # Find the nearest node
    nearest_node = min(distances, key=distances.get)
    nearest_distance = distances[nearest_node]

    # Check if destination is in unvisited nodes
    if destination_node in distances:
        destination_distance = distances[destination_node]

        # Probabilistic selection: higher chance if destination is closer
        threshold = nearest_distance * 0.7  # More lenient threshold
        if destination_distance <= threshold:
            # Higher probability if destination is closer
            prob = 0.7 if destination_distance <= nearest_distance * 0.5 else 0.4
            if random.random() < prob:
                return destination_node

    # If not selected destination, pick randomly from nearest nodes with bias
    candidates = [node for node in unvisited_nodes if distances[node] <= nearest_distance * 1.2]
    if not candidates:
        candidates = unvisited_nodes

    # Weighted random selection based on distance
    weights = [1 / (1 + distances[node]) for node in candidates]
    return next_node
