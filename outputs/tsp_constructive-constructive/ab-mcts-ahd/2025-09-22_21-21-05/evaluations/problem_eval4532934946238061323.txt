def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_steps = len(unvisited_nodes)
    scores = []
    nodes = []

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Dynamic weighting factor based on remaining steps
        weight = 1.0 - 0.5 * (remaining_steps / (remaining_steps + 1))

        # Temperature-based exploration rate (decreases as steps progress)
        temperature = 1.0 - (remaining_steps / (remaining_steps + 1))

        # Calculate utility score (lower is better)
        utility_score = distance_to_current + weight * distance_to_destination

        # Calculate probability using softmax with temperature
        probability = np.exp(-utility_score / temperature)

        scores.append(probability)
        nodes.append(node)

    # Select node based on probability distribution
    next_node = np.random.choice(nodes, p=np.array(scores)/sum(scores))

    return next_node
