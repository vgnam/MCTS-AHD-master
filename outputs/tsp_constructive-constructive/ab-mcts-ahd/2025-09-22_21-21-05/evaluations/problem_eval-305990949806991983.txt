def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, temperature=1.0, iteration=0):
    if not unvisited_nodes:
        return destination_node

    scores = []
    nodes = []

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0
        normalized_avg = avg_distance_to_remaining / (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) + 1e-6)
        centrality = sum(1 / (distance_matrix[node][n] + 1e-6) for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0
        exploration_factor = 1 / (1 + math.exp(-normalized_avg))  # Sigmoid for exploration
        exploitation_factor = 1 - exploration_factor
        dynamic_weight = 1 - 0.5 * (iteration / (iteration + 1))  # Decreasing weight over iterations

        combined_score = (distance_to_current + distance_to_destination) * dynamic_weight + centrality * (0.7 * exploitation_factor + 0.3 * exploration_factor)

        scores.append(combined_score)
        nodes.append(node)

    probabilities = softmax([-s / temperature for s in scores])
    next_node = nodes[np.random.choice(len(nodes), p=probabilities)]

    return next_node

def softmax(x):
    e_x = np.exp(x - np.max(x))
    return next_node
