def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('-inf')
    next_node = None
    total_nodes = len(distance_matrix)
    remaining_count = len(unvisited_nodes)
    progress_ratio = (total_nodes - remaining_count) / total_nodes

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Global potential: sum of inverse distances to all unvisited nodes
        global_potential = sum(1 / (distance_matrix[node][n] + 1e-6) for n in unvisited_nodes if n != node)

        # Adaptive weights based on path progress
        local_weight = 1.0 - 0.5 * progress_ratio
        global_weight = 0.5 + 0.5 * progress_ratio

        # Density penalty: discourage nodes in dense regions
        node_degree = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 0.1 * (sum(distance_matrix[node]) / len(distance_matrix[node])))

        # Exploration reward: bonus for less connected nodes
        exploration_reward = 0.2 * (1 / (node_degree + 1))

        # Combined score with dynamic components
        combined_score = (local_weight * distance_to_current +
                          local_weight * distance_to_destination +
                          global_weight * global_potential -
                          0.3 * node_degree +
                          exploration_reward)

        if combined_score > best_score:
            best_score = combined_score
            next_node = node

    return next_node
