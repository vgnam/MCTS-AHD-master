def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    best_score = float('-inf')
    next_node = None
    remaining_nodes_count = len(unvisited_nodes)

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        remaining_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        avg_distance_to_remaining = sum(remaining_distances) / len(remaining_distances) if remaining_distances else 0
        max_distance_to_remaining = max(remaining_distances) if remaining_distances else 0
        outlier_penalty = (max_distance_to_remaining - avg_distance_to_remaining) * 0.5

        dynamic_weight_current = 0.6
        dynamic_weight_destination = 0.3 + (0.1 * (remaining_nodes_count / (remaining_nodes_count + 1)))
        dynamic_weight_avg = 0.1 - (0.05 * (remaining_nodes_count / (remaining_nodes_count + 1)))

        combined_score = (distance_to_current * dynamic_weight_current) - (distance_to_destination * dynamic_weight_destination) + (avg_distance_to_remaining * dynamic_weight_avg) - outlier_penalty

        if combined_score > best_score:
            best_score = combined_score
            next_node = node

    return next_node
