[
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted combination of proximity to the destination and centrality in the remaining graph. It prioritizes central nodes (those with low average distance to other unvisited nodes) with a 30% weight, while the remaining 70% weight adjusts dynamically based on the number of unvisited nodes to ensure exploration. The score function combines these factors to find the most promising next node, favoring nodes that reduce path length while encouraging centrality.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting scheme that combines immediate distance with both destination proximity and a novel \"exploration factor\" based on node centrality, which encourages visiting nodes that are central in the remaining graph to reduce total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    # Calculate average distance to all unvisited nodes for centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))  # Avoid division by zero\n        combined_weight = weight * 0.7 + centrality_factor * 0.3\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate proximity to the current node and long-term efficiency toward the destination, using a dynamic weight that decreases as unvisited nodes decrease, while penalizing revisits to recently visited nodes to avoid cycles. The `combined_score` prioritizes proximity (`distance_to_current`) over future efficiency (`distance_to_destination`) with a weight that adjusts dynamically, and a penalty discourages revisiting nodes. The `penalty` is higher for recently visited nodes, ensuring the algorithm avoids cycles.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between immediate proximity and long-term path efficiency, while also penalizing revisits to recently visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 0.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        penalty = 1.0 if node in unvisited_nodes else 1.5\n        combined_score = (distance_to_current + dynamic_weight * distance_to_destination) * penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local optimization (minimizing distance from the current node) and global optimization (minimizing distance to the destination) by dynamically weighting the two distances. The weight for the current distance decreases as the number of unvisited nodes decreases, while the weight for the destination distance increases, ensuring the algorithm prioritizes proximity to the current node early on and gradually shifts toward minimizing the total path length.",
          "thought": "The new algorithm prioritizes minimizing the immediate distance to the current node while considering the remaining path length to the destination, using a dynamic weight that increases with the number of unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_current = remaining_nodes / (remaining_nodes + 1)\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance (prioritizing shorter-term gains) and a growing weight for destination proximity (focusing on long-term goals), while penalizing frequently revisited nodes to avoid local optima. The memory factor adjusts weights based on past selections, and the `immediate_weight` and `destination_weight` are inversely proportional, ensuring the algorithm adapts to remaining unvisited nodes. The score combines these factors to select the next node, with memory updated to influence future choices.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance and a growing weight for destination proximity, while also incorporating a memory factor based on past selections to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    if memory is None:\n        memory = {}\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weights with memory influence\n        immediate_weight = 0.8 * (total_unvisited / (total_unvisited + 1)) + 0.2 * (1 - memory.get(node, 0))\n        destination_weight = 1 - immediate_weight\n\n        # Memory factor to avoid revisiting poor choices\n        memory_factor = 1 + 0.1 * memory.get(node, 0)\n\n        score = (immediate_weight * distance_to_current + destination_weight * distance_to_destination) * memory_factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # Update memory for the selected node\n    memory[next_node] = memory.get(next_node, 0) + 1\n\n    return next_node",
          "objective": 7.15296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance from the current node and long-term potential (proximity to the destination), using a dynamic weight adjustment that prioritizes immediate distance when few nodes remain. It normalizes scores using the distance matrix to avoid bias, with weights favoring proximity when nodes are scarce. The function iterates through unvisited nodes, calculates a weighted score, and returns the node with the lowest score.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining nodes' proximity to the destination, favoring nodes that balance immediate distance and potential future path efficiency through a normalized scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment based on remaining nodes\n        remaining_nodes = len(unvisited_nodes)\n        weight = 0.5 if remaining_nodes > 1 else 0.8  # Prioritize proximity as fewer nodes remain\n\n        # Normalized score to balance immediate and long-term distance\n        normalized_score = (distance_to_current / max(1, sum(distance_matrix[current_node]))) * weight + \\\n                          (distance_to_destination / max(1, sum(distance_matrix[node]))) * (1 - weight)\n\n        if normalized_score < best_score:\n            best_score = normalized_score\n            next_node = node\n\n    return next_node",
          "objective": 7.19276,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance to the current node and the weighted future distance to the destination, where the weight factor decreases as more nodes are visited, prioritizing immediate efficiency early on and long-term optimization later. The weight factor is calculated as `max(0.1, 0.5 * (remaining_nodes / total_nodes))`, ensuring a minimum weight of 0.1 to avoid excessive bias. The `combined_score` combines the current distance and the weighted future distance, with the best-scoring node chosen iteratively.",
          "thought": "The new algorithm modifies the selection criteria by introducing a dynamic weight factor that adjusts based on the remaining number of unvisited nodes, ensuring a balance between immediate efficiency and long-term path optimization, while also incorporating a penalty for revisiting nodes that were previously considered but not chosen.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = max(0.1, 0.5 * (remaining_nodes / len(distance_matrix)))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + weight_factor * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.20128,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local proximity early in the search (using `distance_to_current`) while gradually shifting focus to global proximity (via `distance_to_destination`) through a dynamic weight (`weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited) ** 2`), which decreases as unvisited nodes decrease. It also normalizes distances by the average distance (`normalized_distance`) to balance selection, with the final score combining these factors to choose the next node.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts to the problem's progress, using a non-linear scaling factor to prioritize local proximity early and global proximity later, while incorporating a heuristic that considers the average distance of unvisited nodes to refine the selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / total_unvisited\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited) ** 2\n        normalized_distance = distance_to_current / avg_distance\n        score = (distance_to_current + weight * distance_to_destination) * (1 + normalized_distance)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.35538,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance to the current node (higher priority) and the distance to the destination (lower priority, weighted by 0.3), ensuring the destination is chosen only if it offers a better combined score than alternatives. The function prioritizes minimizing `distance_to_current` while slightly considering `distance_to_destination`, and explicitly checks if the destination is the best option when unvisited.",
          "thought": "The new algorithm combines the No.1's prioritization of the destination node when it is closer than the nearest alternative with the No.2's balanced scoring approach, using a combined score that weights the current distance more heavily than the destination distance. The algorithm selects the next node by minimizing the score (distance_to_current + 0.3 * distance_to_destination), but ensures the destination is chosen if it is unvisited and closer than the best alternative.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + 0.3 * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_score = distance_matrix[current_node][destination_node] + 0.3 * 0\n        if destination_score < best_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     }
]