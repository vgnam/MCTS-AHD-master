[
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic destination bias and centrality-based node evaluation. It prioritizes nodes closer to the current node while adjusting selection based on the fraction of remaining nodes (destination bias) and node centrality (average distance to unvisited nodes). The `destination_bias` increases as the tour progresses, favoring the destination node, while `centrality_factor` (weighted by 0.3) encourages selecting nodes with lower average distances to other unvisited nodes. The combined score balances distance and centrality, dynamically shifting focus between exploration and exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic destination bias and centrality-based selection inspired by No.1, where the centrality is adjusted by the fraction of remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.41797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimization by dynamically weighting the distance from the current node and the distance to the destination, while also favoring nodes with high centrality (low average distance to unvisited nodes). The weight for the remaining unvisited nodes (`remaining_nodes_factor`) decreases as more nodes are visited, prioritizing local decisions early and global decisions later. The centrality factor (`centrality_factor`) further refines choices by favoring nodes well-connected to unvisited nodes, with a fixed `weight_factor` (0.3) balancing its influence.",
          "thought": "The new algorithm combines the dynamic balance of local and global optimization from No.2 with the centrality-based node evaluation from No.1, using a smoothly transitioning weight that incorporates both distance to current and destination nodes while favoring nodes with lower average distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    if remaining_unvisited == 0:\n        return destination_node\n\n    remaining_nodes_factor = 1.0 / (remaining_unvisited ** 2)\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        weight = remaining_nodes_factor\n\n        combined_score = (1 - weight) * distance_to_current + weight * distance_to_destination + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local distance optimization** (via dynamic penalties) with **global centrality consideration** (weighted by centrality factors) to balance immediate and long-term path efficiency. It prioritizes **distance penalties** (scaled by remaining nodes) over **centrality factors** (weighted by 0.5) to select the next node, ensuring both short-term proximity and strategic node selection. The dynamic penalty adjusts based on unvisited nodes, while centrality balances by normalizing average distances across candidates.",
          "thought": "The new algorithm combines the balanced approach of No.1 (using centrality and dynamic penalties) with the efficiency of No.2 (weighted distance calculation), selecting nodes that minimize a combined score of immediate distance, weighted centrality, and a dynamic penalty based on remaining nodes to ensure both local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5  # Balanced weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43339,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors, while penalizing nodes with many nearby unvisited neighbors to avoid revisiting regions. It dynamically adjusts weights based on the visited ratio and remaining nodes, balancing local (distance to current node) and global (distance to destination) considerations, with centrality and penalty terms to guide selection. The best candidate is chosen based on a combined score, with ties resolved randomly.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors from No.2, while adding a penalty for nodes with many nearby unvisited neighbors to avoid revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n    centrality_weight = 0.5\n\n    remaining_nodes = len(unvisited_nodes)\n    time_decay = 0.9 ** (remaining_nodes - 1) if remaining_nodes > 0 else 0.5\n    dynamic_weight = time_decay * (1.0 / (remaining_nodes + 1))\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    best_score = float('inf')\n    candidates = []\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        combined_score = (weight_current * distance_to_current + weight_destination * distance_to_destination + centrality_weight * centrality_factor + penalty) * dynamic_weight\n\n        if combined_score < best_score:\n            best_score = combined_score\n            candidates = [node]\n        elif combined_score == best_score:\n            candidates.append(node)\n\n    if candidates:\n        next_node = np.random.choice(candidates) if len(candidates) > 1 else candidates[0]\n        return next_node\n    else:\n        return next_node",
          "objective": 6.48933,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic destination bias, centrality-based node evaluation, and local-global distance balancing, prioritizing nodes closer to the current position while considering centrality (proximity to other unvisited nodes) and penalizing high-cost nodes. The destination bias decreases over time, while centrality and exploration bonuses are weighted dynamically, with centrality decaying over iterations. The score balances immediate distance, centrality, and penalties, favoring nodes that are both locally optimal and globally central.",
          "thought": "The new algorithm combines the dynamic destination bias and centrality-based node evaluation from No.1 with the local-global distance balancing and exploration bonus from No.2, using a time-decaying weight for centrality and a penalty for high-cost nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    time_decay_factor = 0.7\n    exploration_bonus = 0.5\n    centrality_weight = 0.3\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        penalty = max(0, distance_to_current - avg_distances[i])\n\n        combined_score = distance_to_current + time_decay_factor * centrality_weight * centrality_factor - exploration_bonus * penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.49452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, destination proximity, and exploration bonuses, with weights adjusted based on the number of unvisited nodes and the current node's centrality. It prioritizes minimizing the distance to the current node while also considering the node's closeness to the destination and encouraging less traversed paths, with the exploration bonus given lower weight (0.1) compared to the other factors. The centrality of the current node and the number of unvisited nodes influence the dynamic weight (0.3 and 0.2 respectively), shaping the trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance, destination proximity, and a novel \"exploration bonus\" that encourages visiting less frequently traversed paths, with weights that evolve based on the number of unvisited nodes and the current node's centrality in the graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on unvisited nodes and centrality\n        weight = 0.3 * (1 / (1 + 0.05 * total_unvisited)) + 0.2 * centrality\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight * distance_to_destination + 0.1 * exploration_bonus\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.53939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic centrality weighting, prioritizing proximity early in the tour and balancing proximity with centrality (average distance to unvisited nodes) as the tour progresses. The weight factor (`weight_factor`) increases centrality importance as more nodes are visited, while the `combined_score` balances direct distance and centrality-adjusted scores. The destination node is considered as a potential final step if its score is close to the best alternative, ensuring a reasonable return path.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic centrality weighting inspired by No.1, where centrality (measured by average distance to unvisited nodes) is weighted more heavily as the tour progresses, ensuring a balance between proximity and tour centralization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.4 * (1 - (remaining_nodes / len(distance_matrix)))\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < min_distance:\n            min_distance = combined_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        destination_avg_dist = sum(distance_matrix[destination_node][other] for other in unvisited_nodes) / remaining_nodes\n        destination_centrality = 1.0 - (destination_avg_dist / (avg_avg_distance + 1e-6))\n        destination_score = destination_distance + weight_factor * destination_centrality\n\n        if destination_score < min_distance * 1.3:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.55555,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic thresholding and centrality-based selection: it prioritizes nodes that are both close to the current node (using a threshold based on distance variance) and well-connected to unvisited nodes (centrality factor), balancing local and global optimization. The threshold adjusts dynamically to favor nearby nodes, while the centrality factor (0.3 weight) ensures the next node is also a good hub for remaining nodes. The score function (`distance - bonus + 0.3 * centrality_factor`) ensures a trade-off between proximity and connectivity.",
          "thought": "The new algorithm combines dynamic thresholding from No.2 with centrality-based selection from No.1, prioritizing nodes that are both close to the current node and well-connected to unvisited nodes, while dynamically adjusting the threshold based on distance variance to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    min_distance = min(distances)\n    max_distance = max(distances)\n    mean_distance = sum(distances) / len(distances)\n    variance = sum((d - mean_distance) ** 2 for d in distances) / len(distances)\n    std_dev = variance ** 0.5\n    threshold = mean_distance - std_dev\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    next_node = None\n    best_score = float('inf')\n\n    for i, node in enumerate(unvisited_nodes):\n        distance = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        bonus = 0\n        if distance < threshold:\n            bonus = threshold - distance\n        score = distance - bonus + 0.3 * centrality_factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < threshold:\n            next_node = destination_node\n\n    return next_node",
          "objective": 6.58676,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance minimization (prioritized by `distance_to_current`) with centrality consideration (weighted by `weight_factor` and `centrality_factor`), where centrality's influence grows as the tour progresses (via `weight_factor = 0.3 * (1 - remaining_nodes / total_nodes)`). Centrality is measured by how close a node's average distance to others is to the overall average, with nodes closer to the average given higher priority. The weight of centrality increases as fewer nodes remain unvisited, ensuring the tour becomes more \"centralized\" toward the end.",
          "thought": "The new algorithm combines the immediate distance minimization from No.2 with dynamic centrality consideration inspired by No.1, using a weighted sum where centrality's influence grows as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3 * (1 - (remaining_nodes / len(distance_matrix)))  # Dynamic weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.61128,
          "other_inf": null
     }
]