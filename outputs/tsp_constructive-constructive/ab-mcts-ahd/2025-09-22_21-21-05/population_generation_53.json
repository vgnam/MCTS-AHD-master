[
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted combination of proximity to the destination and centrality in the remaining graph. It prioritizes central nodes (those with low average distance to other unvisited nodes) with a 30% weight, while the remaining 70% weight adjusts dynamically based on the number of unvisited nodes to ensure exploration. The score function combines these factors to find the most promising next node, favoring nodes that reduce path length while encouraging centrality.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting scheme that combines immediate distance with both destination proximity and a novel \"exploration factor\" based on node centrality, which encourages visiting nodes that are central in the remaining graph to reduce total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    # Calculate average distance to all unvisited nodes for centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))  # Avoid division by zero\n        combined_weight = weight * 0.7 + centrality_factor * 0.3\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate proximity to the current node and long-term efficiency toward the destination, using a dynamic weight that decreases as unvisited nodes decrease, while penalizing revisits to recently visited nodes to avoid cycles. The `combined_score` prioritizes proximity (`distance_to_current`) over future efficiency (`distance_to_destination`) with a weight that adjusts dynamically, and a penalty discourages revisiting nodes. The `penalty` is higher for recently visited nodes, ensuring the algorithm avoids cycles.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight factor that adjusts based on the number of remaining unvisited nodes, ensuring a balance between immediate proximity and long-term path efficiency, while also penalizing revisits to recently visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 0.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        penalty = 1.0 if node in unvisited_nodes else 1.5\n        combined_score = (distance_to_current + dynamic_weight * distance_to_destination) * penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local optimization (minimizing distance from the current node) and global optimization (minimizing distance to the destination) by dynamically weighting the two distances. The weight for the current distance decreases as the number of unvisited nodes decreases, while the weight for the destination distance increases, ensuring the algorithm prioritizes proximity to the current node early on and gradually shifts toward minimizing the total path length.",
          "thought": "The new algorithm prioritizes minimizing the immediate distance to the current node while considering the remaining path length to the destination, using a dynamic weight that increases with the number of unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_current = remaining_nodes / (remaining_nodes + 1)\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance (prioritizing shorter-term gains) and a growing weight for destination proximity (focusing on long-term goals), while penalizing frequently revisited nodes to avoid local optima. The memory factor adjusts weights based on past selections, and the `immediate_weight` and `destination_weight` are inversely proportional, ensuring the algorithm adapts to remaining unvisited nodes. The score combines these factors to select the next node, with memory updated to influence future choices.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance and a growing weight for destination proximity, while also incorporating a memory factor based on past selections to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    if memory is None:\n        memory = {}\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weights with memory influence\n        immediate_weight = 0.8 * (total_unvisited / (total_unvisited + 1)) + 0.2 * (1 - memory.get(node, 0))\n        destination_weight = 1 - immediate_weight\n\n        # Memory factor to avoid revisiting poor choices\n        memory_factor = 1 + 0.1 * memory.get(node, 0)\n\n        score = (immediate_weight * distance_to_current + destination_weight * distance_to_destination) * memory_factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # Update memory for the selected node\n    memory[next_node] = memory.get(next_node, 0) + 1\n\n    return next_node",
          "objective": 7.15296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the current node while dynamically balancing proximity to the destination, with the weight of the destination's influence decreasing as more nodes are visited. The weight is calculated as `0.5 * (total_unvisited / (total_unvisited + 1))`, ensuring the destination's role becomes less dominant as the number of unvisited nodes shrinks. The combined score (`distance_to_current + weight * distance_to_destination`) guides the selection of the next node, favoring shorter immediate paths early on but increasingly considering destination proximity as the tour progresses.",
          "thought": "The new algorithm combines the immediate distance to the current node (high weight) with a dynamic balance of proximity to the destination and centrality in the remaining graph, similar to No.1 but with a simpler weight adjustment. It calculates a score as `distance_to_current + weight * distance_to_destination`, where the weight is dynamically adjusted based on the number of unvisited nodes to prioritize exploration early and focus on destination proximity later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 * (total_unvisited / (total_unvisited + 1))\n\n        combined_score = distance_to_current + weight * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.43399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the shortest distance to the current node (higher weight) while also considering the node's proximity to the destination (lower weight). The combined score balances immediate travel efficiency and eventual path completion, steering the tour toward the destination without excessive detours. The `combined_score` is calculated as `distance_to_current + 0.5 * distance_to_destination`, where the current node's distance has double the weight of the destination's distance.",
          "thought": "The algorithm prioritizes nodes based on a weighted combination of their distance to the current node and their proximity to the destination node, ensuring the path progressively steers toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + 0.5 * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to the current node with long-term proximity to the destination, using a weighted score that adapts based on remaining unvisited nodes. The weight decreases as more nodes are visited, prioritizing closer nodes early while gradually considering destination proximity. The score combines immediate distance (higher priority early) and weighted destination distance (higher priority later), normalized by the weight to avoid extreme values.",
          "thought": "This new algorithm introduces a dynamic balancing mechanism that combines immediate distance to the current node with a weighted long-term proximity to the destination, using a novel scoring function that adapts based on the number of remaining unvisited nodes to avoid premature commitment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        score = (distance_to_current + weight * distance_to_destination) / (1 + weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.48904,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing distance to the current node and the destination node, dynamically adjusting weights based on the ratio of visited to unvisited nodes, and penalizing high-degree nodes (centrality) to avoid revisiting them prematurely. The weighted score prioritizes minimizing distance to the current node early (higher weight) and to the destination later (lower weight), while the centrality penalty reduces revisits to densely connected nodes. The scaling factor and centrality term dynamically adjust priorities during traversal.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic scaling factor for weights, where the scaling factor is determined by the ratio of visited to unvisited nodes, and adds a penalty term based on node centrality to avoid revisiting high-degree nodes prematurely.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        scaling_factor = 1.0 + visited_ratio\n        weight_current = scaling_factor / (1.0 + scaling_factor)\n        weight_destination = 1.0 - weight_current\n\n        centrality_penalty = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1e-9) / len(unvisited_nodes)\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) - (0.5 * centrality_penalty)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.98635,
          "other_inf": null
     }
]