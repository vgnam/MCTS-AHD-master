[
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm dynamically balances local and global optimization by combining immediate distance to the current node with an exploration potential metric, weighted by a decaying factor. The exploration potential prioritizes nodes closer to the destination while accounting for average distances, with the decaying factor reducing exploration emphasis as the number of unvisited nodes decreases. The algorithm selects the next node by minimizing a combined score of direct distance and exploration-adjusted potential, ensuring a trade-off between proximity and long-term path efficiency.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance with a novel \"exploration potential\" metric, where nodes are scored based on the ratio of their distance to the current node and the average distance to the destination, weighted by a decaying exploration factor that balances local and global optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 0.8 ** (1 / (remaining_nodes + 1))  # Decays from 0.8 to ~0.5\n    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        exploration_potential = (distance_to_current / (distance_to_destination + 1e-6)) * exploration_factor\n        combined_score = distance_to_current + exploration_potential * avg_distance_to_dest\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.81616,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality measures, prioritizing nodes that balance short-term distance (distance from current node) with long-term centrality (average distance to other unvisited nodes). The weight for centrality decreases as the tour progresses (via `weight = 0.5 * (total_unvisited / (total_unvisited + 1))`), while the combined score favors nodes with shorter immediate distances and better centrality. The final selection is based on a normalized score, where centrality contributes 40% and immediate distance 60% of the weight.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the centrality measure of No.1, prioritizing nodes that balance short-term distance with long-term centrality, where the centrality weight decreases as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 0.5 * (total_unvisited / (total_unvisited + 1))\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_weight = weight * 0.6 + centrality_factor * 0.4\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88765,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency. It gives higher priority to nodes closer to the current node relative to their distance to the destination, ensuring efficient path progression. The code iterates through unvisited nodes, calculates the ratio, and selects the node with the lowest ratio.",
          "thought": "The new algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < best_score:\n            best_score = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes destination proximity (weighted by `heuristic_factor = 0.5`) while heavily penalizing revisits (memory factor of `+0.2` per visit) and encouraging moderate-distance exploration (via `exploration_bonus = 0.8`). The score combines these factors to select the next node, balancing immediate distance, destination alignment, and exploration.",
          "thought": "The new algorithm prioritizes destination proximity more aggressively (heuristic factor 0.5) and uses higher memory penalties (0.2 per visit) to strongly discourage revisits, while also introducing a dynamic exploration bonus for nodes with moderate distances to encourage balanced exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    heuristic_factor = 0.5\n    memory = {}\n    exploration_bonus = 0.8\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if node == destination_node:\n            weighted_score = distance_to_current * (1 - heuristic_factor)\n        else:\n            weighted_score = distance_to_current * (1 + heuristic_factor)\n\n        memory_factor = 1 + 0.2 * memory.get(node, 0)\n        exploration_factor = 1 - (distance_to_destination / max(distance_matrix[node])) * exploration_bonus\n        score = weighted_score * memory_factor * exploration_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    memory[next_node] = memory.get(next_node, 0) + 1\n    return next_node",
          "objective": 6.93514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance when few nodes remain (controlled by `heuristic_factor`) while balancing it with centrality (average distance to other nodes) and penalizing revisits (via `memory_factor`). It also encourages exploration by reducing scores for nodes far from the destination (via `exploration_factor`). The `weight_current` and `weight_centrality` dynamically adjust priorities, favoring centrality when more nodes remain. The `memory` dictionary tracks revisits to discourage repetition.",
          "thought": "The new algorithm combines dynamic weighting with exploration bonuses, prioritizing immediate distance when few nodes remain but balancing it with centrality and penalizing revisits, while encouraging moderate-distance exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    heuristic_factor = 0.5\n    memory = {}\n    exploration_bonus = 0.8\n\n    centrality_scores = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        centrality_scores.append(avg_dist)\n\n    avg_centrality = sum(centrality_scores) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if node == destination_node:\n            weighted_distance = distance_to_current * (1 - heuristic_factor)\n        else:\n            weighted_distance = distance_to_current * (1 + heuristic_factor)\n\n        memory_factor = 1 + 0.2 * memory.get(node, 0)\n        exploration_factor = 1 - (distance_to_destination / max(distance_matrix[node])) * exploration_bonus\n\n        weight_current = remaining_nodes / (remaining_nodes + 1)\n        weight_centrality = 1.0 - weight_current\n        weighted_score = (weight_current * weighted_distance) + (weight_centrality * centrality_scores[i] / (avg_centrality + 1e-6))\n        score = weighted_score * memory_factor * exploration_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    memory[next_node] = memory.get(next_node, 0) + 1\n    return next_node",
          "objective": 7.03022,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted combination of proximity to the destination and centrality in the remaining graph. It prioritizes central nodes (those with low average distance to other unvisited nodes) with a 30% weight, while the remaining 70% weight adjusts dynamically based on the number of unvisited nodes to ensure exploration. The score function combines these factors to find the most promising next node, favoring nodes that reduce path length while encouraging centrality.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting scheme that combines immediate distance with both destination proximity and a novel \"exploration factor\" based on node centrality, which encourages visiting nodes that are central in the remaining graph to reduce total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    # Calculate average distance to all unvisited nodes for centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))  # Avoid division by zero\n        combined_weight = weight * 0.7 + centrality_factor * 0.3\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node and distance to the destination, dynamically adjusting the weight to prioritize closer nodes as the number of unvisited nodes decreases, while explicitly checking the destination for direct path improvements. Higher priority is given to minimizing the combined score of distance to the current node and a weighted distance to the destination, with the weight increasing as the tour progresses. The destination node is explicitly checked for direct path improvements, ensuring optimal routing near the end of the tour.",
          "thought": "The new algorithm balances proximity to the current node and distance to the destination, with a dynamic weight that increases as the number of unvisited nodes decreases, prioritizing closer nodes to the destination as the tour progresses, while explicitly checking the destination for direct path improvement.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))\n        combined_score = distance_to_current + weight * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_score = distance_matrix[current_node][destination_node]\n        if destination_score < best_score:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     }
]