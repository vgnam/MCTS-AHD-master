[
     {
          "algorithm": "The algorithm combines immediate distance prioritization with a ratio-based balance, selecting the next node by minimizing a score that adds the direct distance from the current node to a candidate node and a ratio of that distance to the candidate's distance to the destination. This balances short-term efficiency (distance to current node) with long-term efficiency (distance to destination), ensuring a trade-off between immediate and future steps. The ratio term helps avoid getting stuck in local optima by considering the candidate's proximity to the final destination.",
          "thought": "The new algorithm combines the ideas of prioritizing immediate distance (like No.2) while incorporating a ratio-based balance (like No.1) for better efficiency. It calculates a score as the immediate distance plus a weighted ratio of the distance to the destination, ensuring a trade-off between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        combined_score = distance_to_current + ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm dynamically balances local and global optimization by combining immediate distance to the current node with an exploration potential metric, weighted by a decaying factor. The exploration potential prioritizes nodes closer to the destination while accounting for average distances, with the decaying factor reducing exploration emphasis as the number of unvisited nodes decreases. The algorithm selects the next node by minimizing a combined score of direct distance and exploration-adjusted potential, ensuring a trade-off between proximity and long-term path efficiency.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance with a novel \"exploration potential\" metric, where nodes are scored based on the ratio of their distance to the current node and the average distance to the destination, weighted by a decaying exploration factor that balances local and global optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 0.8 ** (1 / (remaining_nodes + 1))  # Decays from 0.8 to ~0.5\n    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        exploration_potential = (distance_to_current / (distance_to_destination + 1e-6)) * exploration_factor\n        combined_score = distance_to_current + exploration_potential * avg_distance_to_dest\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.81616,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances progress toward the destination with local efficiency, dynamically weighting destination distance by progress (higher weight as more nodes are visited) while penalizing nodes that create detours or revisits to nearby unvisited nodes. It prioritizes minimizing the sum of current distance, weighted destination distance, and penalties, with penalties increasing for nodes that would lead to unnecessary detours or revisits. The weight factor (`weight_factor`) and destination weight (`weight_destination`) adapt to progress, while penalties enforce local efficiency.",
          "thought": "The new algorithm combines the destination-focused weighting of No.2 with the progress-adaptive penalties and non-linear weighting of No.1. It selects the next node by balancing current distance with a dynamically weighted destination distance, while penalizing nodes that would create detours or revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_destination = 1.0 + visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 1.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 1.5\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.2:\n                penalty += 0.15\n\n        combined_score = distance_to_current + weight_factor * weight_destination * distance_to_destination + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.86218,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality measures, prioritizing nodes that balance short-term distance (distance from current node) with long-term centrality (average distance to other unvisited nodes). The weight for centrality decreases as the tour progresses (via `weight = 0.5 * (total_unvisited / (total_unvisited + 1))`), while the combined score favors nodes with shorter immediate distances and better centrality. The final selection is based on a normalized score, where centrality contributes 40% and immediate distance 60% of the weight.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the centrality measure of No.1, prioritizing nodes that balance short-term distance with long-term centrality, where the centrality weight decreases as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 0.5 * (total_unvisited / (total_unvisited + 1))\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_weight = weight * 0.6 + centrality_factor * 0.4\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88765,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency. It gives higher priority to nodes closer to the current node relative to their distance to the destination, ensuring efficient path progression. The code iterates through unvisited nodes, calculates the ratio, and selects the node with the lowest ratio.",
          "thought": "The new algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < best_score:\n            best_score = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes destination proximity (weighted by `heuristic_factor = 0.5`) while heavily penalizing revisits (memory factor of `+0.2` per visit) and encouraging moderate-distance exploration (via `exploration_bonus = 0.8`). The score combines these factors to select the next node, balancing immediate distance, destination alignment, and exploration.",
          "thought": "The new algorithm prioritizes destination proximity more aggressively (heuristic factor 0.5) and uses higher memory penalties (0.2 per visit) to strongly discourage revisits, while also introducing a dynamic exploration bonus for nodes with moderate distances to encourage balanced exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    heuristic_factor = 0.5\n    memory = {}\n    exploration_bonus = 0.8\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if node == destination_node:\n            weighted_score = distance_to_current * (1 - heuristic_factor)\n        else:\n            weighted_score = distance_to_current * (1 + heuristic_factor)\n\n        memory_factor = 1 + 0.2 * memory.get(node, 0)\n        exploration_factor = 1 - (distance_to_destination / max(distance_matrix[node])) * exploration_bonus\n        score = weighted_score * memory_factor * exploration_factor\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    memory[next_node] = memory.get(next_node, 0) + 1\n    return next_node",
          "objective": 6.93514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing proximity and novelty, using a decay factor to prioritize destination nodes early in the search (exploitation) and favoring less-traveled nodes with sparse neighbors later (exploration). It computes a weighted score combining distance and novelty (inverse of neighbor density), adjusting novelty by inverse distance to avoid overemphasizing distant nodes. The `exploration_phase` and `decay_factor` control the transition from exploitation to exploration, while the `bias` term ensures the destination is prioritized when it becomes close.",
          "thought": "The new algorithm dynamically prioritizes nodes based on a weighted combination of proximity and novelty, using a linear decay factor to balance exploration and exploitation, while novelty scores are adjusted by inverse distance to encourage less-traveled nodes with sparse neighbors.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        destination_distance = distance_matrix[current_node][destination_node]\n        exploration_phase = len(unvisited_nodes) / (len(unvisited_nodes) + len(unvisited_nodes) - len(unvisited_nodes))\n        decay_factor = 0.8 ** exploration_phase\n        bias = 1 - (destination_distance / (avg_distance + 1e-10))\n        if bias * decay_factor > 0.6:\n            return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    novelty_scores = {}\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        novelty_scores[node] = 1 / (1 + sum(1 / (distance_matrix[node][n] + 1e-10) for n in unvisited_nodes if n != node))\n        weighted_score = distance * (1 - novelty_scores[node])\n        if weighted_score < min_distance or (weighted_score == min_distance and novelty_scores[node] > novelty_scores.get(next_node, 0)):\n            min_distance = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 7.00412,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     }
]