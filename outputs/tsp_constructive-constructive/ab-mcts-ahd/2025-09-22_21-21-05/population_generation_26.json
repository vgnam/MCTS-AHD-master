[
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted combination of proximity to the destination and centrality in the remaining graph. It prioritizes central nodes (those with low average distance to other unvisited nodes) with a 30% weight, while the remaining 70% weight adjusts dynamically based on the number of unvisited nodes to ensure exploration. The score function combines these factors to find the most promising next node, favoring nodes that reduce path length while encouraging centrality.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting scheme that combines immediate distance with both destination proximity and a novel \"exploration factor\" based on node centrality, which encourages visiting nodes that are central in the remaining graph to reduce total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    # Calculate average distance to all unvisited nodes for centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and centrality\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))  # Avoid division by zero\n        combined_weight = weight * 0.7 + centrality_factor * 0.3\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06307,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance (prioritizing shorter-term gains) and a growing weight for destination proximity (focusing on long-term goals), while penalizing frequently revisited nodes to avoid local optima. The memory factor adjusts weights based on past selections, and the `immediate_weight` and `destination_weight` are inversely proportional, ensuring the algorithm adapts to remaining unvisited nodes. The score combines these factors to select the next node, with memory updated to influence future choices.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, destination proximity, and historical path efficiency, using a decaying weight for immediate distance and a growing weight for destination proximity, while also incorporating a memory factor based on past selections to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, memory=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    if memory is None:\n        memory = {}\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weights with memory influence\n        immediate_weight = 0.8 * (total_unvisited / (total_unvisited + 1)) + 0.2 * (1 - memory.get(node, 0))\n        destination_weight = 1 - immediate_weight\n\n        # Memory factor to avoid revisiting poor choices\n        memory_factor = 1 + 0.1 * memory.get(node, 0)\n\n        score = (immediate_weight * distance_to_current + destination_weight * distance_to_destination) * memory_factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # Update memory for the selected node\n    memory[next_node] = memory.get(next_node, 0) + 1\n\n    return next_node",
          "objective": 7.15296,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the shortest distance to the current node (higher weight) while also considering the node's proximity to the destination (lower weight). The combined score balances immediate travel efficiency and eventual path completion, steering the tour toward the destination without excessive detours. The `combined_score` is calculated as `distance_to_current + 0.5 * distance_to_destination`, where the current node's distance has double the weight of the destination's distance.",
          "thought": "The algorithm prioritizes nodes based on a weighted combination of their distance to the current node and their proximity to the destination node, ensuring the path progressively steers toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + 0.5 * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to the current node with long-term proximity to the destination, using a weighted score that adapts based on remaining unvisited nodes. The weight decreases as more nodes are visited, prioritizing closer nodes early while gradually considering destination proximity. The score combines immediate distance (higher priority early) and weighted destination distance (higher priority later), normalized by the weight to avoid extreme values.",
          "thought": "This new algorithm introduces a dynamic balancing mechanism that combines immediate distance to the current node with a weighted long-term proximity to the destination, using a novel scoring function that adapts based on the number of remaining unvisited nodes to avoid premature commitment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        score = (distance_to_current + weight * distance_to_destination) / (1 + weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.48904,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the sum of its distance to the current node and its distance to the destination, ensuring a balanced path that reduces cumulative travel costs. It iterates through unvisited nodes, calculates the combined distance for each, and chooses the node with the lowest total distance, effectively minimizing both immediate and long-term proximity. The function handles edge cases (like no unvisited nodes) and leverages the distance matrix for efficient distance lookups.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the sum of distances to the current node and the destination, ensuring a path that balances immediate and long-term proximity, aiming to minimize cumulative distances rather than worst-case scenarios.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_current + distance_to_destination\n\n        if total_distance < best_score:\n            best_score = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of distances to the current node and to the destination, while also balancing this with the average distance to remaining unvisited nodes (weighted by 0.3). It ensures a trade-off between local efficiency (current and destination distances) and global exploration (average distance to unvisited nodes) to guide the selection of the next node in the TSP path. The combined score balances these factors, with the average distance given lower priority (0.3 weight) compared to direct distances.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of distances to the current node and to the destination, while also considering the average distance to all remaining unvisited nodes to ensure balanced exploration, aiming to find a path that is both locally efficient and globally optimal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        combined_score = distance_to_current + distance_to_destination + 0.3 * avg_distance_to_remaining\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 8.42445,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes selecting the next node by minimizing the maximum distance to either the current node or the destination, ensuring a balanced path that avoids long detours. It evaluates each unvisited node based on the larger of its distances to the current node and destination, choosing the one with the smallest such value. The algorithm thus balances immediate proximity to the current node with long-term proximity to the destination, making it a heuristic for minimizing the worst-case distance in the path.",
          "thought": "The new algorithm prioritizes nodes that minimize the maximum distance to either the current node or the destination, ensuring a balanced path by considering both immediate and long-term proximity, thereby reducing the risk of long detours or suboptimal sequences.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        max_distance = max(distance_to_current, distance_to_destination)\n\n        if max_distance < best_score:\n            best_score = max_distance\n            next_node = node\n\n    return next_node",
          "objective": 13.75157,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity to the current node and closeness to the destination, with weights dynamically adjusted based on remaining unvisited nodes. It prioritizes immediate proximity when few nodes remain (higher weight on `distance_to_current`) and long-term planning when many nodes are left (higher weight on `distance_to_destination`). The weighted sum (`weighted_score`) ensures a trade-off between greediness and global optimization.",
          "thought": "This new algorithm modifies the original by incorporating a weighted sum of distances to the current node and destination, where the weights are dynamically adjusted based on the number of remaining unvisited nodes, promoting a balance between immediate proximity and long-term planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 14.08142,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the maximum distance to the current node and the destination, while dynamically increasing the weight on destination proximity as more nodes are visited. It prioritizes nodes that minimize the weighted combination of these distances, using a normalization factor to ensure stability. The weight adjusts from 0.5 to 1.0 as unvisited nodes decrease, emphasizing destination proximity in later stages.",
          "thought": "This new algorithm combines the balanced approach of minimizing the maximum distance to current or destination with dynamic weighting of distances, where the weight for destination proximity increases as more nodes are visited, while also incorporating a normalization factor to prevent extreme values.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        max_distance = max(distance_to_current, distance_to_destination)\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + (0.5 * (total_unvisited - 1) / total_unvisited)\n        score = (max_distance + weight * distance_to_destination) / (1 + weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 14.1469,
          "other_inf": null
     }
]