[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with a ratio-based balance, selecting the next node by minimizing a score that adds the direct distance from the current node to a candidate node and a ratio of that distance to the candidate's distance to the destination. This balances short-term efficiency (distance to current node) with long-term efficiency (distance to destination), ensuring a trade-off between immediate and future steps. The ratio term helps avoid getting stuck in local optima by considering the candidate's proximity to the final destination.",
          "thought": "The new algorithm combines the ideas of prioritizing immediate distance (like No.2) while incorporating a ratio-based balance (like No.1) for better efficiency. It calculates a score as the immediate distance plus a weighted ratio of the distance to the destination, ensuring a trade-off between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        combined_score = distance_to_current + ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: minimizing the distance from the current node (weighted heavily when few nodes remain) and minimizing the ratio of current distance to destination distance (weighted more when many nodes remain). The weights adjust dynamically based on the number of unvisited nodes, ensuring a trade-off between local and global optimization. The function evaluates each unvisited node using this weighted sum and returns the one with the lowest score.",
          "thought": "The new algorithm combines the ratio-based balance from No.1 (avoiding local optima by considering distance to destination) with No.2's dynamic weighting (adjusting trade-off based on remaining nodes). It selects the next node by minimizing a weighted sum of the distance to the current node and a ratio of that distance to the distance to the destination, with weights inversely proportional to the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * ratio)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.6832,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing either immediate proximity (early stages) or proximity to the destination (later stages) using a weighted ratio, while penalizing nearby revisits to prevent cycles. It balances these factors with a heuristic score combining normalized distances and penalties, favoring nodes with lower combined costs. The weights (`weight_current` and `weight_destination`) shift based on progress, and penalties discourage revisiting nodes too close to the current one.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment based on the ratio of visited nodes, adding a penalty for revisiting nearby nodes to avoid cycles, and using a heuristic to balance immediate and long-term distances with a novel scoring function that combines normalized distances and a historical visit penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        normalized_distance = (distance_to_current / sum(distance_matrix[current_node])) + (distance_to_destination / sum(distance_matrix[node]))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70414,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm dynamically balances local and global optimization by combining immediate distance to the current node with an exploration potential metric, weighted by a decaying factor. The exploration potential prioritizes nodes closer to the destination while accounting for average distances, with the decaying factor reducing exploration emphasis as the number of unvisited nodes decreases. The algorithm selects the next node by minimizing a combined score of direct distance and exploration-adjusted potential, ensuring a trade-off between proximity and long-term path efficiency.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance with a novel \"exploration potential\" metric, where nodes are scored based on the ratio of their distance to the current node and the average distance to the destination, weighted by a decaying exploration factor that balances local and global optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 0.8 ** (1 / (remaining_nodes + 1))  # Decays from 0.8 to ~0.5\n    avg_distance_to_dest = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        exploration_potential = (distance_to_current / (distance_to_destination + 1e-6)) * exploration_factor\n        combined_score = distance_to_current + exploration_potential * avg_distance_to_dest\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.81616,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **proximity to the current node (40%)** with a **dynamic weighted balance between local efficiency and destination proximity**, adjusting weights based on progress (earlier stages favor destination proximity, later stages balance more). It includes **penalties for detours or revisits** and **local efficiency checks** to avoid unnecessary detours. The score is computed as `0.4 * distance_to_current + weight_factor * weight_destination * distance_to_destination + penalty`, prioritizing shorter paths while adapting to remaining progress.",
          "thought": "The new algorithm combines the weighted balancing of No.1 (60% destination proximity and 40% local efficiency) with dynamic penalties for detours or revisits, adapting weights based on progress to minimize the combined score of distance to current, weighted destination distance, and penalties.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_destination = 0.6 + 0.4 * visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 1.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 1.5\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.2:\n                penalty += 0.15\n\n        combined_score = 0.4 * distance_to_current + weight_factor * weight_destination * distance_to_destination + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.81973,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances progress toward the destination with local efficiency, dynamically weighting destination distance by progress (higher weight as more nodes are visited) while penalizing nodes that create detours or revisits to nearby unvisited nodes. It prioritizes minimizing the sum of current distance, weighted destination distance, and penalties, with penalties increasing for nodes that would lead to unnecessary detours or revisits. The weight factor (`weight_factor`) and destination weight (`weight_destination`) adapt to progress, while penalties enforce local efficiency.",
          "thought": "The new algorithm combines the destination-focused weighting of No.2 with the progress-adaptive penalties and non-linear weighting of No.1. It selects the next node by balancing current distance with a dynamically weighted destination distance, while penalizing nodes that would create detours or revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_destination = 1.0 + visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 1.5\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 1.5\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.2:\n                penalty += 0.15\n\n        combined_score = distance_to_current + weight_factor * weight_destination * distance_to_destination + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.86218,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with centrality measures, prioritizing nodes that balance short-term distance (distance from current node) with long-term centrality (average distance to other unvisited nodes). The weight for centrality decreases as the tour progresses (via `weight = 0.5 * (total_unvisited / (total_unvisited + 1))`), while the combined score favors nodes with shorter immediate distances and better centrality. The final selection is based on a normalized score, where centrality contributes 40% and immediate distance 60% of the weight.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the centrality measure of No.1, prioritizing nodes that balance short-term distance with long-term centrality, where the centrality weight decreases as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / total_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / total_unvisited if total_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 0.5 * (total_unvisited / (total_unvisited + 1))\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        combined_weight = weight * 0.6 + centrality_factor * 0.4\n\n        score = (distance_to_current + combined_weight * distance_to_destination) / (1 + combined_weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88765,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency. It gives higher priority to nodes closer to the current node relative to their distance to the destination, ensuring efficient path progression. The code iterates through unvisited nodes, calculates the ratio, and selects the node with the lowest ratio.",
          "thought": "The new algorithm selects the next node by prioritizing the one that minimizes the ratio of its distance to the current node over its distance to the destination, balancing immediate and long-term travel efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        if ratio < best_score:\n            best_score = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     }
]