[
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic destination bias and centrality-based node evaluation. It prioritizes nodes closer to the current node while adjusting selection based on the fraction of remaining nodes (destination bias) and node centrality (average distance to unvisited nodes). The `destination_bias` increases as the tour progresses, favoring the destination node, while `centrality_factor` (weighted by 0.3) encourages selecting nodes with lower average distances to other unvisited nodes. The combined score balances distance and centrality, dynamically shifting focus between exploration and exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic destination bias and centrality-based selection inspired by No.1, where the centrality is adjusted by the fraction of remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.41797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimization by dynamically weighting the distance from the current node and the distance to the destination, while also favoring nodes with high centrality (low average distance to unvisited nodes). The weight for the remaining unvisited nodes (`remaining_nodes_factor`) decreases as more nodes are visited, prioritizing local decisions early and global decisions later. The centrality factor (`centrality_factor`) further refines choices by favoring nodes well-connected to unvisited nodes, with a fixed `weight_factor` (0.3) balancing its influence.",
          "thought": "The new algorithm combines the dynamic balance of local and global optimization from No.2 with the centrality-based node evaluation from No.1, using a smoothly transitioning weight that incorporates both distance to current and destination nodes while favoring nodes with lower average distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    if remaining_unvisited == 0:\n        return destination_node\n\n    remaining_nodes_factor = 1.0 / (remaining_unvisited ** 2)\n    weight_factor = 0.3\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        weight = remaining_nodes_factor\n\n        combined_score = (1 - weight) * distance_to_current + weight * distance_to_destination + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43324,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local distance optimization** (via dynamic penalties) with **global centrality consideration** (weighted by centrality factors) to balance immediate and long-term path efficiency. It prioritizes **distance penalties** (scaled by remaining nodes) over **centrality factors** (weighted by 0.5) to select the next node, ensuring both short-term proximity and strategic node selection. The dynamic penalty adjusts based on unvisited nodes, while centrality balances by normalizing average distances across candidates.",
          "thought": "The new algorithm combines the balanced approach of No.1 (using centrality and dynamic penalties) with the efficiency of No.2 (weighted distance calculation), selecting nodes that minimize a combined score of immediate distance, weighted centrality, and a dynamic penalty based on remaining nodes to ensure both local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5  # Balanced weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43339,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines dynamic destination bias (adjusting the focus on the destination as the tour progresses) with centrality-based node selection (prioritizing nodes with high centrality, weighted by 0.3). It balances immediate distance to the current node and long-term centrality, smoothly shifting from exploration (early stages) to exploitation (later stages) by adjusting the weight factor. The destination bias is stronger as more nodes are visited, while centrality scores (normalized by average distances) guide the selection toward well-connected nodes.",
          "thought": "The new algorithm combines dynamic destination bias (adjusting based on remaining nodes) with centrality-based node evaluation (weighted by 0.3), prioritizing nodes closer to the current node while balancing immediate and future distances, and smoothly transitioning focus from exploration to exploitation as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n    weight_factor = max(0.1, 0.5 * (remaining_unvisited / total_nodes))\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    best_score = float('inf')\n    next_node = None\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        combined_score = distance_to_current + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.44812,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing distance to the current node (exploitation) and distance to the destination (exploration), dynamically adjusting the exploration weight based on remaining nodes. It penalizes high local density (to avoid clustering) and long detours (to maintain path efficiency), prioritizing shorter current distances and penalizing nodes that disrupt the direct path to the destination. The exploration weight decreases as nodes are visited, shifting focus toward exploitation.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic exploration-exploitation trade-off, where the weighting factor is adjusted based on the remaining nodes and a novel \"local density\" metric to avoid clustering, while penalizing nodes that create long detours from the destination path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    exploration_weight = 0.3 + 0.7 * (1.0 / (remaining_nodes + 1e-9))  # Dynamic exploration focus\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Local density penalty to avoid clustering\n        local_density = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        density_penalty = 0.2 * local_density\n\n        # Detour penalty for long paths\n        detour_penalty = 0.4 * max(0, (distance_to_current + distance_to_destination) - distance_matrix[current_node][destination_node])\n\n        combined_score = (1 - exploration_weight) * distance_to_current + exploration_weight * distance_to_destination - density_penalty - detour_penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.45154,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance to the next node while dynamically balancing progress toward the destination, applying exploration bonuses to less visited nodes, and penalizing revisits. Dynamic weighting adjusts based on remaining nodes and average distance, while penalties enforce cycle avoidance. The combined score favors closer nodes and those with better exploration potential, with penalties reducing revisit likelihood.",
          "thought": "The new algorithm combines the balanced scoring of No.1 and No.2, with dynamic weighting and exploration bonuses from No.3, while adding a penalty for revisiting nodes and adaptive weights based on progress, ensuring efficient path completion with cycle avoidance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 0.7 * (1.0 / (remaining_nodes + 1)) + 0.3 * (1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node])))\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n        penalty = 1.2 if node in unvisited_nodes else 1.5\n\n        combined_score = (-distance_to_current + dynamic_weight * distance_to_destination + 0.2 * exploration_bonus) / penalty\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.48195,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors, while penalizing nodes with many nearby unvisited neighbors to avoid revisiting regions. It dynamically adjusts weights based on the visited ratio and remaining nodes, balancing local (distance to current node) and global (distance to destination) considerations, with centrality and penalty terms to guide selection. The best candidate is chosen based on a combined score, with ties resolved randomly.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 (prioritizing local proximity early and global proximity later) with probabilistic selection and centrality factors from No.2, while adding a penalty for nodes with many nearby unvisited neighbors to avoid revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n    centrality_weight = 0.5\n\n    remaining_nodes = len(unvisited_nodes)\n    time_decay = 0.9 ** (remaining_nodes - 1) if remaining_nodes > 0 else 0.5\n    dynamic_weight = time_decay * (1.0 / (remaining_nodes + 1))\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    best_score = float('inf')\n    candidates = []\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        combined_score = (weight_current * distance_to_current + weight_destination * distance_to_destination + centrality_weight * centrality_factor + penalty) * dynamic_weight\n\n        if combined_score < best_score:\n            best_score = combined_score\n            candidates = [node]\n        elif combined_score == best_score:\n            candidates.append(node)\n\n    if candidates:\n        next_node = np.random.choice(candidates) if len(candidates) > 1 else candidates[0]\n        return next_node\n    else:\n        return next_node",
          "objective": 6.48933,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic destination bias, centrality-based node evaluation, and local-global distance balancing, prioritizing nodes closer to the current position while considering centrality (proximity to other unvisited nodes) and penalizing high-cost nodes. The destination bias decreases over time, while centrality and exploration bonuses are weighted dynamically, with centrality decaying over iterations. The score balances immediate distance, centrality, and penalties, favoring nodes that are both locally optimal and globally central.",
          "thought": "The new algorithm combines the dynamic destination bias and centrality-based node evaluation from No.1 with the local-global distance balancing and exploration bonus from No.2, using a time-decaying weight for centrality and a penalty for high-cost nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    time_decay_factor = 0.7\n    exploration_bonus = 0.5\n    centrality_weight = 0.3\n\n    total_nodes = len(distance_matrix)\n    remaining_unvisited = len(unvisited_nodes)\n    destination_bias = (total_nodes - remaining_unvisited) / total_nodes\n\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_unvisited\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_unvisited if remaining_unvisited > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n\n        if node == destination_node:\n            distance_to_current *= (1 - destination_bias)\n\n        penalty = max(0, distance_to_current - avg_distances[i])\n\n        combined_score = distance_to_current + time_decay_factor * centrality_weight * centrality_factor - exploration_bonus * penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.49452,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing immediate distance minimization (prioritized via negative `distance_to_current`), destination proximity (weighted by `dynamic_weight`), connectivity (via `connectivity_factor`), and novelty (via `novelty_bonus`). The `dynamic_weight` adapts based on remaining nodes and average distance, while fixed weights (0.4, 0.3, 0.2, 0.1) prioritize destination proximity > connectivity > novelty. The algorithm iterates over unvisited nodes, computes a combined score, and selects the node with the highest score.",
          "thought": "The new algorithm introduces a dynamic exploration factor that adapts to the node's connectivity and a novelty bonus based on the node's frequency of occurrence in the path, while maintaining the core principles of immediate distance minimization and destination proximity from the original, but with a more sophisticated weighting mechanism that considers both local and global path characteristics.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    avg_distance = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])\n    dynamic_weight = 0.4 * (1 / (1 + 0.1 * remaining_nodes)) + 0.3 * (1.0 / avg_distance)\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        connectivity_factor = 1.0 / (1 + sum(distance_matrix[node]))\n        novelty_bonus = 1.0 / (1 + len([n for n in unvisited_nodes if n == node]))\n\n        combined_score = (-distance_to_current + dynamic_weight * distance_to_destination + 0.2 * connectivity_factor + 0.1 * novelty_bonus)\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.5308,
          "other_inf": null
     }
]