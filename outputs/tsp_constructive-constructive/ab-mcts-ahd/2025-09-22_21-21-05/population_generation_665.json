[
     {
          "algorithm": "The algorithm combines **local distance optimization** (via dynamic penalties) with **global centrality consideration** (weighted by centrality factors) to balance immediate and long-term path efficiency. It prioritizes **distance penalties** (scaled by remaining nodes) over **centrality factors** (weighted by 0.5) to select the next node, ensuring both short-term proximity and strategic node selection. The dynamic penalty adjusts based on unvisited nodes, while centrality balances by normalizing average distances across candidates.",
          "thought": "The new algorithm combines the balanced approach of No.1 (using centrality and dynamic penalties) with the efficiency of No.2 (weighted distance calculation), selecting nodes that minimize a combined score of immediate distance, weighted centrality, and a dynamic penalty based on remaining nodes to ensure both local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5  # Balanced weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.43339,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, destination proximity, and exploration bonuses, with weights adjusted based on the number of unvisited nodes and the current node's centrality. It prioritizes minimizing the distance to the current node while also considering the node's closeness to the destination and encouraging less traversed paths, with the exploration bonus given lower weight (0.1) compared to the other factors. The centrality of the current node and the number of unvisited nodes influence the dynamic weight (0.3 and 0.2 respectively), shaping the trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance, destination proximity, and a novel \"exploration bonus\" that encourages visiting less frequently traversed paths, with weights that evolve based on the number of unvisited nodes and the current node's centrality in the graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on unvisited nodes and centrality\n        weight = 0.3 * (1 / (1 + 0.05 * total_unvisited)) + 0.2 * centrality\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight * distance_to_destination + 0.1 * exploration_bonus\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.53939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global proximity by adjusting weights based on the number of unvisited nodes: early in the search, it prioritizes proximity to the current node (`weight_current = 2.0 - visited_ratio`), while later it shifts focus to proximity to the destination (`weight_destination = 0.5 * visited_ratio`). It also penalizes nodes with many nearby unvisited neighbors (`penalty` term) to avoid revisiting regions, ensuring a trade-off between immediate and long-term optimization. The best node is selected based on the lowest weighted score combining these factors.",
          "thought": "The new algorithm prioritizes local proximity early in the search while gradually shifting focus to global proximity, using a dynamic weight adjustment based on the number of unvisited nodes and incorporating a penalty for nodes with many nearby unvisited neighbors to prevent revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization (weighted by `weight`) with destination proximity (weighted by `weight_destination`), dynamically adjusting weights based on progress. It also penalizes nodes with nearby unvisited neighbors to avoid detours, with penalties increasing as the algorithm progresses. Early in the search, local optimization (distance to current node) dominates, while later stages emphasize global optimization (distance to destination). The `penalty` term discourages revisiting nearby nodes, especially as the tour progresses.",
          "thought": "The new algorithm combines the high weight on immediate distance from No.2 with the dynamic weight adjustment and destination proximity emphasis from No.1, while also incorporating a penalty for nearby revisits to avoid detours. It prioritizes local optimization early (high weight on distance_to_current) and balances with global considerations (weighted destination proximity and dynamic penalty) as progress increases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_count = len(unvisited_nodes)\n    progress = (total_nodes - remaining_count) / total_nodes\n    weight = 0.5 * (1 - progress)\n    weight_destination = progress\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64346,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing both remaining nodes and path length) with exploration bonuses (favoring less traversed paths) and centrality considerations (preferring nodes with high centrality in the graph), balancing short-term and long-term optimization while dynamically adjusting weights based on the remaining nodes and current path length. The code prioritizes minimizing immediate distance (`-distance_to_current`), balancing long-term destination proximity (`weight_factor * distance_to_destination`), and adding small bonuses for exploration and centrality (`exploration_bonus` and `centrality`). The dynamic `weight_factor` scales with remaining nodes and path length, while fixed weights (0.1) are applied to exploration and centrality terms.",
          "thought": "The new algorithm combines dynamic weight adjustment based on remaining nodes and path length (inspired by No.2) with exploration bonuses and centrality considerations (inspired by No.1) to balance short-term and long-term optimization while encouraging less traversed paths.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    path_length = sum(distance_matrix[current_node][destination_node] for _ in range(remaining_nodes))\n\n    # Dynamic weight factor with logarithmic scaling and path length consideration\n    weight_factor = max(0.1, 0.5 * (math.log(remaining_nodes + 1) / math.log(total_nodes + 1)) + 0.2 * (path_length / total_nodes))\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / total_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight_factor * distance_to_destination + 0.1 * exploration_bonus + 0.1 * centrality\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64359,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with a ratio-based balance, selecting the next node by minimizing a score that adds the direct distance from the current node to a candidate node and a ratio of that distance to the candidate's distance to the destination. This balances short-term efficiency (distance to current node) with long-term efficiency (distance to destination), ensuring a trade-off between immediate and future steps. The ratio term helps avoid getting stuck in local optima by considering the candidate's proximity to the final destination.",
          "thought": "The new algorithm combines the ideas of prioritizing immediate distance (like No.2) while incorporating a ratio-based balance (like No.1) for better efficiency. It calculates a score as the immediate distance plus a weighted ratio of the distance to the destination, ensuring a trade-off between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        combined_score = distance_to_current + ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: minimizing the distance from the current node (weighted heavily when few nodes remain) and minimizing the ratio of current distance to destination distance (weighted more when many nodes remain). The weights adjust dynamically based on the number of unvisited nodes, ensuring a trade-off between local and global optimization. The function evaluates each unvisited node using this weighted sum and returns the one with the lowest score.",
          "thought": "The new algorithm combines the ratio-based balance from No.1 (avoiding local optima by considering distance to destination) with No.2's dynamic weighting (adjusting trade-off based on remaining nodes). It selects the next node by minimizing a weighted sum of the distance to the current node and a ratio of that distance to the distance to the destination, with weights inversely proportional to the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * ratio)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.6832,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     }
]