[
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the unvisited node with the smallest distance from the current node, but always favors the destination node if it is unvisited and closer than the nearest alternative. The `destination_node` is given higher priority when it is in `unvisited_nodes` and its distance is smaller than the nearest other node. The `distance_matrix` is used to compute distances between nodes, and the loop ensures the closest unvisited node is chosen unless the destination is closer.",
          "thought": "The algorithm selects the next node to visit in the TSP path by choosing the unvisited node with the minimum distance from the current node, favoring the destination node if it is unvisited and closest.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the shortest distance to the current node (higher weight) while also considering the node's proximity to the destination (lower weight). The combined score balances immediate travel efficiency and eventual path completion, steering the tour toward the destination without excessive detours. The `combined_score` is calculated as `distance_to_current + 0.5 * distance_to_destination`, where the current node's distance has double the weight of the destination's distance.",
          "thought": "The algorithm prioritizes nodes based on a weighted combination of their distance to the current node and their proximity to the destination node, ensuring the path progressively steers toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = distance_to_current + 0.5 * distance_to_destination\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance to the current node with long-term proximity to the destination, using a weighted score that adapts based on remaining unvisited nodes. The weight decreases as more nodes are visited, prioritizing closer nodes early while gradually considering destination proximity. The score combines immediate distance (higher priority early) and weighted destination distance (higher priority later), normalized by the weight to avoid extreme values.",
          "thought": "This new algorithm introduces a dynamic balancing mechanism that combines immediate distance to the current node with a weighted long-term proximity to the destination, using a novel scoring function that adapts based on the number of remaining unvisited nodes to avoid premature commitment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 1.0 - (0.5 * (total_unvisited - 1) / total_unvisited)\n        score = (distance_to_current + weight * distance_to_destination) / (1 + weight)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.48904,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the sum of its distance to the current node and its distance to the destination, ensuring a balanced path that reduces cumulative travel costs. It iterates through unvisited nodes, calculates the combined distance for each, and chooses the node with the lowest total distance, effectively minimizing both immediate and long-term proximity. The function handles edge cases (like no unvisited nodes) and leverages the distance matrix for efficient distance lookups.",
          "thought": "The new algorithm prioritizes selecting the next node by minimizing the sum of distances to the current node and the destination, ensuring a path that balances immediate and long-term proximity, aiming to minimize cumulative distances rather than worst-case scenarios.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_current + distance_to_destination\n\n        if total_distance < best_score:\n            best_score = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of distances to the current node and to the destination, while also balancing this with the average distance to remaining unvisited nodes (weighted by 0.3). It ensures a trade-off between local efficiency (current and destination distances) and global exploration (average distance to unvisited nodes) to guide the selection of the next node in the TSP path. The combined score balances these factors, with the average distance given lower priority (0.3 weight) compared to direct distances.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of distances to the current node and to the destination, while also considering the average distance to all remaining unvisited nodes to ensure balanced exploration, aiming to find a path that is both locally efficient and globally optimal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        combined_score = distance_to_current + distance_to_destination + 0.3 * avg_distance_to_remaining\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 8.42445,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes selecting the next node by minimizing the maximum distance to either the current node or the destination, ensuring a balanced path that avoids long detours. It evaluates each unvisited node based on the larger of its distances to the current node and destination, choosing the one with the smallest such value. The algorithm thus balances immediate proximity to the current node with long-term proximity to the destination, making it a heuristic for minimizing the worst-case distance in the path.",
          "thought": "The new algorithm prioritizes nodes that minimize the maximum distance to either the current node or the destination, ensuring a balanced path by considering both immediate and long-term proximity, thereby reducing the risk of long detours or suboptimal sequences.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        max_distance = max(distance_to_current, distance_to_destination)\n\n        if max_distance < best_score:\n            best_score = max_distance\n            next_node = node\n\n    return next_node",
          "objective": 13.75157,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity to the current node and closeness to the destination, with weights dynamically adjusted based on remaining unvisited nodes. It prioritizes immediate proximity when few nodes remain (higher weight on `distance_to_current`) and long-term planning when many nodes are left (higher weight on `distance_to_destination`). The weighted sum (`weighted_score`) ensures a trade-off between greediness and global optimization.",
          "thought": "This new algorithm modifies the original by incorporating a weighted sum of distances to the current node and destination, where the weights are dynamically adjusted based on the number of remaining unvisited nodes, promoting a balance between immediate proximity and long-term planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 14.08142,
          "other_inf": null
     }
]