[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (exploitation) and centrality in the remaining graph (exploration), using a fixed weight (0.3) for centrality and a dynamic penalty scaling with remaining nodes. It prioritizes nodes with lower combined scores, where distance penalty dominates early, but centrality becomes more influential as the tour progresses. The centrality measure is based on average distances to other unvisited nodes, normalized by their average.",
          "thought": "The new algorithm prioritizes proximity to the current node and centrality in the remaining graph, using a fixed weight factor for centrality and a dynamic penalty for nodes distant from the current position, ensuring a balance between exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.3  # Fixed weight for centrality\n\n    # Calculate centrality measure\n    avg_distances = []\n    for node in unvisited_nodes:\n        avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes\n        avg_distances.append(avg_dist)\n\n    avg_avg_distance = sum(avg_distances) / remaining_nodes if remaining_nodes > 0 else 0\n\n    for i, node in enumerate(unvisited_nodes):\n        distance_to_current = distance_matrix[current_node][node]\n        centrality_factor = 1.0 - (avg_distances[i] / (avg_avg_distance + 1e-6))\n        distance_penalty = distance_to_current * (1.0 + (remaining_nodes / len(distance_matrix)))  # Dynamic penalty\n        combined_score = distance_penalty + weight_factor * centrality_factor\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.51019,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance, destination proximity, and exploration bonuses, with weights adjusted based on the number of unvisited nodes and the current node's centrality. It prioritizes minimizing the distance to the current node while also considering the node's closeness to the destination and encouraging less traversed paths, with the exploration bonus given lower weight (0.1) compared to the other factors. The centrality of the current node and the number of unvisited nodes influence the dynamic weight (0.3 and 0.2 respectively), shaping the trade-off between immediate and long-term optimization.",
          "thought": "The new algorithm dynamically adjusts node selection by combining immediate distance, destination proximity, and a novel \"exploration bonus\" that encourages visiting less frequently traversed paths, with weights that evolve based on the number of unvisited nodes and the current node's centrality in the graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    best_score = float('-inf')\n    next_node = None\n\n    # Calculate centrality of current node (inverse of average distance to all nodes)\n    centrality = 1.0 / (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on unvisited nodes and centrality\n        weight = 0.3 * (1 / (1 + 0.05 * total_unvisited)) + 0.2 * centrality\n\n        # Exploration bonus: encourage less traversed paths\n        exploration_bonus = 1.0 / (1 + sum(distance_matrix[node]))\n\n        combined_score = -distance_to_current + weight * distance_to_destination + 0.1 * exploration_bonus\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.53939,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global proximity by adjusting weights based on the number of unvisited nodes: early in the search, it prioritizes proximity to the current node (`weight_current = 2.0 - visited_ratio`), while later it shifts focus to proximity to the destination (`weight_destination = 0.5 * visited_ratio`). It also penalizes nodes with many nearby unvisited neighbors (`penalty` term) to avoid revisiting regions, ensuring a trade-off between immediate and long-term optimization. The best node is selected based on the lowest weighted score combining these factors.",
          "thought": "The new algorithm prioritizes local proximity early in the search while gradually shifting focus to global proximity, using a dynamic weight adjustment based on the number of unvisited nodes and incorporating a penalty for nodes with many nearby unvisited neighbors to prevent revisiting regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 2.0 - visited_ratio\n    weight_destination = 0.5 * visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_to_current * 1.2:\n                penalty += 0.2\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (70% weight) while slightly favoring nodes farther from the destination (30% weight), balancing immediate efficiency with long-term path optimization. The `combined_score` is calculated as `0.7 * (-distance_to_current) + 0.3 * distance_to_destination`, where closer nodes to the current node contribute more positively, and nodes farther from the destination also slightly increase the score.",
          "thought": "The new algorithm prioritizes nodes closer to the current node (70%) while slightly favoring nodes farther from the destination (30%), aiming for a balance between immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('-inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = 0.7 * (-distance_to_current) + 0.3 * distance_to_destination\n\n        if combined_score > best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance prioritization with a ratio-based balance, selecting the next node by minimizing a score that adds the direct distance from the current node to a candidate node and a ratio of that distance to the candidate's distance to the destination. This balances short-term efficiency (distance to current node) with long-term efficiency (distance to destination), ensuring a trade-off between immediate and future steps. The ratio term helps avoid getting stuck in local optima by considering the candidate's proximity to the final destination.",
          "thought": "The new algorithm combines the ideas of prioritizing immediate distance (like No.2) while incorporating a ratio-based balance (like No.1) for better efficiency. It calculates a score as the immediate distance plus a weighted ratio of the distance to the destination, ensuring a trade-off between immediate and long-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        combined_score = distance_to_current + ratio\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: minimizing the distance from the current node (weighted heavily when few nodes remain) and minimizing the ratio of current distance to destination distance (weighted more when many nodes remain). The weights adjust dynamically based on the number of unvisited nodes, ensuring a trade-off between local and global optimization. The function evaluates each unvisited node using this weighted sum and returns the one with the lowest score.",
          "thought": "The new algorithm combines the ratio-based balance from No.1 (avoiding local optima by considering distance to destination) with No.2's dynamic weighting (adjusting trade-off based on remaining nodes). It selects the next node by minimizing a weighted sum of the distance to the current node and a ratio of that distance to the distance to the destination, with weights inversely proportional to the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        weight_current = 1.0 / remaining_nodes\n        weight_destination = 1.0 - weight_current\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * ratio)\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.6832,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node (weighted higher early in the tour) with distance to the destination (weighted higher as progress increases), while penalizing nodes too far from the destination and nearby revisits. The `weight_current` decreases linearly with progress, while `weight_destination` increases, and `weight_factor` non-linearly decays to emphasize destination proximity later. The penalty term discourages detours and revisits to nearby nodes.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 and the non-linear decay of No.2, using a weighted balance between proximity to the current node, distance to the destination, and a penalty for nodes too far from the destination, while adjusting weights based on progress and penalizing revisits to nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n    weight_factor = (len(unvisited_nodes) / total_nodes) ** 2\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_factor * weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global considerations by adjusting weights based on the visited ratio, prioritizing closer nodes early (high `weight_current`) and global structure later (high `weight_destination`), while penalizing crowded regions with nearby unvisited neighbors. The combined score integrates distances to the current and destination nodes, average distances to remaining nodes, and a penalty for dense clusters, making it adaptive to the tour's progress.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (based on visited ratio and decay factor) with the balanced local-global scoring of No.2, while adding a penalty for nodes with many nearby unvisited neighbors similar to No.1. It selects the next node by considering the weighted sum of distances to the current and destination nodes, adjusted dynamically by the visited ratio, along with a global factor that balances local and global distances, and penalizes crowded regions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    decay_factor = 0.5\n    weight_current = (1.0 - visited_ratio) ** decay_factor\n    weight_destination = visited_ratio ** (1.0 / decay_factor)\n    weight_global = 0.3 * (1.0 - visited_ratio)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n\n        bonus = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] > distance_to_current * 1.5:\n                bonus -= 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + (weight_global * avg_distance_to_remaining) + bonus\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.69923,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the destination node, using a decaying weight for the current node and an increasing weight for the destination as the search progresses. It penalizes nodes that are too far from the destination or have nearby revisits, prioritizing nodes that reduce the total path length while avoiding unnecessary detours. The combined score evaluates these factors to select the next node efficiently.",
          "thought": "The new algorithm combines the dynamic weighting of No.2 with the proximity and penalty adjustments of No.1, using a decaying weight for the current node and an increasing weight for the destination, while penalizing nodes too far from the destination or with nearby revisits.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    weight_current = 1.0 - visited_ratio\n    weight_destination = visited_ratio\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        penalty = max(0, distance_to_destination - 2 * distance_matrix[current_node][destination_node]) ** 2\n\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] < distance_matrix[current_node][node] * 1.5:\n                penalty += 0.1\n\n        combined_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + penalty\n\n        if combined_score < best_score:\n            best_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70372,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weighted heavily early) and proximity to the destination (weighted more heavily later), using an exponential decay factor. It also penalizes nodes with many nearby unvisited neighbors to encourage exploration of less crowded regions, with weights dynamically adjusted based on the visited ratio. The weighted score combines these factors to prioritize efficient local moves early and strategic destination approaches later.",
          "thought": "The new algorithm modifies the original by using an exponential decay factor for weights, increasing destination proximity influence early, and adding a bonus for nodes with few nearby unvisited neighbors to encourage exploration of less crowded regions while maintaining local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    decay_factor = 0.5\n    weight_current = (1.0 - visited_ratio) ** decay_factor\n    weight_destination = visited_ratio ** (1.0 / decay_factor)\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        bonus = 0.0\n        for neighbor in unvisited_nodes:\n            if neighbor != node and distance_matrix[node][neighbor] > distance_to_current * 1.5:\n                bonus -= 0.1\n\n        weighted_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination) + bonus\n\n        if weighted_score < best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.70376,
          "other_inf": null
     }
]