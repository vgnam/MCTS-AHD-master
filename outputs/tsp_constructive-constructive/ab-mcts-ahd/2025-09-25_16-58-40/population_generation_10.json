[
     {
          "algorithm": "The algorithm balances immediate distance to the next node with potential future savings by prioritizing nodes that minimize a weighted score combining current distance and the difference between direct and detour distances to the destination. The score is computed as `current_distance - 0.3 * future_savings`, where future savings are estimated by the difference between the direct distance from the candidate node to the destination and the current detour distance. The weight of 0.3 gives more priority to immediate distance than future savings, favoring nodes closer in the short term while still considering long-term efficiency.",
          "thought": "The new algorithm introduces a weighted balance between immediate distance and potential future savings by incorporating a lookahead mechanism, where the selection of the next node considers both the current distance and the estimated savings from choosing that node over others, balancing immediate and long-term optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = current_distance - 0.3 * future_savings\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance and long-term node centrality, prioritizing shorter distances (70% weight) over centrality (30% weight). Centrality is calculated as the average distance to other unvisited nodes, with higher centrality nodes being penalized (inverted and normalized). The code efficiently combines these factors using a weighted scoring mechanism to guide the selection toward both proximity and strategic node placement.",
          "thought": "The algorithm implements a probabilistic selection mechanism that considers both immediate distance and potential long-term benefits, using a weighted combination of distance and node centrality to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is better, so invert)\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = 0.7 * distance + 0.3 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.77573,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements the **nearest neighbor heuristic** for TSP, prioritizing the unvisited node closest to the current node. It checks all unvisited nodes, selects the one with the smallest distance from the current node, and returns to the destination if no nodes remain. The function prioritizes minimizing immediate distance over long-term optimality, with `current_node` and `unvisited_nodes` being key inputs.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node with the smallest distance from the current node, or the destination node if all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor heuristic by assigning higher priority to immediate distance (70%) and lower priority to future cost (30%) when selecting the next node to visit. It dynamically balances these factors using a weighted sum, ensuring the path remains efficient while avoiding local optima. The function prioritizes minimizing the current distance more than estimating future distances to the destination.",
          "thought": "The new algorithm modifies the nearest neighbor heuristic by incorporating a dynamic weighting mechanism that balances immediate distance minimization with long-term path optimality, using a weighted sum of the current distance and an estimated future cost to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weighted_scores = {}\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_estimate = distance_matrix[node][destination_node]\n        weighted_scores[node] = 0.7 * current_distance + 0.3 * future_estimate\n    next_node = min(weighted_scores, key=weighted_scores.get)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest neighbor heuristic with a lookahead mechanism by prioritizing immediate distance (70%) over the average distance to remaining unvisited nodes (30%). It balances short-term efficiency (current_distance) with long-term connectivity (avg_distance), ensuring the next node is chosen based on both proximity and potential future path quality. The score calculation (0.7*current_distance + 0.3*avg_distance) explicitly weights immediate distance higher, making it a greedy but informed heuristic.",
          "thought": "The new algorithm, inspired by the nearest neighbor heuristic, selects the next node based on a weighted combination of the current distance and the average distance to unvisited nodes, balancing immediate and long-term optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.7 * current_distance + 0.3 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.71312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: (1) minimizing the maximum distance from the candidate node to all other unvisited nodes (for compactness) and (2) being close to the current node (for efficiency). It evaluates each unvisited node by computing the sum of its distance to the current node and the maximum distance to the remaining unvisited nodes, then chooses the node with the smallest total cost. The `current_node` and `distance_matrix` are prioritized in the cost calculation, while the `destination_node` is only used as a fallback when no unvisited nodes remain.",
          "thought": "The new algorithm combines the No.1 algorithm's idea of prioritizing nodes that minimize the maximum distance to other unvisited nodes (for compactness) with the No.2 algorithm's nearest neighbor approach, by selecting the next node that minimizes the maximum distance to the remaining unvisited nodes while also being close to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_max_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        remaining_nodes = [other for other in unvisited_nodes if other != node]\n        if not remaining_nodes:\n            current_max = 0\n        else:\n            current_max = max(distance_matrix[node][other] for other in remaining_nodes)\n        total_cost = distance_matrix[current_node][node] + current_max\n\n        if total_cost < min_max_distance:\n            min_max_distance = total_cost\n            next_node = node\n\n    return next_node",
          "objective": 8.58622,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the maximum distance to any other unvisited node, ensuring a balanced and compact tour. It evaluates each candidate node by computing the largest minimum distance to other unvisited nodes and chooses the one with the highest such value, thereby optimizing for global path compactness. The function iterates through unvisited nodes, checks their distances to others, and selects the node that maximizes this metric, while the `distance_matrix` provides the necessary distance values for comparisons.",
          "thought": "The new algorithm prioritizes nodes that minimize the maximum distance to any other unvisited node, ensuring a more balanced and compact tour by always choosing the node that reduces the largest gap in the remaining unvisited set, thus optimizing for global path compactness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    max_min_distance = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        min_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n        current_max_min = max(min_distances) if min_distances else 0\n        if current_max_min > max_min_distance:\n            max_min_distance = current_max_min\n            next_node = node\n\n    return next_node",
          "objective": 20.66534,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the sum of distances to all other unvisited nodes, ensuring global connectivity while balancing proximity. It evaluates each unvisited node based on its total distance to all remaining nodes, choosing the one with the smallest sum to reduce cumulative travel distance. The function iterates through unvisited nodes, computes their total distances, and selects the node with the minimal sum, effectively optimizing for a compact and efficient path.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the sum of distances to all other unvisited nodes, aiming to create a path that balances proximity and global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 32.0389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements the **farthest insertion heuristic** for TSP, selecting the next node as the one farthest from the current node to maximize tour diversity. It prioritizes **distance** over other factors (e.g., immediate optimality) by always choosing the unvisited node with the greatest distance from the current node, ensuring a balanced and exploratory tour construction. The **destination_node** is only returned if no unvisited nodes remain, and the **distance_matrix** drives the selection logic.",
          "thought": "The new algorithm implements the farthest insertion heuristic for TSP, prioritizing the unvisited node farthest from the current node to maximize diversity in the tour, balancing immediate distance with potential long-term path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_distance = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] > max_distance:\n            max_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]