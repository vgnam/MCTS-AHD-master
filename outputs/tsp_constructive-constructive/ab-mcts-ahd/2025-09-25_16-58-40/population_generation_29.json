[
     {
          "algorithm": "The algorithm dynamically balances three key factors: immediate distance (40% weight), node centrality (30% weight with dynamic adjustment), and destination proximity penalty (30% weight). Centrality is prioritized more as the tour progresses (via dynamic weighting), while nodes too close to the destination receive a penalty to ensure strategic intermediate placement. The algorithm combines these factors into a score, selecting the next node with the minimum score to minimize total travel distance while maintaining strategic positioning.",
          "thought": "This new algorithm dynamically balances immediate distance (40% weight), node centrality (30% weight), and destination proximity penalty (30% weight), with centrality prioritized later in the process and penalizing nodes too close to the destination to ensure strategic intermediate placement.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weight for centrality based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = max(0.1, min(0.9, 0.6 - 0.05 * (remaining_nodes - 1)))\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Calculate penalty for nodes too close to destination\n    penalty = {}\n    for node in unvisited_nodes:\n        penalty[node] = 1 / (1 + distance_matrix[node][destination_node])\n\n    # Combine factors with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = (0.4 * distance +\n                        (0.3 * (1 - dynamic_weight) + 0.3 * dynamic_weight) * normalized_centrality +\n                        0.3 * penalty[node])\n\n    # Select node with minimum score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.33107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes node centrality early in the process (high dynamic weight) and balances it with distance later (lower dynamic weight), while aggressively penalizing nodes close to the destination to avoid premature convergence. The score combines normalized centrality, distance, and a penalty term, with the dynamic weight adjusting based on remaining nodes. Centrality is calculated as average distance to unvisited nodes, while the penalty inversely scales with proximity to the destination. The algorithm selects the node with the lowest combined score, effectively trading off strategic positioning and immediate distance efficiency.",
          "thought": "The new algorithm prioritizes node centrality early in the process and balances it with distance later, using a different dynamic weight scheme and a more aggressive penalty for nodes close to the destination, aiming to create a more strategic intermediate path while maintaining overall distance efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weight based on remaining nodes (prioritize centrality early)\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = max(0.3, min(0.7, 0.5 + 0.03 * (remaining_nodes - 1)))\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Calculate penalty for nodes too close to destination (more aggressive)\n    penalty = {}\n    for node in unvisited_nodes:\n        penalty[node] = 1 / (1 + 0.5 * distance_matrix[node][destination_node])\n\n    # Combine factors with dynamic weight\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = (dynamic_weight * normalized_centrality +\n                        (1 - dynamic_weight) * distance +\n                        0.3 * penalty[node])\n\n    # Select node with minimum score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.53286,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between proximity (distance) and strategic placement (centrality) using an exploration factor that adapts based on remaining nodes. It prioritizes nodes with lower immediate distance and higher centrality (calculated as average distance to other unvisited nodes), while penalizing detours to avoid unnecessary loops. The exploration factor (ranging 0.1-0.9) shifts focus from proximity to centrality as the tour progresses, with detour penalties (0.3 weight) ensuring efficiency. The score is minimized to select the optimal next node.",
          "thought": "The new algorithm introduces a dynamic priority system that combines immediate distance, node centrality, and a novel \"exploration factor\" to balance between proximity and strategic placement, while also incorporating a \"detour penalty\" to avoid unnecessary loops, adjusting weights dynamically based on remaining nodes and tour progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = max(0.1, min(0.9, 0.5 + 0.03 * (remaining_nodes - 1)))\n\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / max(1, len(unvisited_nodes) - 1)\n\n    detour_penalty = {}\n    for node in unvisited_nodes:\n        detour = distance_matrix[current_node][node] + distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        detour_penalty[node] = 1 / (1 + detour) if detour > 0 else 1\n\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = (exploration_factor * distance +\n                        (1 - exploration_factor) * normalized_centrality +\n                        0.3 * detour_penalty[node])\n\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.69912,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the next node with potential future savings by prioritizing nodes that minimize a weighted score combining current distance and the difference between direct and detour distances to the destination. The score is computed as `current_distance - 0.3 * future_savings`, where future savings are estimated by the difference between the direct distance from the candidate node to the destination and the current detour distance. The weight of 0.3 gives more priority to immediate distance than future savings, favoring nodes closer in the short term while still considering long-term efficiency.",
          "thought": "The new algorithm introduces a weighted balance between immediate distance and potential future savings by incorporating a lookahead mechanism, where the selection of the next node considers both the current distance and the estimated savings from choosing that node over others, balancing immediate and long-term optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = current_distance - 0.3 * future_savings\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) over node centrality (40%), where centrality is defined as the maximum distance to other unvisited nodes (higher centrality is penalized by normalization and inversion). It selects the next node by minimizing a weighted score combining distance and normalized centrality.",
          "thought": "The new algorithm prioritizes immediate distance (60% weight) over node centrality (40% weight), where centrality is calculated as the maximum distance to other unvisited nodes (instead of average), and higher centrality is penalized (normalized and inverted).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (maximum distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        if len(unvisited_nodes) > 1:\n            max_distance = max(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            centrality[node] = max_distance\n        else:\n            centrality[node] = 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is worse, so invert)\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = 0.6 * distance + 0.4 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.74159,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance and long-term node centrality, prioritizing shorter distances (70% weight) over centrality (30% weight). Centrality is calculated as the average distance to other unvisited nodes, with higher centrality nodes being penalized (inverted and normalized). The code efficiently combines these factors using a weighted scoring mechanism to guide the selection toward both proximity and strategic node placement.",
          "thought": "The algorithm implements a probabilistic selection mechanism that considers both immediate distance and potential long-term benefits, using a weighted combination of distance and node centrality to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is better, so invert)\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = 0.7 * distance + 0.3 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.77573,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a global connectivity approach with dynamic weighting to balance immediate distance and long-term centrality. It prioritizes immediate distance more when few nodes remain unvisited (weight=0.7) but shifts to prioritizing centrality (lower scores for nodes with high total distance to others) when more nodes remain (weight=0.8). The score for each node is calculated as a weighted sum of its distance from the current node and its normalized centrality (inverse of average distance to other unvisited nodes), ensuring both short-term efficiency and long-term tour optimization.",
          "thought": "The new algorithm will combine the global connectivity approach from No.2 with the dynamic weighting and centrality/lookahead factors from No.1, creating a hybrid selection strategy that minimizes both immediate and future path costs while maintaining tour efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    dynamic_weight = 0.7 if len(unvisited_nodes) > len(distance_matrix) / 2 else 0.8\n    scores = {}\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        normalized_centrality = 1 / (1 + centrality) if centrality != 0 else 1\n        scores[node] = dynamic_weight * distance + (1 - dynamic_weight) * normalized_centrality\n\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.81545,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines immediate distance minimization with node centrality and strategic placement, dynamically adjusting priorities: early on, it heavily favors nearby nodes (high `dynamic_weight`), while later emphasizing centrality (lower `dynamic_weight`). It also penalizes nodes too close to the destination to avoid premature convergence, balancing these factors in a weighted score to select the next node. The `dynamic_weight` decays linearly from 0.8 to 0.3 as nodes are visited, while penalties and centrality are normalized and combined with distance.",
          "thought": "The new algorithm prioritizes immediate distance minimization early in the process, gradually shifting focus to node centrality (average distance to other nodes) as more nodes are visited, while dynamically adjusting penalties for nodes too close to the destination to ensure strategic intermediate placement.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weight based on remaining nodes (linear decay)\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = max(0.3, min(0.8, 0.8 - 0.03 * remaining_nodes))\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Calculate penalty for nodes too close to destination (exponential)\n    penalty = {}\n    for node in unvisited_nodes:\n        penalty[node] = 1 / (1 + (distance_matrix[node][destination_node] ** 2))\n\n    # Combine factors with dynamic weight\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = (dynamic_weight * distance +\n                        (1 - dynamic_weight) * normalized_centrality +\n                        0.3 * penalty[node])\n\n    # Select node with minimum score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.83414,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by dynamically balancing distance, centrality, lookahead, and penalty factors, with higher priority given to immediate distance (weighted by `dynamic_weight`), followed by centrality and lookahead, while penalties for proximity to the destination and global node distribution are applied with lower weights (0.2). The `dynamic_weight` adjusts based on tour progress and node density, while centrality and lookahead use normalized averages to estimate future path impact. The final score combines these factors to minimize the next node's selection.",
          "thought": "The new algorithm introduces a multi-criteria selection mechanism that dynamically adjusts weights based on node density and tour progress, incorporates a \"look-ahead\" feature to estimate future path impact, and uses a penalty term that considers both immediate and global proximity to the destination, while also rewarding nodes that are well-positioned for future centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weights based on tour progress and node density\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.6 if remaining_nodes > len(distance_matrix) / 2 else 0.8\n    dynamic_weight = max(0.2, min(0.9, base_weight - 0.03 * remaining_nodes))\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Look-ahead factor: estimate impact on future path\n    lookahead = {}\n    for node in unvisited_nodes:\n        future_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n        lookahead[node] = sum(sorted(future_distances)[:2]) if len(future_distances) >= 2 else 0\n\n    # Penalty term considering both immediate and global proximity to destination\n    penalty = {}\n    for node in unvisited_nodes:\n        immediate_penalty = 1 / (1 + distance_matrix[node][destination_node])\n        global_penalty = 1 / (1 + sum(distance_matrix[node][other] for other in unvisited_nodes))\n        penalty[node] = 0.7 * immediate_penalty + 0.3 * global_penalty\n\n    # Combine factors with dynamic weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        normalized_lookahead = 1 / (1 + lookahead[node]) if lookahead[node] != 0 else 1\n        scores[node] = (dynamic_weight * distance +\n                        (1 - dynamic_weight) * normalized_centrality +\n                        0.3 * normalized_lookahead +\n                        0.2 * penalty[node])\n\n    # Select node with minimum score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.97221,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements the **nearest neighbor heuristic** for TSP, prioritizing the unvisited node closest to the current node. It checks all unvisited nodes, selects the one with the smallest distance from the current node, and returns to the destination if no nodes remain. The function prioritizes minimizing immediate distance over long-term optimality, with `current_node` and `unvisited_nodes` being key inputs.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node with the smallest distance from the current node, or the destination node if all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     }
]