[
     {
          "algorithm": "The algorithm balances immediate distance to the next node with potential future savings by prioritizing nodes that minimize a weighted score combining current distance and the difference between direct and detour distances to the destination. The score is computed as `current_distance - 0.3 * future_savings`, where future savings are estimated by the difference between the direct distance from the candidate node to the destination and the current detour distance. The weight of 0.3 gives more priority to immediate distance than future savings, favoring nodes closer in the short term while still considering long-term efficiency.",
          "thought": "The new algorithm introduces a weighted balance between immediate distance and potential future savings by incorporating a lookahead mechanism, where the selection of the next node considers both the current distance and the estimated savings from choosing that node over others, balancing immediate and long-term optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_savings = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n        score = current_distance - 0.3 * future_savings\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance (60%) over node centrality (40%), where centrality is defined as the maximum distance to other unvisited nodes (higher centrality is penalized by normalization and inversion). It selects the next node by minimizing a weighted score combining distance and normalized centrality.",
          "thought": "The new algorithm prioritizes immediate distance (60% weight) over node centrality (40% weight), where centrality is calculated as the maximum distance to other unvisited nodes (instead of average), and higher centrality is penalized (normalized and inverted).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (maximum distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        if len(unvisited_nodes) > 1:\n            max_distance = max(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            centrality[node] = max_distance\n        else:\n            centrality[node] = 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is worse, so invert)\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = 0.6 * distance + 0.4 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.74159,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance and long-term node centrality, prioritizing shorter distances (70% weight) over centrality (30% weight). Centrality is calculated as the average distance to other unvisited nodes, with higher centrality nodes being penalized (inverted and normalized). The code efficiently combines these factors using a weighted scoring mechanism to guide the selection toward both proximity and strategic node placement.",
          "thought": "The algorithm implements a probabilistic selection mechanism that considers both immediate distance and potential long-term benefits, using a weighted combination of distance and node centrality to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is better, so invert)\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = 0.7 * distance + 0.3 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.77573,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements the **nearest neighbor heuristic** for TSP, prioritizing the unvisited node closest to the current node. It checks all unvisited nodes, selects the one with the smallest distance from the current node, and returns to the destination if no nodes remain. The function prioritizes minimizing immediate distance over long-term optimality, with `current_node` and `unvisited_nodes` being key inputs.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the unvisited node with the smallest distance from the current node, or the destination node if all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor heuristic by assigning higher priority to immediate distance (70%) and lower priority to future cost (30%) when selecting the next node to visit. It dynamically balances these factors using a weighted sum, ensuring the path remains efficient while avoiding local optima. The function prioritizes minimizing the current distance more than estimating future distances to the destination.",
          "thought": "The new algorithm modifies the nearest neighbor heuristic by incorporating a dynamic weighting mechanism that balances immediate distance minimization with long-term path optimality, using a weighted sum of the current distance and an estimated future cost to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    weighted_scores = {}\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_estimate = distance_matrix[node][destination_node]\n        weighted_scores[node] = 0.7 * current_distance + 0.3 * future_estimate\n    next_node = min(weighted_scores, key=weighted_scores.get)\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest neighbor heuristic with a lookahead mechanism by prioritizing immediate distance (70%) over the average distance to remaining unvisited nodes (30%). It balances short-term efficiency (current_distance) with long-term connectivity (avg_distance), ensuring the next node is chosen based on both proximity and potential future path quality. The score calculation (0.7*current_distance + 0.3*avg_distance) explicitly weights immediate distance higher, making it a greedy but informed heuristic.",
          "thought": "The new algorithm, inspired by the nearest neighbor heuristic, selects the next node based on a weighted combination of the current distance and the average distance to unvisited nodes, balancing immediate and long-term optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.7 * current_distance + 0.3 * avg_distance\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.71312,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts weights between distance and centrality based on the number of unvisited nodes, prioritizing centrality early (higher weight) and distance later (higher weight). It penalizes high-centrality nodes to avoid clustering and selects the next node by minimizing a combined score of weighted distance, normalized centrality, and a penalty term. The key variables are `weight_distance` and `weight_centrality`, which are inversely proportional to the remaining nodes, and the penalty term `(1 - normalized_centrality) ** 2` discourages overcentralized nodes.",
          "thought": "This new algorithm modifies the original by incorporating a dynamic weight adjustment based on the remaining tour length, where weights for distance and centrality are inversely proportional to the number of unvisited nodes, emphasizing centrality in early stages and distance in later stages. It also introduces a penalty term for nodes with high centrality to avoid clustering, calculated as the square of the normalized centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Dynamic weight adjustment based on remaining tour length\n    remaining_nodes = len(unvisited_nodes)\n    weight_distance = 0.7 * (remaining_nodes / (remaining_nodes + 10))  # Decreases as tour progresses\n    weight_centrality = 0.3 * (10 / (remaining_nodes + 10))  # Increases as tour progresses\n\n    # Combine distance and centrality with dynamic weights and penalty\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        penalty = (1 - normalized_centrality) ** 2  # Penalize high centrality nodes\n        scores[node] = weight_distance * distance + weight_centrality * normalized_centrality + penalty\n\n    # Select node with minimum score (distance + centrality + penalty)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 8.09362,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between minimizing immediate distance and maximizing node centrality (average distance to other nodes), adjusting the weight based on remaining unvisited nodes (prioritizing distance early and centrality later). It also penalizes nodes too close to the destination, ensuring strategic intermediate placement. The score combines distance, centrality (normalized), and penalty with dynamic weights, selecting the node with the minimum score.",
          "thought": "The new algorithm introduces a dynamic weight adjustment mechanism that adapts the balance between immediate distance and long-term centrality based on the remaining number of unvisited nodes, emphasizing distance early in the process and centrality as unvisited nodes decrease. It also incorporates a penalty factor for nodes that are too close to the destination, ensuring strategic placement of intermediate nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate dynamic weight based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = max(0.1, min(0.9, 0.7 - 0.05 * (remaining_nodes - 1)))\n\n    # Calculate node centrality (average distance to other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Calculate penalty for nodes too close to destination\n    penalty = {}\n    for node in unvisited_nodes:\n        penalty[node] = 1 / (1 + distance_matrix[node][destination_node])\n\n    # Combine factors with dynamic weight\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        normalized_centrality = 1 / (1 + centrality[node]) if centrality[node] != 0 else 1\n        scores[node] = (dynamic_weight * distance +\n                        (1 - dynamic_weight) * normalized_centrality +\n                        0.2 * penalty[node])\n\n    # Select node with minimum score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 8.34464,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two priorities: (1) minimizing the maximum distance from the candidate node to all other unvisited nodes (for compactness) and (2) being close to the current node (for efficiency). It evaluates each unvisited node by computing the sum of its distance to the current node and the maximum distance to the remaining unvisited nodes, then chooses the node with the smallest total cost. The `current_node` and `distance_matrix` are prioritized in the cost calculation, while the `destination_node` is only used as a fallback when no unvisited nodes remain.",
          "thought": "The new algorithm combines the No.1 algorithm's idea of prioritizing nodes that minimize the maximum distance to other unvisited nodes (for compactness) with the No.2 algorithm's nearest neighbor approach, by selecting the next node that minimizes the maximum distance to the remaining unvisited nodes while also being close to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_max_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        remaining_nodes = [other for other in unvisited_nodes if other != node]\n        if not remaining_nodes:\n            current_max = 0\n        else:\n            current_max = max(distance_matrix[node][other] for other in remaining_nodes)\n        total_cost = distance_matrix[current_node][node] + current_max\n\n        if total_cost < min_max_distance:\n            min_max_distance = total_cost\n            next_node = node\n\n    return next_node",
          "objective": 8.58622,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes **long-term centrality (60% weight)** over **immediate distance (40% weight)**, where centrality is the average distance to all nodes (visited and unvisited), favoring nodes with higher centrality (normalized and directly used). The function selects the next node by minimizing a combined score of distance and centrality, ensuring a balance between proximity and strategic positioning.",
          "thought": "The new algorithm prioritizes long-term centrality (60% weight) over immediate distance (40% weight), where centrality is calculated as the average distance to all nodes (visited and unvisited), with higher centrality nodes being favored (normalized and directly used).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    # Calculate node centrality (average distance to all nodes)\n    centrality = {}\n    all_nodes = set(unvisited_nodes) | {current_node}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in all_nodes if other != node)\n        centrality[node] = total_distance / (len(all_nodes) - 1) if len(all_nodes) > 1 else 0\n\n    # Combine distance and centrality with weights\n    scores = {}\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Normalize centrality (higher centrality is better)\n        normalized_centrality = centrality[node] / (max(centrality.values()) if max(centrality.values()) != 0 else 1)\n        scores[node] = 0.4 * distance + 0.6 * normalized_centrality\n\n    # Select node with minimum score (distance + centrality)\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 9.3454,
          "other_inf": null
     }
]