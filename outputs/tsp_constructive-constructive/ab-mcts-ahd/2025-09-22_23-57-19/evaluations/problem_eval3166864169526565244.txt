def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    costs = []
    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        costs.append((node, cost))

    costs.sort(key=lambda x: x[1])
    min_cost = costs[0][1]

    if len(unvisited_nodes) > 2:
        penalty_factor = 0.1
        total_weight = 0.0
        weighted_nodes = []

        for node, cost in costs:
            penalty = penalty_factor * (cost - min_cost)
            weight = 1.0 / (cost + penalty)
            weighted_nodes.append((node, weight))
            total_weight += weight

        if total_weight > 0:
            rand_val = random.random() * total_weight
            cumulative_weight = 0.0
            for node, weight in weighted_nodes:
                cumulative_weight += weight
                if rand_val <= cumulative_weight:
                    return node

    return next_node
