def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    costs = [distance_matrix[current_node][node] for node in unvisited_nodes]
    min_cost = min(costs)
    max_cost = max(costs)
    cost_range = max_cost - min_cost if max_cost != min_cost else 1

    dynamic_threshold = 0.1 + (0.9 * (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))))

    probabilities = []
    for cost in costs:
        normalized_cost = (cost - min_cost) / cost_range
        prob = math.exp(-normalized_cost / dynamic_threshold)
        probabilities.append(prob)

    total_prob = sum(probabilities)
    probabilities = [p / total_prob for p in probabilities]

    selected_index = random.choices(range(len(unvisited_nodes)), weights=probabilities, k=1)[0]
    next_node = unvisited_nodes[selected_index]

    return next_node
