def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    remaining_nodes = len(unvisited_nodes)
    dynamic_weight = 0.7 if remaining_nodes > 4 else 0.3

    candidates = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0
        score = distance + dynamic_weight * heuristic
        candidates.append((node, score))

    candidates.sort(key=lambda x: x[1])
    top_candidates = candidates[:min(3, len(candidates))]

    if remaining_nodes > 3:
        next_node = top_candidates[0][0]
    else:
        probabilities = [1.0 / (i + 1) for i in range(len(top_candidates))]
        total = sum(probabilities)
        probabilities = [p / total for p in probabilities]
        next_node = random.choices([c[0] for c in top_candidates], weights=probabilities, k=1)[0]

    if remaining_nodes <= 2:
        for candidate in top_candidates:
            if candidate[0] != next_node:
                detour_cost = distance_matrix[current_node][candidate[0]] + distance_matrix[candidate[0]][next_node]
                if detour_cost < 1.2 * (distance_matrix[current_node][next_node] + distance_matrix[next_node][next_node]):
                    next_node = candidate[0]
                    break

    return next_node
