import random
import math
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)
    std_dev = (sum((d - avg_distance) ** 2 for d in distances) / len(distances)) ** 0.5

    # Dynamic temperature based on local density entropy
    local_density = np.histogram(distances, bins=5, density=True)[0]
    entropy = -sum(p * math.log(p + 1e-10) for p in local_density if p > 0)
    temperature = max(0.1, 1.0 - min(0.9, entropy / 2.0))

    # Adaptive momentum based on remaining nodes and local variance
    momentum = 0.5 if len(unvisited_nodes) > 10 else 0.2
    momentum *= (1.0 - min(0.9, std_dev / (avg_distance + 1e-10)))

    # Cluster-based candidate selection
    cluster_threshold = avg_distance + 0.8 * std_dev
    candidates = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= cluster_threshold]

    if not candidates:
        candidates = unvisited_nodes

    # Novel selection mechanism combining probabilistic, nearest, and density-based choices
    if random.random() < temperature:
        if random.random() < 0.7:
            # Density-based selection
            density_scores = []
            for node in candidates:
                neighbor_distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
                neighbor_avg = sum(neighbor_distances) / len(neighbor_distances) if neighbor_distances else float('inf')
                density_scores.append((node, neighbor_avg))
            density_scores.sort(key=lambda x: x[1])
            next_node = density_scores[0][0]
        else:
            # Probabilistic selection with inverse distance weighting
            weights = [1.0 / (distance_matrix[current_node][node] + 1e-10) for node in candidates]
            next_node = random.choices(candidates, weights=weights, k=1)[0]
    else:
        # Nearest neighbor with momentum consideration
        nearest_node = min(candidates, key=lambda x: distance_matrix[current_node][x])
        if random.random() < momentum and len(unvisited_nodes) > 3:
            # Consider second nearest for momentum effect
            sorted_candidates = sorted(candidates, key=lambda x: distance_matrix[current_node][x])
            if len(sorted_candidates) > 1:
                next_node = sorted_candidates[1]
            else:
                next_node = nearest_node
        else:
            next_node = nearest_node

    return next_node
