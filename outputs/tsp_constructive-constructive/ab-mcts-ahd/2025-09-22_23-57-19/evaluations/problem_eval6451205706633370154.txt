def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    distances = [(node, distance_matrix[current_node][node]) for node in unvisited_nodes]
    closest_node, closest_dist = min(distances, key=lambda x: x[1])
    farthest_node, farthest_dist = max(distances, key=lambda x: x[1])

    # Dynamic weighting based on distance ratio (sigmoid function)
    ratio = (farthest_dist - closest_dist) / (farthest_dist + 1e-10)  # Avoid division by zero
    weight = 1 / (1 + math.exp(-10 * (ratio - 0.5)))  # Sigmoid transition at ratio=0.5

    # Penalize nodes that have been visited more frequently
    visit_counts = {node: sum(1 for n in unvisited_nodes if n == node) for node in unvisited_nodes}
    penalty = {node: 1 / (1 + visit_counts.get(node, 0)) for node in unvisited_nodes}

    # Combine weighted selection with penalty
    weighted_closest = closest_dist * penalty.get(closest_node, 1)
    weighted_farthest = farthest_dist * penalty.get(farthest_node, 1)

    next_node = closest_node if weighted_closest < weighted_farthest * weight else farthest_node

    return next_node
