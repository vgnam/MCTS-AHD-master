def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    remaining_nodes = len(unvisited_nodes)
    temperature = 1.0 / (1.0 + remaining_nodes)  # Decreasing temperature over time
    weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))  # Dynamic weight adjustment
    scores = []

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0
        score = distance + weight * heuristic
        scores.append((node, score))

    # Compute selection probabilities using softmax with temperature
    max_score = max(score[1] for score in scores)
    exp_scores = [math.exp(-(score[1] - max_score) / temperature) for score in scores]
    total = sum(exp_scores)
    probabilities = [exp_score / total for exp_score in exp_scores]

    # Select node based on probabilities
    next_node = random.choices([score[0] for score in scores], weights=probabilities, k=1)[0]

    return next_node
