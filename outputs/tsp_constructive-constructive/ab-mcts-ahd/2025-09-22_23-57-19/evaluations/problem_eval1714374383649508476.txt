def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    total_nodes = len(distance_matrix)
    phase_progress = 1 - (len(unvisited_nodes) / total_nodes)
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)

    min_cost = min(distances)
    min_cost_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] == min_cost]

    node_scores = {}
    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        centrality = sum(distance_matrix[node]) / (total_nodes - 1)
        cost_factor = (cost / min_cost) if min_cost > 0 else 1
        centrality_factor = centrality / avg_distance

        exploration_weight = 0.5 * (1 - phase_progress)
        exploitation_weight = 1 - exploration_weight

        score = (exploration_weight * cost_factor) + (exploitation_weight * centrality_factor)

        if node in min_cost_nodes:
            score *= 0.8

        node_scores[node] = score

    sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])
    candidate_nodes = [node for node, score in sorted_nodes if score <= 1.1 * sorted_nodes[0][1]]

    if len(candidate_nodes) > 1:
        neighborhood_scores = {}
        for node in candidate_nodes:
            neighborhood = [n for n in unvisited_nodes if n != node]
            neighborhood_score = sum(distance_matrix[node][n] for n in neighborhood) / len(neighborhood) if neighborhood else 0
            neighborhood_scores[node] = neighborhood_score

        next_node = min(neighborhood_scores.items(), key=lambda x: x[1])[0]
    else:
        next_node = candidate_nodes[0] if candidate_nodes else sorted_nodes[0][0]

    return next_node
