def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    # Calculate centrality and local density for each node
    centrality = {}
    local_density = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node]) / (len(distance_matrix[node]) - 1)
        neighbors = [n for n in unvisited_nodes if n != node]
        local_density[node] = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors) if neighbors else 0

    # Hybrid cost function: distance + (1 - centrality) + (1 - local_density)
    hybrid_costs = {}
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        hybrid_costs[node] = distance + (1 - centrality[node]) + (1 - local_density[node])

    # Dynamic threshold based on remaining nodes
    threshold_factor = 1.0 if len(unvisited_nodes) > 3 else 0.7
    min_hybrid_cost = min(hybrid_costs.values())
    candidates = [node for node in unvisited_nodes if hybrid_costs[node] <= min_hybrid_cost * threshold_factor]

    if candidates:
        # Prefer higher centrality when few nodes remain
        if len(unvisited_nodes) <= 3:
            candidates.sort(key=lambda x: -centrality[x])
        return candidates[0]
    else:
        # Fallback to nearest neighbor if no candidates meet threshold
        min_distance = min(distance_matrix[current_node][node] for node in unvisited_nodes)
        return next_node
