def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)
    max_distance = max(distances)
    min_distance = min(distances)

    # Temperature for softmax selection (higher temperature for more exploration)
    temperature = 1.0 / len(unvisited_nodes)

    # Compute selection probabilities
    probabilities = []
    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        # Bias toward farthest nodes, but with probabilistic escape
        if cost == max_distance:
            prob = 0.5
        elif cost < avg_distance * 1.2 and cost > max_distance * 0.7:
            prob = 0.3
        else:
            prob = 0.2
        probabilities.append(prob)

    # Softmax selection
    exp_probs = [math.exp(p / temperature) for p in probabilities]
    sum_exp = sum(exp_probs)
    normalized_probs = [e / sum_exp for e in exp_probs]

    # Select node based on probabilities
    next_node = np.random.choice(unvisited_nodes, p=normalized_probs)

    return next_node
