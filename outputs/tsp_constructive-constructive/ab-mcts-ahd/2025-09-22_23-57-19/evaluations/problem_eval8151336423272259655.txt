def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)
    std_dev = (sum((d - avg_distance) ** 2 for d in distances) / len(distances)) ** 0.5

    min_cost = float('inf')
    next_node = None

    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        if cost < min_cost:
            min_cost = cost
            next_node = node

    if next_node is None:
        return unvisited_nodes.pop()

    if len(unvisited_nodes) > 2:
        node_degrees = {node: sum(1 for n in unvisited_nodes if distance_matrix[node][n] <= avg_distance) for node in unvisited_nodes}
        max_degree = max(node_degrees.values()) if node_degrees else 1

        candidates = []
        for node in unvisited_nodes:
            cost = distance_matrix[current_node][node]
            degree_factor = node_degrees[node] / max_degree if max_degree else 0
            weighted_cost = (0.7 * cost + 0.3 * (1 - degree_factor)) * (1 + 0.1 * (std_dev / (avg_distance + 1e-9)))

            if weighted_cost < min_cost * 1.3:
                candidates.append((node, weighted_cost))

        if candidates:
            candidates.sort(key=lambda x: x[1])
            next_node = candidates[0][0]
        else:
            for node in unvisited_nodes:
                if node == next_node:
                    continue
                cost = distance_matrix[current_node][node]
                if cost < avg_distance * 1.5 and cost < min_cost * 1.2:
                    next_node = node
                    break

    return next_node
