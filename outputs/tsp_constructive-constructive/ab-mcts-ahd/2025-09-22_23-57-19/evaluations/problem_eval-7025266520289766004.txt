def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    candidates = []
    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        if node == destination_node:
            candidates.append((node, cost, 0))  # Priority to destination
        else:
            distance_to_dest = distance_matrix[node][destination_node]
            cost_to_distance_ratio = cost / (distance_to_dest + 1e-6)  # Avoid division by zero
            candidates.append((node, cost, cost_to_distance_ratio))

    if not candidates:
        return unvisited_nodes.pop()

    # Calculate dynamic threshold based on average distance
    avg_distance = sum(cost for _, cost, _ in candidates) / len(candidates)
    threshold = avg_distance * 1.1

    # Filter candidates below threshold
    filtered = [(node, cost, ratio) for node, cost, ratio in candidates if cost <= threshold]

    if not filtered:
        # Fallback to nearest neighbor if no candidates meet threshold
        next_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])
    else:
        # Probabilistic selection based on cost-to-distance ratio
        total_ratio = sum(ratio for _, _, ratio in filtered)
        probabilities = [ratio / total_ratio for _, _, ratio in filtered]
        next_node = random.choices([node for node, _, _ in filtered], weights=probabilities, k=1)[0]

    return next_node
