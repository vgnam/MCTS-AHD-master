def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    min_cost = float('inf')
    next_node = None
    total_cost = 0.0
    candidate_nodes = []

    for node in unvisited_nodes:
        cost = distance_matrix[current_node][node]
        total_cost += cost
        if cost < min_cost:
            min_cost = cost
            next_node = node
        candidate_nodes.append((node, cost))

    if next_node is None:
        return unvisited_nodes.pop()

    avg_cost = total_cost / len(unvisited_nodes)
    threshold = min_cost * (1.0 + 0.2 * (avg_cost / min_cost))

    weighted_candidates = []
    for node, cost in candidate_nodes:
        if node == next_node:
            continue
        potential_cost = cost + distance_matrix[node][next_node]
        weight = (1.0 / cost) * (1.0 / potential_cost) if potential_cost > 0 else 1.0
        weighted_candidates.append((node, cost, potential_cost, weight))

    if weighted_candidates:
        weighted_candidates.sort(key=lambda x: x[3], reverse=True)
        total_weight = sum(w for _, _, _, w in weighted_candidates)
        if total_weight > 0:
            for node, cost, _, weight in weighted_candidates:
                if cost <= threshold and random.random() < (weight / total_weight):
                    next_node = node
                    break

    return next_node
