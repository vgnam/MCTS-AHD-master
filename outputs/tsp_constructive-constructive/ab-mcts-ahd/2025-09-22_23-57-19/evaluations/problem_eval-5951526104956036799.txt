def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    distances = [(node, distance_matrix[current_node][node]) for node in unvisited_nodes]
    closest_node, closest_dist = min(distances, key=lambda x: x[1])
    farthest_node, farthest_dist = max(distances, key=lambda x: x[1])

    # Dynamic weighting based on distance ratio
    if farthest_dist > 0:
        ratio = closest_dist / farthest_dist
        weight = 0.5 + 0.4 * ratio  # Adjusts between 0.5 and 0.9
        next_node = closest_node if weight > 0.6 else farthest_node
    else:
        next_node = closest_node

    return next_node
