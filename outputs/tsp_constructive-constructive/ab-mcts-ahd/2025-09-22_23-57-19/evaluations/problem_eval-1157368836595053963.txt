def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    # Calculate distances and penalties for unvisited nodes
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    penalties = [distance_matrix[node][destination_node] if destination_node != node else 0 for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)

    # Temperature for softmax (decreases as unvisited nodes decrease)
    temperature = avg_distance * (len(unvisited_nodes) / len(distance_matrix))

    # Compute probabilities using softmax with temperature
    exp_values = []
    for i, node in enumerate(unvisited_nodes):
        cost = distances[i] + penalties[i]
        exp_values.append(math.exp(-cost / temperature))
    total_exp = sum(exp_values)
    probabilities = [exp / total_exp for exp in exp_values]

    # Select next node based on probabilities
    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]

    # Ensure the nearest node is considered if conditions are met
    min_cost = min(distances)
    nearest_node = unvisited_nodes[distances.index(min_cost)]
    if (min_cost < avg_distance * 0.8 or min_cost < sum(penalties) / len(penalties)) and nearest_node != next_node:
        next_node = nearest_node

    return next_node
