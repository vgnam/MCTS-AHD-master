def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node])

    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)
    weighted_scores = {}

    for node in unvisited_nodes:
        distance_score = 1.0 / (distance_matrix[current_node][node] + 1e-10)
        centrality_score = centrality[node] / (sum(centrality.values()) + 1e-10)
        weighted_scores[node] = (1 - exploration_factor) * distance_score + exploration_factor * centrality_score

    next_node = max(weighted_scores, key=weighted_scores.get)

    if len(unvisited_nodes) > 2 and exploration_factor > 0.3:
        for node in unvisited_nodes:
            if node == next_node:
                continue
            if distance_matrix[current_node][node] < distance_matrix[current_node][next_node] * 1.2:
                if weighted_scores[node] > weighted_scores[next_node] * 0.9:
                    next_node = node

    return next_node
