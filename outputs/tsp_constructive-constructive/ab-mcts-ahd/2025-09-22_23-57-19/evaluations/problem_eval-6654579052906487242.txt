importance (0.5) to higher heuristic priority as progress continues, and the escape mechanism allows selecting slightly longer paths (if they are within 1.3x the average distance or 1.1x the minimum cost) to improve solution quality.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    remaining_nodes = len(unvisited_nodes)
    weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))  # Dynamic weight adjustment
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)

    min_score = float('inf')
    next_node = None
    min_cost = float('inf')

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0
        score = distance + weight * heuristic

        if score < min_score:
            min_score = score
            next_node = node

        if distance < min_cost:
            min_cost = distance

    if next_node is None:
        return unvisited_nodes.pop()

    if len(unvisited_nodes) > 2:
        for node in unvisited_nodes:
            if node == next_node:
                continue
            cost = distance_matrix[current_node][node]
            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:
                heuristic = distance_matrix[node][destination_node] if destination_node != node else 0
                score = cost + weight * heuristic
                if score < min_score:
                    next_node = node
                    min_score = score

    return next_node
