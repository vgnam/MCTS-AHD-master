def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    avg_distance = sum(distances) / len(distances)
    min_cost = min(distances)
    max_cost = max(distances)

    # Calculate dynamic threshold based on path progress
    remaining_nodes = len(unvisited_nodes)
    threshold_factor = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5

    # Weight nodes by both distance and historical success (simplified with random factor)
    weighted_scores = []
    for i, node in enumerate(unvisited_nodes):
        distance_score = (max_cost - distances[i]) / (max_cost - min_cost + 1e-10) if max_cost != min_cost else 0.5
        success_score = 1.0 / (1.0 + distances[i] * threshold_factor)  # Simplified success metric
        weighted_scores.append((distance_score + success_score) * (0.7 + 0.3 * (1.0 - distances[i] / (max_cost + 1e-10))))

    # Select node with highest weighted score
    next_node = unvisited_nodes[weighted_scores.index(max(weighted_scores))]

    # Fallback to nearest neighbor if all weights are equal
    if all(score == weighted_scores[0] for score in weighted_scores):
        next_node = unvisited_nodes[distances.index(min_cost)]

    return next_node
