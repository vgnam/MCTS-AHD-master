import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    if destination_node in unvisited_nodes:
        return destination_node

    if len(unvisited_nodes) == 1:
        return unvisited_nodes.pop()

    # Calculate average distance to unvisited nodes
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)

    # Compute bias factor (favors exploration early, exploitation later)
    bias_factor = 0.5 * (1 + (len(unvisited_nodes) / len(distance_matrix)))

    candidates = []
    weights = []

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Weight is a combination of distance and relative distance to average
        weight = (1 - bias_factor) * (distance / avg_distance) + bias_factor * (1 - (distance / avg_distance))
        candidates.append(node)
        weights.append(weight)

    # Normalize weights
    total_weight = sum(weights)
    if total_weight == 0:
        return random.choice(unvisited_nodes)
    normalized_weights = [w / total_weight for w in weights]

    # Select node based on weighted probabilities
    next_node = random.choices(candidates, weights=normalized_weights, k=1)[0]
    return next_node
