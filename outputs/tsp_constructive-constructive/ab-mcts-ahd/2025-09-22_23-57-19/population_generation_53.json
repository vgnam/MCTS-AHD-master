[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines farthest-neighbor selection with a probabilistic escape mechanism, prioritizing the farthest node but switching to closer nodes if they meet dynamic thresholds (1.3x average distance or 1.1x minimum cost). It balances exploration (farthest neighbor) and exploitation (closer nodes within thresholds) to avoid local optima. The key variables are `max_cost` (prioritized) and thresholds (`avg_distance * 1.3`, `min_cost * 1.1`), while the structure ensures the destination is reached if included in unvisited nodes.",
          "thought": "The new algorithm combines the farthest-neighbor selection from No.2 with the probabilistic escape mechanism from No.1, using a dynamic threshold (1.3x the average distance or 1.1x the minimum cost) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n        min_cost = min(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.26561,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) but occasionally selects slightly farther nodes (within a 1.5x threshold) to balance local optimization and global exploration, ensuring efficiency while avoiding local minima. It first checks for trivial cases (empty/unvisited sets or single nodes) before iterating through unvisited nodes to find the minimum-cost neighbor, then optionally explores slightly longer paths if they improve the overall solution. The 1.5x threshold and conditional checks highlight the trade-off between greediness and exploration.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 50% threshold) to balance local optimization and global exploration, ensuring the path remains efficient while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.5:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.34293,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines nearest-neighbor selection with a probabilistic escape mechanism to avoid local optima. It prioritizes the nearest unvisited node (based on the distance matrix) but occasionally selects a slightly longer path (if it's within 1.5x the average distance or 1.2x the minimum cost) to escape suboptimal solutions. The algorithm dynamically adjusts its threshold using the average distance to unvisited nodes, balancing exploration and exploitation.",
          "thought": "The algorithm combines nearest-neighbor selection with a probabilistic approach, where it occasionally selects a node with a higher cost to escape local optima, using a dynamic threshold based on the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.44598,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, prioritizing nodes closer to both. The `proximity` is calculated as the sum of the distance from the current node and half the distance to the destination, ensuring a trade-off between immediate and long-term efficiency. The `select_next_node` function iterates through unvisited nodes, computes this metric, and selects the node with the lowest combined value.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a balance between proximity to the current node and distance to the destination, prioritizing nodes that are closer to the current position but also closer to the destination to improve overall path efficiency while maintaining exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_proximity = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity < min_proximity:\n            min_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes farthest-node selection (exploitation) but occasionally explores slightly closer nodes within a dynamic threshold (1.3x average distance) to balance exploration. It ensures the destination node is always chosen if unvisited, and the threshold is only applied when more than two nodes remain unvisited. The code structure first computes distances, selects the farthest node, and then probabilistically overrides this choice if a nearby node meets the threshold.",
          "thought": "The new algorithm combines the farthest-node selection from No.2 with probabilistic exploration from No.1, where it occasionally chooses a node slightly closer than the farthest but still within a dynamic threshold (1.3x the average distance of unvisited nodes) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    max_distance = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] > max_distance:\n            max_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 21.73848,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (if their combined cost exceeds 120% of the closest) to balance exploration and avoid local minima. The `destination_node` is always prioritized if unvisited, and edge cases (empty or single-node sets) are handled first. The code checks all unvisited nodes, selects the closest, and introduces variability by considering farther nodes under specific conditions.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 40% threshold) to balance exploration and avoid getting stuck in local minima. It checks all unvisited nodes, selects the closest one, and then re-evaluates if a farther node (with a combined cost >120% of the closest) exists, introducing variability. The `destination_node` is always prioritized if unvisited, and edge cases (empty or single-node sets) are handled first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost > min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 27.59953,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **farthest insertion heuristic** by prioritizing the farthest unvisited node from the current position, then falling back to the closest node if no farthest node is found. It ensures the path extends outward while minimizing insertion costs, balancing exploration and efficiency. The function dynamically adjusts priorities based on unvisited nodes and distance constraints.",
          "thought": "This algorithm implements a farthest insertion heuristic by initially selecting the farthest node from the current position, then iteratively inserting the closest unvisited node to the existing path to minimize insertion cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    farthest_node = None\n    max_distance = -float('inf')\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] > max_distance:\n            max_distance = distance_matrix[current_node][node]\n            farthest_node = node\n\n    if farthest_node is not None:\n        return farthest_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the next node by maximizing the ratio of its distance from the current node to the sum of distances to all remaining unvisited nodes, balancing proximity and exploration. The ratio calculation ensures nodes closer to the current node and more central to unvisited nodes are favored, while the destination node is always prioritized when remaining. The code efficiently handles edge cases (empty unvisited nodes) and avoids division errors.",
          "thought": "The new algorithm prioritizes the destination if unvisited, otherwise selects the node with the highest ratio of distance to the current node and the sum of distances to all unvisited nodes, balancing exploration and proximity to ensure efficient path coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        sum_distances_to_unvisited = sum(distance_matrix[node][unvisited] for unvisited in unvisited_nodes if unvisited != node)\n        ratio = distance_to_current / (sum_distances_to_unvisited + 1e-10)  # Avoid division by zero\n\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 37.22146,
          "other_inf": null
     }
]