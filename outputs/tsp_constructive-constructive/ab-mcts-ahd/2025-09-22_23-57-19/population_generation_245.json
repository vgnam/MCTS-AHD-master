[
     {
          "algorithm": "The algorithm combines **distance** (prioritizing closer nodes) and **centrality** (prioritizing nodes with higher connectivity) in a dynamic balance, where the **exploration factor** (inversely proportional to remaining nodes) adjusts the weight between the two. The distance is normalized and inverted (closer nodes get higher scores), while centrality is normalized directly. The final score is a weighted sum, favoring distance early (high exploration factor) and centrality later (lower exploration factor). The algorithm ensures a trade-off between local optimization and global exploration.",
          "thought": "The new algorithm introduces a multi-criteria selection mechanism that combines distance, centrality, and a dynamic exploration factor, where the exploration factor is inversely proportional to the number of remaining nodes, ensuring a balance between local optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    # Calculate centrality and distance scores\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    # Dynamic exploration factor (inverse of remaining nodes)\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    # Normalize scores\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    # Combine scores with dynamic exploration factor\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node. It introduces a dynamic threshold (based on the remaining nodes) to balance exploration and exploitation, choosing a node within this threshold if found. The threshold scales with the number of remaining nodes, favoring closer nodes early but allowing some flexibility as the tour progresses.",
          "thought": "The new algorithm prioritizes the destination node and otherwise selects the closest unvisited node, but introduces a dynamic threshold (scaling with remaining nodes) to balance exploration and exploitation, choosing the first node within this threshold if found.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        threshold = min_cost * (1 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < threshold:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.00464,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance (prioritized) with node centrality (considered later in the tour) via a weighted score, using a phase factor to adjust the balance between the two. It starts with the nearest node but refines choices probabilistically by favoring nodes within 1.3x the minimum distance, especially when multiple options exist. The weighted score combines cost and centrality, with centrality's influence increasing as the tour progresses.",
          "thought": "This new algorithm enhances the original by incorporating a dynamic threshold mechanism that adapts to the current stage of the tour (early vs. late) and introduces a probabilistic selection bias towards nodes that balance distance and potential for future optimality, using a weighted combination of distance and node centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        weighted_score = cost + (1 - phase_factor) * (centrality / avg_distance)\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])\n        candidate_nodes = [node for node, score in sorted_nodes if score <= 1.3 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.01395,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a probabilistic escape mechanism, prioritizing nodes closer to the current node while occasionally favoring nodes closer to the destination (weighted by a factor of `1 - 0.3 * proximity_to_dest`). It balances exploration and exploitation by dynamically adjusting node selection based on distance to the current node and a proximity-to-destination factor, with additional checks to avoid excessive detours. The score function (`distance_to_current * (1 - 0.3 * proximity_to_dest)`) ensures that nodes closer to the current node are preferred, while the proximity-to-destination factor introduces variability to escape local optima.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic probabilistic escape mechanism, inspired by No.1's proximity-to-destination factor, by prioritizing nodes closer to the current node while occasionally selecting nodes closer to the destination (weighted by 1 - 0.3 * proximity_to_dest) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_score * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.09442,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the distance from the current node with a proximity-to-destination factor (inversely weighted by distance to the destination). It prioritizes shorter distances to the current node while slightly favoring nodes closer to the destination (via the `1 - 0.3 * proximity_to_dest` adjustment), ensuring efficiency and directional progress. The `proximity_to_dest` term is normalized by `1 + distance` to avoid division by zero and weighted less (30%) than distance.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted combination of distance and a novel \"proximity-to-destination\" factor, where the next node is selected based on a balance between minimizing distance to the current node and maximizing proximity to the destination, ensuring the path remains efficient while steering towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.09816,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the closest node while also checking for nodes within a 30% threshold of the minimum cost to balance efficiency and exploration. It first finds the nearest unvisited node, then optionally switches to a cheaper alternative if one exists within 1.3 times the minimum cost, ensuring a trade-off between proximity and path optimality. The threshold (30%) and the secondary check are key design choices to avoid getting stuck in local minima while maintaining efficiency.",
          "thought": "The new algorithm prioritizes the destination node if unvisited, otherwise selects the closest node with a secondary check for nodes within a 30% threshold to balance exploration and efficiency, choosing the first such node if found.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.3:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.12639,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends the nearest-neighbor approach by dynamically balancing immediate distance and heuristic value (estimated future cost) using a weight that decreases as more nodes are visited, prioritizing nodes that minimize both short-term and long-term costs while avoiding premature convergence. The weight adjusts based on remaining unvisited nodes, and the next node is selected by combining the current distance and a weighted heuristic value, with the heuristic given higher priority as the algorithm progresses. The structure iteratively evaluates all unvisited nodes, computes a score, and selects the node with the lowest score.",
          "thought": "The new algorithm extends the nearest-neighbor approach by incorporating a dynamic weighting mechanism that adjusts the balance between immediate distance and heuristic value based on the remaining unvisited nodes, prioritizing nodes that offer both short-term and long-term cost efficiency while dynamically adjusting the heuristic influence to prevent premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))  # Dynamic weight adjustment\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0\n        score = distance + weight * heuristic\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with probabilistic exploration by dynamically adjusting a threshold based on the current tour length, allowing occasional selection of farther nodes (within a calculated threshold) to escape local optima while prioritizing efficiency. The threshold is scaled by the ratio of unvisited nodes to total nodes, favoring closer nodes early in the tour and allowing more exploration as the tour progresses. The code first identifies the nearest node, then checks if any farther nodes (within the threshold) should be considered, balancing greediness and diversity.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism that combines nearest-neighbor prioritization with a dynamic threshold based on the current tour length, allowing occasional exploration of farther nodes to escape local optima while maintaining efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        candidates = []\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            candidates.append((node, cost))\n\n        if candidates:\n            candidates.sort(key=lambda x: x[1])\n            threshold = min_cost * (1.0 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))\n            for node, cost in candidates:\n                if cost <= threshold:\n                    next_node = node\n                    break\n\n    return next_node",
          "objective": 7.13527,
          "other_inf": null
     }
]