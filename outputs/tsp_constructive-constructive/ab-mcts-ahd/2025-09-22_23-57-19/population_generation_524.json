[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node (maximizing `-distance_matrix[current_node][node]`) while also considering their distance to the destination (adding `0.5 * distance_matrix[node][destination_node]`), aiming to delay reaching the destination until the end. The proximity score balances these two factors, favoring nodes that are both nearby and farther from the destination. The structure iterates through unvisited nodes, calculates the proximity score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current node and farther from the destination, aiming to delay reaching the destination until the end, potentially reducing overall path length by exploring more local connections first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_proximity = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = -distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity > max_proximity:\n            max_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity to the destination node more aggressively as the tour nears completion by dynamically adjusting the weight of proximity-to-destination in the scoring function, while still considering the local distance to the current node. The score combines distance to the current node and a weighted proximity-to-destination term, where the weight increases as the tour progresses. The destination node is always prioritized if it is unvisited, ensuring the tour ends optimally.",
          "thought": "The new algorithm prioritizes global optimization by dynamically adjusting the weight of proximity to the destination based on the remaining distance, while also considering the local distance to the current node, but with a different scoring mechanism that emphasizes proximity to the destination more aggressively as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance_to_dest / (remaining_distance_to_dest + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamically weighted proximity-to-destination heuristic, prioritizing nearby nodes while gradually emphasizing the shortest path back to the destination as the tour progresses. The dynamic weight (`dynamic_weight`) increases over time, balancing local distance (`distance_to_current`) and global proximity to the destination (`proximity_to_dest`), ensuring efficiency and adaptability.",
          "thought": "This new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting of proximity-to-destination inspired by No.1, where the weight increases as the tour progresses, balancing local and global considerations while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - (total_unvisited / (total_unvisited + 1)))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.83201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **distance** (prioritizing closer nodes) and **centrality** (prioritizing nodes with higher connectivity) in a dynamic balance, where the **exploration factor** (inversely proportional to remaining nodes) adjusts the weight between the two. The distance is normalized and inverted (closer nodes get higher scores), while centrality is normalized directly. The final score is a weighted sum, favoring distance early (high exploration factor) and centrality later (lower exploration factor). The algorithm ensures a trade-off between local optimization and global exploration.",
          "thought": "The new algorithm introduces a multi-criteria selection mechanism that combines distance, centrality, and a dynamic exploration factor, where the exploration factor is inversely proportional to the number of remaining nodes, ensuring a balance between local optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    # Calculate centrality and distance scores\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    # Dynamic exploration factor (inverse of remaining nodes)\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    # Normalize scores\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    # Combine scores with dynamic exploration factor\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and centrality-based selection, prioritizing nodes with both short distances and high connectivity (centrality), balanced by an exploration factor that adjusts dynamically based on remaining unvisited nodes. It normalizes distance and centrality scores and computes a weighted score, occasionally allowing slightly farther nodes if they improve global connectivity. The exploration factor decreases as nodes are visited, shifting from exploration to exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic centrality prioritization from No.1, using an exploration factor to balance immediate distance and node connectivity, while allowing occasional slightly farther nodes for better global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.94884,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamic threshold to balance efficiency and exploration. It first prioritizes the nearest unvisited node but allows occasional selection of nodes within a dynamically adjusted threshold (scaled by the ratio of unvisited nodes) to avoid local optima, evaluating both immediate and potential future costs. The threshold (`min_cost * (1.0 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))`) ensures flexibility early in the search, gradually tightening as fewer nodes remain. Higher-priority variables include the nearest neighbor and cost thresholds, while lower-priority candidates are evaluated only if they meet relaxed cost constraints.",
          "thought": "This new algorithm combines the dynamic threshold scaling from No.1 with the cost-based exploration from No.2, prioritizing the nearest neighbor but allowing occasional selection of nodes within a dynamically adjusted threshold (scaled by the ratio of unvisited nodes) to balance efficiency and avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        candidates = []\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            potential_cost = cost + distance_matrix[node][next_node]\n            candidates.append((node, cost, potential_cost))\n\n        if candidates:\n            candidates.sort(key=lambda x: x[1])\n            threshold = min_cost * (1.0 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))\n            for node, cost, potential_cost in candidates:\n                if cost <= threshold and potential_cost < min_cost * 1.2:\n                    next_node = node\n                    break\n\n    return next_node",
          "objective": 7.00083,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node. It introduces a dynamic threshold (based on the remaining nodes) to balance exploration and exploitation, choosing a node within this threshold if found. The threshold scales with the number of remaining nodes, favoring closer nodes early but allowing some flexibility as the tour progresses.",
          "thought": "The new algorithm prioritizes the destination node and otherwise selects the closest unvisited node, but introduces a dynamic threshold (scaling with remaining nodes) to balance exploration and exploitation, choosing the first node within this threshold if found.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        threshold = min_cost * (1 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < threshold:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.00464,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **proximity (nearest-neighbor bias)** and **centrality (phase-based weighting)** by dynamically adjusting a phase factor, prioritizing central nodes early and nearby nodes later. It balances cost and centrality, with a fallback to the nearest node if no suitable candidates exist. The phase factor (`phase_factor`) controls the trade-off between proximity and centrality, while the weighted score (`weighted_score`) integrates these factors with a bias toward centrality in early phases. The fallback mechanism ensures robustness when no optimal candidates are found.",
          "thought": "The new algorithm will combine No.1's phase-based centrality weighting with No.2's aggressive nearest-neighbor bias, using a dynamic phase factor to balance proximity and centrality, with a fallback to nearest node when no suitable candidates are found.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        weighted_score = cost + (1 - phase_factor) * (centrality / avg_distance) * 1.5\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])\n        candidate_nodes = [node for node, score in sorted_nodes if score <= 1.5 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.00683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node while occasionally allowing farther nodes (within a dynamically scaled threshold) to improve tour quality, balancing greedy selection with exploration. The threshold scales with the remaining unvisited nodes (1 + 0.2 * fraction of unvisited nodes), and the next node is chosen probabilistically from candidates below this threshold. The algorithm defaults to the nearest node if no candidates meet the threshold, ensuring robustness.",
          "thought": "The new algorithm will combine the threshold-based exploration of No.1 with the probabilistic selection and dynamic threshold adjustment of No.2, prioritizing the nearest node while allowing occasional selection of farther nodes (within a scaled threshold) to improve tour quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        candidates = []\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            candidates.append((node, potential_cost))\n\n        if candidates:\n            threshold = min_cost * (1.0 + 0.2 * (len(unvisited_nodes) / len(distance_matrix)))\n            candidates.sort(key=lambda x: x[1])\n            for node, cost in candidates:\n                if cost <= threshold:\n                    next_node = node\n                    break\n\n    return next_node",
          "objective": 7.00939,
          "other_inf": null
     }
]