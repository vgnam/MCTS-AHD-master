[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines farthest-neighbor selection with a probabilistic escape mechanism, prioritizing the farthest node but switching to closer nodes if they meet dynamic thresholds (1.3x average distance or 1.1x minimum cost). It balances exploration (farthest neighbor) and exploitation (closer nodes within thresholds) to avoid local optima. The key variables are `max_cost` (prioritized) and thresholds (`avg_distance * 1.3`, `min_cost * 1.1`), while the structure ensures the destination is reached if included in unvisited nodes.",
          "thought": "The new algorithm combines the farthest-neighbor selection from No.2 with the probabilistic escape mechanism from No.1, using a dynamic threshold (1.3x the average distance or 1.1x the minimum cost) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n        min_cost = min(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.26561,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) but occasionally selects slightly farther nodes (within a 1.5x threshold) to balance local optimization and global exploration, ensuring efficiency while avoiding local minima. It first checks for trivial cases (empty/unvisited sets or single nodes) before iterating through unvisited nodes to find the minimum-cost neighbor, then optionally explores slightly longer paths if they improve the overall solution. The 1.5x threshold and conditional checks highlight the trade-off between greediness and exploration.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 50% threshold) to balance local optimization and global exploration, ensuring the path remains efficient while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.5:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.34293,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines nearest-neighbor selection with a probabilistic escape mechanism to avoid local optima. It prioritizes the nearest unvisited node (based on the distance matrix) but occasionally selects a slightly longer path (if it's within 1.5x the average distance or 1.2x the minimum cost) to escape suboptimal solutions. The algorithm dynamically adjusts its threshold using the average distance to unvisited nodes, balancing exploration and exploitation.",
          "thought": "The algorithm combines nearest-neighbor selection with a probabilistic approach, where it occasionally selects a node with a higher cost to escape local optima, using a dynamic threshold based on the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.44598,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, prioritizing nodes closer to both. The `proximity` is calculated as the sum of the distance from the current node and half the distance to the destination, ensuring a trade-off between immediate and long-term efficiency. The `select_next_node` function iterates through unvisited nodes, computes this metric, and selects the node with the lowest combined value.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a balance between proximity to the current node and distance to the destination, prioritizing nodes that are closer to the current position but also closer to the destination to improve overall path efficiency while maintaining exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_proximity = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity < min_proximity:\n            min_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes farthest-node selection (exploitation) but occasionally explores slightly closer nodes within a dynamic threshold (1.3x average distance) to balance exploration. It ensures the destination node is always chosen if unvisited, and the threshold is only applied when more than two nodes remain unvisited. The code structure first computes distances, selects the farthest node, and then probabilistically overrides this choice if a nearby node meets the threshold.",
          "thought": "The new algorithm combines the farthest-node selection from No.2 with probabilistic exploration from No.1, where it occasionally chooses a node slightly closer than the farthest but still within a dynamic threshold (1.3x the average distance of unvisited nodes) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    max_distance = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] > max_distance:\n            max_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 21.73848,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (if their combined cost exceeds 120% of the closest) to balance exploration and avoid local minima. The `destination_node` is always prioritized if unvisited, and edge cases (empty or single-node sets) are handled first. The code checks all unvisited nodes, selects the closest, and introduces variability by considering farther nodes under specific conditions.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 40% threshold) to balance exploration and avoid getting stuck in local minima. It checks all unvisited nodes, selects the closest one, and then re-evaluates if a farther node (with a combined cost >120% of the closest) exists, introducing variability. The `destination_node` is always prioritized if unvisited, and edge cases (empty or single-node sets) are handled first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost > min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 27.59953,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing nodes based on a weighted combination of distance from the current node (60%) and distance to the destination (40%), dynamically balancing exploration and exploitation. If no clear candidate emerges, it defaults to the nearest unvisited node. The weights (0.6 and 0.4) reflect a bias toward reducing the remaining path length while ensuring progress toward the destination.",
          "thought": "The new algorithm prioritizes nodes based on a weighted combination of distance and potential path improvement, using a dynamic threshold to balance exploration and exploitation, while ensuring the path progressively converges toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    weighted_scores = {}\n    max_score = -float('inf')\n    best_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        weighted_score = (distance_to_node * 0.6) + (distance_to_dest * 0.4)\n        weighted_scores[node] = weighted_score\n\n        if weighted_score > max_score:\n            max_score = weighted_score\n            best_node = node\n\n    if best_node is not None:\n        return best_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 34.05967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both far from the current position (to encourage exploration) and closer to the destination (to ensure efficiency), using a weighted score (`distance_matrix[current_node][node] - 0.5 * distance_matrix[node][destination_node]`). If no suitable node is found, it defaults to the nearest neighbor. The `destination_node` is always prioritized if unvisited, and the algorithm falls back to the nearest neighbor if all else fails.",
          "thought": "The new algorithm combines farthest insertion with a trade-off between immediate distance and distance to destination, prioritizing nodes that are both far from current position and closer to destination, ensuring a balance between exploration and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    best_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        score = distance_matrix[current_node][node] - 0.5 * distance_matrix[node][destination_node]\n        if score > best_score:\n            best_score = score\n            best_node = node\n\n    if best_node is not None:\n        return best_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 35.78245,
          "other_inf": null
     }
]