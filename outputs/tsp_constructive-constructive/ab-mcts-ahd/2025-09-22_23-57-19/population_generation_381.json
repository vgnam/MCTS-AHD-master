[
     {
          "algorithm": "The algorithm prioritizes proximity to the destination node more aggressively as the tour nears completion by dynamically adjusting the weight of proximity-to-destination in the scoring function, while still considering the local distance to the current node. The score combines distance to the current node and a weighted proximity-to-destination term, where the weight increases as the tour progresses. The destination node is always prioritized if it is unvisited, ensuring the tour ends optimally.",
          "thought": "The new algorithm prioritizes global optimization by dynamically adjusting the weight of proximity to the destination based on the remaining distance, while also considering the local distance to the current node, but with a different scoring mechanism that emphasizes proximity to the destination more aggressively as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance_to_dest / (remaining_distance_to_dest + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **distance** (prioritizing closer nodes) and **centrality** (prioritizing nodes with higher connectivity) in a dynamic balance, where the **exploration factor** (inversely proportional to remaining nodes) adjusts the weight between the two. The distance is normalized and inverted (closer nodes get higher scores), while centrality is normalized directly. The final score is a weighted sum, favoring distance early (high exploration factor) and centrality later (lower exploration factor). The algorithm ensures a trade-off between local optimization and global exploration.",
          "thought": "The new algorithm introduces a multi-criteria selection mechanism that combines distance, centrality, and a dynamic exploration factor, where the exploration factor is inversely proportional to the number of remaining nodes, ensuring a balance between local optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    # Calculate centrality and distance scores\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    # Dynamic exploration factor (inverse of remaining nodes)\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    # Normalize scores\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    # Combine scores with dynamic exploration factor\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and centrality-based selection, prioritizing nodes with both short distances and high connectivity (centrality), balanced by an exploration factor that adjusts dynamically based on remaining unvisited nodes. It normalizes distance and centrality scores and computes a weighted score, occasionally allowing slightly farther nodes if they improve global connectivity. The exploration factor decreases as nodes are visited, shifting from exploration to exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic centrality prioritization from No.1, using an exploration factor to balance immediate distance and node connectivity, while allowing occasional slightly farther nodes for better global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.94884,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node. It introduces a dynamic threshold (based on the remaining nodes) to balance exploration and exploitation, choosing a node within this threshold if found. The threshold scales with the number of remaining nodes, favoring closer nodes early but allowing some flexibility as the tour progresses.",
          "thought": "The new algorithm prioritizes the destination node and otherwise selects the closest unvisited node, but introduces a dynamic threshold (scaling with remaining nodes) to balance exploration and exploitation, choosing the first node within this threshold if found.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        threshold = min_cost * (1 + 0.1 * (len(unvisited_nodes) / len(distance_matrix)))\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < threshold:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.00464,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance (prioritized) with node centrality (considered later in the tour) via a weighted score, using a phase factor to adjust the balance between the two. It starts with the nearest node but refines choices probabilistically by favoring nodes within 1.3x the minimum distance, especially when multiple options exist. The weighted score combines cost and centrality, with centrality's influence increasing as the tour progresses.",
          "thought": "This new algorithm enhances the original by incorporating a dynamic threshold mechanism that adapts to the current stage of the tour (early vs. late) and introduces a probabilistic selection bias towards nodes that balance distance and potential for future optimality, using a weighted combination of distance and node centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        weighted_score = cost + (1 - phase_factor) * (centrality / avg_distance)\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])\n        candidate_nodes = [node for node, score in sorted_nodes if score <= 1.3 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.01395,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing distance and connectivity, where distance is prioritized early (high `phase_factor`) and connectivity (measured via average remaining connections) gains importance later. It uses a weighted score (`cost + (1 - phase_factor) * (connectivity / avg_distance)`) to evaluate nodes, with a fallback to the nearest neighbor if no strong candidates emerge. The `phase_factor` scales with tour progress, ensuring adaptability to the problem's evolving constraints.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic priority mechanism that adjusts node selection based on both distance and a novel \"connectivity score\" (measuring how well a node connects to remaining unvisited nodes), with a phase factor that increasingly prioritizes connectivity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        connectivity = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n        weighted_score = cost + (1 - phase_factor) * (connectivity / avg_distance)\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])\n        candidate_nodes = [node for node, score in sorted_nodes if score <= 1.5 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.02228,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines distance minimization with destination proximity, dynamically adjusting weights based on remaining unvisited nodes. It prioritizes shorter distances early (high weight) but increasingly balances proximity to the destination as nodes are visited (inverse proportional to unvisited count). The `exploration_factor` controls this balance, favoring distance over proximity when many nodes remain.",
          "thought": "The new algorithm combines the dynamic exploration factor from No.1 with the distance and proximity-to-destination balance from No.2, adjusting the weight between distance and proximity inversely proportional to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = (1 - exploration_factor) * distance_to_current + exploration_factor * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.02586,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and centrality-weighted selection, prioritizing the closest unvisited node but allowing occasional exploration of slightly farther nodes (within 1.2\u00d7 the minimum cost) to avoid local optima. It dynamically adjusts node selection by weighing distances and centrality (average distance to other nodes) based on the tour's progress (phase_factor), balancing efficiency and exploration. The centrality term's influence decreases as the tour progresses (1 - phase_factor), while the distance remains the primary factor.",
          "thought": "The new algorithm combines the nearest-neighbor prioritization of No.1 with the dynamic centrality-weighted scoring of No.2, allowing occasional exploration of slightly farther nodes (within 1.2x the minimum cost) to balance efficiency and avoid local optima, while also considering node centrality in the weighted score to refine choices as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        weighted_score = cost + (1 - phase_factor) * (centrality / avg_distance)\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        candidate_nodes = [node for node in unvisited_nodes if node_scores[node] <= 1.2 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.03512,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes node selection by dynamically balancing immediate distance and node centrality, with centrality gaining stronger influence as the tour progresses. It uses a phase factor to adjust weights, favoring nodes within 2.0x the minimum distance when multiple options exist, ensuring a mix of proximity and strategic centrality in the tour construction. The scoring mechanism emphasizes centrality early, while later phases favor proximity, with a fallback to the nearest node when no central candidates are found.",
          "thought": "The new algorithm prioritizes node selection based on a dynamic balance between immediate distance and node centrality, but with a stronger emphasis on centrality as the tour progresses, using a more aggressive phase factor and a different scoring mechanism that favors nodes within 2.0x the minimum distance when multiple options exist.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n    node_scores = {}\n\n    total_nodes = len(distance_matrix)\n    phase_factor = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        weighted_score = cost + (1 - phase_factor) * (centrality / avg_distance) * 2.0\n\n        node_scores[node] = weighted_score\n\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        sorted_nodes = sorted(node_scores.items(), key=lambda x: x[1])\n        candidate_nodes = [node for node, score in sorted_nodes if score <= 2.0 * min_cost]\n\n        if candidate_nodes:\n            next_node = candidate_nodes[0]\n\n    return next_node",
          "objective": 7.03757,
          "other_inf": null
     }
]