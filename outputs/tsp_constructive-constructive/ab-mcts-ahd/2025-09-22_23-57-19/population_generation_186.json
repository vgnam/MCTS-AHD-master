[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a probabilistic escape mechanism, prioritizing nodes closer to the current node while occasionally favoring nodes closer to the destination (weighted by a factor of `1 - 0.3 * proximity_to_dest`). It balances exploration and exploitation by dynamically adjusting node selection based on distance to the current node and a proximity-to-destination factor, with additional checks to avoid excessive detours. The score function (`distance_to_current * (1 - 0.3 * proximity_to_dest)`) ensures that nodes closer to the current node are preferred, while the proximity-to-destination factor introduces variability to escape local optima.",
          "thought": "The new algorithm combines nearest-neighbor selection with a dynamic probabilistic escape mechanism, inspired by No.1's proximity-to-destination factor, by prioritizing nodes closer to the current node while occasionally selecting nodes closer to the destination (weighted by 1 - 0.3 * proximity_to_dest) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_score * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.09442,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the distance from the current node with a proximity-to-destination factor (inversely weighted by distance to the destination). It prioritizes shorter distances to the current node while slightly favoring nodes closer to the destination (via the `1 - 0.3 * proximity_to_dest` adjustment), ensuring efficiency and directional progress. The `proximity_to_dest` term is normalized by `1 + distance` to avoid division by zero and weighted less (30%) than distance.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted combination of distance and a novel \"proximity-to-destination\" factor, where the next node is selected based on a balance between minimizing distance to the current node and maximizing proximity to the destination, ensuring the path remains efficient while steering towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.09816,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extends the nearest-neighbor approach by dynamically balancing immediate distance and heuristic value (estimated future cost) using a weight that decreases as more nodes are visited, prioritizing nodes that minimize both short-term and long-term costs while avoiding premature convergence. The weight adjusts based on remaining unvisited nodes, and the next node is selected by combining the current distance and a weighted heuristic value, with the heuristic given higher priority as the algorithm progresses. The structure iteratively evaluates all unvisited nodes, computes a score, and selects the node with the lowest score.",
          "thought": "The new algorithm extends the nearest-neighbor approach by incorporating a dynamic weighting mechanism that adjusts the balance between immediate distance and heuristic value based on the remaining unvisited nodes, prioritizing nodes that offer both short-term and long-term cost efficiency while dynamically adjusting the heuristic influence to prevent premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))  # Dynamic weight adjustment\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0\n        score = distance + weight * heuristic\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.12651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adapts the nearest-neighbor approach by dynamically weighting the heuristic (distance to the destination) based on remaining unvisited nodes, prioritizing local optimization when few nodes remain (lower `dynamic_weight`) and balancing progress toward the destination otherwise. It selects the next node by minimizing a score combining current distance, heuristic, and a dynamic weight that scales with remaining nodes. The `dynamic_weight` (0.5 for >1 node, 0.1 otherwise) and heuristic prioritization ensure efficient path selection while maintaining progress toward the goal.",
          "thought": "The new algorithm modifies the nearest-neighbor approach by incorporating a dynamic weighting factor for the heuristic that adapts based on the number of remaining unvisited nodes, emphasizing local optimization when few nodes remain and balancing progress toward the destination otherwise. It introduces a novel scoring mechanism that combines distance, heuristic, and a dynamic weight, ensuring efficient path selection while maintaining progress toward the goal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 0.5 if remaining_nodes > 1 else 0.1\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0\n        score = distance + dynamic_weight * heuristic * (1.0 - (remaining_nodes - 1) / remaining_nodes)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the distance from the current node with a normalized proximity-to-destination factor (weighted at 0.3), prioritizing shorter distances while slightly favoring nodes closer to the destination. It ensures progress toward the destination by incorporating a normalized proximity term, while the weighted sum maintains efficiency. The destination is prioritized if it is unvisited, and the algorithm defaults to it if no unvisited nodes remain.",
          "thought": "The new algorithm combines the distance to the current node with a normalized proximity-to-destination factor (weighted by 0.3), similar to No.1, but uses a simpler weighted sum like No.2, ensuring efficiency and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance + 0.3 * (1 - proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.19319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (minimum cost) but occasionally relaxes this by allowing nodes within 1.3x the average distance or 1.1x the minimum cost to escape local optima, dynamically adjusting thresholds based on remaining unvisited nodes. It balances greedy selection with a small chance of diversification to improve solution quality. The critical variables are `min_cost` (highest priority) and `avg_distance` (used for threshold adjustments), while the code structure ensures efficiency by iterating through unvisited nodes once for cost calculation and once for threshold checks.",
          "thought": "The new algorithm prioritizes the nearest unvisited node but occasionally selects a node within 1.3x the average distance or 1.1x the minimum cost to escape local optima, using dynamic threshold adjustments based on unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.20672,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines farthest-neighbor selection with a probabilistic escape mechanism, prioritizing the farthest node but switching to closer nodes if they meet dynamic thresholds (1.3x average distance or 1.1x minimum cost). It balances exploration (farthest neighbor) and exploitation (closer nodes within thresholds) to avoid local optima. The key variables are `max_cost` (prioritized) and thresholds (`avg_distance * 1.3`, `min_cost * 1.1`), while the structure ensures the destination is reached if included in unvisited nodes.",
          "thought": "The new algorithm combines the farthest-neighbor selection from No.2 with the probabilistic escape mechanism from No.1, using a dynamic threshold (1.3x the average distance or 1.1x the minimum cost) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n        min_cost = min(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.26561,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines greedy selection with probabilistic exploration by dynamically adjusting a temperature-based threshold (decreasing as nodes are visited) to balance cost efficiency and exploration. It prioritizes the nearest unvisited node but allows limited local search (within a 3-node radius) when costs exceed a threshold, ensuring flexibility early while converging to greedy choices later. The threshold (`1.2 + 1.5 * temperature`) and local search radius (`min(3, len(candidates))`) are key parameters controlling exploration vs. exploitation.",
          "thought": "The new algorithm introduces a probabilistic selection mechanism that combines greedy cost efficiency with a dynamic exploration bias, using a temperature-based threshold that decreases as nodes are visited, allowing more exploration early and converging to greedy choices later. It also incorporates a local search within a limited radius to escape local optima when the path deviates significantly from the minimum cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    temperature = 1.0 - (1.0 - len(unvisited_nodes) / len(distance_matrix)) ** 2\n    threshold = 1.2 + (1.5 * temperature)\n\n    if len(unvisited_nodes) > 2:\n        candidates = []\n        for node in unvisited_nodes:\n            cost = distance_matrix[current_node][node]\n            if cost < min_cost * threshold:\n                candidates.append((node, cost))\n\n        if candidates:\n            candidates.sort(key=lambda x: x[1])\n            local_search_radius = min(3, len(candidates))\n            for i in range(local_search_radius):\n                node, cost = candidates[i]\n                if node != next_node and cost < min_cost * 1.2:\n                    next_node = node\n                    break\n\n    return next_node",
          "objective": 7.31708,
          "other_inf": null
     }
]