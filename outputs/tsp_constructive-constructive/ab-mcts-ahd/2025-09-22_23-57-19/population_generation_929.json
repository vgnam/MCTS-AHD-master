[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node (maximizing `-distance_matrix[current_node][node]`) while also considering their distance to the destination (adding `0.5 * distance_matrix[node][destination_node]`), aiming to delay reaching the destination until the end. The proximity score balances these two factors, favoring nodes that are both nearby and farther from the destination. The structure iterates through unvisited nodes, calculates the proximity score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current node and farther from the destination, aiming to delay reaching the destination until the end, potentially reducing overall path length by exploring more local connections first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_proximity = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = -distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity > max_proximity:\n            max_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity to the destination node more aggressively as the tour nears completion by dynamically adjusting the weight of proximity-to-destination in the scoring function, while still considering the local distance to the current node. The score combines distance to the current node and a weighted proximity-to-destination term, where the weight increases as the tour progresses. The destination node is always prioritized if it is unvisited, ensuring the tour ends optimally.",
          "thought": "The new algorithm prioritizes global optimization by dynamically adjusting the weight of proximity to the destination based on the remaining distance, while also considering the local distance to the current node, but with a different scoring mechanism that emphasizes proximity to the destination more aggressively as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance_to_dest / (remaining_distance_to_dest + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the proximity to the destination, with a dynamic weight that prioritizes local optimization (distance to current node) when few nodes remain and global optimization (proximity to destination) when more nodes are left. The weight adjusts based on the remaining unvisited nodes, ensuring a smooth transition between local and global considerations.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with the dynamic balancing of No.1, selecting nodes based on a weighted combination of distance to current node and proximity to destination, using a variable weight that adapts to the number of remaining nodes to ensure a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_score = float('inf')\n    next_node = None\n    weight = 0.5 + (0.4 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1)))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current + (weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the destination with probabilistic selection, using a temperature-based decay to prioritize closer nodes while occasionally exploring alternatives. It dynamically weights distances to the current node and destination proximity, with the destination having higher priority when its probability exceeds a temperature threshold. The temperature decreases as more nodes are visited, favoring exploitation over exploration.",
          "thought": "The new algorithm combines dynamic weighting of proximity-to-destination with probabilistic selection, using a temperature-based decay to balance exploration and exploitation, ensuring optimal tour completion while maintaining efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        remaining_unvisited = unvisited_nodes - {destination_node}\n\n        if not remaining_unvisited:\n            return destination_node\n\n        avg_distance = sum(distance_matrix[current_node][node] for node in remaining_unvisited) / len(remaining_unvisited)\n        temp = max(0.1, 1.0 - (1.0 / (1.0 + len(unvisited_nodes))))\n\n        proximity_to_dest = 1 / (1 + destination_distance)\n        dynamic_weight = 0.5 + 0.5 * (1 - destination_distance / (destination_distance + 1))\n\n        if avg_distance > 0:\n            normalized_ratio = (destination_distance / avg_distance) ** -1\n            prob_destination = temp * (dynamic_weight * proximity_to_dest + normalized_ratio)\n        else:\n            prob_destination = 1.0\n\n        prob_destination = min(prob_destination, 1.0)\n\n        if prob_destination > temp:\n            return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - distance_matrix[node][destination_node] / (distance_matrix[node][destination_node] + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.66388,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the distance from the current node and the proximity to the destination, with a fixed weight of 0.7 prioritizing proximity. It evaluates each unvisited node by combining the direct distance to the current node and the inverse of the distance to the destination, then chooses the node with the lowest combined score. The static weight ensures a consistent bias toward proximity, making the tour more direct but less adaptive to local conditions.",
          "thought": "The new algorithm prioritizes nodes based on a static weight that balances local distance and proximity to the destination, using a fixed 0.7 weight for proximity, ensuring a more balanced but less adaptive tour compared to the original dynamic approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        static_weight = 0.7\n        score = distance_to_current + (static_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.80722,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamically weighted proximity-to-destination heuristic, prioritizing nearby nodes while gradually emphasizing the shortest path back to the destination as the tour progresses. The dynamic weight (`dynamic_weight`) increases over time, balancing local distance (`distance_to_current`) and global proximity to the destination (`proximity_to_dest`), ensuring efficiency and adaptability.",
          "thought": "This new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting of proximity-to-destination inspired by No.1, where the weight increases as the tour progresses, balancing local and global considerations while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - (total_unvisited / (total_unvisited + 1)))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.83201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **farthest-neighbor and nearest-neighbor selection** by dynamically balancing distance to the current node and proximity to the destination, using a **static weight (0.7)** to prioritize proximity while applying a **threshold (1.1\u00d7 max distance)** to refine choices between farthest and nearest nodes. It evaluates nodes based on their **distance to the current node** and **inverse distance to the destination**, then selects the best candidate within the threshold. The algorithm prioritizes **proximity to the destination** over raw distance, making it adaptive to the remaining path.",
          "thought": "The new algorithm combines the static weight from No.1 (0.7) to balance distance and proximity, while using the dynamic threshold (1.1\u00d7 max distance) from No.2 to adaptively select nodes between farthest-neighbor and nearest-neighbor. It evaluates nodes by combining their distance to the current node and proximity to the destination, then applies the threshold to refine the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            distance_to_current = distance_matrix[current_node][node]\n            proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n            static_weight = 0.7\n            score = distance_to_current + (static_weight * proximity_to_dest)\n            potential_cost = distance_to_current + distance_matrix[node][next_node]\n\n            if potential_cost < max_cost * 1.1 and score < distance_matrix[current_node][next_node] + (static_weight * 1 / (1 + distance_matrix[next_node][destination_node])):\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.89346,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing local distance, global proximity to the destination, and node novelty, with dynamic weights prioritizing destination proximity as the tour progresses. It assigns higher priority to proximity to the destination (weighted dynamically) and novelty (weighted 0.3), while local distance (weighted 0.6) has moderate priority. The dynamic weight adjusts aggressively to favor destination proximity as unvisited nodes decrease.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic exploration-exploitation balance, where the selection score combines local distance, global proximity to the destination, and a novelty factor based on node visit frequency, while adjusting the dynamic weight more aggressively to prioritize destination proximity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    visit_frequency = {node: 0 for node in unvisited_nodes}\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        novelty_factor = 1 / (1 + visit_frequency[node])\n\n        dynamic_weight = 0.3 + 0.7 * (1 - (total_unvisited / (total_unvisited + 2)))\n        score = (distance_to_current * 0.6) + (dynamic_weight * proximity_to_dest * 0.7) + (novelty_factor * 0.3)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is not None:\n        visit_frequency[next_node] += 1\n\n    return next_node",
          "objective": 6.90067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines probabilistic destination prioritization with dynamic exploration factors, balancing immediate distance (prioritized when the destination is close relative to average distances) and centrality (prioritized when nodes are highly connected) while occasionally allowing slight detours to improve global connectivity. The exploration factor decreases as more nodes are visited, shifting focus from exploration to exploitation, and the centrality score (normalized by total distance) ensures hub nodes are considered. The algorithm prioritizes shorter distances but balances it with centrality and occasionally re-evaluates paths for potential cost savings.",
          "thought": "The new algorithm combines probabilistic destination prioritization with dynamic exploration factors, balancing immediate distance and centrality while allowing slight detours to improve global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        remaining_nodes = unvisited_nodes - {destination_node}\n        if not remaining_nodes:\n            return destination_node\n\n        avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / len(remaining_nodes)\n        prob_destination = 0.5 * (destination_distance / avg_distance) ** -1 if avg_distance > 0 else 1.0\n        prob_destination = min(prob_destination, 1.0)\n\n        if prob_destination > 0.5:\n            return destination_node\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n    centrality = {node: sum(distance_matrix[node]) for node in unvisited_nodes}\n    max_centrality = max(centrality.values()) if centrality else 1\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_score = (max(distance_matrix[current_node][node], 1) - distance_matrix[current_node][node]) / max(distance_matrix[current_node][node], 1)\n        score = (1 - exploration_factor) * distance_score + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.91048,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances between minimizing immediate distance (distance-centrality) and exploring central nodes (centrality), with exploration weighted inversely by remaining nodes. Early in the process, distance dominates, while centrality becomes more important later, occasionally allowing slight detours (10% threshold) to improve global connectivity. The score combines normalized distance and centrality, adjusted by an exploration factor that decreases as nodes are visited.",
          "thought": "The new algorithm combines dynamic distance-centrality balancing with adaptive exploration, where the exploration factor adjusts inversely with remaining nodes, and centrality is weighted more heavily later in the process, while occasionally allowing slight detours if they improve global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.91831,
          "other_inf": null
     }
]