[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node (maximizing `-distance_matrix[current_node][node]`) while also considering their distance to the destination (adding `0.5 * distance_matrix[node][destination_node]`), aiming to delay reaching the destination until the end. The proximity score balances these two factors, favoring nodes that are both nearby and farther from the destination. The structure iterates through unvisited nodes, calculates the proximity score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current node and farther from the destination, aiming to delay reaching the destination until the end, potentially reducing overall path length by exploring more local connections first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_proximity = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = -distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity > max_proximity:\n            max_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity to the destination node more aggressively as the tour nears completion by dynamically adjusting the weight of proximity-to-destination in the scoring function, while still considering the local distance to the current node. The score combines distance to the current node and a weighted proximity-to-destination term, where the weight increases as the tour progresses. The destination node is always prioritized if it is unvisited, ensuring the tour ends optimally.",
          "thought": "The new algorithm prioritizes global optimization by dynamically adjusting the weight of proximity to the destination based on the remaining distance, while also considering the local distance to the current node, but with a different scoring mechanism that emphasizes proximity to the destination more aggressively as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance_to_dest / (remaining_distance_to_dest + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the distance from the current node and the proximity to the destination, with a fixed weight of 0.7 prioritizing proximity. It evaluates each unvisited node by combining the direct distance to the current node and the inverse of the distance to the destination, then chooses the node with the lowest combined score. The static weight ensures a consistent bias toward proximity, making the tour more direct but less adaptive to local conditions.",
          "thought": "The new algorithm prioritizes nodes based on a static weight that balances local distance and proximity to the destination, using a fixed 0.7 weight for proximity, ensuring a more balanced but less adaptive tour compared to the original dynamic approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        static_weight = 0.7\n        score = distance_to_current + (static_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.80722,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamically weighted proximity-to-destination heuristic, prioritizing nearby nodes while gradually emphasizing the shortest path back to the destination as the tour progresses. The dynamic weight (`dynamic_weight`) increases over time, balancing local distance (`distance_to_current`) and global proximity to the destination (`proximity_to_dest`), ensuring efficiency and adaptability.",
          "thought": "This new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting of proximity-to-destination inspired by No.1, where the weight increases as the tour progresses, balancing local and global considerations while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - (total_unvisited / (total_unvisited + 1)))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.83201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing local distance, global proximity to the destination, and node novelty, with dynamic weights prioritizing destination proximity as the tour progresses. It assigns higher priority to proximity to the destination (weighted dynamically) and novelty (weighted 0.3), while local distance (weighted 0.6) has moderate priority. The dynamic weight adjusts aggressively to favor destination proximity as unvisited nodes decrease.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic exploration-exploitation balance, where the selection score combines local distance, global proximity to the destination, and a novelty factor based on node visit frequency, while adjusting the dynamic weight more aggressively to prioritize destination proximity as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    visit_frequency = {node: 0 for node in unvisited_nodes}\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        novelty_factor = 1 / (1 + visit_frequency[node])\n\n        dynamic_weight = 0.3 + 0.7 * (1 - (total_unvisited / (total_unvisited + 2)))\n        score = (distance_to_current * 0.6) + (dynamic_weight * proximity_to_dest * 0.7) + (novelty_factor * 0.3)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    if next_node is not None:\n        visit_frequency[next_node] += 1\n\n    return next_node",
          "objective": 6.90067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines probabilistic destination prioritization with dynamic exploration factors, balancing immediate distance (prioritized when the destination is close relative to average distances) and centrality (prioritized when nodes are highly connected) while occasionally allowing slight detours to improve global connectivity. The exploration factor decreases as more nodes are visited, shifting focus from exploration to exploitation, and the centrality score (normalized by total distance) ensures hub nodes are considered. The algorithm prioritizes shorter distances but balances it with centrality and occasionally re-evaluates paths for potential cost savings.",
          "thought": "The new algorithm combines probabilistic destination prioritization with dynamic exploration factors, balancing immediate distance and centrality while allowing slight detours to improve global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        remaining_nodes = unvisited_nodes - {destination_node}\n        if not remaining_nodes:\n            return destination_node\n\n        avg_distance = sum(distance_matrix[current_node][node] for node in remaining_nodes) / len(remaining_nodes)\n        prob_destination = 0.5 * (destination_distance / avg_distance) ** -1 if avg_distance > 0 else 1.0\n        prob_destination = min(prob_destination, 1.0)\n\n        if prob_destination > 0.5:\n            return destination_node\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n    centrality = {node: sum(distance_matrix[node]) for node in unvisited_nodes}\n    max_centrality = max(centrality.values()) if centrality else 1\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_score = (max(distance_matrix[current_node][node], 1) - distance_matrix[current_node][node]) / max(distance_matrix[current_node][node], 1)\n        score = (1 - exploration_factor) * distance_score + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.91048,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances between minimizing immediate distance (distance-centrality) and exploring central nodes (centrality), with exploration weighted inversely by remaining nodes. Early in the process, distance dominates, while centrality becomes more important later, occasionally allowing slight detours (10% threshold) to improve global connectivity. The score combines normalized distance and centrality, adjusted by an exploration factor that decreases as nodes are visited.",
          "thought": "The new algorithm combines dynamic distance-centrality balancing with adaptive exploration, where the exploration factor adjusts inversely with remaining nodes, and centrality is weighted more heavily later in the process, while occasionally allowing slight detours if they improve global connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.91831,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **distance** (prioritizing closer nodes) and **centrality** (prioritizing nodes with higher connectivity) in a dynamic balance, where the **exploration factor** (inversely proportional to remaining nodes) adjusts the weight between the two. The distance is normalized and inverted (closer nodes get higher scores), while centrality is normalized directly. The final score is a weighted sum, favoring distance early (high exploration factor) and centrality later (lower exploration factor). The algorithm ensures a trade-off between local optimization and global exploration.",
          "thought": "The new algorithm introduces a multi-criteria selection mechanism that combines distance, centrality, and a dynamic exploration factor, where the exploration factor is inversely proportional to the number of remaining nodes, ensuring a balance between local optimization and global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    # Calculate centrality and distance scores\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    # Dynamic exploration factor (inverse of remaining nodes)\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    # Normalize scores\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    # Combine scores with dynamic exploration factor\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91909,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor and centrality-based selection, prioritizing nodes with both short distances and high connectivity (centrality), balanced by an exploration factor that adjusts dynamically based on remaining unvisited nodes. It normalizes distance and centrality scores and computes a weighted score, occasionally allowing slightly farther nodes if they improve global connectivity. The exploration factor decreases as nodes are visited, shifting from exploration to exploitation.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with dynamic centrality prioritization from No.1, using an exploration factor to balance immediate distance and node connectivity, while allowing occasional slightly farther nodes for better global exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    centrality = {}\n    distance_scores = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node])\n        distance_scores[node] = distance_matrix[current_node][node]\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    max_distance = max(distance_scores.values()) if distance_scores else 1\n    max_centrality = max(centrality.values()) if centrality else 1\n\n    normalized_distance = {node: (max_distance - dist) / max_distance if max_distance else 0 for node, dist in distance_scores.items()}\n    normalized_centrality = {node: cent / max_centrality if max_centrality else 0 for node, cent in centrality.items()}\n\n    best_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        score = (1 - exploration_factor) * normalized_distance[node] + exploration_factor * normalized_centrality[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < distance_matrix[current_node][next_node] * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.94884,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adapts the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node and heuristic value (distance to the destination), weighted by a factor that decreases as more nodes are visited (prioritizing closer nodes early). It prioritizes minimizing the current step's distance while gradually shifting focus toward the destination, avoiding excessive detours. The dynamic weight adjusts based on remaining nodes, ensuring a smooth transition from local to global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by introducing a dynamic weighting factor that adapts based on the remaining path length, combining immediate distance with a heuristic value that prioritizes nodes closer to the destination while penalizing nodes that increase the path length excessively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic_value = distance_matrix[node][destination_node] if destination_node != node else 0\n        dynamic_weight = 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1)))  # Adapts based on remaining nodes\n        weighted_score = -distance + dynamic_weight * heuristic_value  # Maximize this score\n\n        if weighted_score > best_score:\n            best_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.96694,
          "other_inf": null
     }
]