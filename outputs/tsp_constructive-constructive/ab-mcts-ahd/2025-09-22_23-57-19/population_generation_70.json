[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (minimum cost) but occasionally relaxes this by allowing nodes within 1.3x the average distance or 1.1x the minimum cost to escape local optima, dynamically adjusting thresholds based on remaining unvisited nodes. It balances greedy selection with a small chance of diversification to improve solution quality. The critical variables are `min_cost` (highest priority) and `avg_distance` (used for threshold adjustments), while the code structure ensures efficiency by iterating through unvisited nodes once for cost calculation and once for threshold checks.",
          "thought": "The new algorithm prioritizes the nearest unvisited node but occasionally selects a node within 1.3x the average distance or 1.1x the minimum cost to escape local optima, using dynamic threshold adjustments based on unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.20672,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines farthest-neighbor selection with a probabilistic escape mechanism, prioritizing the farthest node but switching to closer nodes if they meet dynamic thresholds (1.3x average distance or 1.1x minimum cost). It balances exploration (farthest neighbor) and exploitation (closer nodes within thresholds) to avoid local optima. The key variables are `max_cost` (prioritized) and thresholds (`avg_distance * 1.3`, `min_cost * 1.1`), while the structure ensures the destination is reached if included in unvisited nodes.",
          "thought": "The new algorithm combines the farthest-neighbor selection from No.2 with the probabilistic escape mechanism from No.1, using a dynamic threshold (1.3x the average distance or 1.1x the minimum cost) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n        min_cost = min(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.26561,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a farthest-neighbor escape mechanism: it prioritizes the nearest unvisited node but allows escapes to nodes within 1.4x the average distance or 1.15x the minimum cost to avoid local optima. The code first checks edge cases (empty/unvisited nodes), then selects the nearest node, and finally allows escapes within specified thresholds to improve solution quality. Higher priority is given to minimizing immediate costs, while the escape mechanism balances exploration.",
          "thought": "The new algorithm combines the nearest-neighbor selection of No.2 with the farthest-neighbor escape mechanism of No.1, prioritizing the nearest node but allowing escapes to nodes within 1.4x the average distance or 1.15x the minimum cost to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.4 and cost < min_cost * 1.15:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.33079,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) but occasionally selects slightly farther nodes (within a 1.5x threshold) to balance local optimization and global exploration, ensuring efficiency while avoiding local minima. It first checks for trivial cases (empty/unvisited sets or single nodes) before iterating through unvisited nodes to find the minimum-cost neighbor, then optionally explores slightly longer paths if they improve the overall solution. The 1.5x threshold and conditional checks highlight the trade-off between greediness and exploration.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 50% threshold) to balance local optimization and global exploration, ensuring the path remains efficient while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.5:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.34293,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines nearest-neighbor selection with a probabilistic escape mechanism to avoid local optima. It prioritizes the nearest unvisited node (based on the distance matrix) but occasionally selects a slightly longer path (if it's within 1.5x the average distance or 1.2x the minimum cost) to escape suboptimal solutions. The algorithm dynamically adjusts its threshold using the average distance to unvisited nodes, balancing exploration and exploitation.",
          "thought": "The algorithm combines nearest-neighbor selection with a probabilistic approach, where it occasionally selects a node with a higher cost to escape local optima, using a dynamic threshold based on the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.44598,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, prioritizing nodes closer to both. The `proximity` is calculated as the sum of the distance from the current node and half the distance to the destination, ensuring a trade-off between immediate and long-term efficiency. The `select_next_node` function iterates through unvisited nodes, computes this metric, and selects the node with the lowest combined value.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a balance between proximity to the current node and distance to the destination, prioritizing nodes that are closer to the current position but also closer to the destination to improve overall path efficiency while maintaining exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_proximity = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity < min_proximity:\n            min_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (exploitation) but occasionally allows exploration by selecting a node within 2.0x the average distance or 1.5x the minimum cost, dynamically adjusting thresholds to balance exploration and exploitation. It first checks for edge cases (empty/unvisited nodes or a single remaining node), then computes distances to unvisited nodes, selects the nearest node, and conditionally switches to a node within relaxed thresholds if more than two nodes remain. The average distance and minimum cost act as dynamic thresholds, with the algorithm favoring the nearest node but allowing limited exploration when conditions are met.",
          "thought": "The new algorithm prioritizes the nearest unvisited node but occasionally selects a node within 2.0x the average distance or 1.5x the minimum cost, with dynamic threshold adjustments based on the average distance to unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 2.0 and cost < min_cost * 1.5:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 8.4775,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes farthest-node selection (exploitation) but occasionally explores slightly closer nodes within a dynamic threshold (1.3x average distance) to balance exploration. It ensures the destination node is always chosen if unvisited, and the threshold is only applied when more than two nodes remain unvisited. The code structure first computes distances, selects the farthest node, and then probabilistically overrides this choice if a nearby node meets the threshold.",
          "thought": "The new algorithm combines the farthest-node selection from No.2 with probabilistic exploration from No.1, where it occasionally chooses a node slightly closer than the farthest but still within a dynamic threshold (1.3x the average distance of unvisited nodes) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    max_distance = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] > max_distance:\n            max_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 21.73848,
          "other_inf": null
     }
]