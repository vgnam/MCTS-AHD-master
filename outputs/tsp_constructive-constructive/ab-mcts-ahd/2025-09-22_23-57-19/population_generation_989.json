[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the current node (maximizing `-distance_matrix[current_node][node]`) while also considering their distance to the destination (adding `0.5 * distance_matrix[node][destination_node]`), aiming to delay reaching the destination until the end. The proximity score balances these two factors, favoring nodes that are both nearby and farther from the destination. The structure iterates through unvisited nodes, calculates the proximity score, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the current node and farther from the destination, aiming to delay reaching the destination until the end, potentially reducing overall path length by exploring more local connections first.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_proximity = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = -distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity > max_proximity:\n            max_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity to the destination node more aggressively as the tour nears completion by dynamically adjusting the weight of proximity-to-destination in the scoring function, while still considering the local distance to the current node. The score combines distance to the current node and a weighted proximity-to-destination term, where the weight increases as the tour progresses. The destination node is always prioritized if it is unvisited, ensuring the tour ends optimally.",
          "thought": "The new algorithm prioritizes global optimization by dynamically adjusting the weight of proximity to the destination based on the remaining distance, while also considering the local distance to the current node, but with a different scoring mechanism that emphasizes proximity to the destination more aggressively as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - remaining_distance_to_dest / (remaining_distance_to_dest + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the proximity to the destination, with a dynamic weight that prioritizes local optimization (distance to current node) when few nodes remain and global optimization (proximity to destination) when more nodes are left. The weight adjusts based on the remaining unvisited nodes, ensuring a smooth transition between local and global considerations.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with the dynamic balancing of No.1, selecting nodes based on a weighted combination of distance to current node and proximity to destination, using a variable weight that adapts to the number of remaining nodes to ensure a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_score = float('inf')\n    next_node = None\n    weight = 0.5 + (0.4 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1)))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current + (weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.65711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the destination with probabilistic selection, using a temperature-based decay to prioritize closer nodes while occasionally exploring alternatives. It dynamically weights distances to the current node and destination proximity, with the destination having higher priority when its probability exceeds a temperature threshold. The temperature decreases as more nodes are visited, favoring exploitation over exploration.",
          "thought": "The new algorithm combines dynamic weighting of proximity-to-destination with probabilistic selection, using a temperature-based decay to balance exploration and exploitation, ensuring optimal tour completion while maintaining efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        remaining_unvisited = unvisited_nodes - {destination_node}\n\n        if not remaining_unvisited:\n            return destination_node\n\n        avg_distance = sum(distance_matrix[current_node][node] for node in remaining_unvisited) / len(remaining_unvisited)\n        temp = max(0.1, 1.0 - (1.0 / (1.0 + len(unvisited_nodes))))\n\n        proximity_to_dest = 1 / (1 + destination_distance)\n        dynamic_weight = 0.5 + 0.5 * (1 - destination_distance / (destination_distance + 1))\n\n        if avg_distance > 0:\n            normalized_ratio = (destination_distance / avg_distance) ** -1\n            prob_destination = temp * (dynamic_weight * proximity_to_dest + normalized_ratio)\n        else:\n            prob_destination = 1.0\n\n        prob_destination = min(prob_destination, 1.0)\n\n        if prob_destination > temp:\n            return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - distance_matrix[node][destination_node] / (distance_matrix[node][destination_node] + 1))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.66388,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the distance from the current node and the proximity to the destination, with a fixed weight of 0.7 prioritizing proximity. It evaluates each unvisited node by combining the direct distance to the current node and the inverse of the distance to the destination, then chooses the node with the lowest combined score. The static weight ensures a consistent bias toward proximity, making the tour more direct but less adaptive to local conditions.",
          "thought": "The new algorithm prioritizes nodes based on a static weight that balances local distance and proximity to the destination, using a fixed 0.7 weight for proximity, ensuring a more balanced but less adaptive tour compared to the original dynamic approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        static_weight = 0.7\n        score = distance_to_current + (static_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.80722,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local distance and proximity to the destination by dynamically adjusting weights: local distance (weighted 0.6) and proximity (weighted 0.4 \u00d7 dynamic factor). The dynamic weight increases as the tour progresses (from 0.3 to 1.0), prioritizing proximity more in later stages. The next node is chosen based on the lowest combined score, ensuring a smooth transition toward the destination.",
          "thought": "The new algorithm prioritizes balancing local distance and proximity to the destination by using a fixed weight for proximity-to-destination, while dynamically adjusting the weight for local distance as the tour progresses, ensuring a smoother transition towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.3 + 0.7 * (1 - total_unvisited / len(distance_matrix))\n        score = (0.6 * distance_to_current) + (0.4 * dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.82039,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a dynamically weighted proximity-to-destination heuristic, prioritizing nearby nodes while gradually emphasizing the shortest path back to the destination as the tour progresses. The dynamic weight (`dynamic_weight`) increases over time, balancing local distance (`distance_to_current`) and global proximity to the destination (`proximity_to_dest`), ensuring efficiency and adaptability.",
          "thought": "This new algorithm combines the nearest-neighbor approach of No.2 with a dynamic weighting of proximity-to-destination inspired by No.1, where the weight increases as the tour progresses, balancing local and global considerations while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.5 + 0.5 * (1 - (total_unvisited / (total_unvisited + 1)))\n        score = distance_to_current + (dynamic_weight * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.83201,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with dynamic proximity prioritization, using a static weight (0.7) to balance distance to the current node and inverse distance to the destination, while enforcing a threshold (1.1\u00d7 max distance) to refine choices between farthest and nearest nodes. It prioritizes minimizing distance to the current node while also considering proximity to the destination, but only when the candidate node's distance is within 110% of the maximum distance. The static weight ensures a trade-off between local and global optimization.",
          "thought": "The new algorithm combines nearest-neighbor selection with dynamic proximity prioritization, using a static weight (0.7) to balance distance to the current node and inverse distance to the destination, while applying a threshold (1.1\u00d7 max distance) to refine choices between farthest and nearest nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        max_cost = -float('inf')\n        for node in unvisited_nodes:\n            cost = distance_matrix[current_node][node]\n            if cost > max_cost:\n                max_cost = cost\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            distance_to_current = distance_matrix[current_node][node]\n            proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n            static_weight = 0.7\n            score = distance_to_current + (static_weight * proximity_to_dest)\n\n            if score < distance_matrix[current_node][next_node] + (static_weight * 1 / (1 + distance_matrix[next_node][destination_node])) and distance_to_current < max_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.83379,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity to the current node, dynamic weighting of destination proximity, and a penalty to discourage revisiting nodes. It prioritizes nodes with lower distance to the current node and higher proximity to the destination, while adjusting weights dynamically based on remaining unvisited nodes. The revisit penalty further encourages exploration by penalizing nodes with small distances, ensuring a more diverse path. The score calculation combines these factors to determine the optimal next node.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that prioritizes nodes based on their distance to the current node and a dynamically adjusted proximity to the destination, while also incorporating a penalty for revisiting nodes to encourage exploration of less traveled paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    remaining_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        dynamic_weight = 0.3 + 0.7 * (1 - (total_unvisited / (total_unvisited + 1)))\n        revisit_penalty = 0.1 * (1 / (1 + distance_to_current))  # Penalize revisiting nodes with small distances\n        score = distance_to_current + (dynamic_weight * proximity_to_dest) - revisit_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88229,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **farthest-neighbor and nearest-neighbor selection** by dynamically balancing distance to the current node and proximity to the destination, using a **static weight (0.7)** to prioritize proximity while applying a **threshold (1.1\u00d7 max distance)** to refine choices between farthest and nearest nodes. It evaluates nodes based on their **distance to the current node** and **inverse distance to the destination**, then selects the best candidate within the threshold. The algorithm prioritizes **proximity to the destination** over raw distance, making it adaptive to the remaining path.",
          "thought": "The new algorithm combines the static weight from No.1 (0.7) to balance distance and proximity, while using the dynamic threshold (1.1\u00d7 max distance) from No.2 to adaptively select nodes between farthest-neighbor and nearest-neighbor. It evaluates nodes by combining their distance to the current node and proximity to the destination, then applies the threshold to refine the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            distance_to_current = distance_matrix[current_node][node]\n            proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n            static_weight = 0.7\n            score = distance_to_current + (static_weight * proximity_to_dest)\n            potential_cost = distance_to_current + distance_matrix[node][next_node]\n\n            if potential_cost < max_cost * 1.1 and score < distance_matrix[current_node][next_node] + (static_weight * 1 / (1 + distance_matrix[next_node][destination_node])):\n                next_node = node\n                break\n\n    return next_node",
          "objective": 6.89346,
          "other_inf": null
     }
]