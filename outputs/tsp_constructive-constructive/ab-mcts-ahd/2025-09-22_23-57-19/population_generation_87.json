[
     {
          "algorithm": "The algorithm implements a nearest-neighbor heuristic for TSP by prioritizing the destination node if unvisited, otherwise selecting the closest unvisited node from the current position. It uses the distance matrix to compare distances, with `destination_node` and `unvisited_nodes` given higher priority than other nodes, and `current_node` and `distance_matrix` playing supporting roles. The structure ensures efficiency by iterating only through unvisited nodes.",
          "thought": "The algorithm selects the next node to visit based on the nearest neighbor heuristic, choosing the closest unvisited node from the current position, prioritizing the destination node if it is unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest neighbor (minimizing immediate distance) while occasionally exploring slightly farther nodes to balance efficiency and avoid local optima, as seen in the cost-based selection with a 20% threshold (*1.2). The function checks edge cases (empty/unvisited nodes) and defaults to a greedy nearest-neighbor approach unless a slightly more distant node offers a better combined cost. The hybrid logic ensures a trade-off between speed and solution quality.",
          "thought": "This algorithm implements a hybrid approach that combines nearest neighbor with a cost-based selection, prioritizing nodes that minimize the total path cost while occasionally exploring farther nodes to escape local optima, balancing efficiency and solution quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.03992,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the distance from the current node with a proximity-to-destination factor (inversely weighted by distance to the destination). It prioritizes shorter distances to the current node while slightly favoring nodes closer to the destination (via the `1 - 0.3 * proximity_to_dest` adjustment), ensuring efficiency and directional progress. The `proximity_to_dest` term is normalized by `1 + distance` to avoid division by zero and weighted less (30%) than distance.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted combination of distance and a novel \"proximity-to-destination\" factor, where the next node is selected based on a balance between minimizing distance to the current node and maximizing proximity to the destination, ensuring the path remains efficient while steering towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        proximity_to_dest = 1 / (1 + distance_matrix[node][destination_node])\n        score = distance_to_current * (1 - 0.3 * proximity_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.09816,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the nearest unvisited node (minimum cost) but occasionally relaxes this by allowing nodes within 1.3x the average distance or 1.1x the minimum cost to escape local optima, dynamically adjusting thresholds based on remaining unvisited nodes. It balances greedy selection with a small chance of diversification to improve solution quality. The critical variables are `min_cost` (highest priority) and `avg_distance` (used for threshold adjustments), while the code structure ensures efficiency by iterating through unvisited nodes once for cost calculation and once for threshold checks.",
          "thought": "The new algorithm prioritizes the nearest unvisited node but occasionally selects a node within 1.3x the average distance or 1.1x the minimum cost to escape local optima, using dynamic threshold adjustments based on unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.20672,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines farthest-neighbor selection with a probabilistic escape mechanism, prioritizing the farthest node but switching to closer nodes if they meet dynamic thresholds (1.3x average distance or 1.1x minimum cost). It balances exploration (farthest neighbor) and exploitation (closer nodes within thresholds) to avoid local optima. The key variables are `max_cost` (prioritized) and thresholds (`avg_distance * 1.3`, `min_cost * 1.1`), while the structure ensures the destination is reached if included in unvisited nodes.",
          "thought": "The new algorithm combines the farthest-neighbor selection from No.2 with the probabilistic escape mechanism from No.1, using a dynamic threshold (1.3x the average distance or 1.1x the minimum cost) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    max_cost = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost > max_cost:\n            max_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n        avg_distance = sum(distances) / len(distances)\n        min_cost = min(distances)\n\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.3 and cost < min_cost * 1.1:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.26561,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a farthest-neighbor escape mechanism: it prioritizes the nearest unvisited node but allows escapes to nodes within 1.4x the average distance or 1.15x the minimum cost to avoid local optima. The code first checks edge cases (empty/unvisited nodes), then selects the nearest node, and finally allows escapes within specified thresholds to improve solution quality. Higher priority is given to minimizing immediate costs, while the escape mechanism balances exploration.",
          "thought": "The new algorithm combines the nearest-neighbor selection of No.2 with the farthest-neighbor escape mechanism of No.1, prioritizing the nearest node but allowing escapes to nodes within 1.4x the average distance or 1.15x the minimum cost to avoid local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.4 and cost < min_cost * 1.15:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.33079,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the closest unvisited neighbor (minimizing immediate distance) but occasionally selects slightly farther nodes (within a 1.5x threshold) to balance local optimization and global exploration, ensuring efficiency while avoiding local minima. It first checks for trivial cases (empty/unvisited sets or single nodes) before iterating through unvisited nodes to find the minimum-cost neighbor, then optionally explores slightly longer paths if they improve the overall solution. The 1.5x threshold and conditional checks highlight the trade-off between greediness and exploration.",
          "thought": "The new algorithm prioritizes the closest neighbor (minimizing immediate distance) while occasionally selecting slightly farther nodes (using a 50% threshold) to balance local optimization and global exploration, ensuring the path remains efficient while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            potential_cost = distance_matrix[current_node][node] + distance_matrix[node][next_node]\n            if potential_cost < min_cost * 1.5:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.34293,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor approach by balancing the immediate distance to the next node (higher priority) with a heuristic that favors nodes closer to the destination (lower priority, weighted by 0.3). It prioritizes minimizing the total path length while making progress toward the destination, efficiently selecting the next node from unvisited options. The critical design choices are the weighted combination of distance and heuristic, and the early termination if the destination is unvisited.",
          "thought": "The new algorithm modifies the nearest-neighbor approach by incorporating a weighted combination of distance and a heuristic that favors nodes closer to the destination, balancing exploration of nearby nodes with progress toward the destination, while maintaining efficiency by only considering unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        heuristic = distance_matrix[node][destination_node] if destination_node != node else 0\n        score = distance + 0.3 * heuristic\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines nearest-neighbor selection with a probabilistic escape mechanism to avoid local optima. It prioritizes the nearest unvisited node (based on the distance matrix) but occasionally selects a slightly longer path (if it's within 1.5x the average distance or 1.2x the minimum cost) to escape suboptimal solutions. The algorithm dynamically adjusts its threshold using the average distance to unvisited nodes, balancing exploration and exploitation.",
          "thought": "The algorithm combines nearest-neighbor selection with a probabilistic approach, where it occasionally selects a node with a higher cost to escape local optima, using a dynamic threshold based on the average distance to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]\n    avg_distance = sum(distances) / len(distances)\n\n    min_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        cost = distance_matrix[current_node][node]\n        if cost < min_cost:\n            min_cost = cost\n            next_node = node\n\n    if next_node is None:\n        return unvisited_nodes.pop()\n\n    if len(unvisited_nodes) > 2:\n        for node in unvisited_nodes:\n            if node == next_node:\n                continue\n            cost = distance_matrix[current_node][node]\n            if cost < avg_distance * 1.5 and cost < min_cost * 1.2:\n                next_node = node\n                break\n\n    return next_node",
          "objective": 7.44598,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, prioritizing nodes closer to both. The `proximity` is calculated as the sum of the distance from the current node and half the distance to the destination, ensuring a trade-off between immediate and long-term efficiency. The `select_next_node` function iterates through unvisited nodes, computes this metric, and selects the node with the lowest combined value.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a balance between proximity to the current node and distance to the destination, prioritizing nodes that are closer to the current position but also closer to the destination to improve overall path efficiency while maintaining exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_proximity = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        proximity = distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node]\n        if proximity < min_proximity:\n            min_proximity = proximity\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]