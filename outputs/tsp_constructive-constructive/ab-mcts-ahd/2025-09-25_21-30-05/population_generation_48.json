[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, ensuring minimal incremental distance at each step. The `distance_matrix` is the highest-priority input, as it directly determines the selection criterion, while `destination_node` and `unvisited_nodes` are secondary in guiding the path construction. The function iterates through unvisited nodes to find the closest one, with `min_distance` tracking the best candidate.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, ensuring efficient path construction towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if distance_matrix[current_node][node] < min_distance:\n            min_distance = distance_matrix[current_node][node]\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by prioritizing the closest unvisited node when few nodes remain (greedy) and considering both current and destination distances otherwise. It adjusts selection weights based on remaining nodes and incorporates a dynamic factor to favor nodes closer to the destination, ensuring a smooth transition between local and global strategies. The `local_weight` and `global_weight` parameters ensure the algorithm adapts to the remaining nodes, while the `score` computation balances immediate distance with long-term progress.",
          "thought": "The new algorithm combines the greedy closest-neighbor approach from No.1 with the dynamic weighted balance from No.2, prioritizing local distance when few nodes remain and global progress otherwise, while incorporating a dynamic adjustment factor to refine selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        global_weight = 1 - local_weight\n        if remaining_nodes <= 2:\n            score = -distance_to_current\n        else:\n            score = (local_weight / (distance_to_current + 1e-6)) + (global_weight / (distance_to_destination + 1e-6))\n        score *= (1 + 0.1 * (1 - distance_to_destination / max(distance_matrix[node])))\n        if score > best_score:\n            best_score = score\n            next_node = node\n    return next_node",
          "objective": 7.03141,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance from current node) and global progress (distance to destination) using a weighted harmonic mean, where weights adjust dynamically based on remaining unvisited nodes. It prioritizes closer nodes (local) when few nodes remain, while emphasizing progress toward the destination (global) when many nodes are left. The dynamic adjustment factor further refines selection by considering relative distances to the destination.",
          "thought": "The new algorithm selects the next node by combining a local proximity measure with a global progress measure, using a weighted harmonic mean to balance exploration and exploitation, and incorporates a dynamic adjustment factor based on the remaining unvisited nodes to adapt to the problem's state.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        global_weight = 1 - local_weight\n        total_score = (local_weight / (distance_to_current + 1e-6)) + (global_weight / (distance_to_destination + 1e-6))\n        total_score *= (1 + 0.1 * (1 - distance_to_destination / max(distance_matrix[node])))\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.03282,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing local proximity (prioritized when few nodes remain) with global progress (favoring paths that lead closer to the destination), while incentivizing exploration of central nodes early on. It penalizes nodes too close to the destination unless few nodes remain, and uses a centrality metric to adjust exploration weight. The score combines these factors with dynamic weights, ensuring adaptability to the problem's state.",
          "thought": "The new algorithm modifies the provided one by introducing a dynamic weighting scheme that combines local proximity, global progress, and a novel 'exploration factor' based on node centrality, which encourages visiting central nodes when many options remain while favoring proximity when few nodes are left. It also incorporates a penalty for revisiting nodes based on historical path data.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        centrality[node] = sum(distance_matrix[node]) / (total_nodes - 1)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weights based on remaining nodes and centrality\n        local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        global_weight = 1 - local_weight\n        exploration_weight = 0.3 * (1 - centrality[node] / max(centrality.values())) if max(centrality.values()) != 0 else 0\n\n        # Calculate score with exploration factor\n        total_score = (local_weight / (distance_to_current + 1e-6)) + \\\n                      (global_weight / (distance_to_destination + 1e-6)) + \\\n                      (exploration_weight * (1 / (centrality[node] + 1e-6)))\n\n        # Penalize nodes that are too close to the destination (unless few nodes remain)\n        if remaining_nodes > 3:\n            total_score *= (1 - 0.2 * (distance_to_destination / max(distance_matrix[node])))\n\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 7.14463,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted heavily) and balancing it with proximity to the destination (weighted lightly), using inverse distances to ensure closer nodes get higher scores. The function iterates through unvisited nodes, computes a weighted sum of these distances, and selects the node with the highest score. The small epsilon (1e-6) prevents division by zero, and the 0.3 weight gives the destination distance lower priority than the current node's distance.",
          "thought": "The new algorithm combines the proximity-based selection of No.2 with the weighted balance of local and global optimization from No.1, using the weighted sum of distances to current and destination nodes, with the highest weight on proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_score = (1 / (distance_to_current + 1e-6)) + 0.3 * (1 / (distance_to_destination + 1e-6))\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.20668,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the normalized distance to the destination, with a dynamic weight that prioritizes closer nodes as fewer options remain. The dynamic weight (`dynamic_weight`) increases as the number of unvisited nodes decreases, favoring local proximity when choices are limited, while the normalized destination distance ensures the path remains globally efficient. The selection is based on minimizing a weighted combination of these distances, where the current distance and the normalized destination distance are scaled by the dynamic weight.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that adjusts based on the proportion of unvisited nodes, favoring closer nodes when fewer options remain, while still considering the destination's influence through a normalized distance metric.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight = 1.0 + (1.0 / (remaining_nodes + 1))  # Weight increases as fewer nodes remain\n    best_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        normalized_destination = distance_to_destination / (sum(distance_matrix[node]) / len(distance_matrix[node]))  # Normalize by average distance\n        total_score = distance_to_current * (dynamic_weight * normalized_destination)\n        if total_score < best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.26345,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (distance from current node) and global (distance to destination) factors, dynamically adjusting weights based on remaining nodes. It prioritizes nodes closer to the destination while reinforcing choices with a stronger emphasis on minimizing the distance to the final node, making the selection adaptive and refined. The reinforcement factor (0.2) and additional term (0.3) further bias selection toward nodes that reduce the overall path length.",
          "thought": "The new algorithm combines the weighted trade-off between local and global optimization from No.1, the dynamic weight adjustment based on remaining nodes from No.2, and adds a reinforcement factor that boosts scores for nodes that are closer to the destination relative to their distance from the current node, creating a more adaptive and refined selection process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        local_weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))\n        global_weight = 1 - local_weight\n        total_score = (local_weight / (distance_to_current + 1e-6)) + (global_weight / (distance_to_destination + 1e-6))\n        total_score *= (1 + 0.2 * (1 - distance_to_destination / max(distance_matrix[node])))\n        total_score += 0.3 * (1 / (distance_to_destination + 1e-6))\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.29566,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node with a weighted preference for minimizing the distance to the destination (with 0.3 emphasis), ensuring a trade-off between local and global optimization. The `select_next_node` function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the lowest score, prioritizing nodes closer to the destination while still considering the current path.",
          "thought": "The new algorithm combines the proximity to the current node with a stronger emphasis on minimizing the distance to the destination, using a weighted sum (distance_to_current + 0.3 * distance_to_destination) to balance local and global optimization, ensuring a more efficient path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_score = distance_to_current + 0.3 * distance_to_destination\n        if total_score < best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) factors, with a dynamic weight that prioritizes closer nodes when many are unvisited and balances factors when fewer remain. It avoids revisits by only considering unvisited nodes and penalizes long paths via the weighted scoring mechanism. The dynamic weight (`dynamic_weight`) adjusts based on the number of unvisited nodes, favoring shorter local paths early and more balanced global-local trade-offs later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that adjusts based on the number of unvisited nodes, favoring closer nodes when many are left and balancing global and local factors when fewer remain, while penalizing revisits to previously visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 + (0.2 * (total_unvisited / (total_unvisited + 1)))\n        total_score = (distance_to_current * dynamic_weight) + (0.5 * distance_to_destination)\n        if total_score < best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.42085,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that are close to the current node while also considering their proximity to the destination (with 70% weight), balancing local and global optimization. The `total_score` is computed as the sum of the inverse of the distance to the current node and 0.7 times the inverse of the distance to the destination, ensuring a trade-off between minimizing immediate travel cost and progress toward the destination. The node with the highest `total_score` is chosen as the next node.",
          "thought": "This algorithm selects the next node by combining the distance to the current node with a weighted (0.7\u00d7) inverse of the distance to the destination, favoring nodes that are close to the current node but also sufficiently close to the destination, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    best_score = float('-inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        total_score = (1 / (distance_to_current + 1e-6)) + 0.7 * (1 / (distance_to_destination + 1e-6))\n        if total_score > best_score:\n            best_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.42521,
          "other_inf": null
     }
]