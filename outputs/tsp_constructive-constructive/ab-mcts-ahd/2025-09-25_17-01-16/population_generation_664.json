[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate closeness (negative `current_distance`) while heavily emphasizing destination proximity (`0.6 * destination_distance`), balancing local and global optimization. The `current_distance` is penalized (negative weight) to favor nearby nodes, while the `destination_distance` is weighted strongly (0.6) to guide the path toward the destination, creating an aggressive, destination-aware heuristic.",
          "thought": "The new algorithm prioritizes immediate closeness (negative `current_distance`) with a stronger emphasis on destination proximity (`0.6 * destination_distance`), balancing local and global optimization by favoring nodes that are both nearby and closer to the destination, creating a more aggressive destination-aware heuristic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.6 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized by minimizing `current_distance`) and destination awareness (prioritized by maximizing `destination_distance`), with dynamic weights adjusting based on remaining nodes. A penalty discourages revisiting nearby nodes when many nodes remain unvisited. The score is computed as `-current_distance + weight * destination_distance`, with the weight set to 0.5 for most nodes but reduced to 0.2 when only one node remains. A small penalty (`+0.1 * current_distance`) is added for nodes very close to the current node when more than two nodes are left.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate proximity and destination awareness based on the remaining unvisited nodes, using a normalized score that considers both local and global factors, while also incorporating a penalty for revisiting nodes that were recently considered.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes\n        weight = 0.5 if remaining_nodes > 1 else 0.2\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for nodes recently considered (simulated by favoring nodes further away)\n        if remaining_nodes > 2:\n            score += 0.1 * distance_matrix[current_node][node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance reduction (prioritized with a fixed weight of -1.5) and dynamic destination proximity (scaled by a weight factor that increases as more nodes remain unvisited, favoring closer nodes early). The score is computed as `-1.5 * current_distance + weight_factor * destination_distance`, where `weight_factor = total_nodes / remaining_nodes`, ensuring a trade-off between local and global progress.",
          "thought": "The new algorithm prioritizes immediate distance reduction with a fixed weight and dynamically adjusts the destination proximity's influence based on the remaining nodes, favoring closer nodes early and balancing global progress later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weight_factor = (total_nodes / remaining_nodes) if remaining_nodes > 0 else 1.0\n        score = -1.5 * current_distance + weight_factor * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and closeness to the destination, with a dynamic weight that prioritizes destination proximity as the number of unvisited nodes decreases. It penalizes nodes too close to the current node to avoid backtracking, with the score calculated as a weighted combination of these factors. The dynamic weight (`weight`) increases as the number of remaining nodes decreases, while the penalty (`penalty`) discourages selecting nodes that are too near the current node. The final score is a trade-off between minimizing distance to the next node and maximizing progress toward the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the progress toward the destination (higher weight for destination proximity as the number of unvisited nodes decreases) and penalizing nodes that are too close to the current node to avoid backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and penalize very close nodes\n        weight = 0.5 + (1.0 - 0.5) * (1.0 - remaining_nodes / len(unvisited_nodes))\n        penalty = 1.0 if current_distance < 0.1 * distance_matrix[current_node][destination_node] else 0.0\n        score = -current_distance * (1.0 - penalty) + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53553,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically balancing local and global distances using a weighted combination, where the weight (alpha) adjusts based on the number of remaining nodes. It prioritizes minimizing the immediate distance to the next node while also considering the global path to the destination, with a penalty to avoid revisiting nodes. The scoring mechanism combines these factors to choose the most promising candidate node.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic alpha parameter that adjusts based on the number of remaining nodes and the current path's progress, using a weighted combination of local and global distances with a novel scoring mechanism that includes a penalty for revisiting nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    alpha = 0.5 * (1 + (remaining_nodes / (remaining_nodes + 1)))  # Dynamic alpha\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        penalty = 1.0 if node in unvisited_nodes and node != destination_node else 0.0  # Penalty for revisiting\n        total_score = distance_to_current - alpha * distance_to_destination + penalty * distance_to_current\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 6.54699,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (lower priority) and distance to the destination (higher priority, weighted at 0.7), favoring nodes that are both close to the current position and far from the destination to encourage exploration while still minimizing total path length. The `score` calculation prioritizes `destination_distance` over `current_distance`, and the loop iterates through unvisited nodes to find the one with the highest score.",
          "thought": "The new algorithm prioritizes selecting the next node based on a balance between minimizing immediate distance and maximizing the distance to the destination, with the latter having a stronger influence (positive weight of 0.7) to encourage exploration while still favoring shorter paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.7 * destination_distance  # Stronger emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm balances immediate and future progress by dynamically adjusting a weight factor that prioritizes proximity to the current node while also considering distance to the destination. The weight factor decreases as the number of remaining unvisited nodes decreases, shifting focus from global optimization (destination proximity) to local optimization (current node proximity). The score function combines these factors, favoring nodes that are close to the current node but also have a reasonable distance to the destination, with the latter's influence diminishing as the tour progresses. The algorithm selects the node with the highest score as the next step in the tour.",
          "thought": "The new algorithm combines the No.1's balanced approach of favoring nodes close to the current node and the No.2's dynamic weight factor to prioritize destination proximity as fewer nodes remain. It dynamically adjusts the weight factor to balance immediate and future progress, ensuring a smooth transition from global to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + (destination_distance ** weight_factor)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55342,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (prioritizing closer nodes) and global optimization (considering distance to the destination), using a non-linear weight adjustment that increases emphasis on global factors as fewer nodes remain unvisited. The score combines a negative distance to the current node (local priority) with a weighted term that favors nodes farther from the destination but scales adaptively based on remaining nodes. The bias term further amplifies this global consideration by emphasizing nodes that are both close to the current node and far from the destination.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a non-linear weight adjustment based on remaining nodes and an adaptive bias toward nodes that are closer to the current node but farther from the destination, creating a dynamic balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(unvisited_nodes) + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Non-linear weight adjustment based on remaining nodes\n        weight = 0.3 + 0.7 * (1.0 - (remaining_nodes / total_nodes) ** 2)\n\n        # Adaptive bias: prioritize nodes closer to current but farther from destination\n        bias = (distance_to_destination / (distance_to_current + 1e-6)) ** 0.5\n        score = -distance_to_current + weight * distance_to_destination * bias\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56995,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node (higher priority) and the distance to the destination (lower priority), with an adaptive weight (`alpha`) that decreases as fewer nodes remain. When many nodes are left, it penalizes revisiting nearby nodes with an additional penalty term. The score-based selection ensures efficiency, prioritizing shorter immediate distances while considering long-term progress.",
          "thought": "The new algorithm combines the dynamic weighting from No.1 (balancing local and global progress) with the score-based selection from No.2, using a penalty for revisiting nearby nodes when many nodes remain, and adjusting the alpha parameter based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        alpha = 0.5 if remaining_nodes > 1 else 0.2\n        score = distance_to_current - alpha * distance_to_destination\n\n        if remaining_nodes > 2:\n            score += 0.1 * distance_to_current\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58162,
          "other_inf": null
     }
]