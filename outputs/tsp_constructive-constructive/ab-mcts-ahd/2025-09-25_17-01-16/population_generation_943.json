[
     {
          "algorithm": "The algorithm prioritizes immediate closeness (highest weight) by minimizing the current distance, moderately considers destination proximity (0.4 weight), and balances global optimization with an average unvisited distance term (0.2 weight). The code iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score, effectively balancing local and global optimization.",
          "thought": "The new algorithm combines immediate closeness (negative current_distance) with a moderate emphasis on destination proximity (0.4 * destination_distance) and an additional term (0.2 * average_unvisited_distance) to balance local and global optimization while accounting for remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        average_unvisited_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        score = -current_distance + 0.4 * destination_distance + 0.2 * average_unvisited_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.39138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing both proximity to the current node (with heavy emphasis) and proximity to the destination node (with moderate emphasis). It calculates a score for each unvisited node as `-current_distance + 0.55 * destination_distance`, balancing nearness to the current position (weighted heavily) with nearness to the destination (weighted moderately). The node with the highest score is chosen as the next step.",
          "thought": "The new algorithm combines the balanced approach of No.1 (0.5 weight for destination proximity) with the aggressive emphasis on destination proximity from No.2 (0.6 weight), using a 0.55 weight for destination proximity to achieve a more refined balance, while still penalizing current distance heavily to favor nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.55 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate closeness (negative `current_distance`) while heavily emphasizing destination proximity (`0.6 * destination_distance`), balancing local and global optimization. The `current_distance` is penalized (negative weight) to favor nearby nodes, while the `destination_distance` is weighted strongly (0.6) to guide the path toward the destination, creating an aggressive, destination-aware heuristic.",
          "thought": "The new algorithm prioritizes immediate closeness (negative `current_distance`) with a stronger emphasis on destination proximity (`0.6 * destination_distance`), balancing local and global optimization by favoring nodes that are both nearby and closer to the destination, creating a more aggressive destination-aware heuristic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.6 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node (lower priority) with a weighted combination of the distance to the destination (higher priority), where the weight increases non-linearly as fewer nodes remain. A bias term further favors nodes closer to the current node and farther from the destination, with the distance-to-destination component given slightly more emphasis. The score is computed as `-distance_to_current + weight * distance_to_destination * bias`, ensuring a trade-off between local and global optimization.",
          "thought": "The new algorithm combines the balancing approach of No.1 (weighting current distance and destination distance) with the adaptive weight adjustment and bias term of No.2, using a non-linear weight that increases global emphasis as fewer nodes remain, while also incorporating a bias that favors nodes closer to the current node and farther from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(unvisited_nodes) + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight = 0.4 + 0.6 * (1.0 - (remaining_nodes / total_nodes) ** 1.5)\n\n        bias = (distance_to_destination / (distance_to_current + 1e-6)) ** 0.8\n\n        score = -distance_to_current + weight * distance_to_destination * bias\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48886,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized by minimizing `current_distance`) and destination awareness (prioritized by maximizing `destination_distance`), with dynamic weights adjusting based on remaining nodes. A penalty discourages revisiting nearby nodes when many nodes remain unvisited. The score is computed as `-current_distance + weight * destination_distance`, with the weight set to 0.5 for most nodes but reduced to 0.2 when only one node remains. A small penalty (`+0.1 * current_distance`) is added for nodes very close to the current node when more than two nodes are left.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate proximity and destination awareness based on the remaining unvisited nodes, using a normalized score that considers both local and global factors, while also incorporating a penalty for revisiting nodes that were recently considered.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes\n        weight = 0.5 if remaining_nodes > 1 else 0.2\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for nodes recently considered (simulated by favoring nodes further away)\n        if remaining_nodes > 2:\n            score += 0.1 * distance_matrix[current_node][node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are both far from the destination (to ensure global optimization) and closer to the current node (to maintain local efficiency), with a dynamic weight that adjusts based on the number of remaining unvisited nodes. The score is computed as a combination of the negative distance to the current node (favoring proximity) and a weighted product of the distance to the destination and a bias term (favoring distant nodes), with the weight scaling quadratically with remaining nodes.",
          "thought": "The new algorithm will prioritize global optimization by emphasizing nodes that are far from the destination while adaptively adjusting the weight based on the remaining nodes, using a quadratic scaling factor and a multiplicative bias to favor nodes that are both distant from the destination and closer to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(unvisited_nodes) + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Quadratic weight adjustment based on remaining nodes\n        weight = 0.5 + 0.5 * (1.0 - (remaining_nodes / total_nodes) ** 2)\n\n        # Multiplicative bias: prioritize nodes farther from destination and closer to current\n        bias = (distance_to_destination * (1.0 / (distance_to_current + 1e-6))) ** 1.5\n        score = -distance_to_current + weight * distance_to_destination * bias\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49655,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm prioritizes nodes with shorter distances from the current node while dynamically balancing destination proximity (higher weight early on) and penalizing revisits. It also rewards nodes that bridge clusters (high destination distance) to improve tour connectivity, with weights adapting based on the remaining nodes ratio. The scoring system combines proximity, destination awareness, and cluster bridging, favoring closer nodes but adjusting for long-term path efficiency.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adapts based on the ratio of remaining nodes to total nodes, with a penalty for revisiting nodes and a bonus for nodes that bridge gaps between clusters, computed as a weighted combination of proximity, destination awareness, and cluster connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 1.0\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes ratio\n        weight = 0.6 if remaining_ratio > 0.5 else 0.3\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for revisiting nodes\n        if node in unvisited_nodes and len(unvisited_nodes) > 2:\n            score -= 0.15 * current_distance\n\n        # Bonus for nodes that bridge clusters (simplified as nodes with high destination distance)\n        if destination_distance > 2 * sum(distance_matrix[node]) / len(distance_matrix[node]):\n            score += 0.2 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49827,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity to the current node (weighted by an exponentially decaying exploration factor) with the node's centrality (average distance to remaining unvisited nodes) and its potential to reduce the total tour length (destination distance). The exploration factor prioritizes local optimization early in the tour but shifts toward global optimization as the tour progresses, with centrality gaining importance as the number of remaining nodes decreases. The score equation ensures a trade-off between immediate proximity and long-term tour efficiency.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic exploration factor that adapts to the tour's progress, combining proximity to the current node with a weighted consideration of the node's potential to reduce the total tour length, while also accounting for the node's centrality in the remaining unvisited nodes. The algorithm calculates a score for each unvisited node based on a novel equation that balances local and global optimization, with the exploration factor decaying exponentially as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    exploration_factor = 0.5 ** (1.0 / (1.0 + remaining_nodes))\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Calculate centrality: average distance to all other unvisited nodes\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n\n        # Novel score equation: balances proximity, centrality, and destination distance\n        score = (-current_distance * exploration_factor) + (centrality * exploration_factor) - (destination_distance * (1 - exploration_factor))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50344,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity (lower `current_distance`) while dynamically adjusting destination awareness (higher `weight * destination_distance`) based on remaining nodes. When few nodes remain, it heavily favors closeness (`weight=0.6`), while with more nodes, it balances both factors. A penalty for revisiting nearby nodes (`+ 0.2 * distance_matrix[current_node][node]`) is applied when many nodes are left, ensuring diverse exploration. The score combines these factors to select the next node.",
          "thought": "This algorithm combines dynamic weighting based on remaining nodes, penalizes revisiting nearby nodes when many nodes remain, and balances immediate proximity with destination awareness using a score that adjusts weights dynamically, favoring immediate closeness when few nodes remain and considering destination proximity otherwise.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes\n        weight = 0.4 if remaining_nodes > 2 else 0.6\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for nodes recently considered (simulated by favoring nodes further away)\n        if remaining_nodes > 3:\n            score += 0.2 * distance_matrix[current_node][node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.512,
          "other_inf": null
     }
]