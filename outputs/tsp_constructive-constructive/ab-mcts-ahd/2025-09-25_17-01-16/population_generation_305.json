[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and closeness to the destination, with a dynamic weight that prioritizes destination proximity as the number of unvisited nodes decreases. It penalizes nodes too close to the current node to avoid backtracking, with the score calculated as a weighted combination of these factors. The dynamic weight (`weight`) increases as the number of remaining nodes decreases, while the penalty (`penalty`) discourages selecting nodes that are too near the current node. The final score is a trade-off between minimizing distance to the next node and maximizing progress toward the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the progress toward the destination (higher weight for destination proximity as the number of unvisited nodes decreases) and penalizing nodes that are too close to the current node to avoid backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and penalize very close nodes\n        weight = 0.5 + (1.0 - 0.5) * (1.0 - remaining_nodes / len(unvisited_nodes))\n        penalty = 1.0 if current_distance < 0.1 * distance_matrix[current_node][destination_node] else 0.0\n        score = -current_distance * (1.0 - penalty) + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53553,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (lower priority) and distance to the destination (higher priority, weighted at 0.7), favoring nodes that are both close to the current position and far from the destination to encourage exploration while still minimizing total path length. The `score` calculation prioritizes `destination_distance` over `current_distance`, and the loop iterates through unvisited nodes to find the one with the highest score.",
          "thought": "The new algorithm prioritizes selecting the next node based on a balance between minimizing immediate distance and maximizing the distance to the destination, with the latter having a stronger influence (positive weight of 0.7) to encourage exploration while still favoring shorter paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.7 * destination_distance  # Stronger emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing between minimizing the immediate distance from the current node (prioritized with weight `alpha`) and minimizing the distance to the destination node (prioritized with weight `1-alpha`). The `alpha` parameter controls the trade-off: higher `alpha` favors shorter local steps, while lower `alpha` favors progress toward the destination. The code iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm combines the conservative path selection of No.1 (prioritizing short immediate distances) with the balanced trade-off of No.2 (using alpha to control local/global considerations), resulting in a hybrid heuristic that minimizes long jumps while still guiding toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.7):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -alpha * current_distance + (1 - alpha) * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local proximity (distance from the current node) and global progress (estimated distance to the destination) using a dynamic weighting factor. The factor, derived from a sigmoid function, prioritizes local proximity early in the tour and shifts to global progress as fewer nodes remain unvisited. The score for each candidate node combines these priorities, with the node minimizing the score chosen as the next step. The ratio of local to global distances and the dynamic weighting factor are key design elements.",
          "thought": "The new algorithm modifies the provided ratio-based selection by incorporating a dynamic weighting factor that adjusts the priority of local proximity versus global progress, using a sigmoid function to smoothly transition between these priorities based on the remaining number of unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        # Dynamic weighting factor based on remaining unvisited nodes\n        progress_factor = 1 / (1 + math.exp(-(total_unvisited - len(unvisited_nodes) + 1)))\n        score = (1 - progress_factor) * distance_to_current + progress_factor * ratio\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64923,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global progress by combining a ratio-based prioritization (distance-to-current / distance-to-destination) with a weighted sum approach, where the weight adjusts based on the remaining nodes to prioritize either local or global decisions. The ratio term ensures nodes closer to the destination are favored, while the weighted sum dynamically adjusts this preference based on the number of remaining nodes.",
          "thought": "The new algorithm combines the weighted sum approach of No.2 with the ratio-based prioritization of No.1, dynamically adjusting the weight based on remaining nodes while incorporating a ratio term to balance local and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_weighted_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        weight = remaining_nodes / total_nodes\n        weighted_score = (weight * ratio) + distance_to_current\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.66946,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a weighted sum of the ratio of distance to the current node over distance to the destination (prioritizing nodes that balance local and global progress) and the actual distance to the current node (prioritizing closer nodes). It iterates through unvisited nodes, computes the weighted score, and selects the node with the lowest score. The ratio term ensures progress toward the destination, while the distance term favors nearby nodes.",
          "thought": "This new algorithm combines the strengths of the two existing algorithms by prioritizing nodes that minimize a weighted sum of the ratio of distance to current node over distance to destination and the actual distance to the current node, ensuring a balance between local proximity and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_weighted_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        weighted_score = ratio + distance_to_current\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by heavily favoring the shortest immediate distance from the current node (negative weight) while slightly considering the distance to the destination (positive weight with a 0.3 factor). This creates a conservative path selection that minimizes long jumps while still guiding toward the destination. The score function balances proximity to the current node and destination, with the former dominating the decision.",
          "thought": "The new algorithm prioritizes selecting the next node by emphasizing immediate distance from the current node (weighted negatively) and lessening the impact of proximity to the destination (weighted positively with a 0.3 factor), creating a more conservative path selection that avoids long jumps while still guiding toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.3 * destination_distance  # Reduced emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node (prioritized heavily) with proximity to the destination (scaled by a dynamic factor that decreases as remaining nodes decrease), while applying a penalty to discourage revisiting nodes. The dynamic factor adjusts based on the number of unvisited nodes, favoring closer immediate steps early on but increasingly valuing destination proximity as the tour nears completion. The penalty mechanism ensures exploration by penalizing nodes that were considered but not chosen.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, favoring shorter immediate distances while adaptively balancing proximity to the destination. It also includes a penalty for revisiting nodes that were previously considered but not chosen, encouraging exploration of new paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_factor = 0.5 / (1 + 0.1 * remaining_nodes)  # Adjusts based on remaining nodes\n    penalty = {node: 0 for node in unvisited_nodes}\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + dynamic_factor * destination_distance - penalty[node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    # Apply penalty to the next_node to discourage revisiting\n    if next_node is not None:\n        penalty[next_node] += 0.1\n\n    return next_node",
          "objective": 6.77829,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and potential closeness to the destination, with a weight factor that decreases as the number of remaining nodes decreases, ensuring adaptability and efficiency in path selection. The critical design choices are the ratio-based selection prioritizing nodes with lower ratios (indicating better balance between current and future distances) and the adaptive weight factor, which reduces the influence of the destination distance as the problem progresses. The code iterates through unvisited nodes, computes a weighted ratio, and selects the node with the minimum ratio.",
          "thought": "The new algorithm combines the ratio-based selection of No.2 with the adaptive weighting of No.1, prioritizing nodes that balance proximity to the current node and potential closeness to the destination, adjusted by a weight factor that decreases with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_value = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / (distance_to_destination ** weight_factor)\n\n        if ratio < min_value:\n            min_value = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.80547,
          "other_inf": null
     }
]