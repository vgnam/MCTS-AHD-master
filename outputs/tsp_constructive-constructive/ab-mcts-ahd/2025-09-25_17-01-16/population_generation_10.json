[
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the ratio of the distance from the current node to the node itself, divided by the estimated distance from that node to the destination. This ensures the algorithm favors nodes closer to the current position relative to their progress toward the destination, balancing local proximity with global progress. The code iterates through unvisited nodes, computes the ratio, and selects the node with the smallest ratio, handling division-by-zero cases by assigning infinite ratio.",
          "thought": "The new algorithm modifies the selection criteria by prioritizing nodes that minimize the ratio of the distance to the current node to the estimated distance to the destination, favoring nodes closer to the current node relative to their progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')  # Avoid division by zero\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ignoring the destination's proximity. The function iterates through unvisited nodes, comparing their distances from the current node, and always chooses the nearest one, regardless of its relation to the destination. The code lacks any consideration of the destination, focusing solely on minimizing immediate travel distance.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the distance from the current node and the estimated straight-line distance to the destination, balancing short-term proximity with long-term progress. It selects the node with the smallest product, ensuring efficiency by considering both immediate and future travel costs. The `distance_matrix` and `unvisited_nodes` are critical inputs, while `current_node` and `destination_node` guide the selection toward optimal paths.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the current distance and the estimated straight-line distance to the destination, balancing immediate proximity with long-term progress, and selects the node with the smallest product of these distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_product = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        product = distance_to_current * estimated_distance_to_destination\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term optimization by adjusting the weight of the estimated distance to the destination based on the remaining unvisited nodes. It prioritizes minimizing the immediate distance to the next node while gradually increasing the influence of the estimated distance to the destination as more nodes are visited, ensuring adaptability to the problem's progress. The weight factor (`remaining_nodes / total_nodes`) dynamically adjusts the priority of the destination, starting with a higher focus on immediate steps and shifting toward long-term optimization as the tour progresses.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting factor that adjusts the influence of the estimated distance to the destination based on the proportion of unvisited nodes remaining, ensuring a balance between immediate and long-term optimization while dynamically adapting to the problem's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 to include the current node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weighting factor: prioritize destination as more nodes are visited\n        weight = remaining_nodes / total_nodes\n        total_distance = distance_to_current + (weight * estimated_distance_to_destination)\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.98707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that minimize the sum of the distance from the current node and the estimated straight-line distance to the destination, ensuring a balance between immediate proximity and long-term progress toward the destination. The function iterates through unvisited nodes, calculates this combined distance for each, and selects the node with the smallest total distance. The `distance_matrix` provides the actual distances between nodes, while the `destination_node` guides the long-term direction.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance to the current node and the estimated straight-line distance to the destination, balancing immediate proximity and long-term progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_current + estimated_distance_to_destination\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and the node's centrality in the unvisited set, prioritizing nodes that minimize the sum of their distance to the current node and their average distance to all other unvisited nodes. This ensures a trade-off between proximity and long-term efficiency, with the distance to the current node given higher priority than the average distance to unvisited nodes. The code efficiently computes this by iterating through unvisited nodes and comparing scores based on the given formula.",
          "thought": "\nThe new algorithm selects the next node by prioritizing the one that minimizes the sum of the distance from the current node and the average distance to all unvisited nodes, balancing immediate proximity with potential long-term efficiency by considering the node's centrality in the remaining path.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n        total_score = distance_to_current + avg_distance_to_unvisited\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 8.40257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and long-term efficiency (inverse of distance to destination), prioritizing nodes that minimize the sum of these two factors. It gives higher priority to nodes closer to the current node and slightly favors nodes that are farther from the destination (due to the squared inverse term), ensuring a trade-off between short-term and long-term path optimization. The code iterates through unvisited nodes, calculates the weighted sum, and chooses the node with the minimal value.",
          "thought": "The new algorithm combines the immediate proximity focus of No.1 with the destination-aware heuristic of No.2, selecting the next node by minimizing the sum of the distance from the current node and the squared inverse of the distance to the destination, balancing short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            inverse_distance = float('inf')\n        else:\n            inverse_distance = 1 / distance_to_destination\n        total_distance = distance_to_current + inverse_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 9.88354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (high priority), progress toward the destination (moderate priority), and potential to reduce future costs (low priority) via a weighted scoring system. The `distance_to_current` is directly added, `distance_to_destination` is weighted by 0.5, and the `hub_score` (sum of distances to all other unvisited nodes) is weighted by 0.3. The node with the lowest total score is chosen, favoring locality while considering long-term efficiency.",
          "thought": "The new algorithm prioritizes nodes that balance immediate proximity to the current node with long-term progress toward the destination, while also considering the potential to reduce future travel costs by favoring nodes that are closer to many unvisited nodes, aiming to minimize the total tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        hub_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        total_score = distance_to_current + 0.5 * distance_to_destination + 0.3 * hub_score\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 14.0222,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adaptively selects the next node to visit by balancing immediate distance to the current node and estimated distance to the destination, with a dynamic weight that prioritizes proximity when many nodes remain unvisited and long-term progress as the number of unvisited nodes decreases. The weight is calculated as `remaining_nodes / (remaining_nodes + 1)`, giving higher priority to the estimated distance to the destination as the tour progresses. The total distance is computed as a weighted sum, and the node with the minimum total distance is chosen.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances immediate distance to the current node and estimated distance to the destination, where the weight is adjusted based on the remaining number of unvisited nodes to prioritize either proximity or long-term progress adaptively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 0:\n            weight = remaining_nodes / (remaining_nodes + 1)\n        else:\n            weight = 1.0\n\n        total_distance = (1 - weight) * distance_to_current + weight * estimated_distance_to_destination\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 14.21124,
          "other_inf": null
     }
]