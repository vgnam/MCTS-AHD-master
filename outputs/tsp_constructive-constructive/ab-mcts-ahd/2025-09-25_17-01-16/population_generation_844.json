[
     {
          "algorithm": "The algorithm prioritizes immediate closeness (highest weight) by minimizing the current distance, moderately considers destination proximity (0.4 weight), and balances global optimization with an average unvisited distance term (0.2 weight). The code iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score, effectively balancing local and global optimization.",
          "thought": "The new algorithm combines immediate closeness (negative current_distance) with a moderate emphasis on destination proximity (0.4 * destination_distance) and an additional term (0.2 * average_unvisited_distance) to balance local and global optimization while accounting for remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        average_unvisited_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        score = -current_distance + 0.4 * destination_distance + 0.2 * average_unvisited_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.39138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing both proximity to the current node (with heavy emphasis) and proximity to the destination node (with moderate emphasis). It calculates a score for each unvisited node as `-current_distance + 0.55 * destination_distance`, balancing nearness to the current position (weighted heavily) with nearness to the destination (weighted moderately). The node with the highest score is chosen as the next step.",
          "thought": "The new algorithm combines the balanced approach of No.1 (0.5 weight for destination proximity) with the aggressive emphasis on destination proximity from No.2 (0.6 weight), using a 0.55 weight for destination proximity to achieve a more refined balance, while still penalizing current distance heavily to favor nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.55 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate closeness (negative `current_distance`) while heavily emphasizing destination proximity (`0.6 * destination_distance`), balancing local and global optimization. The `current_distance` is penalized (negative weight) to favor nearby nodes, while the `destination_distance` is weighted strongly (0.6) to guide the path toward the destination, creating an aggressive, destination-aware heuristic.",
          "thought": "The new algorithm prioritizes immediate closeness (negative `current_distance`) with a stronger emphasis on destination proximity (`0.6 * destination_distance`), balancing local and global optimization by favoring nodes that are both nearby and closer to the destination, creating a more aggressive destination-aware heuristic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.6 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized by minimizing `current_distance`) and destination awareness (prioritized by maximizing `destination_distance`), with dynamic weights adjusting based on remaining nodes. A penalty discourages revisiting nearby nodes when many nodes remain unvisited. The score is computed as `-current_distance + weight * destination_distance`, with the weight set to 0.5 for most nodes but reduced to 0.2 when only one node remains. A small penalty (`+0.1 * current_distance`) is added for nodes very close to the current node when more than two nodes are left.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate proximity and destination awareness based on the remaining unvisited nodes, using a normalized score that considers both local and global factors, while also incorporating a penalty for revisiting nodes that were recently considered.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes\n        weight = 0.5 if remaining_nodes > 1 else 0.2\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for nodes recently considered (simulated by favoring nodes further away)\n        if remaining_nodes > 2:\n            score += 0.1 * distance_matrix[current_node][node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance reduction (prioritized with a fixed weight of -1.5) and dynamic destination proximity (scaled by a weight factor that increases as more nodes remain unvisited, favoring closer nodes early). The score is computed as `-1.5 * current_distance + weight_factor * destination_distance`, where `weight_factor = total_nodes / remaining_nodes`, ensuring a trade-off between local and global progress.",
          "thought": "The new algorithm prioritizes immediate distance reduction with a fixed weight and dynamically adjusts the destination proximity's influence based on the remaining nodes, favoring closer nodes early and balancing global progress later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weight_factor = (total_nodes / remaining_nodes) if remaining_nodes > 0 else 1.0\n        score = -1.5 * current_distance + weight_factor * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and closeness to the destination, with a dynamic weight that prioritizes destination proximity as the number of unvisited nodes decreases. It penalizes nodes too close to the current node to avoid backtracking, with the score calculated as a weighted combination of these factors. The dynamic weight (`weight`) increases as the number of remaining nodes decreases, while the penalty (`penalty`) discourages selecting nodes that are too near the current node. The final score is a trade-off between minimizing distance to the next node and maximizing progress toward the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the progress toward the destination (higher weight for destination proximity as the number of unvisited nodes decreases) and penalizing nodes that are too close to the current node to avoid backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and penalize very close nodes\n        weight = 0.5 + (1.0 - 0.5) * (1.0 - remaining_nodes / len(unvisited_nodes))\n        penalty = 1.0 if current_distance < 0.1 * distance_matrix[current_node][destination_node] else 0.0\n        score = -current_distance * (1.0 - penalty) + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53553,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the immediate distance from the current node (prioritized via `-current_distance`) with the node's proximity to the final destination (prioritized via `weight * destination_distance`), where the weight is dynamically adjusted using a sigmoid function to favor closer nodes as the algorithm nears the destination. The sigmoid parameter (`0.1`) controls the transition sharpness, and the score maximization ensures optimal trade-offs between local and global optimization.",
          "thought": "The new algorithm combines the local optimization of minimizing current distance with a dynamic weight for destination proximity, adjusted by a sigmoid function based on the current distance to the destination, to balance exploration and exploitation.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    current_distance_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on current proximity to destination (sigmoid function)\n        weight = 1 / (1 + math.exp(-0.1 * (current_distance_to_dest - destination_distance)))\n        score = -current_distance + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54483,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically balancing local and global distances using a weighted combination, where the weight (alpha) adjusts based on the number of remaining nodes. It prioritizes minimizing the immediate distance to the next node while also considering the global path to the destination, with a penalty to avoid revisiting nodes. The scoring mechanism combines these factors to choose the most promising candidate node.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic alpha parameter that adjusts based on the number of remaining nodes and the current path's progress, using a weighted combination of local and global distances with a novel scoring mechanism that includes a penalty for revisiting nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    alpha = 0.5 * (1 + (remaining_nodes / (remaining_nodes + 1)))  # Dynamic alpha\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        penalty = 1.0 if node in unvisited_nodes and node != destination_node else 0.0  # Penalty for revisiting\n        total_score = distance_to_current - alpha * distance_to_destination + penalty * distance_to_current\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 6.54699,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (lower priority) and distance to the destination (higher priority, weighted at 0.7), favoring nodes that are both close to the current position and far from the destination to encourage exploration while still minimizing total path length. The `score` calculation prioritizes `destination_distance` over `current_distance`, and the loop iterates through unvisited nodes to find the one with the highest score.",
          "thought": "The new algorithm prioritizes selecting the next node based on a balance between minimizing immediate distance and maximizing the distance to the destination, with the latter having a stronger influence (positive weight of 0.7) to encourage exploration while still favoring shorter paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.7 * destination_distance  # Stronger emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     }
]