[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local proximity (distance from the current node) and global progress (estimated distance to the destination) using a dynamic weighting factor. The factor, derived from a sigmoid function, prioritizes local proximity early in the tour and shifts to global progress as fewer nodes remain unvisited. The score for each candidate node combines these priorities, with the node minimizing the score chosen as the next step. The ratio of local to global distances and the dynamic weighting factor are key design elements.",
          "thought": "The new algorithm modifies the provided ratio-based selection by incorporating a dynamic weighting factor that adjusts the priority of local proximity versus global progress, using a sigmoid function to smoothly transition between these priorities based on the remaining number of unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        # Dynamic weighting factor based on remaining unvisited nodes\n        progress_factor = 1 / (1 + math.exp(-(total_unvisited - len(unvisited_nodes) + 1)))\n        score = (1 - progress_factor) * distance_to_current + progress_factor * ratio\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64923,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a weighted sum of the ratio of distance to the current node over distance to the destination (prioritizing nodes that balance local and global progress) and the actual distance to the current node (prioritizing closer nodes). It iterates through unvisited nodes, computes the weighted score, and selects the node with the lowest score. The ratio term ensures progress toward the destination, while the distance term favors nearby nodes.",
          "thought": "This new algorithm combines the strengths of the two existing algorithms by prioritizing nodes that minimize a weighted sum of the ratio of distance to current node over distance to destination and the actual distance to the current node, ensuring a balance between local proximity and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_weighted_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        weighted_score = ratio + distance_to_current\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and potential closeness to the destination, with a weight factor that decreases as the number of remaining nodes decreases, ensuring adaptability and efficiency in path selection. The critical design choices are the ratio-based selection prioritizing nodes with lower ratios (indicating better balance between current and future distances) and the adaptive weight factor, which reduces the influence of the destination distance as the problem progresses. The code iterates through unvisited nodes, computes a weighted ratio, and selects the node with the minimum ratio.",
          "thought": "The new algorithm combines the ratio-based selection of No.2 with the adaptive weighting of No.1, prioritizing nodes that balance proximity to the current node and potential closeness to the destination, adjusted by a weight factor that decreases with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_value = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / (distance_to_destination ** weight_factor)\n\n        if ratio < min_value:\n            min_value = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.80547,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the ratio of the distance from the current node to the node itself, divided by the estimated distance from that node to the destination. This ensures the algorithm favors nodes closer to the current position relative to their progress toward the destination, balancing local proximity with global progress. The code iterates through unvisited nodes, computes the ratio, and selects the node with the smallest ratio, handling division-by-zero cases by assigning infinite ratio.",
          "thought": "The new algorithm modifies the selection criteria by prioritizing nodes that minimize the ratio of the distance to the current node to the estimated distance to the destination, favoring nodes closer to the current node relative to their progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')  # Avoid division by zero\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ignoring the destination's proximity. The function iterates through unvisited nodes, comparing their distances from the current node, and always chooses the nearest one, regardless of its relation to the destination. The code lacks any consideration of the destination, focusing solely on minimizing immediate travel distance.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in the TSP path by balancing proximity to the current node and potential closeness to the destination, adjusted by a weight factor that decreases exponentially with the number of remaining unvisited nodes. It prioritizes nearby nodes while adaptively considering long-term efficiency, using an inverse distance term weighted by the current progress through the tour. The weight factor ensures closer nodes are favored early, while the inverse distance term encourages global path optimization as the tour progresses.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, balancing proximity and long-term efficiency with a novel exponential decay term to prioritize closer nodes while considering the global path structure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            inverse_distance = float('inf')\n        else:\n            inverse_distance = 1 / (distance_to_destination ** weight_factor)\n        total_distance = distance_to_current + inverse_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.02998,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing three key factors: proximity to the current node (50% weight), progress toward the destination (30% weight), and node centrality (20% weight). It dynamically adjusts weights based on remaining nodes and penalizes outliers in distance distribution to avoid suboptimal choices. The weights are prioritized to favor immediate progress while considering long-term centrality, with outlier penalties ensuring robustness.",
          "thought": "The new algorithm combines proximity to current node (weight 0.5), progress toward destination (weight 0.3), and centrality (weight 0.2), with dynamic weight adjustment based on remaining nodes and outlier penalty to balance immediate and long-term planning while avoiding outliers.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n\n        # Dynamic weight adjustment based on remaining nodes\n        remaining_nodes = len(unvisited_nodes)\n        weight_adj = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n        # Penalize outliers in distance distribution\n        distances_to_current = [distance_matrix[current_node][other] for other in unvisited_nodes]\n        mean_dist = sum(distances_to_current) / len(distances_to_current)\n        std_dev = (sum((d - mean_dist) ** 2 for d in distances_to_current) / len(distances_to_current)) ** 0.5\n        outlier_penalty = 0.0 if std_dev == 0 else (distance_to_current - mean_dist) / std_dev\n\n        total_score = (0.5 * distance_to_current +\n                       0.3 * distance_to_destination +\n                       0.2 * centrality_score) * weight_adj + 0.1 * outlier_penalty\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 7.40107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate proximity to the current node while also considering its distance to the destination, balancing local and global path efficiency. The `score` is computed as a weighted sum of the distance from the current node (`distance_current`) and the distance to the destination (`distance_destination`), with the latter given half the weight (`0.5`). The node with the lowest `score` is chosen as the next step, approximating a compromise between short-term and long-term path optimization.",
          "thought": "The new algorithm prioritizes nodes that are closest to the current node but also considers the potential impact on the overall path length by balancing immediate proximity with the distance to the destination, aiming to approximate a more efficient global path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_current = distance_matrix[current_node][node]\n        distance_destination = distance_matrix[node][destination_node]\n        score = distance_current + 0.5 * distance_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the distance from the current node and the estimated straight-line distance to the destination, balancing short-term proximity with long-term progress. It selects the node with the smallest product, ensuring efficiency by considering both immediate and future travel costs. The `distance_matrix` and `unvisited_nodes` are critical inputs, while `current_node` and `destination_node` guide the selection toward optimal paths.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the current distance and the estimated straight-line distance to the destination, balancing immediate proximity with long-term progress, and selects the node with the smallest product of these distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_product = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        product = distance_to_current * estimated_distance_to_destination\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     }
]