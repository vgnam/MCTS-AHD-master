[
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the ratio of the distance from the current node to the node itself, divided by the estimated distance from that node to the destination. This ensures the algorithm favors nodes closer to the current position relative to their progress toward the destination, balancing local proximity with global progress. The code iterates through unvisited nodes, computes the ratio, and selects the node with the smallest ratio, handling division-by-zero cases by assigning infinite ratio.",
          "thought": "The new algorithm modifies the selection criteria by prioritizing nodes that minimize the ratio of the distance to the current node to the estimated distance to the destination, favoring nodes closer to the current node relative to their progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')  # Avoid division by zero\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ignoring the destination's proximity. The function iterates through unvisited nodes, comparing their distances from the current node, and always chooses the nearest one, regardless of its relation to the destination. The code lacks any consideration of the destination, focusing solely on minimizing immediate travel distance.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the distance from the current node and the estimated straight-line distance to the destination, balancing short-term proximity with long-term progress. It selects the node with the smallest product, ensuring efficiency by considering both immediate and future travel costs. The `distance_matrix` and `unvisited_nodes` are critical inputs, while `current_node` and `destination_node` guide the selection toward optimal paths.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of the current distance and the estimated straight-line distance to the destination, balancing immediate proximity with long-term progress, and selects the node with the smallest product of these distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_product = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        product = distance_to_current * estimated_distance_to_destination\n\n        if product < min_product:\n            min_product = product\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 0.6), balancing it with minimizing distance to the destination (weight 0.3), and slightly considering centrality (weight 0.1) to ensure the path remains efficient overall. The code iterates through unvisited nodes, computes a weighted score, and chooses the node with the lowest score, effectively blending greedy and long-term planning.",
          "thought": "The new algorithm prioritizes proximity to the current node (weight 0.6), minimizes distance to the destination (weight 0.3), and considers the node's centrality (weight 0.1) by averaging distances to all unvisited nodes, favoring nodes that balance immediate and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        centrality_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / len(unvisited_nodes)\n        total_score = 0.6 * distance_to_current + 0.3 * distance_to_destination + 0.1 * centrality_score\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 7.61495,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term optimization by adjusting the weight of the estimated distance to the destination based on the remaining unvisited nodes. It prioritizes minimizing the immediate distance to the next node while gradually increasing the influence of the estimated distance to the destination as more nodes are visited, ensuring adaptability to the problem's progress. The weight factor (`remaining_nodes / total_nodes`) dynamically adjusts the priority of the destination, starting with a higher focus on immediate steps and shifting toward long-term optimization as the tour progresses.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting factor that adjusts the influence of the estimated distance to the destination based on the proportion of unvisited nodes remaining, ensuring a balance between immediate and long-term optimization while dynamically adapting to the problem's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 to include the current node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weighting factor: prioritize destination as more nodes are visited\n        weight = remaining_nodes / total_nodes\n        total_distance = distance_to_current + (weight * estimated_distance_to_destination)\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.98707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that minimize the sum of the distance from the current node and the estimated straight-line distance to the destination, ensuring a balance between immediate proximity and long-term progress toward the destination. The function iterates through unvisited nodes, calculates this combined distance for each, and selects the node with the smallest total distance. The `distance_matrix` provides the actual distances between nodes, while the `destination_node` guides the long-term direction.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance to the current node and the estimated straight-line distance to the destination, balancing immediate proximity and long-term progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        total_distance = distance_to_current + estimated_distance_to_destination\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and the node's centrality in the unvisited set, prioritizing nodes that minimize the sum of their distance to the current node and their average distance to all other unvisited nodes. This ensures a trade-off between proximity and long-term efficiency, with the distance to the current node given higher priority than the average distance to unvisited nodes. The code efficiently computes this by iterating through unvisited nodes and comparing scores based on the given formula.",
          "thought": "\nThe new algorithm selects the next node by prioritizing the one that minimizes the sum of the distance from the current node and the average distance to all unvisited nodes, balancing immediate proximity with potential long-term efficiency by considering the node's centrality in the remaining path.\n",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n        total_score = distance_to_current + avg_distance_to_unvisited\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 8.40257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and long-term efficiency (inverse of distance to destination), prioritizing nodes that minimize the sum of these two factors. It gives higher priority to nodes closer to the current node and slightly favors nodes that are farther from the destination (due to the squared inverse term), ensuring a trade-off between short-term and long-term path optimization. The code iterates through unvisited nodes, calculates the weighted sum, and chooses the node with the minimal value.",
          "thought": "The new algorithm combines the immediate proximity focus of No.1 with the destination-aware heuristic of No.2, selecting the next node by minimizing the sum of the distance from the current node and the squared inverse of the distance to the destination, balancing short-term and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            inverse_distance = float('inf')\n        else:\n            inverse_distance = 1 / distance_to_destination\n        total_distance = distance_to_current + inverse_distance\n\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 9.88354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (40% weight), progress toward the destination (30% weight), and hub potential (20% weight), while dynamically adjusting weights based on remaining nodes and penalizing outliers in distance distribution (10% penalty). The scoring system prioritizes immediate proximity and destination progress, with hub potential as a secondary factor, and outliers are discouraged.",
          "thought": "The new algorithm modifies the scoring system by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where immediate proximity is weighted by 0.4, progress toward the destination by 0.3, and hub potential by 0.2, while also penalizing nodes that are outliers in the distance distribution to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        hub_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n\n        # Dynamic weight adjustment based on remaining nodes\n        remaining_nodes = len(unvisited_nodes)\n        weight_adj = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n        # Penalize outliers in distance distribution\n        distances_to_current = [distance_matrix[current_node][other] for other in unvisited_nodes]\n        mean_dist = sum(distances_to_current) / len(distances_to_current)\n        std_dev = (sum((d - mean_dist) ** 2 for d in distances_to_current) / len(distances_to_current)) ** 0.5\n        outlier_penalty = 0.0 if std_dev == 0 else (distance_to_current - mean_dist) / std_dev\n\n        total_score = (0.4 * distance_to_current +\n                       0.3 * distance_to_destination +\n                       0.2 * hub_score) * weight_adj + 0.1 * outlier_penalty\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 10.27743,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (70% weight), followed by proximity to the destination (20% weight), and finally considering the node's centrality as a hub (10% weight). It evaluates all unvisited nodes using a weighted score and chooses the one with the lowest total score, balancing immediate, short-term, and long-term efficiency. The distance matrix provides the necessary connectivity data for these calculations.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.7), near-term progress toward the destination (weight 0.2), and long-term efficiency (weight 0.1), favoring nodes that are close to the current position while considering both short and medium-term goals.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        hub_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        total_score = 0.7 * distance_to_current + 0.2 * distance_to_destination + 0.1 * hub_score\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 10.81541,
          "other_inf": null
     }
]