[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and closeness to the destination, with a dynamic weight that prioritizes destination proximity as the number of unvisited nodes decreases. It penalizes nodes too close to the current node to avoid backtracking, with the score calculated as a weighted combination of these factors. The dynamic weight (`weight`) increases as the number of remaining nodes decreases, while the penalty (`penalty`) discourages selecting nodes that are too near the current node. The final score is a trade-off between minimizing distance to the next node and maximizing progress toward the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the progress toward the destination (higher weight for destination proximity as the number of unvisited nodes decreases) and penalizing nodes that are too close to the current node to avoid backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and penalize very close nodes\n        weight = 0.5 + (1.0 - 0.5) * (1.0 - remaining_nodes / len(unvisited_nodes))\n        penalty = 1.0 if current_distance < 0.1 * distance_matrix[current_node][destination_node] else 0.0\n        score = -current_distance * (1.0 - penalty) + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53553,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing local proximity (distance from the current node) and global progress (estimated distance to the destination) using a dynamic weighting factor. The factor, derived from a sigmoid function, prioritizes local proximity early in the tour and shifts to global progress as fewer nodes remain unvisited. The score for each candidate node combines these priorities, with the node minimizing the score chosen as the next step. The ratio of local to global distances and the dynamic weighting factor are key design elements.",
          "thought": "The new algorithm modifies the provided ratio-based selection by incorporating a dynamic weighting factor that adjusts the priority of local proximity versus global progress, using a sigmoid function to smoothly transition between these priorities based on the remaining number of unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        # Dynamic weighting factor based on remaining unvisited nodes\n        progress_factor = 1 / (1 + math.exp(-(total_unvisited - len(unvisited_nodes) + 1)))\n        score = (1 - progress_factor) * distance_to_current + progress_factor * ratio\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64923,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a weighted sum of the ratio of distance to the current node over distance to the destination (prioritizing nodes that balance local and global progress) and the actual distance to the current node (prioritizing closer nodes). It iterates through unvisited nodes, computes the weighted score, and selects the node with the lowest score. The ratio term ensures progress toward the destination, while the distance term favors nearby nodes.",
          "thought": "This new algorithm combines the strengths of the two existing algorithms by prioritizing nodes that minimize a weighted sum of the ratio of distance to current node over distance to destination and the actual distance to the current node, ensuring a balance between local proximity and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_weighted_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        weighted_score = ratio + distance_to_current\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by heavily favoring the shortest immediate distance from the current node (negative weight) while slightly considering the distance to the destination (positive weight with a 0.3 factor). This creates a conservative path selection that minimizes long jumps while still guiding toward the destination. The score function balances proximity to the current node and destination, with the former dominating the decision.",
          "thought": "The new algorithm prioritizes selecting the next node by emphasizing immediate distance from the current node (weighted negatively) and lessening the impact of proximity to the destination (weighted positively with a 0.3 factor), creating a more conservative path selection that avoids long jumps while still guiding toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.3 * destination_distance  # Reduced emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and potential closeness to the destination, with a weight factor that decreases as the number of remaining nodes decreases, ensuring adaptability and efficiency in path selection. The critical design choices are the ratio-based selection prioritizing nodes with lower ratios (indicating better balance between current and future distances) and the adaptive weight factor, which reduces the influence of the destination distance as the problem progresses. The code iterates through unvisited nodes, computes a weighted ratio, and selects the node with the minimum ratio.",
          "thought": "The new algorithm combines the ratio-based selection of No.2 with the adaptive weighting of No.1, prioritizing nodes that balance proximity to the current node and potential closeness to the destination, adjusted by a weight factor that decreases with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_value = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_current / (distance_to_destination ** weight_factor)\n\n        if ratio < min_value:\n            min_value = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.80547,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance (prioritized with a negative weight) and destination proximity (weighted dynamically based on remaining nodes), with the destination's influence increasing as the fraction of unvisited nodes decreases. The score for each candidate node is computed as `-current_distance + weight_factor * destination_distance`, where `weight_factor` adjusts the destination's role in the selection. This ensures a trade-off between local optimization and global progress toward the destination.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, favoring nodes that balance immediate distance and destination proximity while accounting for the overall path progress. It uses a weighted sum of current distance (negatively weighted) and destination distance (positively weighted), adjusted by a factor proportional to the fraction of nodes remaining to visit.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 for the current node\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weight_factor = (remaining_nodes / total_nodes) ** 2  # Adjusts based on progress\n        score = -current_distance + weight_factor * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines a greedy nearest-neighbor approach with destination awareness by dynamically balancing immediate travel distance (prioritized via `-current_distance`) and progress toward the destination (prioritized via `weight * destination_distance`), where the weight adjusts inversely with remaining unvisited nodes. The score calculation ensures a trade-off between minimizing immediate travel and maximizing destination progress, with the destination's influence growing as the number of unvisited nodes decreases. The function iteratively evaluates all unvisited nodes, selecting the one with the highest computed score.",
          "thought": "This new algorithm combines the greedy nearest-neighbor approach with a destination-awareness mechanism, where the next node is selected based on a weighted balance between minimizing immediate travel distance and maximizing progress toward the destination, using a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / len(unvisited_nodes)  # Dynamic weighting factor\n        score = -current_distance + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85712,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the ratio of the distance from the current node to the node itself, divided by the estimated distance from that node to the destination. This ensures the algorithm favors nodes closer to the current position relative to their progress toward the destination, balancing local proximity with global progress. The code iterates through unvisited nodes, computes the ratio, and selects the node with the smallest ratio, handling division-by-zero cases by assigning infinite ratio.",
          "thought": "The new algorithm modifies the selection criteria by prioritizing nodes that minimize the ratio of the distance to the current node to the estimated distance to the destination, favoring nodes closer to the current node relative to their progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_ratio = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        estimated_distance_to_destination = distance_matrix[node][destination_node]\n        if estimated_distance_to_destination == 0:\n            ratio = float('inf')  # Avoid division by zero\n        else:\n            ratio = distance_to_current / estimated_distance_to_destination\n\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ignoring the destination's proximity. The function iterates through unvisited nodes, comparing their distances from the current node, and always chooses the nearest one, regardless of its relation to the destination. The code lacks any consideration of the destination, focusing solely on minimizing immediate travel distance.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     }
]