importance of distance to current node, distance to destination, and hub centrality based on the remaining unvisited nodes, while maintaining a strong revisit penalty to prevent cycles. It calculates a normalized score for each candidate node, incorporating both immediate and long-term considerations, and selects the node with the highest normalized utility.
}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    max_utility = -float('inf')

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        hub_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)

        # Dynamic weight adjustment based on remaining nodes
        weight_current = 1.0 + (len(unvisited_nodes) / len(distance_matrix))
        weight_dest = 1.0 + (1.0 / (len(unvisited_nodes) + 1))
        weight_hub = 0.5 * (len(unvisited_nodes) / len(distance_matrix))

        # Normalized scores
        norm_distance_current = distance_to_current / max(distance_matrix[current_node])
        norm_distance_dest = distance_to_destination / max(distance_matrix[node])
        norm_hub_score = hub_score / (len(unvisited_nodes) * max(distance_matrix[node]))

        # Calculate utility with adaptive weights
        utility = (weight_current * (1 - norm_distance_current) +
                   weight_dest * (1 - norm_distance_dest) +
                   weight_hub * norm_hub_score) - 1.5 * (1 if node in unvisited_nodes else 0)

        if utility > max_utility:
            max_utility = utility
            next_node = node

    return next_node
