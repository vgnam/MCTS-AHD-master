def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    total_unvisited = len(unvisited_nodes)
    if total_unvisited == 0:
        return destination_node

    # Calculate current node's centrality (average distance to all unvisited nodes)
    centrality = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / total_unvisited

    # Calculate remaining path length estimate
    remaining_path = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / total_unvisited

    # Dynamic weight based on centrality and remaining path
    weight = 0.4 + 0.3 * (centrality / (centrality + remaining_path + 1e-6))

    # Candidate selection with probabilistic consideration
    candidates = []
    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        estimated_distance_to_destination = distance_matrix[node][destination_node]
        weighted_distance = weight * distance_to_current + (1 - weight) * estimated_distance_to_destination
        candidates.append((node, weighted_distance))

    # Select top 3 candidates and choose one probabilistically
    candidates.sort(key=lambda x: x[1])
    top_candidates = candidates[:min(3, len(candidates))]
    selected = min(top_candidates, key=lambda x: x[1] + 0.1 * random.random())[0]

    return next_node
