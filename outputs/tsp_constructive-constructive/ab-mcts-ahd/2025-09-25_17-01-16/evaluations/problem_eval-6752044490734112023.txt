import math
    import random

    if not unvisited_nodes:
        return None

    remaining_nodes = len(unvisited_nodes)
    temperature = max(1.0, remaining_nodes / len(distance_matrix))  # Controls exploration-exploitation
    scores = []
    nodes = []

    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Dynamic weighting with temperature
        weight = 0.3 * temperature if remaining_nodes > 1 else 0.1
        base_score = -current_dist + weight * dest_dist

        # Novelty score based on node centrality
        avg_dist = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes
        novelty = 1.0 / (1.0 + avg_dist)  # Higher for central nodes

        # Penalty for revisiting dense regions
        local_density = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 0.5 * avg_dist)
        penalty = 0.2 * local_density if remaining_nodes > 2 else 0

        final_score = base_score + 0.3 * novelty - penalty
        scores.append(final_score)
        nodes.append(node)

    # Probabilistic selection with softmax
    exp_scores = [math.exp(s / temperature) for s in scores]
    probs = [e / sum(exp_scores) for e in exp_scores]
    next_node = random.choices(nodes, weights=probs, k=1)[0]

    return next_node
