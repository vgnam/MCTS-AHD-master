def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Stage 1: Filter nodes within a dynamic proximity threshold
    proximity_threshold = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)
    candidate_nodes = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= proximity_threshold]

    if not candidate_nodes:
        candidate_nodes = unvisited_nodes

    # Stage 2: Calculate dynamic centrality based on remaining path length
    remaining_length = len(unvisited_nodes)
    centrality_weight = min(0.5, 0.2 + (1.0 - remaining_length / (remaining_length + 1)) * 0.3)

    # Stage 3: Evaluate path potential for each candidate
    next_node = None
    best_score = float('inf')

    for node in candidate_nodes:
        # Proximity to current node (40%)
        dist_current = distance_matrix[current_node][node]

        # Centrality measure (dynamic weight)
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)

        # Path potential: estimate future path efficiency
        path_potential = sum(distance_matrix[n][m] for n in unvisited_nodes if n != node
                            for m in unvisited_nodes if m != node and m != n) / (len(unvisited_nodes) ** 2)

        # Combined score
        total_score = (0.4 * dist_current) + (centrality_weight * centrality) + (0.3 * path_potential)

        if total_score < best_score:
            best_score = total_score
            next_node = node

    return next_node
