def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    min_weighted_distance = float('inf')
    total_unvisited = len(unvisited_nodes)

    # Dynamic weight using quadratic decay
    decay_factor = (total_unvisited / (total_unvisited + 1)) ** 2
    weight = 0.7 * decay_factor + 0.3  # Starts at 0.7, decays to 0.3

    # Penalty for revisiting nearby nodes
    penalty_factor = 1.0
    if len(unvisited_nodes) < len(distance_matrix) // 2:
        nearby_nodes = [node for node in unvisited_nodes if distance_matrix[current_node][node] < 1.5 * min(distance_matrix[current_node])]
        penalty_factor = 1.0 + 0.2 * (len(nearby_nodes) / total_unvisited)

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        estimated_distance_to_destination = distance_matrix[node][destination_node]
        weighted_distance = weight * distance_to_current + (1 - weight) * estimated_distance_to_destination
        weighted_distance *= penalty_factor

        if weighted_distance < min_weighted_distance:
            min_weighted_distance = weighted_distance
            next_node = node

    return next_node
