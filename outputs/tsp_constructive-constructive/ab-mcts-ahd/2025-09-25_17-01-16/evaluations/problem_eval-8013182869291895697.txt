def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)

    # Calculate centrality of each node as average distance to all other nodes
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][n] for n in unvisited_nodes) / (remaining_nodes - 1)

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]

        # Dynamic weight based on remaining nodes and centrality
        weight_dest = 0.6 if remaining_nodes > 1 else 0.3
        weight_central = 0.3 if remaining_nodes > 1 else 0.4

        # Score combines proximity, destination awareness, and centrality
        score = -current_distance + weight_dest * destination_distance - weight_central * centrality[node]

        # Penalty for nodes very close to current node when many nodes remain
        if remaining_nodes > 2 and current_distance < 0.2 * sum(distance_matrix[current_node][n] for n in unvisited_nodes) / remaining_nodes:
            score -= 0.2 * current_distance

        # Bonus for nodes with high centrality when few nodes remain
        if remaining_nodes <= 3 and centrality[node] > 1.5 * sum(centrality.values()) / remaining_nodes:
            score += 0.1 * destination_distance

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
