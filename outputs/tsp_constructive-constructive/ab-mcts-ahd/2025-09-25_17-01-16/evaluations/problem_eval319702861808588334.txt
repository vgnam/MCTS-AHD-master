importance" factor, calculated as the average of all distances from the candidate node to unvisited nodes, to balance exploration and exploitation. The weight for local vs. global distance is adjusted based on remaining nodes, while the importance factor is weighted by the inverse of the remaining nodes to emphasize exploration early.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    min_weighted_distance = float('inf')
    total_unvisited = len(unvisited_nodes)
    weight = 0.5 * (1 + (total_unvisited / (total_unvisited + 1)))  # Dynamic weight for local/global balance

    for node in unvisited_nodes:
        # Local distance: distance from current node to candidate
        distance_to_current = distance_matrix[current_node][node]

        # Global distance: estimated distance to destination
        estimated_distance_to_destination = distance_matrix[node][destination_node]

        # Novel importance factor: average distance to all unvisited nodes
        importance_factor = sum(distance_matrix[node][n] for n in unvisited_nodes) / total_unvisited

        # Weighted combination: local, global, and importance
        weighted_distance = (
            weight * distance_to_current +
            (1 - weight) * estimated_distance_to_destination +
            (1 / (total_unvisited + 1)) * importance_factor  # Inverse weight for importance
        )

        if weighted_distance < min_weighted_distance:
            min_weighted_distance = weighted_distance
            next_node = node

    return next_node
