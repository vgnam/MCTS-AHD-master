[
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate closeness (negative `current_distance`) while heavily emphasizing destination proximity (`0.6 * destination_distance`), balancing local and global optimization. The `current_distance` is penalized (negative weight) to favor nearby nodes, while the `destination_distance` is weighted strongly (0.6) to guide the path toward the destination, creating an aggressive, destination-aware heuristic.",
          "thought": "The new algorithm prioritizes immediate closeness (negative `current_distance`) with a stronger emphasis on destination proximity (`0.6 * destination_distance`), balancing local and global optimization by favoring nodes that are both nearby and closer to the destination, creating a more aggressive destination-aware heuristic.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.6 * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48528,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized by minimizing `current_distance`) and destination awareness (prioritized by maximizing `destination_distance`), with dynamic weights adjusting based on remaining nodes. A penalty discourages revisiting nearby nodes when many nodes remain unvisited. The score is computed as `-current_distance + weight * destination_distance`, with the weight set to 0.5 for most nodes but reduced to 0.2 when only one node remains. A small penalty (`+0.1 * current_distance`) is added for nodes very close to the current node when more than two nodes are left.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate proximity and destination awareness based on the remaining unvisited nodes, using a normalized score that considers both local and global factors, while also incorporating a penalty for revisiting nodes that were recently considered.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting based on remaining nodes\n        weight = 0.5 if remaining_nodes > 1 else 0.2\n        score = -current_distance + weight * destination_distance\n\n        # Penalty for nodes recently considered (simulated by favoring nodes further away)\n        if remaining_nodes > 2:\n            score += 0.1 * distance_matrix[current_node][node]\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate distance from the current node (higher priority, weighted negatively) and proximity to the destination (lower priority, weighted positively with a 0.5 factor). The score calculation (`-current_distance + 0.5 * destination_distance`) ensures the path progresses toward the destination while minimizing short-term travel costs. The loop iterates over unvisited nodes, updating the best node based on the highest computed score.",
          "thought": "The new algorithm prioritizes nodes that are closer to the destination while still considering the immediate distance from the current node, balancing between minimizing the current step's distance and advancing towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.5 * destination_distance  # Balance between current and destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance reduction (prioritized with a fixed weight of -1.5) and dynamic destination proximity (scaled by a weight factor that increases as more nodes remain unvisited, favoring closer nodes early). The score is computed as `-1.5 * current_distance + weight_factor * destination_distance`, where `weight_factor = total_nodes / remaining_nodes`, ensuring a trade-off between local and global progress.",
          "thought": "The new algorithm prioritizes immediate distance reduction with a fixed weight and dynamically adjusts the destination proximity's influence based on the remaining nodes, favoring closer nodes early and balancing global progress later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weight_factor = (total_nodes / remaining_nodes) if remaining_nodes > 0 else 1.0\n        score = -1.5 * current_distance + weight_factor * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and closeness to the destination, with a dynamic weight that prioritizes destination proximity as the number of unvisited nodes decreases. It penalizes nodes too close to the current node to avoid backtracking, with the score calculated as a weighted combination of these factors. The dynamic weight (`weight`) increases as the number of remaining nodes decreases, while the penalty (`penalty`) discourages selecting nodes that are too near the current node. The final score is a trade-off between minimizing distance to the next node and maximizing progress toward the destination.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that adjusts based on the progress toward the destination (higher weight for destination proximity as the number of unvisited nodes decreases) and penalizing nodes that are too close to the current node to avoid backtracking.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes and penalize very close nodes\n        weight = 0.5 + (1.0 - 0.5) * (1.0 - remaining_nodes / len(unvisited_nodes))\n        penalty = 1.0 if current_distance < 0.1 * distance_matrix[current_node][destination_node] else 0.0\n        score = -current_distance * (1.0 - penalty) + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53553,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (lower priority) and distance to the destination (higher priority, weighted at 0.7), favoring nodes that are both close to the current position and far from the destination to encourage exploration while still minimizing total path length. The `score` calculation prioritizes `destination_distance` over `current_distance`, and the loop iterates through unvisited nodes to find the one with the highest score.",
          "thought": "The new algorithm prioritizes selecting the next node based on a balance between minimizing immediate distance and maximizing the distance to the destination, with the latter having a stronger influence (positive weight of 0.7) to encourage exploration while still favoring shorter paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + 0.7 * destination_distance  # Stronger emphasis on destination proximity\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm balances immediate and future progress by dynamically adjusting a weight factor that prioritizes proximity to the current node while also considering distance to the destination. The weight factor decreases as the number of remaining unvisited nodes decreases, shifting focus from global optimization (destination proximity) to local optimization (current node proximity). The score function combines these factors, favoring nodes that are close to the current node but also have a reasonable distance to the destination, with the latter's influence diminishing as the tour progresses. The algorithm selects the node with the highest score as the next step in the tour.",
          "thought": "The new algorithm combines the No.1's balanced approach of favoring nodes close to the current node and the No.2's dynamic weight factor to prioritize destination proximity as fewer nodes remain. It dynamically adjusts the weight factor to balance immediate and future progress, ensuring a smooth transition from global to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + 0.1 * remaining_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -current_distance + (destination_distance ** weight_factor)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55342,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing between minimizing the immediate distance from the current node (prioritized with weight `alpha`) and minimizing the distance to the destination node (prioritized with weight `1-alpha`). The `alpha` parameter controls the trade-off: higher `alpha` favors shorter local steps, while lower `alpha` favors progress toward the destination. The code iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm combines the conservative path selection of No.1 (prioritizing short immediate distances) with the balanced trade-off of No.2 (using alpha to control local/global considerations), resulting in a hybrid heuristic that minimizes long jumps while still guiding toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.7):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = -alpha * current_distance + (1 - alpha) * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate closeness (lower `current_distance`) and destination proximity (higher `destination_distance`) by adjusting the weight based on the number of remaining unvisited nodes. As more nodes are visited, the weight increases, prioritizing paths that lead closer to the destination, ensuring a smoother transition from greedy to destination-aware selection. The score is computed as `-current_distance + weight * destination_distance`, where `weight` increases as the tour progresses.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate closeness and destination proximity based on the number of remaining unvisited nodes, ensuring a smoother transition from greedy to destination-aware selection as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weighting: prioritize destination as more nodes are visited\n        weight = 0.1 + 0.4 * (1 - remaining_nodes / len(distance_matrix))\n        score = -current_distance + weight * destination_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6391,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the current node and node centrality (average distance to unvisited nodes) using a static weight (0.3). It prioritizes nodes closer to the current node while slightly favoring central nodes (lower average distance to unvisited nodes) to avoid getting trapped in local optima. The scoring function penalizes nodes with high average distances, ensuring the path remains efficient and diverse.",
          "thought": "The new algorithm balances immediate distance and node centrality using a static weight (0.3) and a modified scoring function that penalizes nodes with low average distances to unvisited nodes, favoring nodes that are more central as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_total_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n\n        # Static weight\n        weight = 0.3\n\n        # Modified scoring function with inverted penalty\n        total_score = (1 - weight) * distance_to_current - weight * (avg_distance_to_unvisited ** 0.5)\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = node\n\n    return next_node",
          "objective": 6.64506,
          "other_inf": null
     }
]