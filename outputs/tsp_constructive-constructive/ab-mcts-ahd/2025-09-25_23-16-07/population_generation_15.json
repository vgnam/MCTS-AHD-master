[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that minimize the ratio of the current distance to the node and its average distance to remaining unvisited nodes, balancing immediate proximity with long-term efficiency. The `distance_matrix[current_node][node]` term ensures proximity is weighted, while `avg_distances[node]` provides a global perspective by considering average distances to unvisited nodes. The `min` function ensures the node with the smallest ratio is chosen, effectively optimizing the trade-off between immediate and future path costs.",
          "thought": "The new algorithm prioritizes nodes that balance immediate proximity with potential long-term path efficiency by considering the ratio of distance to the current node and the average distance to remaining unvisited nodes, ensuring a more global perspective in node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n    avg_distances = {node: sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes) for node in unvisited_nodes}\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] / avg_distances[node])\n    return next_node",
          "objective": 6.60833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node, using the distance matrix, and ensures the path ends at the destination node once all nodes are visited. It handles the selection based solely on the immediate proximity of nodes, without considering global optimality or future steps. The function gives high priority to minimizing the current step's distance while ignoring potential long-term path efficiency.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the minimum distance from the current node, ensuring the path remains feasible by considering the destination node's distance when all nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future cost using an exponential decay weight, prioritizing proximity early (high immediate cost weight) but gradually emphasizing long-term savings (high future cost weight) as nodes are visited. The weight is calculated as \\(1/(1 + \\text{remaining\\_nodes}^2)\\), where a smaller number of remaining nodes increases the weight on future cost. The cost function combines immediate distance and normalized future cost (average of remaining edges) with weights \\( (1 - \\text{weight}) \\) and \\( \\text{weight} \\), respectively.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate distance and future cost using an exponential decay function, prioritizing immediate proximity early but gradually emphasizing long-term savings as nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1 / (1 + remaining_nodes ** 2)  # Exponential decay weight\n\n    def cost_function(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][other] for other in unvisited_nodes)\n        normalized_future = future_cost / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        return (1 - weight) * immediate_cost + weight * normalized_future\n\n    next_node = min(unvisited_nodes, key=cost_function)\n    return next_node",
          "objective": 7.01742,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and future cost (minimum distances to remaining unvisited nodes), with the weight decreasing as more nodes remain unvisited. Higher priority is given to immediate distance when few nodes are left, while future cost dominates early in the process. The `weight` parameter dynamically adjusts based on remaining nodes, and the `cost_function` combines these factors to guide node selection.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the immediate and future cost prioritization from No.1, selecting nodes that minimize a weighted combination of short-term distance and the sum of minimum distances to unvisited nodes, while the weight decreases as more nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1 / (1 + remaining_nodes)\n\n    def cost_function(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(min(distance_matrix[node][other] for other in unvisited_nodes if other != node) for _ in range(1)) if unvisited_nodes else 0\n        return (1 - weight) * immediate_cost + weight * future_cost\n\n    next_node = min(unvisited_nodes, key=cost_function)\n    return next_node",
          "objective": 7.04196,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future cost, prioritizing nodes with lower immediate distances early but incorporating normalized future costs and diversity penalties to avoid premature convergence. The dynamic weight (`weight`) decreases as nodes are visited, shifting focus from immediate gains to long-term path optimization, while centrality and diversity factors encourage exploration of central and varied paths. The cost function penalizes revisits to recently visited nodes implicitly, favoring unexplored regions.",
          "thought": "The new algorithm modifies the cost function to incorporate a dynamic weighting scheme that adapts to the remaining nodes, combining immediate distance with a normalized future cost based on node centrality and path diversity, while penalizing revisits to recently visited nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n    centrality_factor = 1 / (remaining_nodes ** 0.5)  # Encourages central nodes early\n\n    def cost_function(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][other] for other in unvisited_nodes)\n        normalized_future = future_cost / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        diversity_penalty = 1 - (1 / (1 + sum(distance_matrix[node][other] for other in unvisited_nodes)))  # Penalizes nodes with similar future costs\n        return (1 - weight) * immediate_cost + weight * (normalized_future * centrality_factor + diversity_penalty)\n\n    next_node = min(unvisited_nodes, key=cost_function)\n    return next_node",
          "objective": 7.13612,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future cost by adjusting weights based on remaining unvisited nodes, prioritizing nodes that minimize a weighted combination of short-term proximity and normalized long-term savings. The weight decreases as more nodes remain, favoring immediate distance early but gradually shifting toward future savings. The cost function evaluates each node using the distance matrix, and the next node is selected via a min-key search.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of immediate distance and a normalized future cost, where the weight adjusts dynamically based on the remaining unvisited nodes, favoring nodes that balance proximity and potential long-term savings.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n\n    def cost_function(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][other] for other in unvisited_nodes)\n        normalized_future = future_cost / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        return (1 - weight) * immediate_cost + weight * normalized_future\n\n    next_node = min(unvisited_nodes, key=cost_function)\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing the product of the current distance to the node and the sum of distances from that node to all unvisited nodes, balancing immediate proximity and long-term efficiency. The key design idea is prioritizing nodes that are both close to the current node and likely to lead to a shorter overall path, as the product penalizes nodes that are far from the current node but may have lower future costs. The function uses `distance_matrix[current_node][node]` (immediate cost) and `sum(distance_matrix[node][other] for other in unvisited_nodes)` (future costs) to guide the selection.",
          "thought": "This algorithm selects the next node by prioritizing those that minimize the product of the current distance and the sum of distances to all unvisited nodes, balancing immediate proximity with long-term efficiency by considering both the direct cost and the cumulative future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * sum(distance_matrix[node][other] for other in unvisited_nodes))\n    return next_node",
          "objective": 7.7792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and future cost, using a dynamic weight that prioritizes future cost more as unvisited nodes decrease. It normalizes future cost by the number of remaining nodes to ensure fairness, and the weight adjusts inversely with the number of unvisited nodes. The cost function combines the product of immediate and future costs (weighted lower) with the normalized future cost (weighted higher) to guide the selection toward efficient paths.",
          "thought": "The new algorithm combines the product-based selection of No.1 with the dynamic weight adjustment of No.2, while adding a normalization factor to balance immediate and future costs more effectively. It selects the next node by minimizing a weighted combination of the product of immediate distance and future cost, adjusted dynamically based on remaining nodes, to prioritize nodes that offer both short-term proximity and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1 / (1 + remaining_nodes)\n\n    def cost_function(node):\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][other] for other in unvisited_nodes)\n        normalized_future = future_cost / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n        product_term = immediate_cost * future_cost\n        return (1 - weight) * product_term + weight * normalized_future\n\n    next_node = min(unvisited_nodes, key=cost_function)\n    return next_node",
          "objective": 7.81854,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the sum of the current distance to the node and the minimum distance from that node to any other unvisited node, ensuring both immediate and future steps are optimized. The `current_node` and `unvisited_nodes` are prioritized in the selection, while the `destination_node` is only used as a fallback when no unvisited nodes remain. The `distance_matrix` provides the necessary distance data for evaluation.",
          "thought": "The new algorithm selects the next node by considering the sum of the current distance to the node and the minimum distance from that node to any other unvisited node, aiming to minimize the total path length while ensuring future steps are also optimized.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + min(distance_matrix[node][other] for other in unvisited_nodes if other != node))\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, estimated future cost (scaled by remaining nodes), and a small penalty for early revisiting the destination, prioritizing immediate proximity while dynamically adjusting for future exploration. The future cost is normalized by the number of remaining nodes to avoid bias in early stages, and the destination penalty discourages premature closure. The algorithm defaults to the last unvisited node when only one remains.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of immediate distance and an estimated future cost, where the future cost is adjusted by the number of remaining nodes to balance exploration and exploitation more dynamically, and adds a small penalty for revisiting the destination early to encourage completing the loop.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return unvisited_nodes.pop()\n\n    remaining_nodes = len(unvisited_nodes)\n    next_node = min(unvisited_nodes, key=lambda node: (\n        distance_matrix[current_node][node] +\n        (sum(distance_matrix[node][other] for other in unvisited_nodes) / remaining_nodes) +\n        (0.1 * distance_matrix[node][destination_node] if remaining_nodes > 1 else 0)\n    ))\n    return next_node",
          "objective": 8.39445,
          "other_inf": null
     }
]