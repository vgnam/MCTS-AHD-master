[
     {
          "algorithm": "The algorithm prioritizes local distance (1.2 weight) and global connectivity (0.3 weight for min/avg remaining distances) while adaptively penalizing nodes with poor connectivity, with penalties scaled by the square root of remaining nodes to balance exploration and exploitation. Nodes are scored by combining these factors, favoring shorter current paths but penalizing those with poor future connectivity, especially as the number of unvisited nodes decreases.",
          "thought": "The new algorithm prioritizes nodes by combining local distance, global connectivity, and adaptive penalties, where penalties are weighted by the square root of remaining nodes to balance exploration and exploitation more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 0.5)\n            penalty = max(0, (current_distance - 3 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = 1.2 * current_distance + 0.3 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.3 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.82403,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, connectivity (via min/avg remaining distances), and centrality (using MST-based weighting), with dynamic penalties adjusting for remaining node density. Higher priority is given to immediate distance, followed by min/avg remaining distances, while centrality and penalties have lower weights. The MST centrality metric and dynamic penalty weight adapt based on the remaining nodes, ensuring flexibility in sparse/dense scenarios.",
          "thought": "The new algorithm extends the original by incorporating a node centrality metric based on the minimum spanning tree (MST) of unvisited nodes, using a combination of distance, connectivity, and centrality factors, with dynamic weights that adjust based on the remaining nodes' density and the current path's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n            # Compute centrality based on MST of remaining nodes\n            if len(remaining_nodes) > 1:\n                mst_edges = []\n                for i in range(len(remaining_nodes)):\n                    for j in range(i + 1, len(remaining_nodes)):\n                        mst_edges.append((distance_matrix[remaining_nodes[i]][remaining_nodes[j]], i, j))\n                mst_edges.sort()\n                parent = list(range(len(remaining_nodes)))\n                def find(u):\n                    while parent[u] != u:\n                        parent[u] = parent[parent[u]]\n                        u = parent[u]\n                    return u\n                mst_weight = 0\n                for w, u, v in mst_edges:\n                    root_u = find(u)\n                    root_v = find(v)\n                    if root_u != root_v:\n                        parent[root_v] = root_u\n                        mst_weight += w\n                centrality = mst_weight / len(remaining_nodes) if len(remaining_nodes) > 0 else 0\n            else:\n                centrality = 0\n\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 0.5)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / (avg_remaining_distance + 1e-6))\n            score = (current_distance + 0.3 * min_remaining_distance + 0.2 * centrality) * (1 + dynamic_penalty_weight * penalty) - 0.1 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.99533,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by choosing the nearest unvisited neighbor from the current node, ensuring minimal immediate distance while prioritizing nodes closer to the destination (though this aspect is not explicitly implemented in the given code). The function iterates through unvisited nodes, compares distances from the current node, and selects the closest one, with the destination node returned when no unvisited nodes remain. The design prioritizes local optimality (nearest neighbor) over global efficiency, with the distance matrix and current/next node variables being central to the selection logic.",
          "thought": "This algorithm selects the next node to visit in the TSP by choosing the nearest unvisited node from the current node, prioritizing nodes closer to the destination to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance, remaining node connectivity, and dynamic penalties. It prioritizes nodes with shorter current distances and lower average distances to unvisited nodes, while dynamically adjusting penalties based on the number of remaining nodes. The score combines these factors, with penalties scaling inversely with remaining nodes, to favor nodes that improve connectivity and reduce future path costs.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment for the penalty term, which is inversely proportional to the number of unvisited nodes, and adds a term to favor nodes with high centrality in the remaining graph, computed as the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.2 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.0207,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a balanced scoring approach by prioritizing the current distance to the next node while dynamically adjusting penalties based on remaining nodes and connectivity. It balances immediate distance (`current_distance`) with future connectivity (`min_remaining_distance` and `avg_remaining_distance`), using a hybrid penalty term that scales with both values to improve path efficiency. The dynamic penalty weight (`dynamic_penalty_weight`) and hybrid penalty (`hybrid_penalty`) are key factors in balancing local and global decisions, with lower weights given to average remaining distances (`-0.2 * avg_remaining_distance`).",
          "thought": "The new algorithm combines the balanced scoring approach from both existing algorithms, dynamically adjusts penalties based on remaining nodes and connectivity, and incorporates a hybrid penalty term that scales with both the current distance and the average remaining distance to improve path efficiency and connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            hybrid_penalty = penalty * (current_distance / (min_remaining_distance + 1e-10))\n            score = current_distance + 0.4 * min_remaining_distance + dynamic_penalty_weight * hybrid_penalty - 0.2 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.09089,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing local (immediate distance) and global (distance to destination) considerations, with weights adjusted to favor global optimization as the tour progresses. The weight is inversely proportional to the number of remaining unvisited nodes, prioritizing local distance early and global distance later. The weighted sum `(1 - weight) * local_distance + weight * global_distance` ensures the algorithm adapts to the stage of the tour, selecting the next node based on a trade-off between short-term and long-term gains.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weight adjustment mechanism that balances immediate distance and potential future savings, using a weighted sum of local and global distances, where weights are inversely proportional to the number of remaining unvisited nodes to prioritize global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        global_distance = distance_matrix[node][destination_node]\n        weight = 1 / (1 + remaining_nodes)  # Prioritize global as progress increases\n        score = (1 - weight) * local_distance + weight * global_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance, remaining connectivity, and dynamic penalties. It prioritizes nodes with lower immediate distances and higher connectivity factors (weighted by remaining distances), while dynamically adjusting penalties based on the number of unvisited nodes. The scoring mechanism combines these factors with a penalty term that increases with the node's centrality in the remaining graph, favoring nodes that bridge disconnected subgraphs. The dynamic penalty weight scales inversely with the square root of unvisited nodes, ensuring adaptability to graph size.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic connectivity factor that weighs the node's potential to bridge disconnected subgraphs, using a novel scoring mechanism that combines edge weights, node degrees, and a penalty term based on the node's centrality in the remaining graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n            connectivity_factor = 0.0\n            for n in remaining_nodes:\n                connectivity_factor += (distance_matrix[node][n] - min_remaining_distance) / (avg_remaining_distance + 1e-6)\n\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 1.5)\n            penalty = (current_distance + min_remaining_distance) * (1.0 + connectivity_factor) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.3 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.1 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.16603,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance to the current node, the minimum remaining distance to unvisited nodes, and a penalty for excessive detours. It prioritizes minimizing `current_distance` and `min_remaining_distance` (weighted at 0.4) while penalizing nodes where the current distance is too large relative to the minimum remaining distance (weighted at 0.3). The penalty ensures the algorithm avoids long detours by scaling with the ratio of the current distance to twice the minimum remaining distance.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering both the immediate distance to the current node and the potential to connect to nearby nodes, while also incorporating a penalty for nodes that are too far from the current position to avoid excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / max_remaining_distance) if max_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + 0.3 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.18926,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and the minimum future distance to remaining unvisited nodes, prioritizing immediate distance (100%) and future distance (30%) in its score calculation. It avoids local minima by looking one step ahead when multiple unvisited nodes remain, while directly choosing the final node when only one remains. The `distance_matrix` and `unvisited_nodes` are central inputs, with the score combining current and future distances to guide selection.",
          "thought": "This algorithm selects the next node by considering both the immediate distance to the current node and the potential future connections to other unvisited nodes, using a greedy approach that balances short-term and long-term distance considerations while avoiding immediate local minima by looking ahead one step.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            score = current_distance + 0.3 * min_future_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, minimizing remaining path distances, and penalizing excessive detours. It prioritizes the current distance (weight 1.0) and the minimum remaining distance (weight 0.5), while penalizing detours (weight 0.2) when multiple unvisited nodes remain. The penalty is calculated as a fraction of the current distance exceeding twice the minimum remaining distance, normalized by the maximum remaining distance.",
          "thought": "The new algorithm combines the nearest-neighbor logic of No.1 with the balanced scoring approach of No.2, prioritizing nodes that are both close to the current node and minimize the remaining path while penalizing excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / max_remaining_distance) if max_remaining_distance != 0 else 0\n            score = current_distance + 0.5 * min_remaining_distance + 0.2 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.33774,
          "other_inf": null
     }
]