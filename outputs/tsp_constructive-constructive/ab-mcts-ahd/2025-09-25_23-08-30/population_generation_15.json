[
     {
          "algorithm": "The algorithm selects the next node in TSP by choosing the nearest unvisited neighbor from the current node, ensuring minimal immediate distance while prioritizing nodes closer to the destination (though this aspect is not explicitly implemented in the given code). The function iterates through unvisited nodes, compares distances from the current node, and selects the closest one, with the destination node returned when no unvisited nodes remain. The design prioritizes local optimality (nearest neighbor) over global efficiency, with the distance matrix and current/next node variables being central to the selection logic.",
          "thought": "This algorithm selects the next node to visit in the TSP by choosing the nearest unvisited node from the current node, prioritizing nodes closer to the destination to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance, remaining node connectivity, and dynamic penalties. It prioritizes nodes with shorter current distances and lower average distances to unvisited nodes, while dynamically adjusting penalties based on the number of remaining nodes. The score combines these factors, with penalties scaling inversely with remaining nodes, to favor nodes that improve connectivity and reduce future path costs.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment for the penalty term, which is inversely proportional to the number of unvisited nodes, and adds a term to favor nodes with high centrality in the remaining graph, computed as the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.2 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.0207,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing local (immediate distance) and global (distance to destination) considerations, with weights adjusted to favor global optimization as the tour progresses. The weight is inversely proportional to the number of remaining unvisited nodes, prioritizing local distance early and global distance later. The weighted sum `(1 - weight) * local_distance + weight * global_distance` ensures the algorithm adapts to the stage of the tour, selecting the next node based on a trade-off between short-term and long-term gains.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weight adjustment mechanism that balances immediate distance and potential future savings, using a weighted sum of local and global distances, where weights are inversely proportional to the number of remaining unvisited nodes to prioritize global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        global_distance = distance_matrix[node][destination_node]\n        weight = 1 / (1 + remaining_nodes)  # Prioritize global as progress increases\n        score = (1 - weight) * local_distance + weight * global_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance to the current node, the minimum remaining distance to unvisited nodes, and a penalty for excessive detours. It prioritizes minimizing `current_distance` and `min_remaining_distance` (weighted at 0.4) while penalizing nodes where the current distance is too large relative to the minimum remaining distance (weighted at 0.3). The penalty ensures the algorithm avoids long detours by scaling with the ratio of the current distance to twice the minimum remaining distance.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering both the immediate distance to the current node and the potential to connect to nearby nodes, while also incorporating a penalty for nodes that are too far from the current position to avoid excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / max_remaining_distance) if max_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + 0.3 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.18926,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and the minimum future distance to remaining unvisited nodes, prioritizing immediate distance (100%) and future distance (30%) in its score calculation. It avoids local minima by looking one step ahead when multiple unvisited nodes remain, while directly choosing the final node when only one remains. The `distance_matrix` and `unvisited_nodes` are central inputs, with the score combining current and future distances to guide selection.",
          "thought": "This algorithm selects the next node by considering both the immediate distance to the current node and the potential future connections to other unvisited nodes, using a greedy approach that balances short-term and long-term distance considerations while avoiding immediate local minima by looking ahead one step.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            score = current_distance + 0.3 * min_future_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, minimizing remaining path distances, and penalizing excessive detours. It prioritizes the current distance (weight 1.0) and the minimum remaining distance (weight 0.5), while penalizing detours (weight 0.2) when multiple unvisited nodes remain. The penalty is calculated as a fraction of the current distance exceeding twice the minimum remaining distance, normalized by the maximum remaining distance.",
          "thought": "The new algorithm combines the nearest-neighbor logic of No.1 with the balanced scoring approach of No.2, prioritizing nodes that are both close to the current node and minimize the remaining path while penalizing excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / max_remaining_distance) if max_remaining_distance != 0 else 0\n            score = current_distance + 0.5 * min_remaining_distance + 0.2 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.33774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, average remaining distance, and a detour penalty that scales with distance variance, using a dynamic weight inversely proportional to the square root of unvisited nodes. It prioritizes minimizing immediate distance while adjusting for tour balance, with detour penalties and dynamic weights fine-tuning the selection based on remaining nodes. The score combines these factors, favoring nodes that offer a good trade-off between proximity and tour balance.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weighting scheme that adjusts based on the number of unvisited nodes, using a combination of immediate distance, average remaining distance, and a detour penalty that scales with the variance of remaining distances to encourage more balanced tours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            remaining_distances = [distance_matrix[node][n] for n in remaining_nodes]\n            min_remaining_distance = min(remaining_distances)\n            avg_remaining_distance = sum(remaining_distances) / len(remaining_distances)\n            variance_remaining = sum((d - avg_remaining_distance) ** 2 for d in remaining_distances) / len(remaining_distances)\n            detour_penalty = (current_distance - min_remaining_distance) * (variance_remaining ** 0.5)\n            dynamic_weight = 1 / (len(unvisited_nodes) ** 0.5)\n            score = current_distance + dynamic_weight * avg_remaining_distance + 0.5 * detour_penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.41574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing immediate distance (70% weight) and future path savings (30% weight), prioritizing shorter-term gains while accounting for long-term efficiency. The `current_distance` and `future_estimate` are weighted in a 7:3 ratio, with the score determining the next node. The loop evaluates all unvisited nodes to find the one minimizing this weighted sum.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weighting mechanism that balances immediate distance and potential future savings, using a weighted sum of the current distance and an estimate of the remaining path length from the candidate node to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_estimate = distance_matrix[node][destination_node]\n        score = 0.7 * current_distance + 0.3 * future_estimate\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing the **current distance** (direct cost to the next node) and the **average remaining distance** (future cost), with the latter weighted 0.5. It also applies a **penalty term** (weighted 0.4) to discourage long detours by scaling the penalty based on how much the current distance exceeds the average remaining distance. The penalty ensures the algorithm balances short-term and long-term efficiency while avoiding paths with disproportionately high costs.",
          "thought": "The new algorithm prioritizes minimizing the current distance and the average remaining distance (weighted at 0.5) while penalizing nodes where the current distance is too large relative to the average remaining distance (weighted at 0.4). The penalty ensures the algorithm avoids long detours by scaling with the ratio of the current distance to the average remaining distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            penalty = max(0, (current_distance - avg_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.5 * avg_remaining_distance + 0.4 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.67249,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node (prioritized) and the average distance to remaining unvisited nodes (secondary consideration, weighted by 0.5). The code iterates through unvisited nodes, computes a weighted score combining current distance and average remaining distance, and selects the node with the lowest score. The immediate distance is given higher priority than the average remaining distance.",
          "thought": "This algorithm selects the next node by balancing immediate distance to the current node and potential long-term benefit, using a weighted combination of the current distance and the average distance to remaining unvisited nodes, favoring nodes that offer better overall progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            score = current_distance + 0.5 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.85593,
          "other_inf": null
     }
]