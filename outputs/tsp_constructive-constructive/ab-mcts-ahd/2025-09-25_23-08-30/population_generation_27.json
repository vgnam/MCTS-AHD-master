[
     {
          "algorithm": "The algorithm prioritizes local distance (1.2 weight) and global connectivity (0.3 weight for min/avg remaining distances) while adaptively penalizing nodes with poor connectivity, with penalties scaled by the square root of remaining nodes to balance exploration and exploitation. Nodes are scored by combining these factors, favoring shorter current paths but penalizing those with poor future connectivity, especially as the number of unvisited nodes decreases.",
          "thought": "The new algorithm prioritizes nodes by combining local distance, global connectivity, and adaptive penalties, where penalties are weighted by the square root of remaining nodes to balance exploration and exploitation more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 0.5)\n            penalty = max(0, (current_distance - 3 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = 1.2 * current_distance + 0.3 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.3 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.82403,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, connectivity (via min/avg remaining distances), and centrality (using MST-based weighting), with dynamic penalties adjusting for remaining node density. Higher priority is given to immediate distance, followed by min/avg remaining distances, while centrality and penalties have lower weights. The MST centrality metric and dynamic penalty weight adapt based on the remaining nodes, ensuring flexibility in sparse/dense scenarios.",
          "thought": "The new algorithm extends the original by incorporating a node centrality metric based on the minimum spanning tree (MST) of unvisited nodes, using a combination of distance, connectivity, and centrality factors, with dynamic weights that adjust based on the remaining nodes' density and the current path's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n            # Compute centrality based on MST of remaining nodes\n            if len(remaining_nodes) > 1:\n                mst_edges = []\n                for i in range(len(remaining_nodes)):\n                    for j in range(i + 1, len(remaining_nodes)):\n                        mst_edges.append((distance_matrix[remaining_nodes[i]][remaining_nodes[j]], i, j))\n                mst_edges.sort()\n                parent = list(range(len(remaining_nodes)))\n                def find(u):\n                    while parent[u] != u:\n                        parent[u] = parent[parent[u]]\n                        u = parent[u]\n                    return u\n                mst_weight = 0\n                for w, u, v in mst_edges:\n                    root_u = find(u)\n                    root_v = find(v)\n                    if root_u != root_v:\n                        parent[root_v] = root_u\n                        mst_weight += w\n                centrality = mst_weight / len(remaining_nodes) if len(remaining_nodes) > 0 else 0\n            else:\n                centrality = 0\n\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 0.5)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / (avg_remaining_distance + 1e-6))\n            score = (current_distance + 0.3 * min_remaining_distance + 0.2 * centrality) * (1 + dynamic_penalty_weight * penalty) - 0.1 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.99533,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by choosing the nearest unvisited neighbor from the current node, ensuring minimal immediate distance while prioritizing nodes closer to the destination (though this aspect is not explicitly implemented in the given code). The function iterates through unvisited nodes, compares distances from the current node, and selects the closest one, with the destination node returned when no unvisited nodes remain. The design prioritizes local optimality (nearest neighbor) over global efficiency, with the distance matrix and current/next node variables being central to the selection logic.",
          "thought": "This algorithm selects the next node to visit in the TSP by choosing the nearest unvisited node from the current node, prioritizing nodes closer to the destination to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate and future distances, where future distance importance decreases exponentially as unvisited nodes shrink (prioritizing immediate distances in later stages). It uses a weighted sum of current distance and the minimum future distance, with the weight dynamically adjusted by `0.3 * (0.9 ^ (remaining nodes - 1))` to favor aggressive optimization as the tour progresses. The heuristic ensures a trade-off between local and global optimization while efficiently narrowing down choices.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment for the future distance component, where weights decrease exponentially as the number of unvisited nodes decreases, encouraging more aggressive optimization in later stages while maintaining a balance between immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            weight = 0.3 * (0.9 ** (len(unvisited_nodes) - 1))\n            score = current_distance + weight * min_future_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.01899,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance, remaining node connectivity, and dynamic penalties. It prioritizes nodes with shorter current distances and lower average distances to unvisited nodes, while dynamically adjusting penalties based on the number of remaining nodes. The score combines these factors, with penalties scaling inversely with remaining nodes, to favor nodes that improve connectivity and reduce future path costs.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment for the penalty term, which is inversely proportional to the number of unvisited nodes, and adds a term to favor nodes with high centrality in the remaining graph, computed as the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.2 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.0207,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a balanced scoring approach by prioritizing the current distance to the next node while dynamically adjusting penalties based on remaining nodes and connectivity. It balances immediate distance (`current_distance`) with future connectivity (`min_remaining_distance` and `avg_remaining_distance`), using a hybrid penalty term that scales with both values to improve path efficiency. The dynamic penalty weight (`dynamic_penalty_weight`) and hybrid penalty (`hybrid_penalty`) are key factors in balancing local and global decisions, with lower weights given to average remaining distances (`-0.2 * avg_remaining_distance`).",
          "thought": "The new algorithm combines the balanced scoring approach from both existing algorithms, dynamically adjusts penalties based on remaining nodes and connectivity, and incorporates a hybrid penalty term that scales with both the current distance and the average remaining distance to improve path efficiency and connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            hybrid_penalty = penalty * (current_distance / (min_remaining_distance + 1e-10))\n            score = current_distance + 0.4 * min_remaining_distance + dynamic_penalty_weight * hybrid_penalty - 0.2 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.09089,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest neighbor approach by dynamically balancing local (immediate distance) and global (distance to destination) considerations, with weights adjusted to favor global optimization as the tour progresses. The weight is inversely proportional to the number of remaining unvisited nodes, prioritizing local distance early and global distance later. The weighted sum `(1 - weight) * local_distance + weight * global_distance` ensures the algorithm adapts to the stage of the tour, selecting the next node based on a trade-off between short-term and long-term gains.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weight adjustment mechanism that balances immediate distance and potential future savings, using a weighted sum of local and global distances, where weights are inversely proportional to the number of remaining unvisited nodes to prioritize global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        global_distance = distance_matrix[node][destination_node]\n        weight = 1 / (1 + remaining_nodes)  # Prioritize global as progress increases\n        score = (1 - weight) * local_distance + weight * global_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing immediate distance, remaining connectivity, and dynamic penalties. It prioritizes nodes with lower immediate distances and higher connectivity factors (weighted by remaining distances), while dynamically adjusting penalties based on the number of unvisited nodes. The scoring mechanism combines these factors with a penalty term that increases with the node's centrality in the remaining graph, favoring nodes that bridge disconnected subgraphs. The dynamic penalty weight scales inversely with the square root of unvisited nodes, ensuring adaptability to graph size.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic connectivity factor that weighs the node's potential to bridge disconnected subgraphs, using a novel scoring mechanism that combines edge weights, node degrees, and a penalty term based on the node's centrality in the remaining graph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n            connectivity_factor = 0.0\n            for n in remaining_nodes:\n                connectivity_factor += (distance_matrix[node][n] - min_remaining_distance) / (avg_remaining_distance + 1e-6)\n\n            dynamic_penalty_weight = 1.0 / (len(unvisited_nodes) ** 1.5)\n            penalty = (current_distance + min_remaining_distance) * (1.0 + connectivity_factor) if avg_remaining_distance != 0 else 0\n            score = current_distance + 0.3 * min_remaining_distance + dynamic_penalty_weight * penalty - 0.1 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.16603,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance to the current node, the minimum remaining distance to unvisited nodes, and a penalty for excessive detours. It prioritizes minimizing `current_distance` and `min_remaining_distance` (weighted at 0.4) while penalizing nodes where the current distance is too large relative to the minimum remaining distance (weighted at 0.3). The penalty ensures the algorithm avoids long detours by scaling with the ratio of the current distance to twice the minimum remaining distance.",
          "thought": "The new algorithm prioritizes nodes that minimize the total path length by considering both the immediate distance to the current node and the potential to connect to nearby nodes, while also incorporating a penalty for nodes that are too far from the current position to avoid excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            max_remaining_distance = max(distance_matrix[node][n] for n in remaining_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / max_remaining_distance) if max_remaining_distance != 0 else 0\n            score = current_distance + 0.4 * min_remaining_distance + 0.3 * penalty\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.18926,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance (100% weight) while dynamically balancing future connectivity through penalties based on min/avg remaining distances and adjusting weights by the number of unvisited nodes. It avoids local minima by combining current distance, min remaining distance, and a hybrid penalty term, with lower priority given to avg remaining distances. The score is computed as `current_distance + 0.3*min_remaining_distance + dynamic_penalty_weight*hybrid_penalty - 0.1*avg_remaining_distance`, where penalties scale with current distance and remaining distances.",
          "thought": "The new algorithm combines the immediate distance prioritization from No.2 (100% weight) with a dynamic penalty term inspired by No.1, balancing future connectivity (min and avg remaining distances) and scaling penalties with current distance and remaining distances. It dynamically adjusts penalty weights based on the number of unvisited nodes and avoids local minima by considering both immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_nodes = [n for n in unvisited_nodes if n != node]\n            min_remaining_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n            avg_remaining_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            dynamic_penalty_weight = 1.0 / len(unvisited_nodes)\n            penalty = max(0, (current_distance - 2 * min_remaining_distance) / avg_remaining_distance) if avg_remaining_distance != 0 else 0\n            hybrid_penalty = penalty * (current_distance / (min_remaining_distance + 1e-10))\n            score = current_distance + 0.3 * min_remaining_distance + dynamic_penalty_weight * hybrid_penalty - 0.1 * avg_remaining_distance\n        else:\n            score = current_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.21065,
          "other_inf": null
     }
]