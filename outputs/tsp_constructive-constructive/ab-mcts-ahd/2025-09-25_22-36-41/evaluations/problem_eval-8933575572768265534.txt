importance, where importance is inversely proportional to the number of visits remaining for each node, ensuring a balance between proximity and coverage.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    min_score = float('inf')
    next_node = None
    total_unvisited = len(unvisited_nodes)

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        importance = 1.0 / (total_unvisited - unvisited_nodes.count(node) + 1)  # Inverse of remaining visits
        score = distance * (1 + importance)  # Weighted score
        if score < min_score:
            min_score = score
            next_node = node

    if next_node is None:
        return destination_node
    return next_node
