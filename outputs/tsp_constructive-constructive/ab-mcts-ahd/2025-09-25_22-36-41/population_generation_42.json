[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ensuring all nodes are visited before returning to the destination. If no unvisited nodes remain, it directly proceeds to the destination. The code emphasizes minimizing travel distance by always choosing the nearest available node, with the destination only considered as a fallback.",
          "thought": "The algorithm selects the next node to visit based on the shortest distance to the current node, prioritizing unvisited nodes and eventually moving towards the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor approach by balancing immediate distance (weight 1) and future efficiency (weight 0.3) when selecting the next node, prioritizing shorter-term gains while considering longer-term optimality. It dynamically evaluates each unvisited node's cost as a weighted sum of its distance from the current node and its minimum remaining distance to other unvisited nodes, defaulting to the destination if no nodes remain. The weights reflect a trade-off between immediate proximity and potential future savings.",
          "thought": "The new algorithm modifies the nearest-neighbor approach by dynamically balancing immediate distance and future costs using a weighted combination of the current node's distance to a candidate node and the candidate's minimum distance to remaining unvisited nodes, prioritizing immediate distance (weight 1) while considering future efficiency (weight 0.3), and falling back to the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_weighted_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            remaining_distance = distance_matrix[node][destination_node]\n        else:\n            remaining_distance = min(distance_matrix[node][n] for n in unvisited_nodes - {node})\n\n        weighted_cost = immediate_distance + 0.3 * remaining_distance\n\n        if weighted_cost < min_weighted_cost:\n            min_weighted_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        return destination_node\n\n    return next_node",
          "objective": 7.24067,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing nodes that minimize the direct distance to the current node while also considering the sum of distances to the current node and the destination (with reduced weight). The formula `value = direct_distance + 0.5 * total_increment` balances local efficiency (direct distance) with global progress (total increment), ensuring a smoother transition toward the destination without neglecting proximity. The `total_increment` is weighted lower (`0.5`) to prevent excessive detours while still guiding toward the destination.",
          "thought": "The new algorithm prioritizes nodes that minimize the direct distance to the current node while balancing it with the sum of distances to the current node and the destination, aiming to ensure a smoother transition towards the destination without sacrificing local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_value = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][node]\n        total_increment = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        value = direct_distance + 0.5 * total_increment\n        if value < min_value:\n            min_value = value\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.39182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of the distance from the current node to the candidate and the distance from the candidate to the destination, balancing immediate and final path segments. The code iterates through unvisited nodes, computes this product for each, and selects the node with the smallest product, ensuring efficiency while considering both proximity to the current node and alignment with the final destination. The `distance_matrix` is central, and the product calculation ensures a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing the one that minimizes the product of the distance from the current node to the candidate and the distance from the candidate to the destination, emphasizing a balance between immediate and final path segments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_product = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        product = distance_matrix[current_node][node] * distance_matrix[node][destination_node]\n        if product < min_product:\n            min_product = product\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local efficiency (immediate distance) with global connectivity (proximity to unvisited nodes and destination), dynamically adjusting weights (0.5 for destination proximity and 0.3 for future cost) to prioritize shorter-term gains while considering long-term path feasibility. The score combines immediate cost, destination proximity, and average future cost to select the next node, ensuring adaptability as unvisited nodes decrease.",
          "thought": "The new algorithm modifies the selection criterion by incorporating both the immediate distance to the candidate node and a weighted contribution from the candidate's proximity to unvisited nodes, aiming to balance local efficiency with global connectivity. It dynamically adjusts the weight of the destination factor based on the remaining unvisited nodes, ensuring a more adaptive path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / remaining_nodes if remaining_nodes > 1 else 0\n        score = immediate_cost + 0.5 * distance_matrix[node][destination_node] + 0.3 * future_cost\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.75609,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor approach by dynamically balancing immediate distance and potential future costs, using a weighted combination of the current node's distance to a candidate node and the candidate's average distance to remaining unvisited nodes (or direct distance to the destination if no nodes remain). The immediate distance is prioritized (weight 1), while the future cost is given lower weight (0.5), ensuring the nearest node is still favored but with consideration for overall tour efficiency. The fallback to the destination node handles edge cases where no unvisited nodes are left.",
          "thought": "The new algorithm modifies the nearest neighbor approach by incorporating a dynamic weighting factor that balances distance and potential future costs, using a combination of immediate distance and average distances to unvisited nodes to guide selection, while still prioritizing the nearest node as a fallback.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_weighted_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            remaining_distance = distance_matrix[node][destination_node]\n        else:\n            remaining_distance = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes - {node})\n\n        weighted_cost = immediate_distance + 0.5 * remaining_distance\n\n        if weighted_cost < min_weighted_cost:\n            min_weighted_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        return destination_node\n\n    return next_node",
          "objective": 7.85593,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the sum of distances (current to node and node to destination) with their product, prioritizing the sum (higher weight) while slightly favoring the product (0.5 weight) to ensure both short-term and long-term path efficiency. The `sum_dist` dominates the selection, while `product_dist` acts as a tiebreaker for similar sums, making the heuristic more robust against local minima. The score combines these two metrics to guide the path construction toward the destination efficiently.",
          "thought": "The new algorithm combines the strengths of both algorithms by balancing the sum of distances and the product of distances, using a weighted approach to minimize the total path length while ensuring efficient local and global path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        sum_dist = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        product_dist = distance_matrix[current_node][node] * distance_matrix[node][destination_node]\n        score = sum_dist + 0.5 * product_dist\n        if score < min_score:\n            min_score = score\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.8988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the sum of the distance from the current node to the candidate and from the candidate to the destination, balancing the immediate and final path segments. It ensures the path remains efficient by always choosing the locally optimal step, though it may not guarantee a globally optimal solution. The `distance_matrix` and `unvisited_nodes` are central to the selection process, while the `destination_node` serves as the ultimate goal for path construction.",
          "thought": "This algorithm selects the next node by minimizing the total path length increment from the current node to the candidate node and then to the destination, ensuring a more balanced approach to path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_increment = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        increment = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if increment < min_increment:\n            min_increment = increment\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a nearest-neighbor approach with a weighted balance between immediate distance (weight 1) and estimated future cost (weight 0.75), prioritizing immediate distance while considering global optimization to avoid local optima. It selects the next node by minimizing a weighted cost function that balances current and projected distances, ensuring efficient tour construction. The code iterates through unvisited nodes, calculates the weighted cost for each, and selects the node with the lowest value.",
          "thought": "A new algorithm combines the nearest-neighbor approach with a weighted balance of immediate distance and future cost, where immediate distance is prioritized (weight 1) and future cost is given a higher weight (0.75) to better balance local and global optimization, ensuring efficient tour construction while avoiding premature local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_weighted_cost = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        if not unvisited_nodes - {node}:\n            remaining_distance = distance_matrix[node][destination_node]\n        else:\n            remaining_distance = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes - {node})\n\n        weighted_cost = immediate_distance + 0.75 * remaining_distance\n\n        if weighted_cost < min_weighted_cost:\n            min_weighted_cost = weighted_cost\n            next_node = node\n\n    if next_node is None:\n        return destination_node\n\n    return next_node",
          "objective": 8.14181,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the distance to the destination, with a dynamically adjusted weight (`alpha`) that prioritizes immediate efficiency when fewer nodes remain unvisited. The score for each node is a weighted sum of these distances, and the node with the lowest score is chosen. This balances short-term and long-term path efficiency.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of the distance to the current node and the distance to the destination, introducing a tunable parameter to balance these factors, and dynamically adjusting the weight based on the remaining unvisited nodes to prioritize either immediate or long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    alpha = 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))  # Dynamic weight adjustment\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        score = alpha * distance_matrix[current_node][node] + (1 - alpha) * distance_matrix[node][destination_node]\n        if score < min_score:\n            min_score = score\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 8.24686,
          "other_inf": null
     }
]