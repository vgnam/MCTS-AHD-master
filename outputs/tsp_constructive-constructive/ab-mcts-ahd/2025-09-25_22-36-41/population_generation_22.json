[
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing the closest unvisited node from the current node, ensuring all nodes are visited before returning to the destination. If no unvisited nodes remain, it directly proceeds to the destination. The code emphasizes minimizing travel distance by always choosing the nearest available node, with the destination only considered as a fallback.",
          "thought": "The algorithm selects the next node to visit based on the shortest distance to the current node, prioritizing unvisited nodes and eventually moving towards the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the product of the distance from the current node to the candidate and the distance from the candidate to the destination, balancing immediate and final path segments. The code iterates through unvisited nodes, computes this product for each, and selects the node with the smallest product, ensuring efficiency while considering both proximity to the current node and alignment with the final destination. The `distance_matrix` is central, and the product calculation ensures a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm selects the next node by prioritizing the one that minimizes the product of the distance from the current node to the candidate and the distance from the candidate to the destination, emphasizing a balance between immediate and final path segments.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_product = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        product = distance_matrix[current_node][node] * distance_matrix[node][destination_node]\n        if product < min_product:\n            min_product = product\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local efficiency (immediate distance) with global connectivity (proximity to unvisited nodes and destination), dynamically adjusting weights (0.5 for destination proximity and 0.3 for future cost) to prioritize shorter-term gains while considering long-term path feasibility. The score combines immediate cost, destination proximity, and average future cost to select the next node, ensuring adaptability as unvisited nodes decrease.",
          "thought": "The new algorithm modifies the selection criterion by incorporating both the immediate distance to the candidate node and a weighted contribution from the candidate's proximity to unvisited nodes, aiming to balance local efficiency with global connectivity. It dynamically adjusts the weight of the destination factor based on the remaining unvisited nodes, ensuring a more adaptive path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / remaining_nodes if remaining_nodes > 1 else 0\n        score = immediate_cost + 0.5 * distance_matrix[node][destination_node] + 0.3 * future_cost\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.75609,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the sum of distances (current to node and node to destination) with their product, prioritizing the sum (higher weight) while slightly favoring the product (0.5 weight) to ensure both short-term and long-term path efficiency. The `sum_dist` dominates the selection, while `product_dist` acts as a tiebreaker for similar sums, making the heuristic more robust against local minima. The score combines these two metrics to guide the path construction toward the destination efficiently.",
          "thought": "The new algorithm combines the strengths of both algorithms by balancing the sum of distances and the product of distances, using a weighted approach to minimize the total path length while ensuring efficient local and global path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        sum_dist = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        product_dist = distance_matrix[current_node][node] * distance_matrix[node][destination_node]\n        score = sum_dist + 0.5 * product_dist\n        if score < min_score:\n            min_score = score\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.8988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the one that minimizes the sum of the distance from the current node to the candidate and from the candidate to the destination, balancing the immediate and final path segments. It ensures the path remains efficient by always choosing the locally optimal step, though it may not guarantee a globally optimal solution. The `distance_matrix` and `unvisited_nodes` are central to the selection process, while the `destination_node` serves as the ultimate goal for path construction.",
          "thought": "This algorithm selects the next node by minimizing the total path length increment from the current node to the candidate node and then to the destination, ensuring a more balanced approach to path construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_increment = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        increment = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if increment < min_increment:\n            min_increment = increment\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance from the current node and the distance to the destination, with a dynamically adjusted weight (`alpha`) that prioritizes immediate efficiency when fewer nodes remain unvisited. The score for each node is a weighted sum of these distances, and the node with the lowest score is chosen. This balances short-term and long-term path efficiency.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of the distance to the current node and the distance to the destination, introducing a tunable parameter to balance these factors, and dynamically adjusting the weight based on the remaining unvisited nodes to prioritize either immediate or long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    alpha = 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))  # Dynamic weight adjustment\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        score = alpha * distance_matrix[current_node][node] + (1 - alpha) * distance_matrix[node][destination_node]\n        if score < min_score:\n            min_score = score\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 8.24686,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: immediate cost (40% weight) to minimize the direct travel distance, destination proximity (30% weight) to prioritize nodes closer to the final destination, and average future cost (30% weight) to account for remaining unvisited nodes. It ensures the path is optimized for both short-term efficiency and long-term feasibility.",
          "thought": "The new algorithm combines the No.2's product-based selection with No.1's weighted balance of immediate cost, destination proximity, and average future cost, using 0.4 for immediate cost, 0.3 for destination proximity, and 0.3 for average future cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][node]\n        future_cost = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / remaining_nodes if remaining_nodes > 1 else 0\n        score = 0.4 * immediate_cost + 0.3 * distance_matrix[node][destination_node] + 0.3 * future_cost\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 8.81061,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing exploration (distance from current node) and exploitation (distance to destination), using dynamic weights based on remaining nodes. Weights prioritize exploration early (higher `weight_current`) and shift to exploitation as nodes are visited (lower `weight_current`). The `score` combines these weighted distances to guide node selection, ensuring adaptability to problem scale.",
          "thought": "The new algorithm adapts the original by incorporating a weighted sum of the current distance and destination distance, where weights are dynamically adjusted based on the number of remaining nodes to balance exploration and exploitation, enhancing adaptability to varying problem scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        weight_current = 1.0 / (1.0 + remaining_nodes)\n        weight_dest = 1.0 - weight_current\n        score = weight_current * current_dist + weight_dest * dest_dist\n        if score < min_score:\n            min_score = score\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 14.21124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing those that maximize the immediate gain in reducing the total path length, calculated as the difference between the direct distance to the node and the savings from connecting it to the destination. The savings are computed as the reduction in distance between the node and the destination compared to the direct path from the current node to the destination. This ensures the algorithm avoids unnecessary detours by always choosing the most efficient next step.",
          "thought": "This algorithm prioritizes nodes that provide the highest immediate gain in reducing the total path length by considering both the direct distance to the node and the potential savings from connecting it to the destination, ensuring efficient path construction without unnecessary detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_gain = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][node]\n        savings = distance_matrix[node][destination_node] - (distance_matrix[current_node][destination_node] - direct_distance)\n        gain = direct_distance - savings\n        if gain > max_gain:\n            max_gain = gain\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 18.84834,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing candidates that maximize the ratio of their direct distance from the current node to the sum of their distance to the current node and their distance to the destination. This balances immediate proximity (direct distance) with future efficiency (distance to destination), ensuring the path remains efficient while covering all nodes. The code iterates through unvisited nodes, computes this ratio, and selects the node with the highest ratio, defaulting to the destination if no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes nodes that maximize the ratio of the direct distance to the node and the sum of distances from the current node to the candidate and from the candidate to the destination, balancing immediate and future gains to minimize the total path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_ratio = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][node]\n        total_increment = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if total_increment == 0:\n            ratio = float('inf')\n        else:\n            ratio = direct_distance / total_increment\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    if next_node is None:\n        return destination_node\n    return next_node",
          "objective": 28.21944,
          "other_inf": null
     }
]