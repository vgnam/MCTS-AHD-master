[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance to the destination, prioritizing closer nodes when few unvisited nodes remain (using a weight factor that decreases with remaining nodes). When more options exist, it treats both factors equally. The `weight_factor` adjusts priorities, and the score calculation ensures optimal node selection based on the current context.",
          "thought": "The new algorithm modifies the provided approach by introducing a weighted combination of distance to the current node and distance to the destination, using a dynamic weight that prioritizes closer nodes when few unvisited nodes remain, while balancing both factors when more options are available. The function calculates a score for each unvisited node using a novel weighted formula, selects the node with the lowest score, and returns the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 1.0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes <= 2:\n            score = distance_to_current * (1 - weight_factor) + distance_to_destination * weight_factor\n        else:\n            score = distance_to_current * 0.5 + distance_to_destination * 0.5\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52022,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two main criteria: (1) minimizing the product of distances from the current node and the destination (prioritizing nodes that are close to both), and (2) minimizing the sum of distances (prioritizing nodes that are directly on the path). The score is dynamically weighted, giving higher priority to the product-distance minimization early in the process and shifting to sum-distance minimization as fewer nodes remain. The algorithm also penalizes nodes that are far from both the current and destination nodes by normalizing the product-distance term.",
          "thought": "The new algorithm combines the product distance minimization from No.1, the dynamic weighting and normalized ratio from No.2, and the normalized score calculation from No.3, while adding a penalty for nodes that are far from both the current and destination nodes to further optimize the path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        product_distance = distance_to_current * distance_to_destination\n        normalized_product = product_distance / max_distance\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        weight = remaining_nodes / (remaining_nodes + 1)\n\n        score = weight * (normalized_product + normalized_ratio) + (1 - weight) * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.532,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a weighted sum of their distance from the current node (60% weight) and their distance to the destination (40% weight), balancing local and global efficiency. The code iterates through unvisited nodes, calculates the weighted score, and selects the node with the minimum score as the next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance from the current node and their distance to the destination, with adjustable weights to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.6 * distance_to_current + 0.4 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61536,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the ratio of current-to-next distance over next-to-destination distance (weighted 0.6) with the direct distance to the next node (weighted 0.4), prioritizing immediate efficiency while considering long-term proximity to the destination. It iteratively evaluates unvisited nodes, choosing the one with the minimal combined score, ensuring a heuristic trade-off between local and global path optimality.",
          "thought": "The new algorithm prioritizes the ratio of distances between current and next node to the distance from next node to destination, with a fixed weight of 0.6 for the ratio and 0.4 for the direct distance, ensuring a balance between immediate and long-term efficiency without dynamic weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        score = 0.6 * ratio + 0.4 * distance_to_current\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62234,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the maximum distance between the current node and the next node (70% weight) while also considering the sum of distances (30% weight), balancing local and global path optimization. It iterates through unvisited nodes, computes a weighted combination of the sum and maximum distances, and chooses the node with the smallest weighted distance. The code structure efficiently handles the selection by leveraging a distance matrix and a straightforward loop with conditional updates.",
          "thought": "The new algorithm will prioritize minimizing the maximum distance between the current node and the next node, while also considering the sum of distances to balance between local and global path optimization, using a weighted combination of 0.3 for the sum and 0.7 for the maximum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = 0.3 * sum_distance + 0.7 * max_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node, dynamic scaling of the destination distance (adjusted based on remaining nodes), and a penalty for nodes close to the destination but far from the current node, prioritizing balanced path progression over purely greedy choices. The scoring mechanism combines these factors, with the penalty term ensuring nodes are not overly prioritized just for being close to the destination. The dynamic scaling factor (`scaling_factor`) adjusts the influence of the destination distance based on the proportion of unvisited nodes, promoting more adaptive path planning.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic scaling factor for the destination distance, which adjusts based on the proportion of unvisited nodes remaining, and adds a penalty for nodes that are far from the current node but close to the destination, promoting more balanced path progression.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 for current_node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic scaling factor based on remaining nodes\n        scaling_factor = 0.5 * (remaining_nodes / total_nodes)\n\n        # Penalty for nodes that are close to destination but far from current\n        penalty = 0.3 * (distance_to_destination - distance_to_current) if distance_to_destination < distance_to_current else 0\n\n        combined_score = distance_to_current + scaling_factor * distance_to_destination + penalty\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.65887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing three key factors: immediate proximity (60% weight) to the current node, proximity to the destination (25% weight), and node centrality (15% weight). It prioritizes closeness to the current node and the destination while slightly favoring nodes that are more central in the remaining unvisited nodes. The heuristic score is computed for each candidate node, and the one with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes immediate proximity (60% weight), destination proximity (25% weight), and node centrality (15% weight) to balance efficiency, directionality, and path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        heuristic = 0.6 * distance_to_current + 0.25 * distance_to_destination + 0.15 * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.66559,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by adjusting the weighting of the ratio of current-to-next and next-to-destination distances based on progress. Early in the tour, it prioritizes local efficiency (ratio), while later stages emphasize minimizing the remaining distance to the destination (weighted sum). The `progress_factor` normalizes progress, and the weighted sum (60% ratio + 40% distance) ensures global optimization dominates as the tour nears completion.",
          "thought": "The new algorithm combines the ratio-based scoring of No.1 (balancing current-to-next distance and next-to-destination distance) with the dynamic progress weighting of No.2, using a weighted sum where the influence of the ratio is adjusted by progress to prioritize global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))  # Normalized progress\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            ratio = 0.0\n        else:\n            ratio = distance_to_current / distance_to_destination\n\n        weighted_ratio = (1 - progress_factor) * ratio + progress_factor * (0.6 * ratio + 0.4 * distance_to_current)\n\n        if weighted_ratio < min_score:\n            min_score = weighted_ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.66837,
          "other_inf": null
     }
]