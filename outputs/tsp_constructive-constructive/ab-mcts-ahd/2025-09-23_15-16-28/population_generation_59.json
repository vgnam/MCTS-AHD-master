[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that balance proximity to the current node and future savings to the destination, using a dynamic weighting mechanism that normalizes the ratio of distances to avoid bias from varying scales. It favors nodes with lower scores, where the score combines the normalized ratio of distances and the sum of current and future distances, ensuring efficient path selection while dynamically adapting to the problem's constraints. The `max_distance` normalization ensures fairness across different distance scales, while the ratio prioritizes nodes that minimize both immediate and future travel costs.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts selection criteria based on the ratio of distances to the current node and destination, favoring nodes that balance proximity and future savings while incorporating a normalization factor to account for varying distance scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        score = normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9244,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing proximity to the current node and future savings to the destination, weighted by the remaining unvisited nodes. It prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, especially as the number of remaining nodes decreases. The weighted sum dynamically shifts focus from immediate proximity to strategic long-term savings, with the weight factor inversely proportional to the distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting factor that adjusts the selection criterion based on the remaining number of unvisited nodes, transitioning from prioritizing proximity to balancing proximity and future savings as the tour progresses. It computes a weighted sum of the current distance and the inverse of the future distance to the destination, normalized by the remaining steps, to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / distance_to_destination\n\n        weighted_distance = distance_to_current * weight * (1.0 / (1.0 + remaining_nodes))\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.95109,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by choosing the unvisited node closest to the current node, prioritizing proximity over other factors like the destination. It uses the distance matrix to evaluate distances and iteratively updates the closest unvisited node until all nodes are visited. The destination node is only returned if no unvisited nodes remain, ensuring the path ends at the specified destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are part of the shortest path to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate proximity (distance to current node) with long-term potential (normalized distance to destination) using a progress-dependent weight factor. Early in the tour, it prioritizes proximity to the current node, while later it increasingly favors nodes that reduce overall path length by balancing distances to both the current node and destination. The weight factor `progress_factor` (ranging from 0 to 1) smoothly transitions this priority.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the selection criteria based on the current path progress, favoring nodes that balance immediate proximity with long-term potential savings by incorporating a normalized distance metric and a progress-dependent weight factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))  # Normalized progress\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        normalized_distance = (distance_to_current + distance_to_destination) / 2\n        weighted_distance = (1 - progress_factor) * distance_to_current + progress_factor * normalized_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.12709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and proximity to the destination, with a dynamically adjusted weight. As more nodes are visited (lower `remaining_nodes`), the weight shifts toward favoring nodes closer to the current node, ensuring exploration early and convergence toward the destination later. The score combines the weighted distances, prioritizing the destination during early stages and the current node as the path nears completion.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a weighted combination of proximity to the current node and proximity to the destination node, dynamically adjusting the weight based on the number of remaining unvisited nodes to balance exploration and convergence towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Weighted combination of distances, with higher weight on destination as more nodes are visited\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * distance_to_current + (1 - weight) * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node (prioritized when fewer nodes remain) with a combination of direct distance to the destination and an estimated future cost (averaged over remaining nodes), dynamically adjusting weights based on the number of unvisited nodes. Higher priority is given to immediate efficiency when few nodes remain, while future cost estimation becomes more influential with more nodes. The score combines these factors with weights that decrease as unvisited nodes increase, ensuring adaptability to path optimality.",
          "thought": "The new algorithm combines the balance of immediate and future efficiency from the first algorithm with the dynamic weighting of the second algorithm, while introducing a lookahead mechanism to anticipate future path optimality. It selects the next node by minimizing a weighted combination of current distance, remaining distance, and an estimated future cost based on the unvisited nodes' distances, with weights adjusted based on the remaining nodes to prioritize both short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    weight_factor = 1.0 / (1.0 + total_unvisited)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Estimate future cost by considering average distance to remaining nodes\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        future_cost = sum(distance_matrix[node][n] for n in remaining_nodes) / (len(remaining_nodes) + 1) if remaining_nodes else 0\n\n        # Combine current, remaining, and future costs with dynamic weights\n        score = (1 - weight_factor) * distance_to_current + weight_factor * (0.5 * distance_to_destination + 0.5 * future_cost)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.19572,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing nodes that minimize the maximum of their distance to the current node and their distance to the destination, ensuring a balance between immediate proximity and future efficiency. It iterates through unvisited nodes, computes the max distance for each, and selects the node with the smallest such value. The design ensures the path avoids the worst-case distance while maintaining efficiency.",
          "thought": "This algorithm prioritizes nodes that minimize the maximum of their distance to the current node and their distance to the destination node, ensuring a balance between immediate proximity and future efficiency by avoiding the worst-case distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_max_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        max_distance = max(distance_to_current, distance_to_destination)\n\n        if max_distance < min_max_distance:\n            min_max_distance = max_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.25108,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by minimizing a weighted product of the distance from the current node and the square root of the distance to the destination node, prioritizing the current distance (weight 1.0) over the destination distance (weight 0.5). The code iterates through unvisited nodes, calculates the weighted product, and returns the node with the minimum value. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm combines the weighted distance approach of No.1 with the product distance heuristic of No.2, selecting the next node by minimizing a weighted product of distances from the current node and the destination node, where the current distance is given higher weight (1.0) than the destination distance (0.5).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_product = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weighted_product = current_distance * (destination_distance ** 0.5)\n\n        if weighted_product < min_weighted_product:\n            min_weighted_product = weighted_product\n            next_node = node\n\n    return next_node",
          "objective": 7.42186,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (70% weight) and proximity to the destination (30% weight), avoiding local optima while favoring nearby nodes. The `score` combines these distances linearly, with the current distance prioritized over the destination distance. The function iterates through unvisited nodes, computes the weighted score, and selects the node with the minimum score.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a balance between proximity to the current node and proximity to the destination, using a weighted combination of distances to avoid getting stuck in local optima while still favoring nearby nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = 0.7 * current_distance + 0.3 * destination_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while also considering the distance to the destination, with the current distance given higher weight (1.0) than the destination distance (0.5). It iterates through unvisited nodes, calculates a weighted sum of distances, and returns the node with the lowest score. The function handles empty unvisited nodes by returning the destination.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are closest to the current node but also considers the distance to the destination node, balancing proximity to the current node and the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = current_distance + 0.5 * destination_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]