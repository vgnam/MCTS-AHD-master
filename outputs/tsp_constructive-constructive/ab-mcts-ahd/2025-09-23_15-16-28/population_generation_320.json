[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the maximum distance between the current node and the next node (70% weight) while also considering the sum of distances (30% weight), balancing local and global path optimization. It iterates through unvisited nodes, computes a weighted combination of the sum and maximum distances, and chooses the node with the smallest weighted distance. The code structure efficiently handles the selection by leveraging a distance matrix and a straightforward loop with conditional updates.",
          "thought": "The new algorithm will prioritize minimizing the maximum distance between the current node and the next node, while also considering the sum of distances to balance between local and global path optimization, using a weighted combination of 0.3 for the sum and 0.7 for the maximum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = 0.3 * sum_distance + 0.7 * max_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing three key factors: immediate proximity (60% weight) to the current node, proximity to the destination (25% weight), and node centrality (15% weight). It prioritizes closeness to the current node and the destination while slightly favoring nodes that are more central in the remaining unvisited nodes. The heuristic score is computed for each candidate node, and the one with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes immediate proximity (60% weight), destination proximity (25% weight), and node centrality (15% weight) to balance efficiency, directionality, and path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        heuristic = 0.6 * distance_to_current + 0.25 * distance_to_destination + 0.15 * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.66559,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local and global optimization, prioritizing the maximum of the current-to-node and node-to-destination distances (weighted higher) while also considering their sum (weighted lower). It adjusts the weighted sum by dividing by the inverse square root of remaining nodes to scale the balance between local and global factors as the tour progresses. The selection is made by minimizing the scaled weighted distance.",
          "thought": "The new algorithm combines the weighted sum of distances from the No.1 algorithm with the adaptive scaling of the No.2 algorithm, using a weighted product formula adjusted by the inverse square root of remaining nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = (0.3 * sum_distance + 0.7 * max_distance) / (remaining_nodes ** 0.5)\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.676,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP path by balancing immediate distance and future detour risks, using a dynamic weight factor that prioritizes closer nodes early in the search (higher weight on `normalized_distance`) and penalizes long detours later (higher weight on `penalty`). The score combines these factors, favoring nodes that minimize both current distance and potential future deviations while adapting weights based on remaining unvisited nodes.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, using a normalized distance metric that balances immediate and future path considerations while penalizing nodes that are too far from the current path to reduce detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Dynamic weight adjustment\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Normalized distance metric with dynamic weight\n        normalized_distance = (distance_to_current) / (distance_to_destination + 1e-6)\n        penalty = (distance_to_current + distance_to_destination) ** 0.5  # Penalize long detours\n        score = weight_factor * normalized_distance + (1 - weight_factor) * penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68341,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with shorter distances to the current node while adjusting their selection by a weight factor that decreases with the distance to the destination and the number of remaining nodes. It balances immediate proximity (distance_to_current) with long-term efficiency (distance_to_destination), scaling the influence of the destination distance to reduce future travel costs. The weight factor (1.0 / (1.0 + distance_to_destination)) ensures closer-to-destination nodes are favored, while the remaining_nodes scaling (1.0 / remaining_nodes) reduces the impact of long-term considerations as the problem progresses.",
          "thought": "The new algorithm prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, emphasizing immediate proximity with a weight factor that decreases as the number of remaining nodes increases, creating a balance between short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / (1.0 + distance_to_destination)\n\n        weighted_distance = distance_to_current * weight * (1.0 / remaining_nodes)\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.83635,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that maximize the ratio of distance to the destination over distance from the current node, balancing progress toward the destination with local efficiency. It iterates through unvisited nodes, computes the ratio, and selects the node with the highest ratio, ensuring the path makes strategic progress while avoiding unnecessarily long detours. The code checks for zero distances to handle edge cases, and the ratio calculation directly encodes the design's core heuristic.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the ratio of the distance to the destination over the distance from the current node, aiming to balance progress toward the destination with local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_ratio = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_current == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_destination / distance_to_current\n\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that balance proximity to the current node and future savings to the destination, using a dynamic weighting mechanism that normalizes the ratio of distances to avoid bias from varying scales. It favors nodes with lower scores, where the score combines the normalized ratio of distances and the sum of current and future distances, ensuring efficient path selection while dynamically adapting to the problem's constraints. The `max_distance` normalization ensures fairness across different distance scales, while the ratio prioritizes nodes that minimize both immediate and future travel costs.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts selection criteria based on the ratio of distances to the current node and destination, favoring nodes that balance proximity and future savings while incorporating a normalization factor to account for varying distance scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        score = normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9244,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing the distance to the current node and the distance to the destination, weighted by the ratio of the node's distance to the destination versus the average distance of unvisited nodes. It prioritizes nodes closer to the current node when the destination is far (high dynamic weight) and vice versa, while avoiding division by zero with a small epsilon. The combined score ensures adaptive exploration while maintaining goal-directed progression.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor based on the ratio of the current node's distance to the destination versus the average distance of unvisited nodes, promoting adaptive exploration while maintaining goal-directed progression.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_unvisited_distance = total_unvisited_distance / len(unvisited_nodes) if unvisited_nodes else 0\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = distance_to_destination / (avg_unvisited_distance + 1e-10)  # Avoid division by zero\n        combined_score = dynamic_weight * distance_to_current + (1 - dynamic_weight) * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.93284,
          "other_inf": null
     }
]