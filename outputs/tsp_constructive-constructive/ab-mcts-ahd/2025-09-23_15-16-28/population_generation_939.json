[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance to the destination, prioritizing closer nodes when few unvisited nodes remain (using a weight factor that decreases with remaining nodes). When more options exist, it treats both factors equally. The `weight_factor` adjusts priorities, and the score calculation ensures optimal node selection based on the current context.",
          "thought": "The new algorithm modifies the provided approach by introducing a weighted combination of distance to the current node and distance to the destination, using a dynamic weight that prioritizes closer nodes when few unvisited nodes remain, while balancing both factors when more options are available. The function calculates a score for each unvisited node using a novel weighted formula, selects the node with the lowest score, and returns the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 1.0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes <= 2:\n            score = distance_to_current * (1 - weight_factor) + distance_to_destination * weight_factor\n        else:\n            score = distance_to_current * 0.5 + distance_to_destination * 0.5\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52022,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two main criteria: (1) minimizing the product of distances from the current node and the destination (prioritizing nodes that are close to both), and (2) minimizing the sum of distances (prioritizing nodes that are directly on the path). The score is dynamically weighted, giving higher priority to the product-distance minimization early in the process and shifting to sum-distance minimization as fewer nodes remain. The algorithm also penalizes nodes that are far from both the current and destination nodes by normalizing the product-distance term.",
          "thought": "The new algorithm combines the product distance minimization from No.1, the dynamic weighting and normalized ratio from No.2, and the normalized score calculation from No.3, while adding a penalty for nodes that are far from both the current and destination nodes to further optimize the path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        product_distance = distance_to_current * distance_to_destination\n        normalized_product = product_distance / max_distance\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        weight = remaining_nodes / (remaining_nodes + 1)\n\n        score = weight * (normalized_product + normalized_ratio) + (1 - weight) * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.532,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with proximity, savings, and centrality balancing, prioritizing local proximity early (high weight on `distance_to_current`) and global optimization later (adjusting weights based on remaining nodes and distance ratios). It avoids isolated nodes by penalizing high-degree nodes (`node_degree`), while savings (`normalized_savings`) and proximity are balanced via `adjusted_weight`. The weighted score minimizes `distance_to_current` early (higher weight) and `normalized_savings` later (lower weight), with a fixed penalty for node centrality.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.2 with proximity, savings, and centrality balancing from No.1, prioritizing local proximity early and global optimization later while avoiding isolated nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.6\n    adjustment_factor = 0.4 * (remaining_nodes / (remaining_nodes + 1))\n\n    avg_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        product_distance = distance_to_current * distance_to_destination\n        normalized_savings = product_distance / (distance_to_current + distance_to_destination)\n\n        node_degree = sum(distance_matrix[node]) / len(distance_matrix[node])\n\n        distance_ratio = distance_to_destination / avg_distance if avg_distance != 0 else 1.0\n        adjusted_weight = base_weight * (1 + adjustment_factor * (1 - distance_ratio))\n\n        weighted_score = (adjusted_weight * distance_to_current +\n                         (1 - adjusted_weight) * normalized_savings -\n                         0.5 * node_degree)\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.59216,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing nodes that offer a high ratio of destination distance to current distance while penalizing total distance. It uses a weighted scoring mechanism where the ratio term is emphasized (subtracting a normalized sum of distances), favoring nodes that are both close to the current position and significantly closer to the destination. The destination is returned if no unvisited nodes remain.",
          "thought": "This new algorithm combines the strategies of minimizing the sum of distances to the current and destination nodes (from Algorithm 1) with the ratio-based approach of maximizing the progress toward the destination relative to local distance (from Algorithm 2), while also incorporating a normalization factor to balance the trade-off between immediate proximity and long-term progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_current == 0:\n            score = float('inf')\n        else:\n            score = (distance_to_destination / distance_to_current) - (distance_to_current + distance_to_destination) * 0.5\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60446,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a weighted sum of their distance from the current node (60% weight) and their distance to the destination (40% weight), balancing local and global efficiency. The code iterates through unvisited nodes, calculates the weighted score, and selects the node with the minimum score as the next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance from the current node and their distance to the destination, with adjustable weights to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.6 * distance_to_current + 0.4 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61536,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing progress toward the destination (prioritized via the ratio of distances) and local efficiency (penalized by shorter steps), while avoiding cycles by only considering unvisited nodes. The score is computed as the weighted sum of the ratio of distance to destination over distance from current node, plus a penalty term inversely proportional to the step length. This ensures a dynamic trade-off between global and local objectives.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted sum of the ratio of distances to the destination and a penalty term for revisiting nodes, creating a dynamic balance between progress toward the destination and local efficiency while avoiding cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_current == 0:\n            score = float('inf')\n        else:\n            ratio = distance_to_destination / distance_to_current\n            penalty = 1 / (1 + distance_to_current)  # Penalty for longer steps\n            score = ratio + penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61985,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing spatial proximity, potential savings, and node centrality, with weights adjusted based on tour progress. Proximity is prioritized early (high `proximity_weight`), while savings and centrality gain importance later (higher `savings_weight` and `centrality_weight`). The weighted score combines these factors, favoring nodes that minimize distance products while considering centrality to avoid isolated nodes. The `progress_factor` ensures exploration early and exploitation later.",
          "thought": "This new algorithm modifies the selection process by incorporating a dynamic weight adjustment based on both spatial proximity and potential savings, while also considering the node's centrality in the graph to balance exploration and exploitation more effectively. It uses a combination of distance products, normalized savings, and node degree to guide the selection, with weights that adapt based on tour progress and node centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        product_distance = distance_to_current * distance_to_destination\n        normalized_savings = product_distance / (distance_to_current + distance_to_destination)\n\n        # Calculate node centrality (simplified as average distance to all nodes)\n        node_degree = sum(distance_matrix[node]) / len(distance_matrix[node])\n\n        # Dynamic weight adjustment\n        proximity_weight = (1 - progress_factor) * (1 / (1 + distance_to_current))\n        savings_weight = progress_factor * (normalized_savings / (1 + normalized_savings))\n        centrality_weight = 0.5 * (node_degree / max(distance_matrix[node]))\n\n        weighted_score = (proximity_weight * distance_to_current +\n                          savings_weight * normalized_savings -\n                          centrality_weight * node_degree)\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62097,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the ratio of current-to-next distance over next-to-destination distance (weighted 0.6) with the direct distance to the next node (weighted 0.4), prioritizing immediate efficiency while considering long-term proximity to the destination. It iteratively evaluates unvisited nodes, choosing the one with the minimal combined score, ensuring a heuristic trade-off between local and global path optimality.",
          "thought": "The new algorithm prioritizes the ratio of distances between current and next node to the distance from next node to destination, with a fixed weight of 0.6 for the ratio and 0.4 for the direct distance, ensuring a balance between immediate and long-term efficiency without dynamic weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        score = 0.6 * ratio + 0.4 * distance_to_current\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62234,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two key factors\u2014immediate proximity to the current node and future proximity to the destination\u2014by computing a weighted score (70% ratio of current-to-next/next-to-destination distances and 30% direct distance to current node) to select the next node. It prioritizes nodes that balance short-term and long-term travel efficiency, ensuring the path remains optimal while exploring unvisited nodes. The structure iteratively evaluates each unvisited node, updating the best candidate based on the lowest computed score.",
          "thought": "The new algorithm combines the No.1 algorithm's weighted ratio of current-to-next and next-to-destination distances with the No.2 algorithm's iterative evaluation of unvisited nodes, using a weighted sum to prioritize nodes that balance immediate and future proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        score = 0.7 * ratio + 0.3 * distance_to_current\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62251,
          "other_inf": null
     }
]