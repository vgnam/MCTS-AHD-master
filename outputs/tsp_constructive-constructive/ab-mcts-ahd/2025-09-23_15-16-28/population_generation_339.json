[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a weighted sum of their distance from the current node (60% weight) and their distance to the destination (40% weight), balancing local and global efficiency. The code iterates through unvisited nodes, calculates the weighted score, and selects the node with the minimum score as the next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance from the current node and their distance to the destination, with adjustable weights to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.6 * distance_to_current + 0.4 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61536,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the maximum distance between the current node and the next node (70% weight) while also considering the sum of distances (30% weight), balancing local and global path optimization. It iterates through unvisited nodes, computes a weighted combination of the sum and maximum distances, and chooses the node with the smallest weighted distance. The code structure efficiently handles the selection by leveraging a distance matrix and a straightforward loop with conditional updates.",
          "thought": "The new algorithm will prioritize minimizing the maximum distance between the current node and the next node, while also considering the sum of distances to balance between local and global path optimization, using a weighted combination of 0.3 for the sum and 0.7 for the maximum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = 0.3 * sum_distance + 0.7 * max_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node, dynamic scaling of the destination distance (adjusted based on remaining nodes), and a penalty for nodes close to the destination but far from the current node, prioritizing balanced path progression over purely greedy choices. The scoring mechanism combines these factors, with the penalty term ensuring nodes are not overly prioritized just for being close to the destination. The dynamic scaling factor (`scaling_factor`) adjusts the influence of the destination distance based on the proportion of unvisited nodes, promoting more adaptive path planning.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic scaling factor for the destination distance, which adjusts based on the proportion of unvisited nodes remaining, and adds a penalty for nodes that are far from the current node but close to the destination, promoting more balanced path progression.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 for current_node\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic scaling factor based on remaining nodes\n        scaling_factor = 0.5 * (remaining_nodes / total_nodes)\n\n        # Penalty for nodes that are close to destination but far from current\n        penalty = 0.3 * (distance_to_destination - distance_to_current) if distance_to_destination < distance_to_current else 0\n\n        combined_score = distance_to_current + scaling_factor * distance_to_destination + penalty\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.65887,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing three key factors: immediate proximity (60% weight) to the current node, proximity to the destination (25% weight), and node centrality (15% weight). It prioritizes closeness to the current node and the destination while slightly favoring nodes that are more central in the remaining unvisited nodes. The heuristic score is computed for each candidate node, and the one with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes immediate proximity (60% weight), destination proximity (25% weight), and node centrality (15% weight) to balance efficiency, directionality, and path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        heuristic = 0.6 * distance_to_current + 0.25 * distance_to_destination + 0.15 * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.66559,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance from current node) and long-term efficiency (distance to destination), prioritizing nodes that minimize a weighted sum of these distances. The weighting adjusts dynamically based on the inverse of the distance to the destination, ensuring the selection is neither too myopic nor overly distant. The score is calculated as `distance_to_current + (distance_to_current / distance_to_destination)`, favoring nodes closer to the current node and those that reduce the remaining path length.",
          "thought": "The new algorithm combines the strengths of the two existing algorithms by prioritizing nodes that minimize a weighted sum of their distance from the current node and a scaled version of their distance to the destination, where the scaling factor is the inverse of the distance to the destination. This balances immediate proximity with long-term efficiency, potentially yielding a lower objective value by avoiding overly myopic or overly distant node selections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_destination == 0:\n            score = distance_to_current\n        else:\n            score = distance_to_current + (distance_to_current / distance_to_destination)\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local and global optimization, prioritizing the maximum of the current-to-node and node-to-destination distances (weighted higher) while also considering their sum (weighted lower). It adjusts the weighted sum by dividing by the inverse square root of remaining nodes to scale the balance between local and global factors as the tour progresses. The selection is made by minimizing the scaled weighted distance.",
          "thought": "The new algorithm combines the weighted sum of distances from the No.1 algorithm with the adaptive scaling of the No.2 algorithm, using a weighted product formula adjusted by the inverse square root of remaining nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = (0.3 * sum_distance + 0.7 * max_distance) / (remaining_nodes ** 0.5)\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.676,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP path by balancing immediate distance and future detour risks, using a dynamic weight factor that prioritizes closer nodes early in the search (higher weight on `normalized_distance`) and penalizes long detours later (higher weight on `penalty`). The score combines these factors, favoring nodes that minimize both current distance and potential future deviations while adapting weights based on remaining unvisited nodes.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, using a normalized distance metric that balances immediate and future path considerations while penalizing nodes that are too far from the current path to reduce detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Dynamic weight adjustment\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Normalized distance metric with dynamic weight\n        normalized_distance = (distance_to_current) / (distance_to_destination + 1e-6)\n        penalty = (distance_to_current + distance_to_destination) ** 0.5  # Penalize long detours\n        score = weight_factor * normalized_distance + (1 - weight_factor) * penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68341,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with shorter distances to the current node while adjusting their selection by a weight factor that decreases with the distance to the destination and the number of remaining nodes. It balances immediate proximity (distance_to_current) with long-term efficiency (distance_to_destination), scaling the influence of the destination distance to reduce future travel costs. The weight factor (1.0 / (1.0 + distance_to_destination)) ensures closer-to-destination nodes are favored, while the remaining_nodes scaling (1.0 / remaining_nodes) reduces the impact of long-term considerations as the problem progresses.",
          "thought": "The new algorithm prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, emphasizing immediate proximity with a weight factor that decreases as the number of remaining nodes increases, creating a balance between short-term and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / (1.0 + distance_to_destination)\n\n        weighted_distance = distance_to_current * weight * (1.0 / remaining_nodes)\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.83635,
          "other_inf": null
     }
]