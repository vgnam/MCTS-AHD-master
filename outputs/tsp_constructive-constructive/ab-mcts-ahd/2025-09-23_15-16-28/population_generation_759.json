[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and distance to the destination, prioritizing closer nodes when few unvisited nodes remain (using a weight factor that decreases with remaining nodes). When more options exist, it treats both factors equally. The `weight_factor` adjusts priorities, and the score calculation ensures optimal node selection based on the current context.",
          "thought": "The new algorithm modifies the provided approach by introducing a weighted combination of distance to the current node and distance to the destination, using a dynamic weight that prioritizes closer nodes when few unvisited nodes remain, while balancing both factors when more options are available. The function calculates a score for each unvisited node using a novel weighted formula, selects the node with the lowest score, and returns the destination if no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 1.0 / (remaining_nodes + 1) if remaining_nodes > 0 else 1.0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if remaining_nodes <= 2:\n            score = distance_to_current * (1 - weight_factor) + distance_to_destination * weight_factor\n        else:\n            score = distance_to_current * 0.5 + distance_to_destination * 0.5\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52022,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two main criteria: (1) minimizing the product of distances from the current node and the destination (prioritizing nodes that are close to both), and (2) minimizing the sum of distances (prioritizing nodes that are directly on the path). The score is dynamically weighted, giving higher priority to the product-distance minimization early in the process and shifting to sum-distance minimization as fewer nodes remain. The algorithm also penalizes nodes that are far from both the current and destination nodes by normalizing the product-distance term.",
          "thought": "The new algorithm combines the product distance minimization from No.1, the dynamic weighting and normalized ratio from No.2, and the normalized score calculation from No.3, while adding a penalty for nodes that are far from both the current and destination nodes to further optimize the path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        product_distance = distance_to_current * distance_to_destination\n        normalized_product = product_distance / max_distance\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        weight = remaining_nodes / (remaining_nodes + 1)\n\n        score = weight * (normalized_product + normalized_ratio) + (1 - weight) * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.532,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with proximity, savings, and centrality balancing, prioritizing local proximity early (high weight on `distance_to_current`) and global optimization later (adjusting weights based on remaining nodes and distance ratios). It avoids isolated nodes by penalizing high-degree nodes (`node_degree`), while savings (`normalized_savings`) and proximity are balanced via `adjusted_weight`. The weighted score minimizes `distance_to_current` early (higher weight) and `normalized_savings` later (lower weight), with a fixed penalty for node centrality.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.2 with proximity, savings, and centrality balancing from No.1, prioritizing local proximity early and global optimization later while avoiding isolated nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.6\n    adjustment_factor = 0.4 * (remaining_nodes / (remaining_nodes + 1))\n\n    avg_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        product_distance = distance_to_current * distance_to_destination\n        normalized_savings = product_distance / (distance_to_current + distance_to_destination)\n\n        node_degree = sum(distance_matrix[node]) / len(distance_matrix[node])\n\n        distance_ratio = distance_to_destination / avg_distance if avg_distance != 0 else 1.0\n        adjusted_weight = base_weight * (1 + adjustment_factor * (1 - distance_ratio))\n\n        weighted_score = (adjusted_weight * distance_to_current +\n                         (1 - adjusted_weight) * normalized_savings -\n                         0.5 * node_degree)\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.59216,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes based on a weighted sum of their distance from the current node (60% weight) and their distance to the destination (40% weight), balancing local and global efficiency. The code iterates through unvisited nodes, calculates the weighted score, and selects the node with the minimum score as the next node.",
          "thought": "The new algorithm prioritizes nodes based on a weighted sum of their distance from the current node and their distance to the destination, with adjustable weights to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.6 * distance_to_current + 0.4 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61536,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing spatial proximity, potential savings, and node centrality, with weights adjusted based on tour progress. Proximity is prioritized early (high `proximity_weight`), while savings and centrality gain importance later (higher `savings_weight` and `centrality_weight`). The weighted score combines these factors, favoring nodes that minimize distance products while considering centrality to avoid isolated nodes. The `progress_factor` ensures exploration early and exploitation later.",
          "thought": "This new algorithm modifies the selection process by incorporating a dynamic weight adjustment based on both spatial proximity and potential savings, while also considering the node's centrality in the graph to balance exploration and exploitation more effectively. It uses a combination of distance products, normalized savings, and node degree to guide the selection, with weights that adapt based on tour progress and node centrality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        product_distance = distance_to_current * distance_to_destination\n        normalized_savings = product_distance / (distance_to_current + distance_to_destination)\n\n        # Calculate node centrality (simplified as average distance to all nodes)\n        node_degree = sum(distance_matrix[node]) / len(distance_matrix[node])\n\n        # Dynamic weight adjustment\n        proximity_weight = (1 - progress_factor) * (1 / (1 + distance_to_current))\n        savings_weight = progress_factor * (normalized_savings / (1 + normalized_savings))\n        centrality_weight = 0.5 * (node_degree / max(distance_matrix[node]))\n\n        weighted_score = (proximity_weight * distance_to_current +\n                          savings_weight * normalized_savings -\n                          centrality_weight * node_degree)\n\n        if weighted_score < min_weighted_score:\n            min_weighted_score = weighted_score\n            next_node = node\n\n    return next_node",
          "objective": 6.62097,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the ratio of current-to-next distance over next-to-destination distance (weighted 0.6) with the direct distance to the next node (weighted 0.4), prioritizing immediate efficiency while considering long-term proximity to the destination. It iteratively evaluates unvisited nodes, choosing the one with the minimal combined score, ensuring a heuristic trade-off between local and global path optimality.",
          "thought": "The new algorithm prioritizes the ratio of distances between current and next node to the distance from next node to destination, with a fixed weight of 0.6 for the ratio and 0.4 for the direct distance, ensuring a balance between immediate and long-term efficiency without dynamic weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        score = 0.6 * ratio + 0.4 * distance_to_current\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62234,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two key factors\u2014immediate proximity to the current node and future proximity to the destination\u2014by computing a weighted score (70% ratio of current-to-next/next-to-destination distances and 30% direct distance to current node) to select the next node. It prioritizes nodes that balance short-term and long-term travel efficiency, ensuring the path remains optimal while exploring unvisited nodes. The structure iteratively evaluates each unvisited node, updating the best candidate based on the lowest computed score.",
          "thought": "The new algorithm combines the No.1 algorithm's weighted ratio of current-to-next and next-to-destination distances with the No.2 algorithm's iterative evaluation of unvisited nodes, using a weighted sum to prioritize nodes that balance immediate and future proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        score = 0.7 * ratio + 0.3 * distance_to_current\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62251,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the maximum distance between the current node and the next node (70% weight) while also considering the sum of distances (30% weight), balancing local and global path optimization. It iterates through unvisited nodes, computes a weighted combination of the sum and maximum distances, and chooses the node with the smallest weighted distance. The code structure efficiently handles the selection by leveraging a distance matrix and a straightforward loop with conditional updates.",
          "thought": "The new algorithm will prioritize minimizing the maximum distance between the current node and the next node, while also considering the sum of distances to balance between local and global path optimization, using a weighted combination of 0.3 for the sum and 0.7 for the maximum distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        sum_distance = distance_to_current + distance_to_destination\n        max_distance = max(distance_to_current, distance_to_destination)\n        weighted_distance = 0.3 * sum_distance + 0.7 * max_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     }
]