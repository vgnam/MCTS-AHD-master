[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that balance proximity to the current node and future savings to the destination, using a dynamic weighting mechanism that normalizes the ratio of distances to avoid bias from varying scales. It favors nodes with lower scores, where the score combines the normalized ratio of distances and the sum of current and future distances, ensuring efficient path selection while dynamically adapting to the problem's constraints. The `max_distance` normalization ensures fairness across different distance scales, while the ratio prioritizes nodes that minimize both immediate and future travel costs.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts selection criteria based on the ratio of distances to the current node and destination, favoring nodes that balance proximity and future savings while incorporating a normalization factor to account for varying distance scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        score = normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9244,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing proximity to the current node and future savings to the destination, weighted by the remaining unvisited nodes. It prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, especially as the number of remaining nodes decreases. The weighted sum dynamically shifts focus from immediate proximity to strategic long-term savings, with the weight factor inversely proportional to the distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting factor that adjusts the selection criterion based on the remaining number of unvisited nodes, transitioning from prioritizing proximity to balancing proximity and future savings as the tour progresses. It computes a weighted sum of the current distance and the inverse of the future distance to the destination, normalized by the remaining steps, to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / distance_to_destination\n\n        weighted_distance = distance_to_current * weight * (1.0 / (1.0 + remaining_nodes))\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.95109,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by choosing the unvisited node closest to the current node, prioritizing proximity over other factors like the destination. It uses the distance matrix to evaluate distances and iteratively updates the closest unvisited node until all nodes are visited. The destination node is only returned if no unvisited nodes remain, ensuring the path ends at the specified destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are part of the shortest path to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate proximity (distance to current node) with long-term potential (normalized distance to destination) using a progress-dependent weight factor. Early in the tour, it prioritizes proximity to the current node, while later it increasingly favors nodes that reduce overall path length by balancing distances to both the current node and destination. The weight factor `progress_factor` (ranging from 0 to 1) smoothly transitions this priority.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the selection criteria based on the current path progress, favoring nodes that balance immediate proximity with long-term potential savings by incorporating a normalized distance metric and a progress-dependent weight factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))  # Normalized progress\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        normalized_distance = (distance_to_current + distance_to_destination) / 2\n        weighted_distance = (1 - progress_factor) * distance_to_current + progress_factor * normalized_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.12709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and proximity to the destination, with a dynamically adjusted weight. As more nodes are visited (lower `remaining_nodes`), the weight shifts toward favoring nodes closer to the current node, ensuring exploration early and convergence toward the destination later. The score combines the weighted distances, prioritizing the destination during early stages and the current node as the path nears completion.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a weighted combination of proximity to the current node and proximity to the destination node, dynamically adjusting the weight based on the number of remaining unvisited nodes to balance exploration and convergence towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Weighted combination of distances, with higher weight on destination as more nodes are visited\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * distance_to_current + (1 - weight) * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing nodes that minimize the maximum of their distance to the current node and their distance to the destination, ensuring a balance between immediate proximity and future efficiency. It iterates through unvisited nodes, computes the max distance for each, and selects the node with the smallest such value. The design ensures the path avoids the worst-case distance while maintaining efficiency.",
          "thought": "This algorithm prioritizes nodes that minimize the maximum of their distance to the current node and their distance to the destination node, ensuring a balance between immediate proximity and future efficiency by avoiding the worst-case distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_max_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        max_distance = max(distance_to_current, distance_to_destination)\n\n        if max_distance < min_max_distance:\n            min_max_distance = max_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.25108,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by minimizing a weighted product of the distance from the current node and the square root of the distance to the destination node, prioritizing the current distance (weight 1.0) over the destination distance (weight 0.5). The code iterates through unvisited nodes, calculates the weighted product, and returns the node with the minimum value. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm combines the weighted distance approach of No.1 with the product distance heuristic of No.2, selecting the next node by minimizing a weighted product of distances from the current node and the destination node, where the current distance is given higher weight (1.0) than the destination distance (0.5).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_product = float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weighted_product = current_distance * (destination_distance ** 0.5)\n\n        if weighted_product < min_weighted_product:\n            min_weighted_product = weighted_product\n            next_node = node\n\n    return next_node",
          "objective": 7.42186,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while also considering the distance to the destination, with the current distance given higher weight (1.0) than the destination distance (0.5). It iterates through unvisited nodes, calculates a weighted sum of distances, and returns the node with the lowest score. The function handles empty unvisited nodes by returning the destination.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that are closest to the current node but also considers the distance to the destination node, balancing proximity to the current node and the overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        score = current_distance + 0.5 * destination_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of their distance from the current node and their distance to the destination, balancing proximity and future savings. Nodes closer to both the current and destination positions are favored, as their product distance is minimized. The structure iterates through unvisited nodes, computes the product distance, and selects the node with the smallest value.",
          "thought": "The new algorithm prioritizes nodes that minimize the product of their distance from the current node and their distance to the destination node, balancing proximity and potential future savings by considering multiplicative interactions rather than additive sums.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_product_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        product_distance = distance_to_current * distance_to_destination\n\n        if product_distance < min_product_distance:\n            min_product_distance = product_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weighted at 60%) and proximity to the destination (weighted at 40%), ensuring a trade-off between immediate efficiency and future progress. The `distance_matrix` provides distances between nodes, while `weight_current` and `weight_destination` adjust the priority of these factors. The loop iterates through unvisited nodes, computes the weighted sum, and picks the node with the lowest value.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the weighted sum of their distance to the current node and their distance to the destination, balancing immediate proximity and future efficiency with adjustable weights.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, weight_current=0.6, weight_destination=0.4):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_sum = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_sum = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if weighted_sum < min_weighted_sum:\n            min_weighted_sum = weighted_sum\n            next_node = node\n\n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     }
]