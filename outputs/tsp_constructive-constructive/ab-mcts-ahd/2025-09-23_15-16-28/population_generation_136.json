[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that balance proximity to the current node and future savings to the destination, using a dynamic weighting mechanism that normalizes the ratio of distances to avoid bias from varying scales. It favors nodes with lower scores, where the score combines the normalized ratio of distances and the sum of current and future distances, ensuring efficient path selection while dynamically adapting to the problem's constraints. The `max_distance` normalization ensures fairness across different distance scales, while the ratio prioritizes nodes that minimize both immediate and future travel costs.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts selection criteria based on the ratio of distances to the current node and destination, favoring nodes that balance proximity and future savings while incorporating a normalization factor to account for varying distance scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        score = normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9244,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing proximity to the current node and future savings to the destination, weighted by the remaining unvisited nodes. It prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, especially as the number of remaining nodes decreases. The weighted sum dynamically shifts focus from immediate proximity to strategic long-term savings, with the weight factor inversely proportional to the distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting factor that adjusts the selection criterion based on the remaining number of unvisited nodes, transitioning from prioritizing proximity to balancing proximity and future savings as the tour progresses. It computes a weighted sum of the current distance and the inverse of the future distance to the destination, normalized by the remaining steps, to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / distance_to_destination\n\n        weighted_distance = distance_to_current * weight * (1.0 / (1.0 + remaining_nodes))\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.95109,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and long-term travel costs by dynamically weighting the current node's proximity (prioritized when few nodes remain) and the normalized ratio of distances (prioritized for future savings), adjusting weights based on remaining nodes. It selects the next node by minimizing a score that combines these factors, with the current distance weighted more heavily as the tour progresses. The normalized ratio ensures long-term efficiency, while the dynamic weight adapts to the problem's state.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 (favoring current node proximity as remaining nodes decrease) with the normalized ratio and future savings prioritization of No.2, using a weighted score that balances immediate and long-term travel costs while dynamically adjusting the weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * distance_to_current + (1 - weight) * normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.99301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by choosing the unvisited node closest to the current node, prioritizing proximity over other factors like the destination. It uses the distance matrix to evaluate distances and iteratively updates the closest unvisited node until all nodes are visited. The destination node is only returned if no unvisited nodes remain, ensuring the path ends at the specified destination.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are part of the shortest path to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by prioritizing nodes based on a weighted combination of their distance from the current node and their proximity to the destination. The weight exponentially decreases with the number of unvisited nodes, balancing exploration (early stages) with convergence (late stages) by emphasizing proximity to the destination as more nodes are visited. The function iteratively evaluates unvisited nodes, computes a combined score, and selects the node with the lowest score.",
          "thought": "The new algorithm dynamically prioritizes nodes based on a weighted combination of current distance and destination proximity, with weights adjusted exponentially by the number of unvisited nodes to balance exploration and convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight = 2 ** (-total_unvisited)\n        else:\n            weight = 1.0\n\n        combined_score = distance_to_current + weight * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.01898,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate travel distance and long-term progress toward the destination by dynamically weighting the distance to the destination based on the number of unvisited nodes. It prioritizes minimizing the sum of the distance from the current node and a weighted distance to the destination, where the weight decreases as more nodes remain unvisited, ensuring flexibility early on while progressively focusing on the final destination. The heuristic dynamically adjusts node selection to optimize both short-term and long-term efficiency.",
          "thought": "The new algorithm prioritizes balancing immediate travel distance and long-term progress toward the destination by using a dynamic weight that scales with the remaining path length, ensuring efficient intermediate node selection while progressively focusing on the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight = 1.0 / (total_unvisited ** 2)\n        else:\n            weight = 1.0\n\n        combined_score = distance_to_current + weight * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.06047,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node with progress toward the destination, using a dynamically adjusted weight (0.3/total_unvisited) to prioritize immediate distance while maintaining overall path efficiency. It ensures the destination is reached when no unvisited nodes remain, with the weight scaling inversely with remaining nodes to adapt to different stages of the path.",
          "thought": "The new algorithm combines the strengths of the existing ones by dynamically balancing immediate distance to the current node with progress toward the destination, using a weight that adapts based on the number of remaining unvisited nodes and incorporates a small scaling factor (0.3) to prioritize proximity while maintaining overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight = 0.3 / total_unvisited\n        else:\n            weight = 0.3\n\n        combined_score = distance_to_current + weight * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.07797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing the product of the distance from the current node and a weighted destination distance, where the weight dynamically adjusts based on the number of remaining unvisited nodes. When few nodes remain, the destination distance is prioritized more heavily, while earlier stages balance both distances. The weight is calculated as \\(1/\\text{total\\_unvisited}\\), ensuring the influence of the destination distance increases as the tour progresses.",
          "thought": "The new algorithm combines the multiplicative weighting of No.1 with the dynamic balancing of No.2, selecting nodes by minimizing the product of distances while adjusting the weight of the destination distance based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    min_weighted_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight = 1.0 / total_unvisited\n        else:\n            weight = 1.0\n\n        weighted_distance = distance_to_current * (distance_to_destination ** weight)\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.12004,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate proximity (distance to current node) with long-term potential (normalized distance to destination) using a progress-dependent weight factor. Early in the tour, it prioritizes proximity to the current node, while later it increasingly favors nodes that reduce overall path length by balancing distances to both the current node and destination. The weight factor `progress_factor` (ranging from 0 to 1) smoothly transitions this priority.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the selection criteria based on the current path progress, favoring nodes that balance immediate proximity with long-term potential savings by incorporating a normalized distance metric and a progress-dependent weight factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    progress_factor = 1.0 - (total_unvisited / (total_unvisited + 1))  # Normalized progress\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        normalized_distance = (distance_to_current + distance_to_destination) / 2\n        weighted_distance = (1 - progress_factor) * distance_to_current + progress_factor * normalized_distance\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.12709,
          "other_inf": null
     }
]