def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    scores = []
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Dynamic weight based on path progress and remaining nodes
        progress_factor = 1 - (remaining_nodes / (remaining_nodes + 1)) ** 2
        current_weight = 0.3 + 0.4 * progress_factor
        dest_weight = 0.7 - 0.2 * progress_factor

        # Neighborhood density factor
        neighborhood_size = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < 1.2 * current_dist)
        density_factor = 1 / (1 + 0.1 * neighborhood_size)

        # Path deviation penalty
        direct_dist = distance_matrix[current_node][destination_node]
        deviation_penalty = max(0, (dest_dist - 1.2 * direct_dist) / direct_dist)

        # Combined score with novel factors
        score = (current_weight * current_dist +
                 dest_weight * dest_dist +
                 0.3 * deviation_penalty) * density_factor
        scores.append((score, node))

    # Probabilistic selection based on rank
    scores.sort()
    if len(scores) > 1:
        top_nodes = [node for (score, node) in scores[:min(3, len(scores))]]
        probabilities = [1/(i+1) for i in range(len(top_nodes))]
        total = sum(probabilities)
        probabilities = [p/total for p in probabilities]
        next_node = random.choices(top_nodes, weights=probabilities, k=1)[0]
    else:
        next_node = scores[0][1]

    return next_node
