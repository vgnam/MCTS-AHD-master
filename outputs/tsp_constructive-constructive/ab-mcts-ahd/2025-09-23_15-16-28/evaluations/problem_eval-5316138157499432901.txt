def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_score = float('inf')
    total_unvisited = len(unvisited_nodes)

    # Estimate optimal path length (greedy lower bound)
    estimated_optimal = distance_matrix[current_node][destination_node] + sum(
        min(distance_matrix[current_node][node], distance_matrix[node][destination_node])
        for node in unvisited_nodes
    ) / total_unvisited if total_unvisited > 0 else 0

    # Calculate current path length
    current_path_length = distance_matrix[current_node][destination_node]

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Centrality measure: average distance to all unvisited nodes
        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (total_unvisited - 1) if total_unvisited > 1 else 0

        # Dynamic priority weight
        priority_weight = 0.5 + 0.5 * (current_path_length / (estimated_optimal + 1e-6)) * (total_unvisited / (total_unvisited + 1))

        # Combined score with centrality and dynamic weight
        combined_score = (distance_to_current + distance_to_destination) + priority_weight * centrality

        if combined_score < min_score:
            min_score = combined_score
            next_node = node

    return next_node
