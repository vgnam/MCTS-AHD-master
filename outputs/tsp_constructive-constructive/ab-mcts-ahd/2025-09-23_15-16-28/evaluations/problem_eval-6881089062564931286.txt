def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    node_scores = []
    total_unvisited = len(unvisited_nodes)
    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / total_unvisited if total_unvisited > 0 else 0

    for node in unvisited_nodes:
        current_distance = distance_matrix[current_node][node]
        destination_distance = distance_matrix[node][destination_node]
        weight_current = 0.6 * (1 - (total_unvisited / len(unvisited_nodes))) + 0.3
        distance_penalty = max(0, (current_distance - 1.5 * avg_distance) ** 1.5)
        score = weight_current * current_distance + (1 - weight_current) * destination_distance + distance_penalty
        node_scores.append((node, score))

    if not node_scores:
        return destination_node

    min_score = min(score for _, score in node_scores)
    max_score = max(score for _, score in node_scores)
    normalized_scores = [(node, (max_score - score) / (max_score - min_score + 1e-6)) for node, score in node_scores]

    total_prob = sum(prob for _, prob in normalized_scores)
    rand_val = random.random() * total_prob
    cumulative_prob = 0

    for node, prob in normalized_scores:
        cumulative_prob += prob
        if rand_val <= cumulative_prob:
            return node

    return next_node
