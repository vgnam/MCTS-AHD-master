def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    min_score = float('inf')
    penalty_factors = {node: 1.0 for node in unvisited_nodes}  # Initialize penalties

    for node in unvisited_nodes:
        distance_to_current = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Adaptive weights based on penalty
        weight_current = 0.7 - 0.1 * penalty_factors[node]  # Reduce weight for penalized nodes
        weight_destination = 0.3 + 0.1 * penalty_factors[node]  # Increase weight for penalized nodes

        weighted_sum = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)
        penalty_score = weighted_sum * penalty_factors[node]  # Apply penalty

        if penalty_score < min_score:
            min_score = penalty_score
            next_node = node

    # Update penalty for the selected node (simulate "learning")
    if next_node in penalty_factors:
        penalty_factors[next_node] *= 0.9  # Reduce penalty for selected node

    return next_node
