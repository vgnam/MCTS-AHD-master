[
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity to the current node (higher early, lower later) and proximity to the destination (higher later, lower early), while maintaining a fixed weight for centrality to balance flexibility. The heuristic combines these weighted distances and centrality to select the next node, prioritizing closer nodes early and destination proximity later. The weights are dynamically adjusted based on the number of remaining unvisited nodes.",
          "thought": "The new algorithm adapts the original approach by incorporating a dynamic weight adjustment based on the remaining path length, where proximity to the current node is prioritized early (higher weight) and proximity to the destination is emphasized later (higher weight), while centrality remains a fixed factor to maintain flexibility. The algorithm also considers the number of remaining unvisited nodes to adjust the heuristic dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate centrality\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Dynamic weight adjustment based on remaining nodes\n        weight_current = max(0.4, 0.5 - 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_destination = max(0.4, 0.3 + 0.1 * (remaining_nodes / len(distance_matrix)))\n        weight_centrality = 0.2\n\n        # Combine with dynamic weights\n        heuristic = weight_current * distance_to_current + weight_destination * distance_to_destination + weight_centrality * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.50876,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest product of their distance from the current node and their distance to the destination node, balancing immediate proximity and future efficiency through multiplicative weighting. The `distance_matrix` provides pairwise distances, while `current_node` and `destination_node` define the path's context. The loop iterates over `unvisited_nodes`, computing the weighted distance for each, and selects the node with the minimal product. The structure emphasizes minimizing the product of distances, implicitly favoring nodes that are close to both the current and destination positions.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize the product of their distance from the current node and their distance to the destination node, aiming to balance proximity and future efficiency through multiplicative weighting.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weighted_distance = distance_to_current * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.64861,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing three key factors: immediate proximity (60% weight) to the current node, proximity to the destination (25% weight), and node centrality (15% weight). It prioritizes closeness to the current node and the destination while slightly favoring nodes that are more central in the remaining unvisited nodes. The heuristic score is computed for each candidate node, and the one with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes immediate proximity (60% weight), destination proximity (25% weight), and node centrality (15% weight) to balance efficiency, directionality, and path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_heuristic = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n\n        heuristic = 0.6 * distance_to_current + 0.25 * distance_to_destination + 0.15 * centrality\n\n        if heuristic < min_heuristic:\n            min_heuristic = heuristic\n            next_node = node\n\n    return next_node",
          "objective": 6.66559,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP path by balancing immediate distance and future detour risks, using a dynamic weight factor that prioritizes closer nodes early in the search (higher weight on `normalized_distance`) and penalizes long detours later (higher weight on `penalty`). The score combines these factors, favoring nodes that minimize both current distance and potential future deviations while adapting weights based on remaining unvisited nodes.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, using a normalized distance metric that balances immediate and future path considerations while penalizing nodes that are too far from the current path to reduce detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight_factor = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Dynamic weight adjustment\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Normalized distance metric with dynamic weight\n        normalized_distance = (distance_to_current) / (distance_to_destination + 1e-6)\n        penalty = (distance_to_current + distance_to_destination) ** 0.5  # Penalize long detours\n        score = weight_factor * normalized_distance + (1 - weight_factor) * penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68341,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that maximize the ratio of distance to the destination over distance from the current node, balancing progress toward the destination with local efficiency. It iterates through unvisited nodes, computes the ratio, and selects the node with the highest ratio, ensuring the path makes strategic progress while avoiding unnecessarily long detours. The code checks for zero distances to handle edge cases, and the ratio calculation directly encodes the design's core heuristic.",
          "thought": "The new algorithm prioritizes selecting the next node by maximizing the ratio of the distance to the destination over the distance from the current node, aiming to balance progress toward the destination with local efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_ratio = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        if distance_to_current == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_to_destination / distance_to_current\n\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that balance proximity to the current node and future savings to the destination, using a dynamic weighting mechanism that normalizes the ratio of distances to avoid bias from varying scales. It favors nodes with lower scores, where the score combines the normalized ratio of distances and the sum of current and future distances, ensuring efficient path selection while dynamically adapting to the problem's constraints. The `max_distance` normalization ensures fairness across different distance scales, while the ratio prioritizes nodes that minimize both immediate and future travel costs.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts selection criteria based on the ratio of distances to the current node and destination, favoring nodes that balance proximity and future savings while incorporating a normalization factor to account for varying distance scales.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        score = normalized_ratio * (distance_to_current + distance_to_destination)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9244,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing the distance to the current node and the distance to the destination, weighted by the ratio of the node's distance to the destination versus the average distance of unvisited nodes. It prioritizes nodes closer to the current node when the destination is far (high dynamic weight) and vice versa, while avoiding division by zero with a small epsilon. The combined score ensures adaptive exploration while maintaining goal-directed progression.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor based on the ratio of the current node's distance to the destination versus the average distance of unvisited nodes, promoting adaptive exploration while maintaining goal-directed progression.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited_distance = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)\n    avg_unvisited_distance = total_unvisited_distance / len(unvisited_nodes) if unvisited_nodes else 0\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        dynamic_weight = distance_to_destination / (avg_unvisited_distance + 1e-10)  # Avoid division by zero\n        combined_score = dynamic_weight * distance_to_current + (1 - dynamic_weight) * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.93284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (distance to current node) and long-term efficiency (distance to destination), weighted by a decay factor (0.7) and inversely proportional to the number of remaining unvisited nodes. Nodes closer to the current node and those that reduce future travel (lower `distance_to_destination`) are prioritized, with the weight dynamically adjusted to favor proximity as the tour progresses. The weighted sum ensures a trade-off between short-term and long-term goals.",
          "thought": "The new algorithm combines the dynamic balancing of proximity and future savings from No.1 with the decay factor approach of No.2, using a weighted sum where the weight is inversely proportional to the remaining nodes and scaled by a decay factor to prioritize immediate proximity while considering long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    decay_factor = 0.7\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / distance_to_destination\n\n        weighted_distance = distance_to_current + decay_factor * weight * (1.0 / (1.0 + remaining_nodes))\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.93524,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity-based selection with dynamic weighting, prioritizing immediate distance when few nodes remain (high weight) and balancing with long-term savings (normalized ratio) otherwise. It calculates a weighted score for each unvisited node using the current distance and the ratio of distances to the current and destination nodes, adjusting weights based on remaining nodes. The score is minimized to select the next node, with special handling when a node directly connects to the destination.",
          "thought": "The new algorithm combines the proximity-based selection of No.2 with the dynamic weighting of No.1, prioritizing immediate distance when few nodes remain and balancing with long-term savings otherwise. It uses a weighted score combining current distance and normalized ratio of distances to the current and destination nodes, with weights adjusted based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n    max_distance = max(max(row) for row in distance_matrix)\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            return node\n\n        ratio = distance_to_current / distance_to_destination\n        normalized_ratio = ratio / max_distance\n        weight = remaining_nodes / (remaining_nodes + 1)\n        score = weight * distance_to_current + (1 - weight) * normalized_ratio\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.95071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing proximity to the current node and future savings to the destination, weighted by the remaining unvisited nodes. It prioritizes nodes with shorter distances to the current node while scaling their influence by their potential to reduce future travel costs, especially as the number of remaining nodes decreases. The weighted sum dynamically shifts focus from immediate proximity to strategic long-term savings, with the weight factor inversely proportional to the distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting factor that adjusts the selection criterion based on the remaining number of unvisited nodes, transitioning from prioritizing proximity to balancing proximity and future savings as the tour progresses. It computes a weighted sum of the current distance and the inverse of the future distance to the destination, normalized by the remaining steps, to guide node selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if distance_to_destination == 0:\n            weight = 1.0\n        else:\n            weight = 1.0 / distance_to_destination\n\n        weighted_distance = distance_to_current * weight * (1.0 / (1.0 + remaining_nodes))\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 6.95109,
          "other_inf": null
     }
]