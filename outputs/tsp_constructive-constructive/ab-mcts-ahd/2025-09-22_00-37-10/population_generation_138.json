[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by prioritizing nodes closer to the destination (destination proximity) more aggressively, using an exponential decay function (`bias_factor`) that decreases rapidly as more nodes are visited. The `bias_factor` is calculated as `(len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)`, ensuring higher emphasis on destination proximity early in the search. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing local (current node) and global (destination) optimization dynamically.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by adjusting the bias factor to prioritize nodes closer to the destination more aggressively, using an exponential decay function that decreases the bias factor rapidly as more nodes are visited, ensuring a balance between local and global optimization with a stronger emphasis on destination proximity early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a dynamic bias factor (decreasing as nodes are visited) with a weighted lookahead strategy (increasing priority as the tour progresses) to balance immediate distance savings with long-term optimization. It prioritizes immediate distance reduction early (high bias) but gradually shifts focus to global optimization (high lookahead weight) by adjusting the score calculation with a weighted combination of immediate and lookahead distances. The bias factor and weight are dynamically computed based on remaining unvisited nodes, ensuring adaptability throughout the tour construction.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead strategy of No.2, where the bias factor starts high to prioritize global optimization early and decreases as more nodes are visited, while the lookahead weight increases to ensure global focus as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84383,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term and long-term efficiency by combining immediate distance to the next node with a weighted lookahead distance to the destination, where the weight dynamically adjusts based on the number of remaining unvisited nodes. It prioritizes immediate gains when nodes are few but increasingly values long-term efficiency as the problem size grows, ensuring adaptability to different stages of the TSP solution. The scoring mechanism (`immediate_distance - weight * lookahead_distance`) ensures a trade-off between proximity and strategic planning.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the strategic planning of No.1, using a weight that starts high (prioritizing immediate gains) and decreases as remaining nodes grow, while also incorporating a lookahead distance component to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))) / (1.0 + remaining_nodes)\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.87636,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and long-term distances by combining a static weight (0.5) with a dynamic weight that adjusts based on remaining unvisited nodes, prioritizing strategic planning while adapting to the remaining path length. The score for each node is calculated as `immediate_distance - weight * lookahead_distance`, where the dynamic weight increases as the number of remaining nodes decreases, ensuring a trade-off between short-term and long-term efficiency. The algorithm selects the node with the lowest score, favoring nodes that reduce immediate distance while keeping long-term distance manageable.",
          "thought": "The new algorithm combines the static weight (0.5) from No.1 with the dynamic weight adjustment from No.2, prioritizing strategic planning while adapting to the remaining nodes, ensuring lower objective values by balancing immediate and long-term distances effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = base_weight + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91658,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distances (lower weights) while dynamically balancing them with lookahead distances (higher weights) scaled by a bias factor that adapts to the remaining problem size. The bias factor (`(remaining_nodes / (remaining_nodes + 2)) ** 2`) and weight (`1.0 / (1.0 + remaining_nodes)`) ensure that early decisions favor proximity to the current node, while later decisions increasingly consider the path back to the destination. The score function (`-immediate_distance + weight * bias_factor * lookahead_distance`) balances these priorities, giving higher emphasis to immediate distances early on and to lookahead distances as the problem size shrinks.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the bias factor and score function from No.1, prioritizing immediate distances while dynamically balancing them with lookahead distances scaled by a bias factor that adapts to the remaining problem size.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = (remaining_nodes / (remaining_nodes + 2)) ** 2\n        weight = 1.0 / (1.0 + remaining_nodes)\n        score = -immediate_distance + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.93627,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and lookahead distance to the destination, with a non-linear decay factor prioritizing short-term gains early. It penalizes nodes that are too far from the current node relative to their distance to the destination, ensuring the path remains efficient while adapting to the remaining nodes. The `score` calculation weights immediate and lookahead distances dynamically, with higher priority given to immediate distances early in the process.",
          "thought": "The new algorithm modifies the dynamic weight calculation by incorporating a non-linear decay factor based on the ratio of remaining nodes to total nodes, emphasizing immediate gains early while gradually shifting focus to lookahead distances, and introduces a penalty term for nodes that are far from the current node relative to their distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # Including current node\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        decay_factor = (remaining_nodes / total_nodes) ** 2  # Non-linear decay\n        weight = decay_factor * (1.0 / (1.0 + remaining_nodes))\n        penalty = max(0, immediate_distance - 2 * lookahead_distance)  # Penalize nodes too far from current\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94455,
          "other_inf": null
     }
]