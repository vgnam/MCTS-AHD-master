[
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing the shortest available edge from the current node to an unvisited node. It iteratively selects the next node by minimizing the distance from the current node, ensuring a greedy, constructive path. The code efficiently checks all unvisited nodes, comparing their distances to the current node, and returns the closest one. The `destination_node` is unused, indicating the heuristic does not explicitly optimize for the final return path.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance to the current node, ensuring the path remains efficient and constructive.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (higher priority) and closeness to the destination (lower priority, weighted by 0.3), minimizing detours while guiding the path toward the destination. It iterates through unvisited nodes, computes a weighted score combining these distances, and chooses the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and closeness to the destination, aiming to guide the path toward the destination while minimizing local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the next node while also considering the potential path to the destination with reduced weight (0.5). It evaluates each unvisited node by balancing local (immediate distance) and global (lookahead to destination) factors, selecting the node with the lowest combined score. The code structure iterates through unvisited nodes, computes a weighted sum of distances, and updates the best candidate dynamically.",
          "thought": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, evaluating not just the immediate next node but also the potential impact on the remaining path to the destination, balancing greedy local optimization with global path considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance + 0.5 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted lookahead distance to the destination, with the weight dynamically adjusted based on the proportion of remaining unvisited nodes. It prioritizes global optimization as the tour progresses by increasing the weight of the lookahead distance as fewer nodes remain unvisited. The weight starts at 0.5 and approaches 1 as the remaining nodes decrease, ensuring the algorithm shifts from local to more global decision-making.",
          "thought": "The new algorithm prioritizes nodes by combining immediate distance with a weighted lookahead to the destination, but uses a dynamic weight that adjusts based on the proportion of remaining nodes, favoring global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance + weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.00647,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **farthest-neighbor heuristic** for TSP, selecting the unvisited node farthest from the current node to maximize edge distances, balancing the path by prioritizing longer connections. It iterates through unvisited nodes, comparing distances from the current node to find the maximum, ensuring the next node extends the path as much as possible. The code prioritizes maximizing `max_distance` over all unvisited nodes, while `current_node` and `distance_matrix` are used to compute distances. The heuristic balances path length by favoring longer edges, though it may not guarantee the shortest tour.",
          "thought": "The new algorithm implements a **farthest-neighbor heuristic** for TSP, prioritizing the longest available edge from the current node to an unvisited node, aiming to maximize the distance in each step to potentially improve the overall path balance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    max_distance = -float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance > max_distance:\n            max_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]