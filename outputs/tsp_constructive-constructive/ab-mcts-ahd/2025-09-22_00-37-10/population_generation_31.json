[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and long-term distances by combining a static weight (0.5) with a dynamic weight that adjusts based on remaining unvisited nodes, prioritizing strategic planning while adapting to the remaining path length. The score for each node is calculated as `immediate_distance - weight * lookahead_distance`, where the dynamic weight increases as the number of remaining nodes decreases, ensuring a trade-off between short-term and long-term efficiency. The algorithm selects the node with the lowest score, favoring nodes that reduce immediate distance while keeping long-term distance manageable.",
          "thought": "The new algorithm combines the static weight (0.5) from No.1 with the dynamic weight adjustment from No.2, prioritizing strategic planning while adapting to the remaining nodes, ensuring lower objective values by balancing immediate and long-term distances effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = base_weight + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91658,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing the shortest available edge from the current node to an unvisited node. It iteratively selects the next node by minimizing the distance from the current node, ensuring a greedy, constructive path. The code efficiently checks all unvisited nodes, comparing their distances to the current node, and returns the closest one. The `destination_node` is unused, indicating the heuristic does not explicitly optimize for the final return path.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance to the current node, ensuring the path remains efficient and constructive.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **adaptive lookahead weighting** (prioritizing strategic planning via `weight`) and **dynamic weight adjustment** (balancing immediate and long-term distances via `dynamic_weight`), while applying a **dead-end penalty** (penalizing premature closure of paths via `penalty`). The score prioritizes immediate distances (`immediate_distance`) heavily at the start but gradually shifts focus to strategic lookahead (`lookahead_distance`), with penalties applied when only one node remains. The adaptive `weight` and `dynamic_weight` ensure flexibility, while the `penalty` acts as a safeguard against suboptimal dead-ends.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the adaptive lookahead weighting and dead-end penalty of No.1, creating a hybrid approach that balances immediate and strategic planning while penalizing premature path closure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.3 * (remaining_nodes / len(distance_matrix))  # Adaptive lookahead weight\n        penalty = 0.2 * (immediate_distance + lookahead_distance) if remaining_nodes == 1 else 0  # Dead-end penalty\n        dynamic_weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight from No.2\n        score = immediate_distance + dynamic_weight * weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.11585,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a lookahead distance to the destination, scaled by a dynamic weight inversely proportional to the number of remaining unvisited nodes. This prioritizes immediate distance when few nodes remain (high weight) and balances exploration and exploitation by adjusting the lookahead influence dynamically. The code iteratively evaluates all unvisited nodes using this weighted score to determine the next step in the path.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, combining immediate distance with a lookahead component scaled by a factor inversely proportional to the number of unvisited nodes, thereby balancing exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 / (remaining_nodes + 1)  # Avoid division by zero\n        score = immediate_distance + dynamic_weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and lookahead distance to the destination, with the latter weighted dynamically based on the number of remaining unvisited nodes. Closer nodes are prioritized, but the lookahead influence decreases as the number of remaining nodes grows, ensuring a trade-off between local and global optimization. The weight scales inversely with remaining nodes, reducing lookahead importance as the search progresses.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weight adjustment based on the Euclidean distance between nodes, prioritizing nodes closer to the current node while also considering the lookahead distance to the destination, with the weight scaling inversely with the number of remaining unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        # Dynamic weight based on Euclidean-like scaling\n        weight = 1.0 / (1.0 + remaining_nodes * 0.5)\n        score = immediate_distance + weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24174,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a weighted lookahead distance to the destination, with the weight dynamically decreasing from 0.8 to 0.2 as the number of unvisited nodes shrinks, ensuring a smooth transition from local optimization to global consideration. The immediate distance is always fully prioritized, while the lookahead distance's influence gradually diminishes, favoring shorter-term gains early in the tour and longer-term planning as fewer nodes remain.",
          "thought": "The new algorithm prioritizes local optimization early in the tour by dynamically adjusting the weight of the lookahead distance, starting at 0.8 and decreasing to 0.2 as the number of remaining nodes decreases, ensuring a balance between immediate and global decisions throughout the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.8 - (0.6 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance + weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.35889,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (higher priority) and closeness to the destination (lower priority, weighted by 0.3), minimizing detours while guiding the path toward the destination. It iterates through unvisited nodes, computes a weighted score combining these distances, and chooses the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and closeness to the destination, aiming to guide the path toward the destination while minimizing local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     }
]