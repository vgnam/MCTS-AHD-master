[
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing the shortest available edge from the current node to an unvisited node. It iteratively selects the next node by minimizing the distance from the current node, ensuring a greedy, constructive path. The code efficiently checks all unvisited nodes, comparing their distances to the current node, and returns the closest one. The `destination_node` is unused, indicating the heuristic does not explicitly optimize for the final return path.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance to the current node, ensuring the path remains efficient and constructive.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a lookahead distance to the destination, scaled by a dynamic weight inversely proportional to the number of remaining unvisited nodes. This prioritizes immediate distance when few nodes remain (high weight) and balances exploration and exploitation by adjusting the lookahead influence dynamically. The code iteratively evaluates all unvisited nodes using this weighted score to determine the next step in the path.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, combining immediate distance with a lookahead component scaled by a factor inversely proportional to the number of unvisited nodes, thereby balancing exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 / (remaining_nodes + 1)  # Avoid division by zero\n        score = immediate_distance + dynamic_weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (higher priority) and closeness to the destination (lower priority, weighted by 0.3), minimizing detours while guiding the path toward the destination. It iterates through unvisited nodes, computes a weighted score combining these distances, and chooses the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and closeness to the destination, aiming to guide the path toward the destination while minimizing local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (70% weight) and lookahead distance to the destination (30% weight), prioritizing local proximity while considering global path optimization. The function iterates through unvisited nodes, computes a weighted score, and returns the node with the lowest score, ensuring a trade-off between short-term and long-term path efficiency.",
          "thought": "The new algorithm modifies the provided one by using a different weighting scheme (0.7 for immediate distance and 0.3 for lookahead distance) to prioritize global path optimization, while still considering local proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = 0.7 * immediate_distance + 0.3 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the next node while also considering the potential path to the destination with reduced weight (0.5). It evaluates each unvisited node by balancing local (immediate distance) and global (lookahead to destination) factors, selecting the node with the lowest combined score. The code structure iterates through unvisited nodes, computes a weighted sum of distances, and updates the best candidate dynamically.",
          "thought": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, evaluating not just the immediate next node but also the potential impact on the remaining path to the destination, balancing greedy local optimization with global path considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance + 0.5 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node, weighted lookahead distance to the destination (adjusting dynamically based on remaining unvisited nodes), and a penalty for potential dead-ends (applied only when one node remains). The weight of the lookahead distance increases as more nodes are unvisited, prioritizing global optimization, while the penalty discourages prematurely closing paths.",
          "thought": "The new algorithm enhances the original by incorporating adaptive weighting, where the lookahead factor dynamically adjusts based on the remaining unvisited nodes, and introduces a penalty term for nodes that create potential dead-ends, balancing local and global optimization with a more nuanced scoring mechanism.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Adaptive weighting based on remaining nodes\n        weight = 0.5 + 0.3 * (len(unvisited_nodes) / len(distance_matrix))\n\n        # Penalty for potential dead-end nodes\n        penalty = 0.2 * (immediate_distance + lookahead_distance) if len(unvisited_nodes) == 1 else 0\n\n        score = immediate_distance + weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.62967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted lookahead distance to the destination, with the weight dynamically adjusted based on the proportion of remaining unvisited nodes. It prioritizes global optimization as the tour progresses by increasing the weight of the lookahead distance as fewer nodes remain unvisited. The weight starts at 0.5 and approaches 1 as the remaining nodes decrease, ensuring the algorithm shifts from local to more global decision-making.",
          "thought": "The new algorithm prioritizes nodes by combining immediate distance with a weighted lookahead to the destination, but uses a dynamic weight that adjusts based on the proportion of remaining nodes, favoring global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance + weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.00647,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes lookahead distance (80%) over immediate distance (20%) when selecting the next node, favoring nodes closer to the destination over immediate proximity. It balances exploration (via immediate distance) and exploitation (via lookahead distance) by combining these weighted factors in a score. The function iterates through unvisited nodes, computes the weighted score for each, and selects the node with the lowest score.",
          "thought": "The new algorithm modifies the original by prioritizing lookahead distance with a higher weight (0.8) while reducing the weight of immediate distance (0.2), favoring nodes closer to the destination over immediate proximity, balancing exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = 0.2 * immediate_distance + 0.8 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 10.31116,
          "other_inf": null
     }
]