def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    total_nodes = len(unvisited_nodes) + 1
    remaining_nodes = len(unvisited_nodes)

    # Track revisit counts (simplified for this example)
    revisit_counts = {node: 0 for node in unvisited_nodes}

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Dynamic exploration factor (exponential decay)
        exploration_factor = (0.5 ** (1 - remaining_nodes / total_nodes)) * (remaining_nodes / total_nodes)

        # Probabilistic selection based on inverse distance (scaled by exploration)
        distance_prob = exploration_factor / (immediate_distance + 1e-6)

        # Revisit penalty (grows with revisit count)
        revisit_penalty = 0.1 * (1 / (remaining_nodes + 1)) * (revisit_counts[node] + 1)

        # Heuristic lookahead adjustment (accounts for remaining path length)
        lookahead_adjustment = lookahead_distance / (remaining_nodes + 1)

        # Combined score: probabilistic selection with penalties and adjustments
        score = distance_prob - revisit_penalty - lookahead_adjustment

        if score > best_score:
            best_score = score
            next_node = node

        # Update revisit count for this node
        revisit_counts[node] += 1

    return next_node
