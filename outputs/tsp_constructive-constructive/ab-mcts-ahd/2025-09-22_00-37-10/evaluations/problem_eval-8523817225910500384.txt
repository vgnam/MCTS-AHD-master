import math
import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(unvisited_nodes) + 1

    # Calculate path entropy for diversity
    path_entropy = 0.0
    for node in unvisited_nodes:
        for neighbor in unvisited_nodes:
            if node != neighbor:
                path_entropy += math.log(distance_matrix[node][neighbor] + 1e-10)  # Avoid log(0)
    path_entropy /= (remaining_nodes * (remaining_nodes - 1)) if remaining_nodes > 1 else 1.0

    # Temperature for exploration vs exploitation
    temperature = math.exp(-remaining_nodes / total_nodes)

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Dynamic horizon based on entropy
        horizon = max(1, int(min(3, total_nodes / (path_entropy + 1e-5))))

        # Path diversity term
        diversity = sum(math.exp(-distance_matrix[node][other]) for other in unvisited_nodes if other != node) / remaining_nodes

        # Novel score function
        score = (temperature * (immediate_distance - 0.5 * lookahead_distance) +
                 (1 - temperature) * diversity -
                 0.2 * path_entropy * horizon)

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
