import random
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate centrality for each node (average distance to all other nodes)
    centrality = {}
    n_nodes = len(distance_matrix)
    for node in unvisited_nodes:
        centrality[node] = np.mean([distance_matrix[node][i] for i in range(n_nodes) if i != node])

    # Find top candidates based on both distance and centrality
    candidates = []
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        centrality_score = centrality[node]
        # Combined score: favor nodes that are both close and less central
        score = distance + 0.5 * centrality_score
        candidates.append((node, score))

    # Select top 3 candidates by score
    candidates.sort(key=lambda x: x[1])
    top_candidates = [node for node, _ in candidates[:min(3, len(candidates))]]

    # Weight selection by inverse distance and centrality
    if len(top_candidates) > 1:
        weights = []
        for node in top_candidates:
            distance = distance_matrix[current_node][node]
            centrality_score = centrality[node]
            # Weight inversely proportional to distance and centrality
            weight = 1.0 / (distance + 1e-6) * (1.0 / (centrality_score + 1e-6))
            weights.append(weight)

        weights = [w / sum(weights) for w in weights]
        next_node = random.choices(top_candidates, weights=weights, k=1)[0]
    else:
        next_node = top_candidates[0]

    return next_node
