import random
    import math

    next_node = None
    remaining_nodes = len(unvisited_nodes)
    temperature = max(1.0, 1.0 / remaining_nodes)  # Decreases over time

    if remaining_nodes == 0:
        return destination_node

    scores = []
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Calculate centrality (inverse of degree)
        degree = sum(1 for d in distance_matrix[node] if d > 0)
        centrality = 1.0 / (degree + 1) if degree > 0 else 1.0

        # Weighted score with centrality and temperature
        weight = centrality * temperature
        score = immediate_distance + weight * lookahead_distance
        scores.append((node, score))

    # Select node with softmax-like probabilistic selection
    if not scores:
        return destination_node

    min_score = min(score for _, score in scores)
    adjusted_scores = [(node, math.exp((min_score - score) / temperature)) for node, score in scores]
    total = sum(score for _, score in adjusted_scores)
    probabilities = [score / total for _, score in adjusted_scores]

    next_node = random.choices([node for node, _ in adjusted_scores], weights=probabilities, k=1)[0]

    return next_node
