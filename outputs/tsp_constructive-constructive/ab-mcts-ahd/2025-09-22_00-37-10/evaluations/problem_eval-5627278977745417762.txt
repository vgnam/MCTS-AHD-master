import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    candidate_nodes = []

    # Calculate heuristic values for each unvisited node
    heuristic_values = {}
    for node in unvisited_nodes:
        # Heuristic: inverse of (distance to current node + estimated remaining distance to destination)
        remaining_distance = distance_matrix[node][destination_node] if node != destination_node else 0
        heuristic_values[node] = 1.0 / (distance_matrix[current_node][node] + remaining_distance + 1e-6)

    # Sort nodes by heuristic value in descending order
    sorted_nodes = sorted(unvisited_nodes, key=lambda x: heuristic_values[x], reverse=True)

    # Select top candidates based on heuristic (top 30% or at least 2 nodes)
    num_candidates = max(2, int(0.3 * len(sorted_nodes)))
    candidate_nodes = sorted_nodes[:num_candidates]

    # Weight nodes based on heuristic and distance
    weights = []
    for node in candidate_nodes:
        distance_weight = 1.0 / (distance_matrix[current_node][node] + 1e-6)
        heuristic_weight = heuristic_values[node]
        combined_weight = 0.6 * heuristic_weight + 0.4 * distance_weight
        weights.append(combined_weight)

    # Normalize weights
    weights = [w / sum(weights) for w in weights]

    # Select next node probabilistically
    next_node = random.choices(candidate_nodes, weights=weights, k=1)[0]

    return next_node
