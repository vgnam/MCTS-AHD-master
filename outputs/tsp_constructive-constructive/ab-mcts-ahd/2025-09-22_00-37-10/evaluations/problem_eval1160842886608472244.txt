def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('inf')
    remaining_nodes = len(unvisited_nodes)
    candidates = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]
        weight = 1.0 / (1.0 + remaining_nodes ** 2)  # Non-linear dynamic weight
        detour_penalty = (immediate_distance + lookahead_distance - distance_matrix[current_node][destination_node]) ** 2  # Penalize detours
        score = immediate_distance + weight * lookahead_distance + 0.1 * detour_penalty

        candidates.append((node, score))

    if not candidates:
        return None

    # Probabilistic selection: higher scores get exponentially lower probabilities
    candidates.sort(key=lambda x: x[1])
    probabilities = [math.exp(-i * 0.5) for i in range(len(candidates))]
    probabilities = [p / sum(probabilities) for p in probabilities]
    selected = random.choices([c[0] for c in candidates], weights=probabilities, k=1)[0]

    return next_node
