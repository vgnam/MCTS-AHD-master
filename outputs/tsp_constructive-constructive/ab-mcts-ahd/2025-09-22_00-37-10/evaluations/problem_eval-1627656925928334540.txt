def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    alpha = 0.5 * (remaining_nodes / total_nodes)  # Decreases as more nodes are visited
    beta = 0.3 * (1 - remaining_nodes / total_nodes)  # Increases as more nodes are visited
    temperature = 1.0 - (remaining_nodes / total_nodes)  # Increases as more nodes are visited

    scores = []
    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Calculate centrality: average distance to all other unvisited nodes
        centrality = 0.0
        for other_node in unvisited_nodes:
            if other_node != node:
                centrality += distance_matrix[node][other_node]
        centrality /= max(1, remaining_nodes - 1)  # Avoid division by zero

        # Novel score calculation with probabilistic component
        score = (immediate_distance + alpha * lookahead_distance) / (1 + beta * centrality)
        score = score * (1 - temperature) + (temperature * (1 / (1 + immediate_distance)))  # Add stochasticity
        scores.append((node, score))

    # Select node with highest score (higher scores are better)
    if scores:
        # Sort by score in descending order
        scores.sort(key=lambda x: x[1], reverse=True)
        # Select top node or a random node with probability proportional to rank
        if temperature > 0.5:
            # Higher temperature: more randomness
            weights = [1.0 / (i + 1) for i in range(len(scores))]
            total_weight = sum(weights)
            weights = [w / total_weight for w in weights]
            next_node = random.choices([s[0] for s in scores], weights=weights, k=1)[0]
        else:
            # Lower temperature: deterministic selection
            next_node = scores[0][0]

    return next_node
