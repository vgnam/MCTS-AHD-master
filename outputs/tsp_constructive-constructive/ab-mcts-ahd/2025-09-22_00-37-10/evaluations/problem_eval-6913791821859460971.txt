def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    total_nodes = len(unvisited_nodes) + 1
    progress_ratio = 1 - (len(unvisited_nodes) / total_nodes)

    # Calculate node centrality (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node]) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Dynamic weight adjustment based on progress and centrality
        base_weight = 0.5 + 0.5 * (1 - progress_ratio)
        centrality_weight = 0.3 * (centrality[node] / max(centrality.values())) if centrality else 0.3

        # Novel scoring function combining multiple factors
        score = (base_weight * immediate_distance +
                 (1 - base_weight) * lookahead_distance -
                 centrality_weight * immediate_distance)

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
