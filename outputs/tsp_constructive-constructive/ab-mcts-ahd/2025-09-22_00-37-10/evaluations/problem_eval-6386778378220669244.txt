import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate dynamic weights
    weights = []
    temperature = 1.0 / (1 + len(unvisited_nodes))  # Cooling temperature

    for node in unvisited_nodes:
        dist_to_current = distance_matrix[current_node][node]
        dist_to_dest = distance_matrix[node][destination_node]

        # Normalize destination distance
        max_dist = max(distance_matrix[node]) if distance_matrix[node] else 1.0
        normalized_dist_to_dest = dist_to_dest / max_dist if max_dist > 0 else 0.0

        # Combined weight
        weight = (1.0 / (dist_to_current + 1e-6)) * (1.0 - normalized_dist_to_dest)
        weights.append(weight)

    # Apply temperature-based softmax
    exp_weights = [math.exp(w / temperature) for w in weights]
    sum_exp = sum(exp_weights)
    probs = [ew / sum_exp for ew in exp_weights]

    # Select node with weighted probability
    next_node = random.choices(unvisited_nodes, weights=probs, k=1)[0]

    return next_node
