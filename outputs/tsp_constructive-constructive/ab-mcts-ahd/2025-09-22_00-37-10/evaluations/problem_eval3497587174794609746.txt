import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    alpha = 0.4 * (remaining_nodes / total_nodes)  # Decreases as more nodes are visited
    beta = 0.6 * (1 - remaining_nodes / total_nodes)  # Increases as more nodes are visited
    gamma = 0.2 * (1 - remaining_nodes / total_nodes)  # Increases as more nodes are visited

    scores = []
    novelty_scores = []

    for node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][node]
        lookahead_distance = distance_matrix[node][destination_node]

        # Calculate centrality: average distance to all other unvisited nodes
        centrality = 0.0
        for other_node in unvisited_nodes:
            if other_node != node:
                centrality += distance_matrix[node][other_node]
        centrality /= max(1, remaining_nodes - 1)  # Avoid division by zero

        # Novelty score: inversely proportional to how often this node has been selected (simplified)
        novelty = 1.0 / (1 + sum(1 for n in unvisited_nodes if n == node))  # Placeholder for actual tracking

        # Combined score
        score = (immediate_distance + alpha * lookahead_distance) / (1 + beta * centrality + gamma * novelty)
        scores.append(score)
        novelty_scores.append(novelty)

    # Convert scores to probabilities using softmax
    exp_scores = np.exp(-np.array(scores))  # Lower scores are better
    probabilities = exp_scores / np.sum(exp_scores)

    # Select node based on probabilities
    next_node = np.random.choice(unvisited_nodes, p=probabilities)

    return next_node
