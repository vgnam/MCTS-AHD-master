import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    candidate_nodes = []
    scores = []

    for node in unvisited_nodes:
        dist_to_current = distance_matrix[current_node][node]
        dist_to_dest = distance_matrix[node][destination_node]
        dist_current_to_dest = distance_matrix[current_node][destination_node]

        # Hybrid score combining multiple criteria
        if dist_current_to_dest == 0:
            score = 1.0 / (dist_to_current + 1e-6)
        else:
            position_score = (dist_current_to_dest - dist_to_current) / dist_current_to_dest
            score = (1.0 / (dist_to_current + 1e-6)) * (1.0 / (dist_to_dest + 1e-6)) * (1.0 + position_score)

        scores.append(score)
        candidate_nodes.append(node)

    # Dynamic weight adjustment based on node diversity
    if len(candidate_nodes) > 1:
        max_score = max(scores)
        min_score = min(scores)
        score_range = max_score - min_score if max_score != min_score else 1.0

        # Normalize and apply non-linear transformation
        weights = [(s - min_score) / score_range for s in scores]
        weights = [math.exp(w) for w in weights]
        weights = [w / sum(weights) for w in weights]

        next_node = random.choices(candidate_nodes, weights=weights, k=1)[0]
    else:
        next_node = candidate_nodes[0] if candidate_nodes else None

    return next_node
