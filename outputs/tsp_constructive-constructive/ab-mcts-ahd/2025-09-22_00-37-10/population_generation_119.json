[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by prioritizing nodes closer to the destination (destination proximity) more aggressively, using an exponential decay function (`bias_factor`) that decreases rapidly as more nodes are visited. The `bias_factor` is calculated as `(len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)`, ensuring higher emphasis on destination proximity early in the search. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing local (current node) and global (destination) optimization dynamically.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by adjusting the bias factor to prioritize nodes closer to the destination more aggressively, using an exponential decay function that decreases the bias factor rapidly as more nodes are visited, ensuring a balance between local and global optimization with a stronger emphasis on destination proximity early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term and long-term efficiency by combining immediate distance to the next node with a weighted lookahead distance to the destination, where the weight dynamically adjusts based on the number of remaining unvisited nodes. It prioritizes immediate gains when nodes are few but increasingly values long-term efficiency as the problem size grows, ensuring adaptability to different stages of the TSP solution. The scoring mechanism (`immediate_distance - weight * lookahead_distance`) ensures a trade-off between proximity and strategic planning.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the strategic planning of No.1, using a weight that starts high (prioritizing immediate gains) and decreases as remaining nodes grow, while also incorporating a lookahead distance component to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))) / (1.0 + remaining_nodes)\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.87636,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate and long-term distances by combining a static weight (0.5) with a dynamic weight that adjusts based on remaining unvisited nodes, prioritizing strategic planning while adapting to the remaining path length. The score for each node is calculated as `immediate_distance - weight * lookahead_distance`, where the dynamic weight increases as the number of remaining nodes decreases, ensuring a trade-off between short-term and long-term efficiency. The algorithm selects the node with the lowest score, favoring nodes that reduce immediate distance while keeping long-term distance manageable.",
          "thought": "The new algorithm combines the static weight (0.5) from No.1 with the dynamic weight adjustment from No.2, prioritizing strategic planning while adapting to the remaining nodes, ensuring lower objective values by balancing immediate and long-term distances effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    base_weight = 0.5\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = base_weight + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91658,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and destination distance, with the weight for destination distance decreasing as more nodes are visited. It prioritizes minimizing immediate distance while adaptively reducing focus on the destination, ensuring a trade-off between local and global optimization. The weight parameter dynamically adjusts based on the number of remaining unvisited nodes, with higher weights early on to guide toward the destination and lower weights later to refine local paths.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the balanced scoring approach of No.2, using a weighted sum of immediate distance and destination distance where the weight for destination distance decreases as more nodes are visited, ensuring adaptive focus between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        remaining_nodes = len(unvisited_nodes)\n        weight = 0.5 * (1.0 / (1.0 + remaining_nodes))\n        score = -immediate_distance + weight * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96694,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm adapts the nearest-neighbor heuristic by dynamically balancing the immediate distance to the next node with the potential gain toward the destination, using an exponentially decreasing bias factor that prioritizes minimizing the current distance early on and gradually incorporates the destination distance as more nodes are visited. The score is computed as `-current_distance + exp(-len(unvisited_nodes)) * dest_distance`, where the bias factor shifts focus from global to local optimization.",
          "thought": "The new algorithm adapts the nearest-neighbor heuristic by dynamically balancing the immediate distance to the next node with the potential gain toward the destination, using an exponential bias factor that heavily prioritizes minimizing the current distance while gradually incorporating the destination distance as more nodes are visited. The score is computed as `-current_distance + exp(-len(unvisited_nodes)) * dest_distance`, where the bias factor decreases exponentially to shift the focus back to local optimization.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = math.exp(-len(unvisited_nodes))\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9966,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing the shortest available edge from the current node to an unvisited node. It iteratively selects the next node by minimizing the distance from the current node, ensuring a greedy, constructive path. The code efficiently checks all unvisited nodes, comparing their distances to the current node, and returns the closest one. The `destination_node` is unused, indicating the heuristic does not explicitly optimize for the final return path.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance to the current node, ensuring the path remains efficient and constructive.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     }
]