[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by prioritizing immediate distance (heavily weighted) while balancing destination proximity and a lookahead term (average distance to remaining nodes), with a bias factor that adjusts based on progress (early: more exploration, late: more exploitation). The scoring function (`-2 * current_distance + bias_factor * (dest_distance + 0.3 * lookahead_term)`) ensures short-term efficiency, while the bias factor and lookahead term introduce adaptability.",
          "thought": "The new algorithm enhances the original by introducing a dynamic bias factor that adapts based on the progress ratio (visited nodes vs. total nodes) and incorporates a lookahead mechanism to evaluate the potential impact of choosing a node on future steps, using a weighted score combining immediate distance, destination proximity, and a lookahead term that estimates the average distance to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 to include current_node if considering progress\n    progress_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        # Calculate lookahead term: average distance to remaining nodes\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        lookahead_term = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic bias factor: decreases as progress increases\n        bias_factor = (1 - progress_ratio) * 0.5 + 0.5  # Ranges from 0.5 (early) to 1.0 (late)\n\n        # Weighted score: current_distance is heavily weighted, dest_distance and lookahead are balanced\n        score = -2 * current_distance + bias_factor * (dest_distance + 0.3 * lookahead_term)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43789,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by prioritizing immediate distance (higher weight) while incorporating a weighted average of future distances (lower weight), with the exploration factor adjusting based on remaining nodes to ensure a balance between greedy and exploratory behavior. The score calculation (`-current_distance + exploration_factor * avg_future_distance`) ensures closer nodes are preferred early on, while the exploration factor (`remaining_nodes / (remaining_nodes + 2)`) ensures global considerations remain relevant as the tour progresses.",
          "thought": "The new algorithm introduces a dynamic exploration factor that adjusts based on the remaining nodes, blending immediate distance with a weighted average of distances to unvisited nodes, creating a more balanced trade-off between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        exploration_factor = remaining_nodes / (remaining_nodes + 2)\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n        score = -current_distance + exploration_factor * avg_future_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.44632,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances short-term (immediate distance) and long-term (lookahead distance) priorities by combining a non-linear dynamic weight (decreasing with remaining nodes) and a fixed weight (0.5) for strategic planning. It prioritizes immediate distances more as the number of remaining nodes decreases, while still considering long-term potential, avoiding premature convergence by adjusting weights dynamically. The `score` calculation ensures the next node is chosen based on a trade-off between proximity and potential future gains.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate and lookahead distances using a non-linear, decreasing function of remaining nodes, combined with a fixed weight (0.5) for strategic planning, to prioritize both short-term gains and long-term potential while avoiding premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 / (1.0 + remaining_nodes ** 0.5)  # Non-linear dynamic weight\n        fixed_weight = 0.5  # Fixed weight for strategic planning\n        score = immediate_distance - (dynamic_weight + fixed_weight) * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48076,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance, lookahead distance to the destination, and a penalty for long steps, with a weight that increases as progress is made (favoring exploitation over exploration). The score prioritizes shorter immediate steps and penalizes revisiting nodes, while the dynamic weight ensures early exploration and later exploitation. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the lowest score.",
          "thought": "The new algorithm enhances the original by introducing dynamic weight adjustment based on the remaining unvisited nodes, incorporating a penalty for revisiting nodes, and using a heuristic that combines immediate distance, lookahead distance, and a penalty term to balance exploration and exploitation in path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 + 0.5 * (1 - remaining_nodes / (remaining_nodes + 1))  # Dynamic weight based on progress\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        penalty = 0.1 * (1 / (1 + distance_matrix[current_node][node]))  # Penalty for long immediate steps\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48098,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate gains early by dynamically adjusting weights based on remaining nodes, balancing short-term distances (immediate_distance) with long-term strategic planning (lookahead_distance) using a non-linear weight (1.0/(1.0 + remaining_nodes) + 0.5). The score function `immediate_distance - weight * lookahead_distance` ensures shorter-term distances dominate early, while the weight gradually shifts focus to long-term planning as remaining nodes decrease.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 with a fixed weight from No.2, but introduces a non-linear weight that increases with the number of remaining nodes to prioritize immediate gains early and strategic planning later, while ensuring a balanced consideration of short-term and long-term distances throughout the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted lookahead distance to the destination, with the weight dynamically adjusted to prioritize immediate distances early (higher weight) and balance with lookahead later (lower weight), while also incorporating a fixed component (`0.5`) to ensure strategic planning. The score is minimized (`immediate_distance - weight * lookahead_distance`), favoring nodes closer to the current node and, to a diminishing extent, closer to the destination. The weight function (`(1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5`) ensures a smooth transition from immediate to lookahead focus.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate and lookahead distances using a non-linear weight function that prioritizes immediate distances early and balances with lookahead distances later, while also incorporating a fixed weight component to ensure strategic planning throughout the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48674,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the current node while dynamically balancing it with a weighted lookahead distance to the destination, using a hybrid scoring function that adapts weights based on the number of remaining nodes. The weight starts at 0.5 and increases slightly with fewer remaining nodes, ensuring a trade-off between proximity and strategic planning. The code iterates through unvisited nodes, computes the score, and selects the node with the lowest score, effectively minimizing both immediate and long-term travel costs.",
          "thought": "The new algorithm combines the dynamic weight adaptation from No.1, the fixed weight balance from No.3, and the immediate distance prioritization from No.2, using a hybrid scoring function (immediate_distance - (0.5 + 0.2 * (1.0 / (1.0 + remaining_nodes))) * lookahead_distance) to dynamically balance proximity to the current node and strategic planning toward the destination, ensuring lower objective values.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.2 * (1.0 / (1.0 + remaining_nodes))  # Hybrid dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48951,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term distances, prioritizing short-term gains early in the search (high weight for lookahead) and long-term proximity as the destination nears (lower weight). It penalizes nodes too close to the current position to avoid revisiting them prematurely, using a penalty term based on immediate distance. The score is computed as `immediate_distance - weight * lookahead_distance + penalty`, favoring nodes that minimize this metric.",
          "thought": "The new algorithm introduces a dynamic weight mechanism that adjusts the balance between immediate and lookahead distances based on the number of remaining unvisited nodes, gradually shifting focus from short-term gains to long-term proximity as the destination is approached. It also incorporates a penalty term for nodes that are too close to the current node to avoid revisiting them prematurely.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + 0.5 * (1 - num_unvisited / (num_unvisited + 1))\n\n        # Penalty for nodes too close to current node\n        penalty = 0.2 * immediate_distance if immediate_distance < 0.1 * distance_matrix[current_node][destination_node] else 0\n\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49145,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted lookahead distance to the destination, using a dynamically adjusted weight that prioritizes lookahead as more nodes remain unvisited. The bias factor decreases over time to shift focus from global optimization (early stages) to local optimization (later stages), with the score function favoring nodes that minimize immediate distance while considering future steps. The weight formula (`1.0 / (1.0 + remaining_nodes) + 0.5`) ensures higher lookahead influence early on.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the bias factor from No.2, using a non-linear weight that balances immediate distance with lookahead distance, while the bias factor decreases as more nodes are visited to shift focus from global to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        bias_factor = remaining_nodes / (remaining_nodes + 1)  # Decreasing bias\n        score = -immediate_distance + bias_factor * (weight * lookahead_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing immediate distance with decreasing emphasis on lookahead as the tour progresses) and a bias factor (balancing global and local optimization) to select the next node. It penalizes revisits slightly and uses a weighted score to balance immediate and lookahead distances, favoring closer nodes early while maintaining some lookahead consideration. The bias factor decreases as nodes are visited, shifting focus from global optimization to local optimization.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the bias factor from No.2, using a weighted score that balances immediate distance, lookahead distance, and a penalty for revisits, while the bias factor decreases as the tour progresses to shift focus from global optimization to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        remaining_nodes = len(unvisited_nodes)\n\n        # Dynamic weight based on remaining nodes (similar to No.1)\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Bias factor decreasing as nodes are visited (similar to No.2)\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n\n        # Penalty for revisits (similar to No.1)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        # Combined score: prioritize immediate distance, balance lookahead, and penalize revisits\n        score = -immediate_distance + bias_factor * (weight * lookahead_distance) - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50535,
          "other_inf": null
     }
]