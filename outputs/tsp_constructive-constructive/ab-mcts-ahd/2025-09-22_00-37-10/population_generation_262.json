[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing distance minimization and destination proximity, using a bias factor that prioritizes shorter current distances while accounting for angular deviation between current and destination paths. The scoring mechanism combines `-current_distance` (minimizing immediate distance) and `bias_factor * (dest_distance - angular_deviation * current_distance)` (prioritizing nodes closer to the destination while penalizing large angular deviations), with the bias factor decreasing as more nodes are visited.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a dynamic bias factor that prioritizes both minimizing the current distance and maximizing the potential gain toward the destination, using a novel scoring mechanism that combines distance and angular deviation to better handle node selection in complex TSP instances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        angular_deviation = abs(current_distance - dest_distance) / (current_distance + dest_distance)\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 1)) ** 2\n        score = -current_distance + bias_factor * (dest_distance - angular_deviation * current_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global optimization by prioritizing immediate distance reduction early in the tour (using `immediate_distance`) while gradually shifting focus to lookahead distance (using `lookahead_distance`) as the tour progresses, controlled by a quadratically increasing `bias_factor`. The `bias_factor` starts at 0.5 and grows as more nodes are visited, balancing local and global decisions. The `score` function weighs these factors dynamically, favoring shorter immediate paths early but increasingly considering global completion as the tour advances.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 (balancing local and global optimization) with the weighted lookahead approach from No.2 (prioritizing global optimization as the tour progresses). The bias factor starts at 0.5 and increases quadratically as more nodes are visited, while the weight for the lookahead distance decreases, shifting from global to local decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 + 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1))) ** 2\n        score = -immediate_distance + bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate and lookahead distances dynamically (weighted by remaining nodes) while penalizing frequently visited nodes to encourage exploration, prioritizing immediate distance over lookahead distance with a penalty term for revisits. The weight adjusts aggressively as the tour progresses, favoring immediate distances early and lookahead distances later. The penalty term reduces revisits but is outweighed by distance considerations.",
          "thought": "The new algorithm introduces a dynamic weight mechanism that adjusts based on the number of remaining unvisited nodes, blending immediate and lookahead distances more aggressively as the tour progresses, while incorporating a penalty term for nodes that have been visited more frequently in previous iterations to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Penalty for nodes visited more frequently (simulated here for exploration)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term path optimization by combining local distance (immediate) with a scaled lookahead distance (global), where the scaling factor adapts inversely to node centrality (average distance to all nodes). Nodes with higher centrality (closer to the graph center) have their lookahead influence reduced, prioritizing local optimality, while a probabilistic element based on remaining nodes further refines selection. The score function prioritizes minimizing immediate distance while dynamically weighting long-term potential, with the scaling factor adjusting for node importance.",
          "thought": "The new algorithm extends the original by introducing a dynamic lookahead scaling factor that adapts based on the node's centrality in the graph, measured by its average distance to all other nodes, and combines this with a probabilistic selection mechanism weighted by the node's local optimality and global potential, creating a balance between immediate and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate node centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        dynamic_weight = 1.0 / (centrality + 1)  # Higher centrality reduces lookahead influence\n\n        # Combine immediate and lookahead with dynamic weight\n        score = -immediate_distance + dynamic_weight * lookahead_distance\n\n        # Add probabilistic element based on relative score\n        if remaining_nodes > 1:\n            score *= (1.0 + (0.1 * (remaining_nodes / total_nodes)))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distances more aggressively by assigning a 0.7 weight to the lookahead distance, balancing short-term gains with long-term proximity to the destination. It selects the next node by minimizing the score, where the score is computed as `immediate_distance - 0.7 * lookahead_distance`, effectively favoring nodes that are both close to the current node and closer to the destination. The function iterates through unvisited nodes, evaluates each candidate based on this weighted score, and returns the node with the lowest score.",
          "thought": "The new algorithm modifies the scoring equation to prioritize immediate distances more aggressively by increasing the weight of the lookahead distance to 0.7, balancing short-term gains with a stronger consideration of long-term proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.7  # Increased weight to prioritize longer-term proximity\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node and lookahead distance to the destination, weighted by a static factor (0.5) and a dynamic bias that adapts based on the number of remaining unvisited nodes. Higher priority is given to minimizing the immediate distance (current_distance), while the lookahead distance (dest_distance) is weighted by the dynamic bias, which decreases as more nodes are visited, favoring strategic planning in later stages. The score is calculated as `-current_distance + bias_factor * (weight * dest_distance)`, ensuring the algorithm adapts between greediness and foresight.",
          "thought": "The new algorithm combines the static weight from No.1 with the dynamic bias factor from No.2, using a weighted score that balances immediate distance and lookahead distance while adapting the bias factor to prioritize strategic planning as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight = 0.5  # Static weight from No.1\n    bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic bias from No.2\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        score = -current_distance + bias_factor * (weight * dest_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **dynamic bias factor** (exponentially decaying from 0.5) and a **weighted lookahead approach** (starting at 0.5 and increasing as remaining nodes decrease) to balance local (immediate distance) and global (lookahead to destination) optimization. The score prioritizes **shorter immediate distances** (with bias) over **longer lookahead distances**, adjusting weights dynamically based on remaining nodes. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead approach from No.2, where the bias factor decays exponentially to balance local and global optimization, and the weight starts at 0.5 and increases as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / (remaining_nodes + 1))\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance * (1 + bias_factor) + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5525,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term distances, prioritizing closer nodes when many remain (weighted by the proportion of unvisited nodes) and penalizing nodes too far from the destination, ensuring feasible paths while optimizing for efficiency. The weight adjusts between 0.5 and 1.0, favoring immediate distances early and long-term proximity later, while penalties discourage extreme detours. The score combines immediate distance, weighted lookahead distance, and a penalty term to select the next node.",
          "thought": "The new algorithm introduces a dynamic weight mechanism that adjusts the balance between immediate and lookahead distances based on the proportion of unvisited nodes, favoring closer nodes when many remain, while emphasizing long-term proximity when fewer nodes are left. It also incorporates a penalty term for nodes that are too far from the destination, ensuring the path remains feasible.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n    max_distance = max(max(row) for row in distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + 0.5 * (1 - total_unvisited / len(distance_matrix))\n\n        # Penalty for nodes too far from destination\n        penalty = 0.1 * (lookahead_distance / max_distance) if lookahead_distance > 0.7 * max_distance else 0\n\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58967,
          "other_inf": null
     }
]