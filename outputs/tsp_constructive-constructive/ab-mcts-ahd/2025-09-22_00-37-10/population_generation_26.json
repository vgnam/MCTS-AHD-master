[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distances while dynamically balancing this with lookahead distances to the destination, using a weight that decreases as the number of remaining unvisited nodes grows, favoring immediate gains early and strategic planning later. The critical design idea is the dynamic weight (1.0 / (1.0 + remaining_nodes)), which adapts the balance between immediate distance (higher priority) and lookahead distance (lower priority) as the algorithm progresses. The score function (`immediate_distance - weight * lookahead_distance`) ensures the algorithm selects nodes that offer the best short-term gains while not ignoring long-term potential.",
          "thought": "The new algorithm prioritizes nodes that minimize the immediate distance while maximizing the potential reduction in remaining path length, using a dynamic weighting factor that adapts based on the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for TSP, prioritizing the shortest available edge from the current node to an unvisited node. It iteratively selects the next node by minimizing the distance from the current node, ensuring a greedy, constructive path. The code efficiently checks all unvisited nodes, comparing their distances to the current node, and returns the closest one. The `destination_node` is unused, indicating the heuristic does not explicitly optimize for the final return path.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node with the shortest distance to the current node, ensuring the path remains efficient and constructive.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **adaptive lookahead weighting** (prioritizing strategic planning via `weight`) and **dynamic weight adjustment** (balancing immediate and long-term distances via `dynamic_weight`), while applying a **dead-end penalty** (penalizing premature closure of paths via `penalty`). The score prioritizes immediate distances (`immediate_distance`) heavily at the start but gradually shifts focus to strategic lookahead (`lookahead_distance`), with penalties applied when only one node remains. The adaptive `weight` and `dynamic_weight` ensure flexibility, while the `penalty` acts as a safeguard against suboptimal dead-ends.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.2 with the adaptive lookahead weighting and dead-end penalty of No.1, creating a hybrid approach that balances immediate and strategic planning while penalizing premature path closure.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.3 * (remaining_nodes / len(distance_matrix))  # Adaptive lookahead weight\n        penalty = 0.2 * (immediate_distance + lookahead_distance) if remaining_nodes == 1 else 0  # Dead-end penalty\n        dynamic_weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight from No.2\n        score = immediate_distance + dynamic_weight * weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.11585,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and a lookahead distance to the destination, scaled by a dynamic weight inversely proportional to the number of remaining unvisited nodes. This prioritizes immediate distance when few nodes remain (high weight) and balances exploration and exploitation by adjusting the lookahead influence dynamically. The code iteratively evaluates all unvisited nodes using this weighted score to determine the next step in the path.",
          "thought": "The new algorithm enhances the original by incorporating a dynamic weighting factor that adjusts based on the remaining unvisited nodes, combining immediate distance with a lookahead component scaled by a factor inversely proportional to the number of unvisited nodes, thereby balancing exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 / (remaining_nodes + 1)  # Avoid division by zero\n        score = immediate_distance + dynamic_weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (higher priority) and closeness to the destination (lower priority, weighted by 0.3), minimizing detours while guiding the path toward the destination. It iterates through unvisited nodes, computes a weighted score combining these distances, and chooses the node with the lowest score.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and closeness to the destination, aiming to guide the path toward the destination while minimizing local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + 0.3 * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (70% weight) and lookahead distance to the destination (30% weight), prioritizing local proximity while considering global path optimization. The function iterates through unvisited nodes, computes a weighted score, and returns the node with the lowest score, ensuring a trade-off between short-term and long-term path efficiency.",
          "thought": "The new algorithm modifies the provided one by using a different weighting scheme (0.7 for immediate distance and 0.3 for lookahead distance) to prioritize global path optimization, while still considering local proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = 0.7 * immediate_distance + 0.3 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the next node while also considering the potential path to the destination with reduced weight (0.5). It evaluates each unvisited node by balancing local (immediate distance) and global (lookahead to destination) factors, selecting the node with the lowest combined score. The code structure iterates through unvisited nodes, computes a weighted sum of distances, and updates the best candidate dynamically.",
          "thought": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, evaluating not just the immediate next node but also the potential impact on the remaining path to the destination, balancing greedy local optimization with global path considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance + 0.5 * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance, lookahead distance, and node centrality (average distance to unvisited nodes) with time-decaying weights, prioritizing immediate gains early (60% weight) while incorporating strategic planning later (30% weight for lookahead and decaying 10% for centrality). The centrality weight decreases as nodes are visited, reducing its influence over time. The score combines these factors to select the next node, favoring nodes that minimize immediate distance while considering long-term centrality.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, lookahead distance, and a node's centrality (average distance to all unvisited nodes) with a time-decaying weight, favoring immediate gains early while incorporating strategic planning later, and dynamically adjusting centrality influence based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate centrality: average distance to all unvisited nodes\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes\n\n        # Dynamic weight: time-decaying factor for centrality\n        time_decay = 1.0 / (1.0 + remaining_nodes)\n        weight_immediate = 0.6  # Higher priority for immediate distance\n        weight_lookahead = 0.3  # Moderate priority for lookahead\n        weight_centrality = 0.1 * time_decay  # Decaying priority for centrality\n\n        # Score combines immediate, lookahead, and centrality with dynamic weights\n        score = (weight_immediate * immediate_distance +\n                 weight_lookahead * lookahead_distance +\n                 weight_centrality * centrality)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.48988,
          "other_inf": null
     }
]