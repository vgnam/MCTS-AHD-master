[
     {
          "algorithm": "The algorithm prioritizes immediate gains early by dynamically adjusting weights based on remaining nodes, balancing short-term distances (immediate_distance) with long-term strategic planning (lookahead_distance) using a non-linear weight (1.0/(1.0 + remaining_nodes) + 0.5). The score function `immediate_distance - weight * lookahead_distance` ensures shorter-term distances dominate early, while the weight gradually shifts focus to long-term planning as remaining nodes decrease.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 with a fixed weight from No.2, but introduces a non-linear weight that increases with the number of remaining nodes to prioritize immediate gains early and strategic planning later, while ensuring a balanced consideration of short-term and long-term distances throughout the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing immediate distance with decreasing emphasis on lookahead as the tour progresses) and a bias factor (balancing global and local optimization) to select the next node. It penalizes revisits slightly and uses a weighted score to balance immediate and lookahead distances, favoring closer nodes early while maintaining some lookahead consideration. The bias factor decreases as nodes are visited, shifting focus from global optimization to local optimization.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the bias factor from No.2, using a weighted score that balances immediate distance, lookahead distance, and a penalty for revisits, while the bias factor decreases as the tour progresses to shift focus from global optimization to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        remaining_nodes = len(unvisited_nodes)\n\n        # Dynamic weight based on remaining nodes (similar to No.1)\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Bias factor decreasing as nodes are visited (similar to No.2)\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n\n        # Penalty for revisits (similar to No.1)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        # Combined score: prioritize immediate distance, balance lookahead, and penalize revisits\n        score = -immediate_distance + bias_factor * (weight * lookahead_distance) - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50535,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing distance minimization and destination proximity, using a bias factor that prioritizes shorter current distances while accounting for angular deviation between current and destination paths. The scoring mechanism combines `-current_distance` (minimizing immediate distance) and `bias_factor * (dest_distance - angular_deviation * current_distance)` (prioritizing nodes closer to the destination while penalizing large angular deviations), with the bias factor decreasing as more nodes are visited.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a dynamic bias factor that prioritizes both minimizing the current distance and maximizing the potential gain toward the destination, using a novel scoring mechanism that combines distance and angular deviation to better handle node selection in complex TSP instances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        angular_deviation = abs(current_distance - dest_distance) / (current_distance + dest_distance)\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 1)) ** 2\n        score = -current_distance + bias_factor * (dest_distance - angular_deviation * current_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global optimization by prioritizing immediate distance reduction early in the tour (using `immediate_distance`) while gradually shifting focus to lookahead distance (using `lookahead_distance`) as the tour progresses, controlled by a quadratically increasing `bias_factor`. The `bias_factor` starts at 0.5 and grows as more nodes are visited, balancing local and global decisions. The `score` function weighs these factors dynamically, favoring shorter immediate paths early but increasingly considering global completion as the tour advances.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 (balancing local and global optimization) with the weighted lookahead approach from No.2 (prioritizing global optimization as the tour progresses). The bias factor starts at 0.5 and increases quadratically as more nodes are visited, while the weight for the lookahead distance decreases, shifting from global to local decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 + 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1))) ** 2\n        score = -immediate_distance + bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing immediate distance, lookahead distance, and an exploration factor, where immediate distance is prioritized (1.2 weight), lookahead distance is less prioritized (-0.7 weight), and the exploration factor (dynamic weight) adjusts based on remaining nodes to favor exploration when few nodes are left. The scoring mechanism combines these factors to guide the selection toward shorter-term gains while dynamically adjusting for global path potential.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a weighted sum of immediate distance, lookahead distance, and a novel \"exploration factor\" that balances between immediate gains and long-term potential paths, using a dynamic weight that adjusts based on the size of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    # Dynamic weight based on remaining nodes\n    exploration_weight = 1.0 - (0.8 * len(unvisited_nodes) / len(distance_matrix))\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Novel scoring: weighted sum with exploration factor\n        score = (1.2 * immediate_distance) - (0.7 * lookahead_distance) + (exploration_weight * (immediate_distance - lookahead_distance))\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate and lookahead distances dynamically (weighted by remaining nodes) while penalizing frequently visited nodes to encourage exploration, prioritizing immediate distance over lookahead distance with a penalty term for revisits. The weight adjusts aggressively as the tour progresses, favoring immediate distances early and lookahead distances later. The penalty term reduces revisits but is outweighed by distance considerations.",
          "thought": "The new algorithm introduces a dynamic weight mechanism that adjusts based on the number of remaining unvisited nodes, blending immediate and lookahead distances more aggressively as the tour progresses, while incorporating a penalty term for nodes that have been visited more frequently in previous iterations to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Penalty for nodes visited more frequently (simulated here for exploration)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term path optimization by combining local distance (immediate) with a scaled lookahead distance (global), where the scaling factor adapts inversely to node centrality (average distance to all nodes). Nodes with higher centrality (closer to the graph center) have their lookahead influence reduced, prioritizing local optimality, while a probabilistic element based on remaining nodes further refines selection. The score function prioritizes minimizing immediate distance while dynamically weighting long-term potential, with the scaling factor adjusting for node importance.",
          "thought": "The new algorithm extends the original by introducing a dynamic lookahead scaling factor that adapts based on the node's centrality in the graph, measured by its average distance to all other nodes, and combines this with a probabilistic selection mechanism weighted by the node's local optimality and global potential, creating a balance between immediate and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate node centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        dynamic_weight = 1.0 / (centrality + 1)  # Higher centrality reduces lookahead influence\n\n        # Combine immediate and lookahead with dynamic weight\n        score = -immediate_distance + dynamic_weight * lookahead_distance\n\n        # Add probabilistic element based on relative score\n        if remaining_nodes > 1:\n            score *= (1.0 + (0.1 * (remaining_nodes / total_nodes)))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distances more aggressively by assigning a 0.7 weight to the lookahead distance, balancing short-term gains with long-term proximity to the destination. It selects the next node by minimizing the score, where the score is computed as `immediate_distance - 0.7 * lookahead_distance`, effectively favoring nodes that are both close to the current node and closer to the destination. The function iterates through unvisited nodes, evaluates each candidate based on this weighted score, and returns the node with the lowest score.",
          "thought": "The new algorithm modifies the scoring equation to prioritize immediate distances more aggressively by increasing the weight of the lookahead distance to 0.7, balancing short-term gains with a stronger consideration of long-term proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.7  # Increased weight to prioritize longer-term proximity\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54925,
          "other_inf": null
     }
]