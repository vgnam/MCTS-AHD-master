[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global optimization by prioritizing immediate distance reduction early in the tour (using `immediate_distance`) while gradually shifting focus to lookahead distance (using `lookahead_distance`) as the tour progresses, controlled by a quadratically increasing `bias_factor`. The `bias_factor` starts at 0.5 and grows as more nodes are visited, balancing local and global decisions. The `score` function weighs these factors dynamically, favoring shorter immediate paths early but increasingly considering global completion as the tour advances.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 (balancing local and global optimization) with the weighted lookahead approach from No.2 (prioritizing global optimization as the tour progresses). The bias factor starts at 0.5 and increases quadratically as more nodes are visited, while the weight for the lookahead distance decreases, shifting from global to local decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 + 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1))) ** 2\n        score = -immediate_distance + bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and long-term path optimization by combining local distance (immediate) with a scaled lookahead distance (global), where the scaling factor adapts inversely to node centrality (average distance to all nodes). Nodes with higher centrality (closer to the graph center) have their lookahead influence reduced, prioritizing local optimality, while a probabilistic element based on remaining nodes further refines selection. The score function prioritizes minimizing immediate distance while dynamically weighting long-term potential, with the scaling factor adjusting for node importance.",
          "thought": "The new algorithm extends the original by introducing a dynamic lookahead scaling factor that adapts based on the node's centrality in the graph, measured by its average distance to all other nodes, and combines this with a probabilistic selection mechanism weighted by the node's local optimality and global potential, creating a balance between immediate and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate node centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node]) / (total_nodes - 1)\n        dynamic_weight = 1.0 / (centrality + 1)  # Higher centrality reduces lookahead influence\n\n        # Combine immediate and lookahead with dynamic weight\n        score = -immediate_distance + dynamic_weight * lookahead_distance\n\n        # Add probabilistic element based on relative score\n        if remaining_nodes > 1:\n            score *= (1.0 + (0.1 * (remaining_nodes / total_nodes)))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54567,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node and lookahead distance to the destination, weighted by a static factor (0.5) and a dynamic bias that adapts based on the number of remaining unvisited nodes. Higher priority is given to minimizing the immediate distance (current_distance), while the lookahead distance (dest_distance) is weighted by the dynamic bias, which decreases as more nodes are visited, favoring strategic planning in later stages. The score is calculated as `-current_distance + bias_factor * (weight * dest_distance)`, ensuring the algorithm adapts between greediness and foresight.",
          "thought": "The new algorithm combines the static weight from No.1 with the dynamic bias factor from No.2, using a weighted score that balances immediate distance and lookahead distance while adapting the bias factor to prioritize strategic planning as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight = 0.5  # Static weight from No.1\n    bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic bias from No.2\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        score = -current_distance + bias_factor * (weight * dest_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **dynamic bias factor** (exponentially decaying from 0.5) and a **weighted lookahead approach** (starting at 0.5 and increasing as remaining nodes decrease) to balance local (immediate distance) and global (lookahead to destination) optimization. The score prioritizes **shorter immediate distances** (with bias) over **longer lookahead distances**, adjusting weights dynamically based on remaining nodes. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead approach from No.2, where the bias factor decays exponentially to balance local and global optimization, and the weight starts at 0.5 and increases as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / (remaining_nodes + 1))\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance * (1 + bias_factor) + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5525,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor with a dynamic bias factor, prioritizing local optimization (minimizing `current_distance`) early in the search and gradually shifting toward global optimization (maximizing `dest_distance`) as more nodes are visited. The bias factor decreases quadratically with the number of unvisited nodes, balancing immediate distance and potential gain toward the destination.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that prioritizes local optimization early in the search and gradually shifts focus toward global optimization, balancing immediate distance and potential gain toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59295,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, lookahead distance (scaled by inverse remaining nodes), and centrality (scaled by square root of remaining nodes), prioritizing shorter paths while penalizing high-centrality nodes later. The dynamic weights ensure exploration early and exploitation as nodes are visited. The score combines these factors to choose the most promising next node.",
          "thought": "The new algorithm introduces a hybrid scoring mechanism that combines immediate distance, lookahead distance, and a dynamic penalty term based on node centrality, where centrality is estimated by the average distance to all other nodes. The weight of the lookahead distance is scaled by the inverse of the remaining nodes, while the centrality penalty is scaled by the square root of the remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1 if remaining_nodes > 1 else 1)\n\n        # Dynamic weights\n        weight_lookahead = 1.0 / (1.0 + remaining_nodes * 0.5)\n        weight_centrality = (remaining_nodes ** 0.5) / 10.0  # Penalize high-centrality nodes later\n\n        score = immediate_distance + weight_lookahead * lookahead_distance - weight_centrality * centrality\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.67799,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically adjusting a bias factor based on the number of unvisited nodes. It prioritizes nodes closer to the destination early in the tour (higher bias) but gradually shifts focus to minimizing immediate distances (lower bias) as the number of unvisited nodes decreases. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing proximity to the current node and the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by dynamically adjusting the bias factor based on the number of unvisited nodes, favoring nodes closer to the destination while gradually reducing the bias to focus more on immediate distance optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 1 - (len(unvisited_nodes) / (len(unvisited_nodes) + 2))\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81097,
          "other_inf": null
     }
]