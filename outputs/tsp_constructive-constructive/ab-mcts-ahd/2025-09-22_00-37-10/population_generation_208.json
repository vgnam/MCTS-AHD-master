[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node and lookahead distance to the destination, weighted by a static factor (0.5) and a dynamic bias that adapts based on the number of remaining unvisited nodes. Higher priority is given to minimizing the immediate distance (current_distance), while the lookahead distance (dest_distance) is weighted by the dynamic bias, which decreases as more nodes are visited, favoring strategic planning in later stages. The score is calculated as `-current_distance + bias_factor * (weight * dest_distance)`, ensuring the algorithm adapts between greediness and foresight.",
          "thought": "The new algorithm combines the static weight from No.1 with the dynamic bias factor from No.2, using a weighted score that balances immediate distance and lookahead distance while adapting the bias factor to prioritize strategic planning as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight = 0.5  # Static weight from No.1\n    bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic bias from No.2\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        score = -current_distance + bias_factor * (weight * dest_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **dynamic bias factor** (exponentially decaying from 0.5) and a **weighted lookahead approach** (starting at 0.5 and increasing as remaining nodes decrease) to balance local (immediate distance) and global (lookahead to destination) optimization. The score prioritizes **shorter immediate distances** (with bias) over **longer lookahead distances**, adjusting weights dynamically based on remaining nodes. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead approach from No.2, where the bias factor decays exponentially to balance local and global optimization, and the weight starts at 0.5 and increases as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / (remaining_nodes + 1))\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance * (1 + bias_factor) + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5525,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor with a dynamic bias factor, prioritizing local optimization (minimizing `current_distance`) early in the search and gradually shifting toward global optimization (maximizing `dest_distance`) as more nodes are visited. The bias factor decreases quadratically with the number of unvisited nodes, balancing immediate distance and potential gain toward the destination.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that prioritizes local optimization early in the search and gradually shifts focus toward global optimization, balancing immediate distance and potential gain toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59295,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, lookahead distance (scaled by inverse remaining nodes), and centrality (scaled by square root of remaining nodes), prioritizing shorter paths while penalizing high-centrality nodes later. The dynamic weights ensure exploration early and exploitation as nodes are visited. The score combines these factors to choose the most promising next node.",
          "thought": "The new algorithm introduces a hybrid scoring mechanism that combines immediate distance, lookahead distance, and a dynamic penalty term based on node centrality, where centrality is estimated by the average distance to all other nodes. The weight of the lookahead distance is scaled by the inverse of the remaining nodes, while the centrality penalty is scaled by the square root of the remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1 if remaining_nodes > 1 else 1)\n\n        # Dynamic weights\n        weight_lookahead = 1.0 / (1.0 + remaining_nodes * 0.5)\n        weight_centrality = (remaining_nodes ** 0.5) / 10.0  # Penalize high-centrality nodes later\n\n        score = immediate_distance + weight_lookahead * lookahead_distance - weight_centrality * centrality\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.67799,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically adjusting a bias factor based on the number of unvisited nodes. It prioritizes nodes closer to the destination early in the tour (higher bias) but gradually shifts focus to minimizing immediate distances (lower bias) as the number of unvisited nodes decreases. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing proximity to the current node and the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by dynamically adjusting the bias factor based on the number of unvisited nodes, favoring nodes closer to the destination while gradually reducing the bias to focus more on immediate distance optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 1 - (len(unvisited_nodes) / (len(unvisited_nodes) + 2))\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81097,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by prioritizing nodes closer to the destination (destination proximity) more aggressively, using an exponential decay function (`bias_factor`) that decreases rapidly as more nodes are visited. The `bias_factor` is calculated as `(len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)`, ensuring higher emphasis on destination proximity early in the search. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing local (current node) and global (destination) optimization dynamically.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by adjusting the bias factor to prioritize nodes closer to the destination more aggressively, using an exponential decay function that decreases the bias factor rapidly as more nodes are visited, ensuring a balance between local and global optimization with a stronger emphasis on destination proximity early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, lookahead distance to the destination, and centroid proximity of unvisited nodes to select the next node, prioritizing closer unvisited nodes while balancing strategic positioning. It dynamically adjusts weights between these factors based on remaining nodes, giving higher priority to immediate distance and centroid proximity when fewer nodes remain. The score calculation favors nodes with minimal immediate distance, reduced lookahead distance, and proximity to the centroid of unvisited nodes.",
          "thought": "This new algorithm combines the dynamic weight adjustment from both existing algorithms with an additional heuristic that prioritizes nodes closer to the centroid of unvisited nodes, ensuring a balance between immediate gains and strategic positioning. It uses a weighted score that adapts based on remaining nodes and centroid proximity to select the next node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    # Calculate centroid of unvisited nodes\n    centroid_x, centroid_y = 0, 0\n    for node in unvisited_nodes:\n        centroid_x += distance_matrix[node][0]\n        centroid_y += distance_matrix[node][1]\n    centroid_x /= remaining_nodes\n    centroid_y /= remaining_nodes\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        centroid_distance = ((distance_matrix[node][0] - centroid_x) ** 2 + (distance_matrix[node][1] - centroid_y) ** 2) ** 0.5\n        weight_immediate = 1.0 / (1.0 + remaining_nodes)\n        weight_centroid = (1.0 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))) / (1.0 + remaining_nodes)\n        score = immediate_distance - weight_immediate * lookahead_distance - weight_centroid * centroid_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81582,
          "other_inf": null
     }
]