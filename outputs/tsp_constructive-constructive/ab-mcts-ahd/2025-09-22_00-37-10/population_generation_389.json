[
     {
          "algorithm": "The algorithm prioritizes immediate gains early by dynamically adjusting weights based on remaining nodes, balancing short-term distances (immediate_distance) with long-term strategic planning (lookahead_distance) using a non-linear weight (1.0/(1.0 + remaining_nodes) + 0.5). The score function `immediate_distance - weight * lookahead_distance` ensures shorter-term distances dominate early, while the weight gradually shifts focus to long-term planning as remaining nodes decrease.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 with a fixed weight from No.2, but introduces a non-linear weight that increases with the number of remaining nodes to prioritize immediate gains early and strategic planning later, while ensuring a balanced consideration of short-term and long-term distances throughout the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted lookahead distance to the destination, with the weight dynamically adjusted to prioritize immediate distances early (higher weight) and balance with lookahead later (lower weight), while also incorporating a fixed component (`0.5`) to ensure strategic planning. The score is minimized (`immediate_distance - weight * lookahead_distance`), favoring nodes closer to the current node and, to a diminishing extent, closer to the destination. The weight function (`(1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5`) ensures a smooth transition from immediate to lookahead focus.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate and lookahead distances using a non-linear weight function that prioritizes immediate distances early and balances with lookahead distances later, while also incorporating a fixed weight component to ensure strategic planning throughout the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48674,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node with a weighted lookahead distance to the destination, using a dynamically adjusted weight that prioritizes lookahead as more nodes remain unvisited. The bias factor decreases over time to shift focus from global optimization (early stages) to local optimization (later stages), with the score function favoring nodes that minimize immediate distance while considering future steps. The weight formula (`1.0 / (1.0 + remaining_nodes) + 0.5`) ensures higher lookahead influence early on.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the bias factor from No.2, using a non-linear weight that balances immediate distance with lookahead distance, while the bias factor decreases as more nodes are visited to shift focus from global to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        bias_factor = remaining_nodes / (remaining_nodes + 1)  # Decreasing bias\n        score = -immediate_distance + bias_factor * (weight * lookahead_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.49835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing immediate distance with decreasing emphasis on lookahead as the tour progresses) and a bias factor (balancing global and local optimization) to select the next node. It penalizes revisits slightly and uses a weighted score to balance immediate and lookahead distances, favoring closer nodes early while maintaining some lookahead consideration. The bias factor decreases as nodes are visited, shifting focus from global optimization to local optimization.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 with the bias factor from No.2, using a weighted score that balances immediate distance, lookahead distance, and a penalty for revisits, while the bias factor decreases as the tour progresses to shift focus from global optimization to local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        remaining_nodes = len(unvisited_nodes)\n\n        # Dynamic weight based on remaining nodes (similar to No.1)\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Bias factor decreasing as nodes are visited (similar to No.2)\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n\n        # Penalty for revisits (similar to No.1)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        # Combined score: prioritize immediate distance, balance lookahead, and penalize revisits\n        score = -immediate_distance + bias_factor * (weight * lookahead_distance) - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50535,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing distance minimization and destination proximity, using a bias factor that prioritizes shorter current distances while accounting for angular deviation between current and destination paths. The scoring mechanism combines `-current_distance` (minimizing immediate distance) and `bias_factor * (dest_distance - angular_deviation * current_distance)` (prioritizing nodes closer to the destination while penalizing large angular deviations), with the bias factor decreasing as more nodes are visited.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a dynamic bias factor that prioritizes both minimizing the current distance and maximizing the potential gain toward the destination, using a novel scoring mechanism that combines distance and angular deviation to better handle node selection in complex TSP instances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        angular_deviation = abs(current_distance - dest_distance) / (current_distance + dest_distance)\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 1)) ** 2\n        score = -current_distance + bias_factor * (dest_distance - angular_deviation * current_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51321,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local and global optimization by prioritizing immediate distance reduction early in the tour (using `immediate_distance`) while gradually shifting focus to lookahead distance (using `lookahead_distance`) as the tour progresses, controlled by a quadratically increasing `bias_factor`. The `bias_factor` starts at 0.5 and grows as more nodes are visited, balancing local and global decisions. The `score` function weighs these factors dynamically, favoring shorter immediate paths early but increasingly considering global completion as the tour advances.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 (balancing local and global optimization) with the weighted lookahead approach from No.2 (prioritizing global optimization as the tour progresses). The bias factor starts at 0.5 and increases quadratically as more nodes are visited, while the weight for the lookahead distance decreases, shifting from global to local decision-making.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 + 0.5 * (1 - (remaining_nodes / (remaining_nodes + 1))) ** 2\n        score = -immediate_distance + bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing immediate distance, lookahead distance, and an exploration factor, where immediate distance is prioritized (1.2 weight), lookahead distance is less prioritized (-0.7 weight), and the exploration factor (dynamic weight) adjusts based on remaining nodes to favor exploration when few nodes are left. The scoring mechanism combines these factors to guide the selection toward shorter-term gains while dynamically adjusting for global path potential.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a weighted sum of immediate distance, lookahead distance, and a novel \"exploration factor\" that balances between immediate gains and long-term potential paths, using a dynamic weight that adjusts based on the size of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    # Dynamic weight based on remaining nodes\n    exploration_weight = 1.0 - (0.8 * len(unvisited_nodes) / len(distance_matrix))\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Novel scoring: weighted sum with exploration factor\n        score = (1.2 * immediate_distance) - (0.7 * lookahead_distance) + (exploration_weight * (immediate_distance - lookahead_distance))\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.53471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate and lookahead distances dynamically (weighted by remaining nodes) while penalizing frequently visited nodes to encourage exploration, prioritizing immediate distance over lookahead distance with a penalty term for revisits. The weight adjusts aggressively as the tour progresses, favoring immediate distances early and lookahead distances later. The penalty term reduces revisits but is outweighed by distance considerations.",
          "thought": "The new algorithm introduces a dynamic weight mechanism that adjusts based on the number of remaining unvisited nodes, blending immediate and lookahead distances more aggressively as the tour progresses, while incorporating a penalty term for nodes that have been visited more frequently in previous iterations to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight based on remaining nodes\n        weight = 0.5 + 0.5 * (1 - remaining_nodes / len(distance_matrix))\n\n        # Penalty for nodes visited more frequently (simulated here for exploration)\n        penalty = 0.1 * (1 / (remaining_nodes + 1))\n\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing shorter current distances while dynamically adjusting a bias factor based on remaining nodes and current distance, balancing immediate progress with long-term path efficiency. It penalizes revisiting nodes (though the penalty is unused in the given code) and uses a score function that weighs current distance, destination distance, and the bias factor. The bias factor decays as more nodes are visited, reducing the influence of the destination distance over time.",
          "thought": "The new algorithm introduces a dynamic bias factor that adapts based on the remaining nodes and the current path length, incorporating a penalty for revisiting nodes and a heuristic to balance immediate distance with global progress, using a score function that combines these factors with a decaying weight for the destination distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        # Dynamic bias factor based on remaining nodes and current distance\n        bias_factor = (remaining_nodes / (remaining_nodes + 1)) * (1 - (current_distance / max(distance_matrix[current_node])))\n\n        # Penalty for revisiting nodes (if applicable)\n        penalty = 0.0 if node not in unvisited_nodes else 0.0\n\n        # Score combines current distance, destination distance, and penalty\n        score = -current_distance + bias_factor * dest_distance - penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54171,
          "other_inf": null
     }
]