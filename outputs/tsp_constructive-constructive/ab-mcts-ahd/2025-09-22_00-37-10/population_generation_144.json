[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node and lookahead distance to the destination, weighted by a static factor (0.5) and a dynamic bias that adapts based on the number of remaining unvisited nodes. Higher priority is given to minimizing the immediate distance (current_distance), while the lookahead distance (dest_distance) is weighted by the dynamic bias, which decreases as more nodes are visited, favoring strategic planning in later stages. The score is calculated as `-current_distance + bias_factor * (weight * dest_distance)`, ensuring the algorithm adapts between greediness and foresight.",
          "thought": "The new algorithm combines the static weight from No.1 with the dynamic bias factor from No.2, using a weighted score that balances immediate distance and lookahead distance while adapting the bias factor to prioritize strategic planning as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight = 0.5  # Static weight from No.1\n    bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic bias from No.2\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        score = -current_distance + bias_factor * (weight * dest_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by prioritizing nodes closer to the destination (destination proximity) more aggressively, using an exponential decay function (`bias_factor`) that decreases rapidly as more nodes are visited. The `bias_factor` is calculated as `(len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)`, ensuring higher emphasis on destination proximity early in the search. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing local (current node) and global (destination) optimization dynamically.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by adjusting the bias factor to prioritize nodes closer to the destination more aggressively, using an exponential decay function that decreases the bias factor rapidly as more nodes are visited, ensuring a balance between local and global optimization with a stronger emphasis on destination proximity early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a dynamic bias factor (decreasing as nodes are visited) with a weighted lookahead strategy (increasing priority as the tour progresses) to balance immediate distance savings with long-term optimization. It prioritizes immediate distance reduction early (high bias) but gradually shifts focus to global optimization (high lookahead weight) by adjusting the score calculation with a weighted combination of immediate and lookahead distances. The bias factor and weight are dynamically computed based on remaining unvisited nodes, ensuring adaptability throughout the tour construction.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead strategy of No.2, where the bias factor starts high to prioritize global optimization early and decreases as more nodes are visited, while the lookahead weight increases to ensure global focus as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84383,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance local distance minimization (prioritized by `-current_distance`) and global optimization (prioritized by `dest_distance` with a decaying bias factor). The bias factor (`bias_factor`) decreases as the number of unvisited nodes decreases, ensuring the algorithm adapts from local to global optimization. The `score` calculation weighs these factors, favoring nodes closer to the current node while gradually considering proximity to the destination.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that prioritizes immediate distance minimization while adaptively favoring nodes closer to the destination, using a decaying bias that balances local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) - 1) / len(unvisited_nodes)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85339,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances short-term and long-term efficiency by combining immediate distance to the next node with a weighted lookahead distance to the destination, where the weight dynamically adjusts based on the number of remaining unvisited nodes. It prioritizes immediate gains when nodes are few but increasingly values long-term efficiency as the problem size grows, ensuring adaptability to different stages of the TSP solution. The scoring mechanism (`immediate_distance - weight * lookahead_distance`) ensures a trade-off between proximity and strategic planning.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the strategic planning of No.1, using a weight that starts high (prioritizing immediate gains) and decreases as remaining nodes grow, while also incorporating a lookahead distance component to balance short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))) / (1.0 + remaining_nodes)\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.87636,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing local and global optimization, prioritizing nodes closer to the destination (weighted by `dest_distance ** 2`) while penalizing longer distances from the current node (`-current_distance`). The bias factor adjusts this balance over time, increasing global focus as more nodes are visited. The score calculation ensures the algorithm starts locally optimal (favoring short immediate steps) but gradually shifts toward minimizing the path to the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by dynamically balancing the immediate distance to the next node with the potential gain toward the destination, using a bias factor that prioritizes minimizing the current distance while heavily favoring nodes closer to the destination. The bias factor increases as more nodes are visited, gradually shifting the focus toward global optimization. The score is computed as `-current_distance + bias_factor * (dest_distance ** 2)`, where `dest_distance` is weighted more than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 1 - (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        score = -current_distance + bias_factor * (dest_distance ** 2)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.88767,
          "other_inf": null
     }
]