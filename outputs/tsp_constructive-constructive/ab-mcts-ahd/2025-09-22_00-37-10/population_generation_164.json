[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node with a weighted lookahead distance to the destination, using a static weight (0.5) to prioritize strategic planning. It minimizes a score combining these distances, favoring nodes that reduce the immediate distance while slightly considering their proximity to the destination. The weight ensures a consistent trade-off between short-term gains and long-term potential.",
          "thought": "The new algorithm prioritizes balancing immediate distances with lookahead distances using a static weight that emphasizes strategic planning early, with the weight (0.5) remaining constant throughout the process, ensuring a consistent trade-off between short-term gains and long-term potential.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    weight = 0.5  # Static weight emphasizing strategic planning\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by dynamically balancing immediate distance to the next node with potential gain toward the destination, using an exponentially decaying bias factor. The bias factor prioritizes local optimization early on (high bias) and gradually shifts focus to minimizing immediate distance (low bias). The score function weighs `-current_distance * (1 + bias_factor)` heavily early on but reduces its influence as `bias_factor` decays, while `bias_factor * dest_distance` ensures some consideration for the destination.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by emphasizing the immediate distance to the next node while dynamically balancing it with the potential gain toward the destination, using an exponentially decaying bias factor that prioritizes local optimization early on and gradually shifts focus to minimizing the immediate distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / len(unvisited_nodes))\n        score = -current_distance * (1 + bias_factor) + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.54486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance to the current node and lookahead distance to the destination, weighted by a static factor (0.5) and a dynamic bias that adapts based on the number of remaining unvisited nodes. Higher priority is given to minimizing the immediate distance (current_distance), while the lookahead distance (dest_distance) is weighted by the dynamic bias, which decreases as more nodes are visited, favoring strategic planning in later stages. The score is calculated as `-current_distance + bias_factor * (weight * dest_distance)`, ensuring the algorithm adapts between greediness and foresight.",
          "thought": "The new algorithm combines the static weight from No.1 with the dynamic bias factor from No.2, using a weighted score that balances immediate distance and lookahead distance while adapting the bias factor to prioritize strategic planning as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight = 0.5  # Static weight from No.1\n    bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)  # Dynamic bias from No.2\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        score = -current_distance + bias_factor * (weight * dest_distance)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a **dynamic bias factor** (exponentially decaying from 0.5) and a **weighted lookahead approach** (starting at 0.5 and increasing as remaining nodes decrease) to balance local (immediate distance) and global (lookahead to destination) optimization. The score prioritizes **shorter immediate distances** (with bias) over **longer lookahead distances**, adjusting weights dynamically based on remaining nodes. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead approach from No.2, where the bias factor decays exponentially to balance local and global optimization, and the weight starts at 0.5 and increases as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = 0.5 ** (1 / (remaining_nodes + 1))\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance * (1 + bias_factor) + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5525,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate distance, lookahead distance (scaled by inverse remaining nodes), and centrality (scaled by square root of remaining nodes), prioritizing shorter paths while penalizing high-centrality nodes later. The dynamic weights ensure exploration early and exploitation as nodes are visited. The score combines these factors to choose the most promising next node.",
          "thought": "The new algorithm introduces a hybrid scoring mechanism that combines immediate distance, lookahead distance, and a dynamic penalty term based on node centrality, where centrality is estimated by the average distance to all other nodes. The weight of the lookahead distance is scaled by the inverse of the remaining nodes, while the centrality penalty is scaled by the square root of the remaining nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Calculate centrality (average distance to all other nodes)\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (remaining_nodes - 1 if remaining_nodes > 1 else 1)\n\n        # Dynamic weights\n        weight_lookahead = 1.0 / (1.0 + remaining_nodes * 0.5)\n        weight_centrality = (remaining_nodes ** 0.5) / 10.0  # Penalize high-centrality nodes later\n\n        score = immediate_distance + weight_lookahead * lookahead_distance - weight_centrality * centrality\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.67799,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance immediate distance to the next node and potential gain toward the destination. It prioritizes minimizing the current distance (higher weight) while also considering the remaining distance to the destination (scaled by a bias factor that decreases as nodes are visited). The bias factor dynamically adjusts based on the number of unvisited nodes, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that adapts to the remaining distance to the destination, using a score function that balances immediate distance and potential gain toward the destination, while also incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) / (len(unvisited_nodes) + 2)) ** 2\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74697,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by prioritizing nodes closer to the destination (destination proximity) more aggressively, using an exponential decay function (`bias_factor`) that decreases rapidly as more nodes are visited. The `bias_factor` is calculated as `(len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)`, ensuring higher emphasis on destination proximity early in the search. The score for each node is computed as `-current_distance + bias_factor * dest_distance`, balancing local (current node) and global (destination) optimization dynamically.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by adjusting the bias factor to prioritize nodes closer to the destination more aggressively, using an exponential decay function that decreases the bias factor rapidly as more nodes are visited, ensuring a balance between local and global optimization with a stronger emphasis on destination proximity early in the search.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) ** 2) / ((len(unvisited_nodes) + 1) ** 2)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.81319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a dynamic bias factor (decreasing as nodes are visited) with a weighted lookahead strategy (increasing priority as the tour progresses) to balance immediate distance savings with long-term optimization. It prioritizes immediate distance reduction early (high bias) but gradually shifts focus to global optimization (high lookahead weight) by adjusting the score calculation with a weighted combination of immediate and lookahead distances. The bias factor and weight are dynamically computed based on remaining unvisited nodes, ensuring adaptability throughout the tour construction.",
          "thought": "The new algorithm combines the dynamic bias factor from No.1 with the weighted lookahead strategy of No.2, where the bias factor starts high to prioritize global optimization early and decreases as more nodes are visited, while the lookahead weight increases to ensure global focus as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        bias_factor = remaining_nodes / (remaining_nodes + 1)\n        weight = 0.5 + (0.5 * (remaining_nodes / (remaining_nodes + 1)))\n        score = -immediate_distance + weight * bias_factor * lookahead_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84383,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm modifies the nearest-neighbor heuristic by balancing the immediate distance to the next node with the potential gain toward the destination, using a dynamic bias factor that prioritizes minimizing the current distance while slightly favoring nodes closer to the destination. The bias factor decreases as more nodes are visited, gradually shifting the focus back to minimizing the immediate distance. The score is computed as `-current_distance + bias_factor * dest_distance`, where `dest_distance` is weighted less than `current_distance`. This ensures the algorithm adapts dynamically between local and global optimization.",
          "thought": "The new algorithm modifies the nearest-neighbor heuristic by incorporating a weighted balance between minimizing the current distance and maximizing the potential gain toward the destination, introducing a dynamic bias factor that adjusts based on the remaining nodes' proximity to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.84818,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a dynamic bias factor to balance local distance minimization (prioritized by `-current_distance`) and global optimization (prioritized by `dest_distance` with a decaying bias factor). The bias factor (`bias_factor`) decreases as the number of unvisited nodes decreases, ensuring the algorithm adapts from local to global optimization. The `score` calculation weighs these factors, favoring nodes closer to the current node while gradually considering proximity to the destination.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a dynamic bias factor that prioritizes immediate distance minimization while adaptively favoring nodes closer to the destination, using a decaying bias that balances local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        bias_factor = (len(unvisited_nodes) - 1) / len(unvisited_nodes)\n        score = -current_distance + bias_factor * dest_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.85339,
          "other_inf": null
     }
]