[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by prioritizing immediate distance (heavily weighted) while balancing destination proximity and a lookahead term (average distance to remaining nodes), with a bias factor that adjusts based on progress (early: more exploration, late: more exploitation). The scoring function (`-2 * current_distance + bias_factor * (dest_distance + 0.3 * lookahead_term)`) ensures short-term efficiency, while the bias factor and lookahead term introduce adaptability.",
          "thought": "The new algorithm enhances the original by introducing a dynamic bias factor that adapts based on the progress ratio (visited nodes vs. total nodes) and incorporates a lookahead mechanism to evaluate the potential impact of choosing a node on future steps, using a weighted score combining immediate distance, destination proximity, and a lookahead term that estimates the average distance to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 to include current_node if considering progress\n    progress_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        # Calculate lookahead term: average distance to remaining nodes\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        lookahead_term = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n\n        # Dynamic bias factor: decreases as progress increases\n        bias_factor = (1 - progress_ratio) * 0.5 + 0.5  # Ranges from 0.5 (early) to 1.0 (late)\n\n        # Weighted score: current_distance is heavily weighted, dest_distance and lookahead are balanced\n        score = -2 * current_distance + bias_factor * (dest_distance + 0.3 * lookahead_term)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43789,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by prioritizing immediate distance (higher weight) while incorporating a weighted average of future distances (lower weight), with the exploration factor adjusting based on remaining nodes to ensure a balance between greedy and exploratory behavior. The score calculation (`-current_distance + exploration_factor * avg_future_distance`) ensures closer nodes are preferred early on, while the exploration factor (`remaining_nodes / (remaining_nodes + 2)`) ensures global considerations remain relevant as the tour progresses.",
          "thought": "The new algorithm introduces a dynamic exploration factor that adjusts based on the remaining nodes, blending immediate distance with a weighted average of distances to unvisited nodes, creating a more balanced trade-off between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        exploration_factor = remaining_nodes / (remaining_nodes + 2)\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n        score = -current_distance + exploration_factor * avg_future_distance\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.44632,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (prioritized), destination proximity (weighted by a decaying bias factor), and node centrality (weighted lower) in the unvisited set. The bias factor decreases as more nodes are visited, shifting from global (destination-proximity) to local (centrality) optimization. The score combines these factors with higher weight on immediate distance and destination proximity early, while centrality plays a smaller but stabilizing role.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines immediate distance, destination proximity, and a node's centrality in the remaining unvisited set, using a decaying bias factor that emphasizes destination proximity early and balances it with local optimization as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes) / remaining_nodes\n        bias_factor = (remaining_nodes / (remaining_nodes + 2)) ** 2\n        score = -current_distance + bias_factor * (0.6 * dest_distance + 0.4 * centrality)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.4478,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, destination proximity, and lookahead costs, with a dynamic bias factor that prioritizes short-term gains early (high weight on current distance) but gradually shifts focus to long-term optimization (destination proximity and lookahead). The score calculation weights current distance heavily (negative coefficient) while incorporating destination distance and average lookahead cost with a progress-based bias factor. Early in the tour, the bias factor heavily favors immediate distance, while later it emphasizes destination proximity and lookahead efficiency.",
          "thought": "The new algorithm combines No.2's dynamic bias factor with No.1's lookahead term, using a progress-based bias factor that heavily weights immediate distance early but gradually incorporates lookahead and destination proximity as progress increases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    progress_ratio = 1 - (len(unvisited_nodes) / total_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        lookahead_term = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes) if remaining_nodes else 0\n\n        bias_factor = (1 - progress_ratio) * 0.7 + 0.3\n        score = -2 * current_distance + bias_factor * (dest_distance + 0.2 * lookahead_term)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.45009,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances short-term (immediate distance) and long-term (lookahead distance) priorities by combining a non-linear dynamic weight (decreasing with remaining nodes) and a fixed weight (0.5) for strategic planning. It prioritizes immediate distances more as the number of remaining nodes decreases, while still considering long-term potential, avoiding premature convergence by adjusting weights dynamically. The `score` calculation ensures the next node is chosen based on a trade-off between proximity and potential future gains.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate and lookahead distances using a non-linear, decreasing function of remaining nodes, combined with a fixed weight (0.5) for strategic planning, to prioritize both short-term gains and long-term potential while avoiding premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        dynamic_weight = 1.0 / (1.0 + remaining_nodes ** 0.5)  # Non-linear dynamic weight\n        fixed_weight = 0.5  # Fixed weight for strategic planning\n        score = immediate_distance - (dynamic_weight + fixed_weight) * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48076,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing immediate distance, lookahead distance to the destination, and a penalty for long steps, with a weight that increases as progress is made (favoring exploitation over exploration). The score prioritizes shorter immediate steps and penalizes revisiting nodes, while the dynamic weight ensures early exploration and later exploitation. The structure iterates through unvisited nodes, computes a weighted score, and selects the node with the lowest score.",
          "thought": "The new algorithm enhances the original by introducing dynamic weight adjustment based on the remaining unvisited nodes, incorporating a penalty for revisiting nodes, and using a heuristic that combines immediate distance, lookahead distance, and a penalty term to balance exploration and exploitation in path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    weight = 0.5 + 0.5 * (1 - remaining_nodes / (remaining_nodes + 1))  # Dynamic weight based on progress\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        penalty = 0.1 * (1 / (1 + distance_matrix[current_node][node]))  # Penalty for long immediate steps\n        score = immediate_distance - weight * lookahead_distance + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48098,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate gains early by dynamically adjusting weights based on remaining nodes, balancing short-term distances (immediate_distance) with long-term strategic planning (lookahead_distance) using a non-linear weight (1.0/(1.0 + remaining_nodes) + 0.5). The score function `immediate_distance - weight * lookahead_distance` ensures shorter-term distances dominate early, while the weight gradually shifts focus to long-term planning as remaining nodes decrease.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.1 with a fixed weight from No.2, but introduces a non-linear weight that increases with the number of remaining nodes to prioritize immediate gains early and strategic planning later, while ensuring a balanced consideration of short-term and long-term distances throughout the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 1.0 / (1.0 + remaining_nodes) + 0.5  # Non-linear dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance with a fixed weight (0.7) and balances it with a decaying lookahead influence (using a linear decay factor). It uses a constant bias factor (0.8) and no revisit penalty, making the selection more aggressive in early stages by favoring proximity while gradually considering longer-term routes. The score is computed as `immediate_distance - decay_factor * (weight * lookahead_distance * bias_factor)`, where immediate distance dominates due to the fixed weight and decay factor.",
          "thought": "The new algorithm prioritizes immediate distance with a fixed weight while using a linear decay factor for lookahead influence, balancing global and local optimization with a constant bias factor and no revisit penalty, creating a more aggressive early-stage focus on proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n\n        # Fixed weight (no dynamic adjustment)\n        weight = 0.7\n\n        # Constant bias factor (no decrease)\n        bias_factor = 0.8\n\n        # No revisit penalty\n        penalty = 0\n\n        # Linear decay factor (instead of quadratic)\n        decay_factor = remaining_nodes / total_nodes\n\n        # Combined score: immediate distance dominates with fixed weight\n        score = immediate_distance - decay_factor * (weight * lookahead_distance * bias_factor) + penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48555,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and a weighted lookahead distance to the destination, with the weight dynamically adjusted to prioritize immediate distances early (higher weight) and balance with lookahead later (lower weight), while also incorporating a fixed component (`0.5`) to ensure strategic planning. The score is minimized (`immediate_distance - weight * lookahead_distance`), favoring nodes closer to the current node and, to a diminishing extent, closer to the destination. The weight function (`(1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5`) ensures a smooth transition from immediate to lookahead focus.",
          "thought": "The new algorithm dynamically adjusts the weight between immediate and lookahead distances using a non-linear weight function that prioritizes immediate distances early and balances with lookahead distances later, while also incorporating a fixed weight component to ensure strategic planning throughout the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = (1.0 / (1.0 + remaining_nodes)) * (remaining_nodes / (remaining_nodes + 1)) + 0.5\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48674,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance to the current node while dynamically balancing it with a weighted lookahead distance to the destination, using a hybrid scoring function that adapts weights based on the number of remaining nodes. The weight starts at 0.5 and increases slightly with fewer remaining nodes, ensuring a trade-off between proximity and strategic planning. The code iterates through unvisited nodes, computes the score, and selects the node with the lowest score, effectively minimizing both immediate and long-term travel costs.",
          "thought": "The new algorithm combines the dynamic weight adaptation from No.1, the fixed weight balance from No.3, and the immediate distance prioritization from No.2, using a hybrid scoring function (immediate_distance - (0.5 + 0.2 * (1.0 / (1.0 + remaining_nodes))) * lookahead_distance) to dynamically balance proximity to the current node and strategic planning toward the destination, ensuring lower objective values.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        lookahead_distance = distance_matrix[node][destination_node]\n        weight = 0.5 + 0.2 * (1.0 / (1.0 + remaining_nodes))  # Hybrid dynamic weight\n        score = immediate_distance - weight * lookahead_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48951,
          "other_inf": null
     }
]