[
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two objectives: minimizing the distance from the current node (weighted 2.0) and maximizing the distance to the destination (weighted 1.0). It prioritizes reducing immediate travel cost while indirectly encouraging progress toward the final destination. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node (weighted 2.0) while also considering the node's proximity to the destination (weighted 1.0), aiming to balance immediate efficiency with progress toward the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines distance, centrality, and exploration priorities, dynamically adjusting weights: early prioritizes proximity (high distance_weight), later balances centrality (centrality_weight), and penalizes high-variance nodes (variance_penalty) while rewarding less-visited nodes (exploration_bonus). The score favors closer nodes initially, shifts to more central nodes later, and avoids nodes with erratic distances. The weights are scaled by remaining unvisited nodes, ensuring adaptive behavior.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.2 with proximity and centrality scoring from No.1, prioritizing distance early and balancing centrality and exploration later while penalizing high-variance nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    node_frequency = {node: sum(1 for n in unvisited_nodes if n == node) for node in unvisited_nodes}\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        distance_weight = 1.0 - (0.3 * (remaining_nodes / len(unvisited_nodes)))\n        centrality_weight = 0.4 + (0.5 * (remaining_nodes / len(unvisited_nodes)))\n        variance_penalty = 0.2 * (variance / (avg_distance + 1e-6))\n        exploration_bonus = 1.0 / (1.0 + node_frequency.get(node, 0))\n\n        score = (-distance_weight * distance_to_node +\n                centrality_weight * avg_distance -\n                variance_penalty * distance_to_node +\n                exploration_bonus)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59803,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted 1.5) while also considering the node's average distance to other unvisited nodes (weighted 0.5), balancing short-term efficiency and long-term flexibility. The `select_next_node` function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 1.5) and have the highest average distance to the destination node (weighted 0.5), balancing proximity and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = -1.5 * distance_to_node + 0.5 * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity and centrality, prioritizing closer nodes early (high proximity weight) but gradually favoring central nodes (increasing centrality weight) as unvisited nodes decrease. It uses variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes, while proximity is weighted more heavily initially. The score combines proximity (distance to current node) and centrality (average distance to others), with weights dynamically adjusted based on the number of unvisited nodes.",
          "thought": "The new algorithm combines dynamic weighting of proximity and centrality, where proximity weight decreases as unvisited nodes decrease, while centrality weight increases, and adds variance-based centrality scoring to favor nodes with more balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.5 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        centrality_weight = 0.5 * (1 - variance / (avg_distance_to_dest + 1e-6)) * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68174,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing proximity (weighted higher early on but increasing in importance as unvisited nodes decrease) while penalizing nodes with high distance variance to other unvisited nodes (favoring more \"central\" nodes). It balances these factors through a weighted scoring system, where proximity is inversely proportional to distance and centrality is proportional to average distance to other nodes. The weights themselves adjust based on the remaining problem size, ensuring local optimality in later stages.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for proximity increases as the number of unvisited nodes decreases to prioritize local optimality in the final stages. It also introduces a penalty term for nodes with high variance in their distances to other unvisited nodes, favoring nodes that are more \"central\" in the remaining subgraph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.5 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        centrality_weight = 0.5 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69328,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity early in the process by heavily weighting the current distance (`distance_to_node`) with a high `weight_factor` (up to 1.5 when few nodes remain). As the number of unvisited nodes decreases, the `weight_factor` decreases, shifting focus to long-term efficiency by balancing the average future distances (`avg_future_distance`). The score combines these weighted terms, ensuring exploration early and optimization later.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 with the immediate proximity and long-term efficiency balance of No.2. It uses a weight factor that decreases as unvisited nodes decrease, prioritizing immediate distance early and long-term efficiency later, while penalizing revisits to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.73404,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP tour by balancing short-term (immediate distance to the next node) and long-term (distance from the next node to the destination) priorities, with weights dynamically adjusted based on the remaining unvisited nodes. The weight for short-term optimization decreases more aggressively (from 1.5 to 0.4) as nodes are visited, while long-term optimization becomes more dominant. The score for each candidate node combines these weighted distances, and the node with the lowest score is chosen. The algorithm prioritizes immediate proximity early in the search but increasingly favors nodes that better align with the long-term path to the destination as the search progresses.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the weighted score balancing from No.1, using a more aggressive transition from short-term to long-term optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment with more aggressive transition\n        weight_immediate = max(0.4, 1.5 * (remaining_nodes / total_nodes))\n        weight_long_term = 1.0 - weight_immediate\n        score = weight_immediate * distance_to_node + weight_long_term * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.79566,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate proximity (prioritized with a higher weight) and long-term connectivity (prioritized with a lower weight), where proximity is inversely proportional to the distance from the current node, and connectivity is based on the node's average future travel cost among unvisited nodes. The weights dynamically adjust based on the remaining problem size, giving higher priority to proximity as the problem shrinks. The scoring system combines these factors to guide the path selection.",
          "thought": "The new algorithm modifies the selection process by incorporating dynamic proximity and centrality weights that adapt based on both the remaining problem size and the node's potential to reduce future travel costs, using a hybrid scoring system that balances immediate proximity with long-term connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes) / max(1, len(unvisited_nodes))\n        future_cost = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        proximity_weight = 2.0 * (1 - 0.7 * (num_unvisited / len(distance_matrix)))\n        connectivity_weight = 1.5 * (1 - future_cost / (avg_distance_to_dest + 1e-6))\n\n        score = -proximity_weight * distance_to_node + connectivity_weight * (1 / (future_cost + 1e-6))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.80843,
          "other_inf": null
     }
]