[
     {
          "algorithm": "The algorithm prioritizes immediate proximity early in the process by heavily weighting the current distance (`distance_to_node`) with a high `weight_factor` (up to 1.5 when few nodes remain). As the number of unvisited nodes decreases, the `weight_factor` decreases, shifting focus to long-term efficiency by balancing the average future distances (`avg_future_distance`). The score combines these weighted terms, ensuring exploration early and optimization later.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 with the immediate proximity and long-term efficiency balance of No.2. It uses a weight factor that decreases as unvisited nodes decrease, prioritizing immediate distance early and long-term efficiency later, while penalizing revisits to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.73404,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the destination, prioritizing immediate distance in early stages (high `weight_factor`) and destination distance in later stages (lower `weight_factor`), while penalizing revisits to encourage exploration. It uses a weighted score combining these distances, adjusted by the remaining unvisited nodes, to select the next node. The `weight_factor` decreases as the number of unvisited nodes decreases, ensuring a smooth transition between early exploration and late-stage efficiency.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting factor that adjusts based on the remaining number of unvisited nodes, favoring immediate proximity in early stages and balancing with destination proximity in later stages, while also introducing a penalty for revisiting nodes to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.00423,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the nearest unvisited node from the current node, ensuring a greedy approach to minimize immediate travel distance, while implicitly guiding the path toward the destination by favoring closer nodes. The function iterates through unvisited nodes, checks their distances from the current node using the distance matrix, and selects the one with the smallest distance. The destination node is not explicitly prioritized, but its proximity is indirectly considered by the greedy selection of nearby nodes.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with a fixed 70-30 split, prioritizing proximity (70%) early in the search (when many nodes remain) and future efficiency (30%) later (when fewer nodes remain). The weights are calculated based on the number of unvisited nodes, ensuring a smooth transition between immediate and long-term considerations. The next node is selected by balancing the current distance to the node and the average future distances from that node to the remaining unvisited nodes.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing proximity and future efficiency based on remaining nodes) with the fixed 70-30 weight split from No.2, creating a hybrid approach that adapts to the problem's stage while maintaining a structured balance between immediate and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, num_unvisited - 1)\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.02577,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity and long-term efficiency, with weights dynamically adjusted based on the number of remaining unvisited nodes. In early stages (many unvisited nodes), it prioritizes proximity (weighted higher), while in later stages (fewer unvisited nodes), it emphasizes future efficiency (weighted higher). The score combines weighted proximity (distance to the node) and average future distances, ensuring a trade-off between immediate and long-term optimality.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where weights are inversely proportional to the number of remaining nodes, emphasizing immediate proximity in early stages and long-term efficiency in later stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / max(1, num_unvisited)\n        weight_proximity = 0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))\n        weight_future = 0.4 * (1 - (num_unvisited / (num_unvisited + 1)))\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06159,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (50% weight), destination proximity (30% weight), and penalizing nodes with high average distances to unvisited nodes (-80% weight). It prioritizes short-term efficiency (current and destination distances) while avoiding nodes that are central to remaining unvisited nodes (long-term penalty). The scoring mechanism ensures a trade-off between greediness and global path optimization.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.5) and destination proximity (weight 0.3), while incorporating a stronger penalty for nodes with high average distances to unvisited nodes (weight -0.8), aiming for a balance between short-term efficiency and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.5 * distance_to_node + 0.3 * distance_to_destination - 0.8 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06294,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a 70-30 split between immediate proximity (distance to the next node) and long-term considerations (average future distances), dynamically adjusting weights based on the number of unvisited nodes. It prioritizes proximity early (higher weight) and future distances later (lower weight) to balance short-term and long-term optimization, using the distance matrix to evaluate candidate nodes and select the one with the lowest weighted score. The weights are scaled by the inverse of unvisited nodes to ensure flexibility in the decision-making process.",
          "thought": "The new algorithm combines the fixed 70-30 split from No.2 with dynamic weight adjustment inspired by No.1, where the weight for proximity is scaled by the number of unvisited nodes to balance immediate and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (num_unvisited / (num_unvisited + 1))\n    weight_future = 0.3 * (1 - (num_unvisited / (num_unvisited + 1)))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, num_unvisited - 1)\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.07486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (60% for proximity early, 40% for future efficiency later) with probabilistic selection (20% chance to pick the destination node) and centrality bias (prioritizing nodes with lower average distances to others). The score for each candidate node is calculated as a weighted sum of immediate distance and average future distances, adjusted by a centrality bias factor, ensuring a balance between immediate proximity and long-term efficiency.",
          "thought": "The new algorithm combines dynamic weight adjustment (like No.2) with probabilistic selection and centrality considerations (like No.1), prioritizing proximity early with a 60% weight and future efficiency with a 40% weight, while also incorporating a 20% random chance to select the destination node and a centrality-based bias factor to refine node selection.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (num_unvisited / (num_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    # Centrality of current node\n    current_centrality = sum(distance_matrix[current_node]) / len(distance_matrix[current_node])\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, num_unvisited - 1)\n\n        # Centrality of candidate node\n        node_centrality = sum(distance_matrix[node]) / len(distance_matrix[node])\n\n        # Bias factor combining distance and centrality\n        bias_factor = (distance_to_node / (distance_matrix[current_node][destination_node] + 1e-6)) * (1 + node_centrality / (current_centrality + 1e-6))\n\n        # Score with dynamic weights and centrality bias\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n        score *= (1 + 0.1 * bias_factor)  # Centrality bias factor\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 20% chance to select destination node if not already selected\n    if random.random() < 0.2 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 7.08889,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and future efficiency to the destination, with weights dynamically adjusted based on remaining unvisited nodes. It penalizes nodes that are significantly farther from the current node than the distance to the destination, prioritizing closer nodes early and more future-oriented choices later. The weights (`weight_proximity` and `weight_future`) and penalty (`penalty`) dynamically adapt to the remaining nodes, ensuring a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing proximity and future efficiency) with the penalty mechanism from No.2 (discouraging excessive detours) to improve solution quality. It selects the next node by scoring nodes based on a weighted combination of immediate distance and future distance to the destination, while penalizing nodes that are too far from the current node, and dynamically adjusts weights based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_proximity = 0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))\n        weight_future = 0.4 * (1 - (num_unvisited / (num_unvisited + 1)))\n        penalty = 1.2 if distance_to_node > 2 * distance_to_destination else 1.0\n        score = weight_proximity * distance_to_node + weight_future * distance_to_destination * penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.11069,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts the selection of the next node in TSP by prioritizing proximity to the current node when many unvisited nodes remain (short-term optimization) and shifting toward proximity to the destination as fewer nodes remain (long-term optimization). The weights for these distances are calculated using a linear function of the remaining nodes, with `weight_current` decreasing and `weight_destination` increasing as the number of unvisited nodes decreases. The node with the smallest weighted distance is chosen as the next step.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for proximity to the current node decreases and the weight for proximity to the destination increases as the number of unvisited nodes decreases, promoting a shift from short-term to long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_weighted_distance = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment: prioritize long-term optimization as fewer nodes remain\n        weight_current = 0.7 * (remaining_nodes / (remaining_nodes + 1))\n        weight_destination = 0.3 * (1 - remaining_nodes / (remaining_nodes + 1))\n        weighted_distance = weight_current * distance_to_current + weight_destination * distance_to_destination\n\n        if weighted_distance < min_weighted_distance:\n            min_weighted_distance = weighted_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.11644,
          "other_inf": null
     }
]