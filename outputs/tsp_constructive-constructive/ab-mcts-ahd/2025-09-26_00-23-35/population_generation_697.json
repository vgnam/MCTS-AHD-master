[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity (60% weight) by minimizing distance to the next node, while maximizing centrality (40% weight) by selecting nodes that are centrally located among unvisited nodes. It evaluates each candidate node by combining these two weighted scores and selects the one with the highest total score. The centrality score is calculated as the average distance to all other unvisited nodes, ensuring the next node is both close and well-connected to the remaining unvisited nodes.",
          "thought": "The new algorithm prioritizes proximity (60% weight) and centrality (40% weight), but uses a different scoring formula where proximity is minimized and centrality is maximized, favoring nodes that are close to the current node and central to the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight_proximity = 0.6\n    weight_centrality = 0.4\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        centrality_score = avg_distance_to_dest\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40663,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity (weighted higher early in the tour), centrality (weighted higher later), and novelty (penalizing high-variance nodes to avoid imbalanced tours). It dynamically adjusts weights based on remaining unvisited nodes, prioritizing distance reduction early and tour balance later, while penalizing nodes with inconsistent distances to others. The score combines proximity (negative distance), centrality (average distance minus variance), and novelty (variance penalty) with adjustable weights.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight adjustment mechanism based on both proximity and centrality, while also introducing a novelty factor that penalizes nodes with high variance in distances to unvisited nodes, encouraging more balanced tours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    proximity_weight = 0.7 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    centrality_weight = 0.3 * (num_unvisited / (num_unvisited + 1)) + 0.7\n    novelty_weight = 0.5 * (1 - num_unvisited / (num_unvisited + 1))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n        novelty_penalty = variance * novelty_weight\n\n        score = -proximity_weight * distance_to_node + centrality_weight * centrality_score - novelty_penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40839,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity (weighted higher early on) and global efficiency (weighted higher later) to select the next node, while penalizing outliers and rewarding central nodes, using a distance matrix and unvisited nodes set. The weights adjust based on remaining unvisited nodes, with proximity dominating early (60% initial) and future efficiency gaining importance later (40% later). The score combines weighted local distance, average future distances, outlier penalties, and centrality rewards to guide the path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment with global progress, where weights shift from local proximity to global efficiency as nodes are visited, and includes outlier penalties while balancing local and global scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality reward\n        centrality_reward = -0.4 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (distance to the next node) and centrality (node centrality in the remaining unvisited nodes) by adjusting weights based on the number of remaining unvisited nodes. Early in the search, proximity is prioritized (60% weight), while centrality gains importance (40% weight) later. Centrality is scored using variance-adjusted average distances, favoring nodes with balanced connections to remaining nodes. The weights transition smoothly from (60% proximity, 40% centrality) to (40% proximity, 60% centrality) as the search progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with centrality consideration, prioritizing proximity (60%) and centrality (40%) early in the search, with weights smoothly transitioning to proximity (40%) and centrality (60%) later, while using variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity and centrality by assigning higher weights to proximity early in the tour (when many nodes are unvisited) and shifting toward centrality later. It calculates a score for each unvisited node, combining proximity (distance to the current node) and centrality (average distance to other nodes minus variance), then selects the node with the highest score, while penalizing revisits to avoid loops. The weights adjust based on the number of unvisited nodes, prioritizing proximity when options are plentiful and centrality when choices narrow.",
          "thought": "The new algorithm dynamically balances proximity and centrality, using a weighted score that prioritizes nearby nodes early and shifts toward more central nodes as the tour progresses, with a penalty for revisiting nodes to avoid suboptimal loops.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.8 * (num_unvisited / (num_unvisited + 1)) + 0.2\n    weight_centrality = 0.2 * (num_unvisited / (num_unvisited + 1)) + 0.8\n    penalty_factor = 1.0 + (1.0 - num_unvisited / len(unvisited_nodes)) * 0.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = (-weight_proximity * distance_to_node + weight_centrality * centrality_score) / penalty_factor\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41247,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing proximity (distance from the current node) and centrality (how well-connected a node is to others), with weights dynamically adjusted based on the number of remaining unvisited nodes. Proximity is emphasized early in the tour (higher weight when few nodes remain), while centrality grows in importance as the tour progresses. Centrality is measured by a node's average distance to others minus its variance, ensuring the algorithm selects nodes that are both close and well-positioned in the remaining network. The score combines these factors to guide node selection.",
          "thought": "The new algorithm prioritizes nodes based on a dynamic balance between proximity and centrality, using a decaying weight for proximity and an increasing weight for centrality as the tour progresses, with centrality measured by the node's average distance to others minus its variance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.8 * (num_unvisited / (num_unvisited + 2)) + 0.2\n    weight_centrality = 0.2 * (num_unvisited / (num_unvisited + 2)) + 0.8\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41485,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy proximity heuristic with dynamic centrality bias, prioritizing closer nodes early and central hubs as the tour progresses. It adjusts weights for proximity (initially higher) and centrality (initially lower) based on remaining unvisited nodes, using a score combining distance and centrality (average distance minus variance). The centrality score helps balance proximity and network centrality, with weights shifting toward centrality as the tour advances.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a dynamic bias toward centrality, adjusting weights based on the number of unvisited nodes to prioritize central hubs as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    weight_centrality = 0.3 * (num_unvisited / (num_unvisited + 1)) + 0.7\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41745,
          "other_inf": null
     }
]