[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity (weighted higher early on) and global efficiency (weighted higher later) to select the next node, while penalizing outliers and rewarding central nodes, using a distance matrix and unvisited nodes set. The weights adjust based on remaining unvisited nodes, with proximity dominating early (60% initial) and future efficiency gaining importance later (40% later). The score combines weighted local distance, average future distances, outlier penalties, and centrality rewards to guide the path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment with global progress, where weights shift from local proximity to global efficiency as nodes are visited, and includes outlier penalties while balancing local and global scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality reward\n        centrality_reward = -0.4 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (distance to the next node) and centrality (node centrality in the remaining unvisited nodes) by adjusting weights based on the number of remaining unvisited nodes. Early in the search, proximity is prioritized (60% weight), while centrality gains importance (40% weight) later. Centrality is scored using variance-adjusted average distances, favoring nodes with balanced connections to remaining nodes. The weights transition smoothly from (60% proximity, 40% centrality) to (40% proximity, 60% centrality) as the search progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with centrality consideration, prioritizing proximity (60%) and centrality (40%) early in the search, with weights smoothly transitioning to proximity (40%) and centrality (60%) later, while using variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy proximity heuristic with dynamic centrality bias, prioritizing closer nodes early and central hubs as the tour progresses. It adjusts weights for proximity (initially higher) and centrality (initially lower) based on remaining unvisited nodes, using a score combining distance and centrality (average distance minus variance). The centrality score helps balance proximity and network centrality, with weights shifting toward centrality as the tour advances.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a dynamic bias toward centrality, adjusting weights based on the number of unvisited nodes to prioritize central hubs as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    weight_centrality = 0.3 * (num_unvisited / (num_unvisited + 1)) + 0.7\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41745,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity (distance to current node) and centrality (node's average distance to others minus variance) in a dynamic weighted scoring system, where weights smoothly transition from proximity-heavy to centrality-heavy as unvisited nodes decrease. It prioritizes proximity early (with bias toward destination nodes when far) and centrality later, using a bias factor to boost scores for nodes that are closer to the destination. The scoring function balances these criteria to select the next node efficiently.",
          "thought": "The new algorithm combines the dynamic weighting approach of No.1 (balancing proximity and centrality) with the destination-biased selection of No.2, using a smoothly transitioning weight between the two criteria based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        if node == destination_node:\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n        else:\n            dest_distance = distance_matrix[node][destination_node]\n            bias_factor = distance_to_node / (dest_distance + 1e-6)\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n            if bias_factor > 0.7:\n                score *= 1.2\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43114,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-based selection with dynamic weight adjustment, prioritizing nodes with lower average distances to others (centrality) while balancing proximity and future efficiency through adaptive weights (60% proximity early, 40% future efficiency later). It includes a probabilistic 25% chance to select the destination node for occasional direct paths, with penalties for outliers and centrality adjustments to refine node selection.",
          "thought": "The new algorithm combines centrality-based selection with dynamic weight adjustment, prioritizing nodes with lower average distances to others while balancing proximity and future efficiency through adaptive weights, and includes a probabilistic 25% chance to select the destination node for occasional direct paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = centrality.get(node, 0)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.43218,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing immediate proximity (weighted 1.2) and node centrality (weighted 0.8), with a dynamic scaling factor adjusting the balance based on remaining unvisited nodes. Nodes closer to the current node are prioritized, while centrality (average distance to other unvisited nodes) is considered to avoid isolated nodes. The score is further adjusted by a centrality factor relative to the destination node, scaled by the number of unvisited nodes.",
          "thought": "This new algorithm combines dynamic centrality weighting with adaptive proximity and centrality balancing, where the selection prioritizes nodes closer to the current node while dynamically adjusting for node centrality and remaining unvisited nodes, using a weighted score that balances immediate proximity (weighted 1.2) and centrality (weighted 0.8) with a dynamic scaling factor based on the number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    total_unvisited = len(unvisited_nodes)\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Dynamic weight factor based on unvisited nodes\n    if total_unvisited > 1:\n        weight_factor = 1.0 + (0.4 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n    else:\n        weight_factor = 1.4\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Centrality factor for bias adjustment\n        centrality_factor = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)\n\n        # Weighted score with centrality adjustment\n        score = -1.2 * weight_factor * distance_to_node + 0.8 * avg_distance_to_dest\n        score *= (1.0 + centrality_factor * (1.0 / total_unvisited))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43231,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic centrality weighting with proximity-based selection, prioritizing nodes that balance proximity to the current node with centrality (measured by average distance to other unvisited nodes) and variance (lower variance nodes are preferred). The weight factor adjusts dynamically based on remaining unvisited nodes, favoring exploration early and exploitation later. The scoring function emphasizes proximity early (via `weight_factor`) but increasingly values centrality and variance as the tour progresses.",
          "thought": "The new algorithm combines dynamic centrality weighting with proximity-based selection, balancing exploration and exploitation by adjusting the weight factor based on remaining unvisited nodes while incorporating variance-based centrality refinement similar to No.1.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    total_unvisited = len(unvisited_nodes)\n\n    centrality = {}\n    variance = {}\n    for node in unvisited_nodes:\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        avg_distance = sum(distances_to_others) / max(1, len(distances_to_others))\n        centrality[node] = avg_distance\n        variance[node] = sum((d - avg_distance) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n    weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2)) if total_unvisited > 1 else 1.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = centrality.get(node, 0)\n        centrality_factor = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)\n        variance_factor = 1.2 * (1 - variance.get(node, 0) / (avg_distance_to_dest + 1e-6))\n\n        score = -weight_factor * distance_to_node + variance_factor * avg_distance_to_dest\n        score *= (1.0 + centrality_factor * (1.0 / total_unvisited))\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43428,
          "other_inf": null
     }
]