[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted 1.5) while also considering the node's average distance to other unvisited nodes (weighted 0.5), balancing short-term efficiency and long-term flexibility. The `select_next_node` function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 1.5) and have the highest average distance to the destination node (weighted 0.5), balancing proximity and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = -1.5 * distance_to_node + 0.5 * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity early in the process by heavily weighting the current distance (`distance_to_node`) with a high `weight_factor` (up to 1.5 when few nodes remain). As the number of unvisited nodes decreases, the `weight_factor` decreases, shifting focus to long-term efficiency by balancing the average future distances (`avg_future_distance`). The score combines these weighted terms, ensuring exploration early and optimization later.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 with the immediate proximity and long-term efficiency balance of No.2. It uses a weight factor that decreases as unvisited nodes decrease, prioritizing immediate distance early and long-term efficiency later, while penalizing revisits to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.73404,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: **immediate proximity** (distance from current node), **destination proximity** (distance to the final node), and **centrality penalty** (average distance to remaining unvisited nodes). It prioritizes nodes that are close to the current node (highest weight) and close to the destination (medium weight), while penalizing nodes that are centrally located among unvisited nodes (lower weight). The score is computed as `distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance`, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the immediate proximity from No.2 with the destination proximity and long-term penalty from No.1, balancing short-term efficiency and global path optimization by prioritizing nodes that are close to the current node, close to the destination, and not central to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86535,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by dynamically balancing immediate distance to the next node and long-term distance to the destination, weighted by the proportion of remaining nodes. As the tour progresses (fewer unvisited nodes remain), the algorithm prioritizes minimizing the immediate distance more heavily (`immediate_weight` increases, while `long_term_weight` decreases). The selection is made by evaluating a weighted score for each unvisited node, combining the current node's distance to it and its distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate and long-term efficiency based on the proportion of remaining nodes, ensuring a smoother transition from short-term to long-term optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 to include current node\n    immediate_weight = max(0.5, 1.2 * (remaining_nodes / total_nodes))\n    long_term_weight = 1.0 - immediate_weight\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = immediate_weight * distance_to_node + long_term_weight * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91617,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and destination distance with dynamic weights, adjusted by node centrality and probabilistic selection (via temperature). It prioritizes closer nodes (weighted by `weight_factor`) while considering destination proximity, with centrality influencing selection bias, especially as the temperature (decreasing with remaining nodes) and centrality factors adjust the scoring. The weight factor increases with remaining nodes, emphasizing proximity early, while centrality helps balance exploration.",
          "thought": "The new algorithm combines dynamic weight balancing from No.1 (prioritizing proximity and destination distance with a weight factor) with probabilistic selection and centrality-based bias from No.2 (using temperature and centrality to adjust node selection).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Temperature for probabilistic selection (decreases with remaining nodes)\n    temperature = max(0.1, 1.0 - (1.0 / len(unvisited_nodes)))\n\n    # Dynamic weight factor based on unvisited nodes\n    if total_unvisited > 1:\n        weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n    else:\n        weight_factor = 1.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Centrality factor for bias adjustment\n        centrality_factor = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)\n\n        # Weighted score with centrality adjustment\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n        score *= (1.0 + centrality_factor * temperature)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94945,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity weighting (70% inverse distance to current node), dynamic centrality prioritization (adjusting weight from 0.3 to 0.5 as nodes remain), and detour cost (0.2 weight) to balance local and global efficiency, prioritizing shorter distances and strategic detours while dynamically adjusting centrality importance. The code iterates through unvisited nodes, calculates a weighted score, and selects the highest-scoring node.",
          "thought": "The new algorithm combines the proximity weighting from No.1 (70% inverse distance) with dynamic centrality prioritization from No.2 (weight adjusts from 0.3 to 0.5 when few nodes remain), while also incorporating detour cost (0.2 weight) to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        detour_cost = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n\n        weight = 0.5 if remaining_nodes <= 3 else 0.3\n        score = 0.7 * (1 / distance_to_node) + weight * avg_distance + 0.2 * detour_cost\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.95177,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on a weighted score: 70% proximity to the current node (inverse distance) and 30% distance from the selected node to the destination. This balances local exploration with global progress, ensuring the path remains efficient while avoiding overly direct routes.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 0.7) and far from the destination (weighted 0.3), encouraging exploration of less direct routes while maintaining proximity to the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.7 * (1 / distance_to_node) + 0.3 * distance_to_destination\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.97961,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the destination, prioritizing immediate distance in early stages (high `weight_factor`) and destination distance in later stages (lower `weight_factor`), while penalizing revisits to encourage exploration. It uses a weighted score combining these distances, adjusted by the remaining unvisited nodes, to select the next node. The `weight_factor` decreases as the number of unvisited nodes decreases, ensuring a smooth transition between early exploration and late-stage efficiency.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting factor that adjusts based on the remaining number of unvisited nodes, favoring immediate proximity in early stages and balancing with destination proximity in later stages, while also introducing a penalty for revisiting nodes to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.00423,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the nearest unvisited node from the current node, ensuring a greedy approach to minimize immediate travel distance, while implicitly guiding the path toward the destination by favoring closer nodes. The function iterates through unvisited nodes, checks their distances from the current node using the distance matrix, and selects the one with the smallest distance. The destination node is not explicitly prioritized, but its proximity is indirectly considered by the greedy selection of nearby nodes.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with a weighted balance between local proximity (80% priority) and global progress (20% priority), selecting the next node based on a score that favors closer nodes while slightly considering their distance to the destination. The `distance_matrix` provides pairwise distances, and the function iterates through `unvisited_nodes` to compute a weighted score for each candidate node, ultimately choosing the one with the highest score.",
          "thought": "The algorithm combines the greedy nearest-neighbor approach with a weighted balance between local proximity and global progress, prioritizing nodes with the highest combined score of inverse distance to the current node (80%) and distance to the destination (20%) to improve path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.8 * (1 / distance_to_node) + 0.2 * distance_to_destination\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.00444,
          "other_inf": null
     }
]