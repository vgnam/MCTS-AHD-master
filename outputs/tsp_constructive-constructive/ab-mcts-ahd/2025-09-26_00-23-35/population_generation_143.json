[
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the destination, prioritizing immediate distance in early stages (high `weight_factor`) and destination distance in later stages (lower `weight_factor`), while penalizing revisits to encourage exploration. It uses a weighted score combining these distances, adjusted by the remaining unvisited nodes, to select the next node. The `weight_factor` decreases as the number of unvisited nodes decreases, ensuring a smooth transition between early exploration and late-stage efficiency.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting factor that adjusts based on the remaining number of unvisited nodes, favoring immediate proximity in early stages and balancing with destination proximity in later stages, while also introducing a penalty for revisiting nodes to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.00423,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing the nearest unvisited node from the current node, ensuring a greedy approach to minimize immediate travel distance, while implicitly guiding the path toward the destination by favoring closer nodes. The function iterates through unvisited nodes, checks their distances from the current node using the distance matrix, and selects the one with the smallest distance. The destination node is not explicitly prioritized, but its proximity is indirectly considered by the greedy selection of nearby nodes.",
          "thought": "The algorithm selects the next node to visit by choosing the nearest unvisited node from the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment with a fixed 70-30 split, prioritizing proximity (70%) early in the search (when many nodes remain) and future efficiency (30%) later (when fewer nodes remain). The weights are calculated based on the number of unvisited nodes, ensuring a smooth transition between immediate and long-term considerations. The next node is selected by balancing the current distance to the node and the average future distances from that node to the remaining unvisited nodes.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing proximity and future efficiency based on remaining nodes) with the fixed 70-30 weight split from No.2, creating a hybrid approach that adapts to the problem's stage while maintaining a structured balance between immediate and long-term considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, num_unvisited - 1)\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.02577,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity and long-term efficiency, with weights dynamically adjusted based on the number of remaining unvisited nodes. In early stages (many unvisited nodes), it prioritizes proximity (weighted higher), while in later stages (fewer unvisited nodes), it emphasizes future efficiency (weighted higher). The score combines weighted proximity (distance to the node) and average future distances, ensuring a trade-off between immediate and long-term optimality.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where weights are inversely proportional to the number of remaining nodes, emphasizing immediate proximity in early stages and long-term efficiency in later stages.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes) / max(1, num_unvisited)\n        weight_proximity = 0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))\n        weight_future = 0.4 * (1 - (num_unvisited / (num_unvisited + 1)))\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06159,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (50% weight), destination proximity (30% weight), and penalizing nodes with high average distances to unvisited nodes (-80% weight). It prioritizes short-term efficiency (current and destination distances) while avoiding nodes that are central to remaining unvisited nodes (long-term penalty). The scoring mechanism ensures a trade-off between greediness and global path optimization.",
          "thought": "The new algorithm prioritizes immediate proximity (weight 0.5) and destination proximity (weight 0.3), while incorporating a stronger penalty for nodes with high average distances to unvisited nodes (weight -0.8), aiming for a balance between short-term efficiency and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = 0.5 * distance_to_node + 0.3 * distance_to_destination - 0.8 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.06294,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and future efficiency to the destination, with weights dynamically adjusted based on remaining unvisited nodes. It penalizes nodes that are significantly farther from the current node than the distance to the destination, prioritizing closer nodes early and more future-oriented choices later. The weights (`weight_proximity` and `weight_future`) and penalty (`penalty`) dynamically adapt to the remaining nodes, ensuring a trade-off between immediate and long-term path efficiency.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing proximity and future efficiency) with the penalty mechanism from No.2 (discouraging excessive detours) to improve solution quality. It selects the next node by scoring nodes based on a weighted combination of immediate distance and future distance to the destination, while penalizing nodes that are too far from the current node, and dynamically adjusts weights based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        weight_proximity = 0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))\n        weight_future = 0.4 * (1 - (num_unvisited / (num_unvisited + 1)))\n        penalty = 1.2 if distance_to_node > 2 * distance_to_destination else 1.0\n        score = weight_proximity * distance_to_node + weight_future * distance_to_destination * penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.11069,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity and global progress by combining the distance to the next node with a weighted distance to the destination, where the weight is adjusted based on the remaining unvisited nodes (higher weight when fewer nodes remain). The score is computed as `distance_to_node + (0.7 * distance_to_destination * density_factor)`, prioritizing local proximity when many nodes remain and global progress when few nodes remain. The `density_factor` scales the destination influence, making the algorithm adaptive.",
          "thought": "The new algorithm combines the adaptive density factor from No.1 with the weighted balancing approach of No.2, dynamically adjusting the priority between local proximity and global progress based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for the current node\n    density_factor = 1 - (len(unvisited_nodes) / total_nodes) if total_nodes > 0 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_node + (0.7 * distance_to_destination * density_factor)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.11809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP tour by balancing immediate proximity (distance from the current node) and long-term efficiency (average future distances to remaining unvisited nodes). It dynamically adjusts the weight of these factors based on the number of remaining unvisited nodes, prioritizing long-term efficiency as the tour progresses. The weight is calculated as `0.7 * (remaining_nodes / (remaining_nodes + 1)) + 0.3`, reducing the emphasis on immediate proximity as `remaining_nodes` decreases. The score for each candidate node combines the weighted distance to the node and the weighted average future distances, ensuring a trade-off between short-term and long-term goals.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for immediate proximity is reduced as the number of unvisited nodes decreases to emphasize long-term efficiency in later stages of the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n        weight = 0.7 * (remaining_nodes / (remaining_nodes + 1)) + 0.3\n        score = weight * distance_to_node + (1 - weight) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.12562,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate proximity (distance from current node) and long-term efficiency (distance to the destination), where the latter's weight decreases dynamically as more nodes are visited. The score function prioritizes minimizing the sum of current distance and a weighted destination distance, with the weight inversely proportional to unvisited nodes, emphasizing long-term efficiency as the tour progresses.",
          "thought": "The new algorithm modifies the scoring mechanism to include a dynamic weight for the distance to the destination, where the weight is inversely proportional to the number of unvisited nodes, emphasizing long-term efficiency as the tour progresses, while still prioritizing immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        weight = 1.0 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = distance_to_node + weight * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.14301,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the next node and efficiency toward the destination by adjusting a density factor. When unvisited nodes are sparse (low density), it prioritizes minimizing `distance_to_node`, while in dense regions, it favors minimizing `distance_to_destination`. The `score` equation combines these priorities using the inverse of the density factor, ensuring adaptability to varying node distributions.",
          "thought": "The new algorithm modifies the selection heuristic by incorporating a dynamic weighting factor that adjusts based on the remaining nodes' density, favoring immediate proximity when unvisited nodes are sparse and balancing long-term efficiency when nodes are dense, using the score equation: score = (distance_to_node * (1 - density_factor)) + (distance_to_destination * density_factor), where density_factor = (1 - len(unvisited_nodes) / total_nodes).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for the current node\n    density_factor = 1 - (len(unvisited_nodes) / total_nodes) if total_nodes > 0 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = (distance_to_node * (1 - density_factor)) + (distance_to_destination * density_factor)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     }
]