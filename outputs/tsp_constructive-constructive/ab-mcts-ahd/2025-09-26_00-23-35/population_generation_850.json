[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance (weight 2.0) while balancing centrality (weight 1.0) and slightly considering destination proximity (weight 0.3) to select the next node in a TSP heuristic. It evaluates each unvisited node by scoring a weighted combination of its distance from the current node, average distance to other unvisited nodes, and its proximity to the destination. The highest-scoring node is chosen as the next move.",
          "thought": "The new algorithm combines the heavy prioritization of immediate distance (weight 2.0) from No.1 with the centrality consideration (weight 1.0) from No.2, while slightly reducing the influence of destination proximity (weight 0.3) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.3 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30063,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple factors to select the next node: it prioritizes proximity to the current node (highest weight 2.5), balances centrality among unvisited nodes (weight 1.5), and considers progress toward the destination (weight 1.0), while penalizing nodes too far from the destination (weight 0.5) to avoid detours. The score is computed as `-2.5 * distance_to_node + 1.5 * avg_distance + 1.0 * distance_to_dest - 0.5 * (distance_to_dest ** 2)`, where higher scores indicate better choices. The function iterates through unvisited nodes, evaluates their scores, and returns the node with the highest score.",
          "thought": "The new algorithm combines the strengths of all four algorithms by prioritizing proximity to the current node (weighted 2.5), centrality among unvisited nodes (weighted 1.5), and progress toward the destination (weighted 1.0), while also incorporating a penalty for nodes that are too far from the destination (weighted 0.5) to avoid detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.5 * distance_to_node + 1.5 * avg_distance + 1.0 * distance_to_dest - 0.5 * (distance_to_dest ** 2)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30866,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 3.0), balancing it with the average distance to remaining unvisited nodes (weight 1.5), and slightly considering the distance to the destination (weight 0.3). The node with the highest computed score, combining these weighted factors, is chosen as the next step in the path. The design balances local optimization (closeness to current node) with a broader view of the remaining path (average distance to unvisited nodes), while minimally accounting for the destination's influence.",
          "thought": "The new algorithm prioritizes minimizing distance to the current node (weight 3.0), maximizing average distance to unvisited nodes (weight 1.5), and slightly considering distance to the destination (weight 0.3), favoring closer nodes with a broader view of the remaining path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -3.0 * distance_to_node + 1.5 * avg_distance + 0.3 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33684,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity, centrality, and indirect progress based on the remaining unvisited nodes. Early in the search (high remaining_ratio), it prioritizes proximity (weight=1.5) and centrality (weight=1.0), while later it balances proximity (weight=1.0) with indirect progress (weight=1.5). Centrality is always moderately weighted (1.0), and indirect progress gets lower priority (0.5 early, 1.0 later). The score combines these weighted components to select the next node.",
          "thought": "The new algorithm combines the scoring mechanism of No.1 (balancing proximity, centrality, and indirect progress) with the dynamic weight adjustment of No.2 (prioritizing proximity early and future efficiency later). It scores nodes by dynamically adjusting weights for proximity, centrality, and indirect progress based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        if remaining_ratio > 0.5:\n            weight_proximity = 1.5\n            weight_centrality = 1.0\n            weight_indirect = 0.5\n        else:\n            weight_proximity = 1.0\n            weight_centrality = 1.5\n            weight_indirect = 1.0\n\n        score = weight_proximity * (-distance_to_node) + weight_centrality * avg_distance + weight_indirect * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.36673,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity (higher weight early), centrality (higher weight later), and progress toward the destination, while incorporating future path efficiency. It adjusts weights based on remaining unvisited nodes and scores each candidate node using a weighted combination of immediate distance, average connectivity, distance to destination, and potential future efficiency. Proximity and centrality weights shift dynamically to prioritize exploration early and efficiency later.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the number of remaining unvisited nodes, favoring centrality early in the path and proximity later, while incorporating a heuristic to balance immediate distance with potential future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Dynamic weights based on remaining nodes\n        proximity_weight = 2.0 if remaining_nodes > 5 else 1.5\n        centrality_weight = 1.5 if remaining_nodes > 5 else 2.0\n        progress_weight = 0.5 if remaining_nodes > 5 else 1.0\n\n        # Heuristic to balance immediate distance with future path efficiency\n        future_efficiency = sum(min(distance_matrix[node][n], distance_matrix[n][destination_node]) for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = (-proximity_weight * distance_to_node) + (centrality_weight * avg_distance) + (progress_weight * distance_to_dest) + (0.3 * future_efficiency)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.37718,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing three criteria: minimizing immediate distance (weight 2.0), ensuring good average connectivity to remaining nodes (weight 0.5), and prioritizing proximity to the destination (weight 1.0). The code iterates over unvisited nodes, computes a weighted score for each, and chooses the node with the highest score. Immediate distance is heavily prioritized, while average connectivity has a moderate influence, and destination proximity is balanced.",
          "thought": "The new algorithm combines the strengths of the three algorithms: balancing immediate distance (weighted 2.0), average distance to unvisited nodes (weighted 0.5), and proximity to the destination (weighted 1.0), while ensuring the path remains efficient and centralized.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_unvisited = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 0.5 * avg_distance_to_unvisited + 1.0 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40146,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes proximity (60% weight) by minimizing distance to the next node, while maximizing centrality (40% weight) by selecting nodes that are centrally located among unvisited nodes. It evaluates each candidate node by combining these two weighted scores and selects the one with the highest total score. The centrality score is calculated as the average distance to all other unvisited nodes, ensuring the next node is both close and well-connected to the remaining unvisited nodes.",
          "thought": "The new algorithm prioritizes proximity (60% weight) and centrality (40% weight), but uses a different scoring formula where proximity is minimized and centrality is maximized, favoring nodes that are close to the current node and central to the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight_proximity = 0.6\n    weight_centrality = 0.4\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        centrality_score = avg_distance_to_dest\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40663,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     }
]