[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity (weighted higher early on) and global efficiency (weighted higher later) to select the next node, while penalizing outliers and rewarding central nodes, using a distance matrix and unvisited nodes set. The weights adjust based on remaining unvisited nodes, with proximity dominating early (60% initial) and future efficiency gaining importance later (40% later). The score combines weighted local distance, average future distances, outlier penalties, and centrality rewards to guide the path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment with global progress, where weights shift from local proximity to global efficiency as nodes are visited, and includes outlier penalties while balancing local and global scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality reward\n        centrality_reward = -0.4 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (distance to the next node) and centrality (node centrality in the remaining unvisited nodes) by adjusting weights based on the number of remaining unvisited nodes. Early in the search, proximity is prioritized (60% weight), while centrality gains importance (40% weight) later. Centrality is scored using variance-adjusted average distances, favoring nodes with balanced connections to remaining nodes. The weights transition smoothly from (60% proximity, 40% centrality) to (40% proximity, 60% centrality) as the search progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with centrality consideration, prioritizing proximity (60%) and centrality (40%) early in the search, with weights smoothly transitioning to proximity (40%) and centrality (60%) later, while using variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy proximity heuristic with dynamic centrality bias, prioritizing closer nodes early and central hubs as the tour progresses. It adjusts weights for proximity (initially higher) and centrality (initially lower) based on remaining unvisited nodes, using a score combining distance and centrality (average distance minus variance). The centrality score helps balance proximity and network centrality, with weights shifting toward centrality as the tour advances.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a dynamic bias toward centrality, adjusting weights based on the number of unvisited nodes to prioritize central hubs as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    weight_centrality = 0.3 * (num_unvisited / (num_unvisited + 1)) + 0.7\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41745,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity (distance to current node) and centrality (node's average distance to others minus variance) in a dynamic weighted scoring system, where weights smoothly transition from proximity-heavy to centrality-heavy as unvisited nodes decrease. It prioritizes proximity early (with bias toward destination nodes when far) and centrality later, using a bias factor to boost scores for nodes that are closer to the destination. The scoring function balances these criteria to select the next node efficiently.",
          "thought": "The new algorithm combines the dynamic weighting approach of No.1 (balancing proximity and centrality) with the destination-biased selection of No.2, using a smoothly transitioning weight between the two criteria based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        if node == destination_node:\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n        else:\n            dest_distance = distance_matrix[node][destination_node]\n            bias_factor = distance_to_node / (dest_distance + 1e-6)\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n            if bias_factor > 0.7:\n                score *= 1.2\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43114,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines proximity and future efficiency with dynamic weights (60% proximity early, 40% future efficiency later), adds a penalty for distant nodes when few remain, and rewards central nodes with lower average future distances. The algorithm prioritizes immediate proximity early in the search but shifts focus to future efficiency as fewer nodes remain, while penalizing distant nodes and rewarding central nodes to balance exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustment for proximity and future efficiency from No.1, with exploration-exploitation balance from No.2, adding a penalty for distant nodes when few nodes remain and a centrality reward to prioritize nodes with lower average future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (remaining_nodes / (remaining_nodes + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (remaining_nodes / (remaining_nodes + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n\n        # Penalty for distant nodes when few nodes remain\n        penalty = 0.2 * distance_matrix[node][destination_node] if remaining_nodes <= 3 else 0\n\n        # Centrality reward\n        centrality_reward = -0.3 * avg_future_distance\n\n        # Score with dynamic weights, penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two objectives: minimizing the distance from the current node (weighted 2.0) and maximizing the distance to the destination (weighted 1.0). It prioritizes reducing immediate travel cost while indirectly encouraging progress toward the final destination. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node (weighted 2.0) while also considering the node's proximity to the destination (weighted 1.0), aiming to balance immediate efficiency with progress toward the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by prioritizing proximity (70% weight) and centrality (30% weight), where proximity is the direct distance from the current node, and centrality is the average distance from the candidate node to all remaining unvisited nodes. The code iterates over unvisited nodes, calculates a weighted score combining these factors, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes proximity (distance to the next node) with a fixed weight of 70% and centrality (node centrality in the remaining unvisited nodes) with 30%. Centrality is scored using the average distance to remaining nodes, favoring nodes that are well-connected to the unvisited nodes. The algorithm does not adjust weights dynamically.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    weight_proximity = 0.7\n    weight_centrality = 0.3\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        centrality_score = avg_distance_to_dest\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51646,
          "other_inf": null
     }
]