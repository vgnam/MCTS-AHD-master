[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing immediate distance (weight 2.0) while balancing centrality (weight 1.0) and slightly considering destination proximity (weight 0.3) to select the next node in a TSP heuristic. It evaluates each unvisited node by scoring a weighted combination of its distance from the current node, average distance to other unvisited nodes, and its proximity to the destination. The highest-scoring node is chosen as the next move.",
          "thought": "The new algorithm combines the heavy prioritization of immediate distance (weight 2.0) from No.1 with the centrality consideration (weight 1.0) from No.2, while slightly reducing the influence of destination proximity (weight 0.3) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.3 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30063,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple factors to select the next node: it prioritizes proximity to the current node (highest weight 2.5), balances centrality among unvisited nodes (weight 1.5), and considers progress toward the destination (weight 1.0), while penalizing nodes too far from the destination (weight 0.5) to avoid detours. The score is computed as `-2.5 * distance_to_node + 1.5 * avg_distance + 1.0 * distance_to_dest - 0.5 * (distance_to_dest ** 2)`, where higher scores indicate better choices. The function iterates through unvisited nodes, evaluates their scores, and returns the node with the highest score.",
          "thought": "The new algorithm combines the strengths of all four algorithms by prioritizing proximity to the current node (weighted 2.5), centrality among unvisited nodes (weighted 1.5), and progress toward the destination (weighted 1.0), while also incorporating a penalty for nodes that are too far from the destination (weighted 0.5) to avoid detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.5 * distance_to_node + 1.5 * avg_distance + 1.0 * distance_to_dest - 0.5 * (distance_to_dest ** 2)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.30866,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (highest priority), average local connectivity (moderate priority), and destination proximity (lowest priority), scaled by a dynamic bias factor that reduces destination influence as more nodes remain unvisited. The weighted score combines these factors (-2.0 for distance, +1.0 for average distance, and 0.3*distance_to_dest*bias_factor), ensuring local optimization while gradually incorporating global goals.",
          "thought": "The new algorithm combines the weighted scoring approach from No.1 (balancing immediate distance, centrality, and destination proximity) with the dynamic bias factor from No.2 (scaling destination proximity inversely with remaining unvisited nodes). It evaluates each unvisited node by adjusting the weighted score with the bias factor, ensuring a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        bias_factor = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + (0.3 * distance_to_dest * bias_factor)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.32684,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 3.0), balancing it with the average distance to remaining unvisited nodes (weight 1.5), and slightly considering the distance to the destination (weight 0.3). The node with the highest computed score, combining these weighted factors, is chosen as the next step in the path. The design balances local optimization (closeness to current node) with a broader view of the remaining path (average distance to unvisited nodes), while minimally accounting for the destination's influence.",
          "thought": "The new algorithm prioritizes minimizing distance to the current node (weight 3.0), maximizing average distance to unvisited nodes (weight 1.5), and slightly considering distance to the destination (weight 0.3), favoring closer nodes with a broader view of the remaining path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -3.0 * distance_to_node + 1.5 * avg_distance + 0.3 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.33684,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts weights for proximity, centrality, and indirect progress based on the remaining unvisited nodes. Early in the search (high remaining_ratio), it prioritizes proximity (weight=1.5) and centrality (weight=1.0), while later it balances proximity (weight=1.0) with indirect progress (weight=1.5). Centrality is always moderately weighted (1.0), and indirect progress gets lower priority (0.5 early, 1.0 later). The score combines these weighted components to select the next node.",
          "thought": "The new algorithm combines the scoring mechanism of No.1 (balancing proximity, centrality, and indirect progress) with the dynamic weight adjustment of No.2 (prioritizing proximity early and future efficiency later). It scores nodes by dynamically adjusting weights for proximity, centrality, and indirect progress based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        if remaining_ratio > 0.5:\n            weight_proximity = 1.5\n            weight_centrality = 1.0\n            weight_indirect = 0.5\n        else:\n            weight_proximity = 1.0\n            weight_centrality = 1.5\n            weight_indirect = 1.0\n\n        score = weight_proximity * (-distance_to_node) + weight_centrality * avg_distance + weight_indirect * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.36673,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity (higher weight early), centrality (higher weight later), and progress toward the destination, while incorporating future path efficiency. It adjusts weights based on remaining unvisited nodes and scores each candidate node using a weighted combination of immediate distance, average connectivity, distance to destination, and potential future efficiency. Proximity and centrality weights shift dynamically to prioritize exploration early and efficiency later.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the number of remaining unvisited nodes, favoring centrality early in the path and proximity later, while incorporating a heuristic to balance immediate distance with potential future path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Dynamic weights based on remaining nodes\n        proximity_weight = 2.0 if remaining_nodes > 5 else 1.5\n        centrality_weight = 1.5 if remaining_nodes > 5 else 2.0\n        progress_weight = 0.5 if remaining_nodes > 5 else 1.0\n\n        # Heuristic to balance immediate distance with future path efficiency\n        future_efficiency = sum(min(distance_matrix[node][n], distance_matrix[n][destination_node]) for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = (-proximity_weight * distance_to_node) + (centrality_weight * avg_distance) + (progress_weight * distance_to_dest) + (0.3 * future_efficiency)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.37718,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines **proximity prioritization** (80% weight early) with **future efficiency** (20% weight later), dynamically adjusting weights as the number of unvisited nodes decreases. It penalizes outliers (nodes with extreme distances) and rewards nodes with lower average future distances, while occasionally (30%) selecting the destination node probabilistically. The score balances immediate proximity, long-term efficiency, and centrality, ensuring a smooth transition from greedy to strategic path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later), outlier penalties, probabilistic selection (30% chance to pick the destination node), and adaptive weights that transition smoothly from proximity to centrality as the number of unvisited nodes decreases, while penalizing outliers and rewarding nodes with lower average future distances.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (80% proximity early, 20% future efficiency later)\n    weight_proximity = 0.8 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.2 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.6 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 30% chance to select destination node if not already selected\n    if random.random() < 0.3 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.38903,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes **centrality** (higher weight as the tour progresses) and **proximity** (decreasing weight) while balancing **novelty** (fixed weight) to encourage exploration. It scores nodes based on distance to the current node, average distance to unvisited nodes (centrality), and variance (novelty penalty), dynamically adjusting weights to favor centrality later in the tour. The proximity weight starts high but decreases, while centrality weight increases, with novelty acting as a fixed penalty to avoid overfitting to clusters.",
          "thought": "The new algorithm emphasizes dynamic centrality prioritization, where centrality weight increases with tour progress, while proximity weight decreases, and novelty is balanced with a fixed weight to encourage exploration without over-penalizing diversity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    proximity_weight = 0.6 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    centrality_weight = 0.3 * (1 - num_unvisited / (num_unvisited + 1)) + 0.7\n    novelty_weight = 0.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        avg_distance_to_dest = sum(distances_to_others) / max(1, len(distances_to_others))\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - 0.3 * variance\n        novelty_penalty = variance * novelty_weight\n\n        score = -proximity_weight * distance_to_node + centrality_weight * centrality_score - novelty_penalty\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40001,
          "other_inf": null
     }
]