[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted 1.5) while also considering the node's average distance to other unvisited nodes (weighted 0.5), balancing short-term efficiency and long-term flexibility. The `select_next_node` function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 1.5) and have the highest average distance to the destination node (weighted 0.5), balancing proximity and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = -1.5 * distance_to_node + 0.5 * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity early in the process by heavily weighting the current distance (`distance_to_node`) with a high `weight_factor` (up to 1.5 when few nodes remain). As the number of unvisited nodes decreases, the `weight_factor` decreases, shifting focus to long-term efficiency by balancing the average future distances (`avg_future_distance`). The score combines these weighted terms, ensuring exploration early and optimization later.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 with the immediate proximity and long-term efficiency balance of No.2. It uses a weight factor that decreases as unvisited nodes decrease, prioritizing immediate distance early and long-term efficiency later, while penalizing revisits to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.73404,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: **immediate proximity** (distance from current node), **destination proximity** (distance to the final node), and **centrality penalty** (average distance to remaining unvisited nodes). It prioritizes nodes that are close to the current node (highest weight) and close to the destination (medium weight), while penalizing nodes that are centrally located among unvisited nodes (lower weight). The score is computed as `distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance`, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the immediate proximity from No.2 with the destination proximity and long-term penalty from No.1, balancing short-term efficiency and global path optimization by prioritizing nodes that are close to the current node, close to the destination, and not central to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86535,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by dynamically balancing immediate distance to the next node and long-term distance to the destination, weighted by the proportion of remaining nodes. As the tour progresses (fewer unvisited nodes remain), the algorithm prioritizes minimizing the immediate distance more heavily (`immediate_weight` increases, while `long_term_weight` decreases). The selection is made by evaluating a weighted score for each unvisited node, combining the current node's distance to it and its distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate and long-term efficiency based on the proportion of remaining nodes, ensuring a smoother transition from short-term to long-term optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 to include current node\n    immediate_weight = max(0.5, 1.2 * (remaining_nodes / total_nodes))\n    long_term_weight = 1.0 - immediate_weight\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = immediate_weight * distance_to_node + long_term_weight * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91617,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, connectivity, and destination alignment to select the next node, dynamically adjusting weights: distance is prioritized early (high weight), while connectivity and alignment gain importance as more nodes are visited. The score function balances these factors, with connectivity weighted lower (0.3-0.1) and alignment weighted higher (0.2+0.1) as the algorithm progresses. The connectivity score measures local connectivity, while alignment ensures progress toward the destination.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance, connectivity, and alignment) with the simplicity of No.2's score function, using a dynamic weight for destination alignment that increases as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        connectivity_score = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < distance_matrix[node][destination_node]) / max(1, len(unvisited_nodes) - 1)\n        destination_alignment = 1 / (1 + distance_matrix[node][destination_node])\n\n        weight_connectivity = 0.3 - 0.1 * (remaining_nodes / total_nodes)\n        weight_alignment = 0.2 + 0.1 * (remaining_nodes / total_nodes)\n\n        score = (distance_to_node +\n                 weight_connectivity * (1 - connectivity_score) +\n                 weight_alignment * destination_alignment)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and destination distance with dynamic weights, adjusted by node centrality and probabilistic selection (via temperature). It prioritizes closer nodes (weighted by `weight_factor`) while considering destination proximity, with centrality influencing selection bias, especially as the temperature (decreasing with remaining nodes) and centrality factors adjust the scoring. The weight factor increases with remaining nodes, emphasizing proximity early, while centrality helps balance exploration.",
          "thought": "The new algorithm combines dynamic weight balancing from No.1 (prioritizing proximity and destination distance with a weight factor) with probabilistic selection and centrality-based bias from No.2 (using temperature and centrality to adjust node selection).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Temperature for probabilistic selection (decreases with remaining nodes)\n    temperature = max(0.1, 1.0 - (1.0 / len(unvisited_nodes)))\n\n    # Dynamic weight factor based on unvisited nodes\n    if total_unvisited > 1:\n        weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n    else:\n        weight_factor = 1.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Centrality factor for bias adjustment\n        centrality_factor = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)\n\n        # Weighted score with centrality adjustment\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n        score *= (1.0 + centrality_factor * temperature)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94945,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity weighting (70% inverse distance to current node), dynamic centrality prioritization (adjusting weight from 0.3 to 0.5 as nodes remain), and detour cost (0.2 weight) to balance local and global efficiency, prioritizing shorter distances and strategic detours while dynamically adjusting centrality importance. The code iterates through unvisited nodes, calculates a weighted score, and selects the highest-scoring node.",
          "thought": "The new algorithm combines the proximity weighting from No.1 (70% inverse distance) with dynamic centrality prioritization from No.2 (weight adjusts from 0.3 to 0.5 when few nodes remain), while also incorporating detour cost (0.2 weight) to balance local and global efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        detour_cost = distance_matrix[node][destination_node] - distance_matrix[current_node][destination_node]\n\n        weight = 0.5 if remaining_nodes <= 3 else 0.3\n        score = 0.7 * (1 / distance_to_node) + weight * avg_distance + 0.2 * detour_cost\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.95177,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node based on a weighted score: 70% proximity to the current node (inverse distance) and 30% distance from the selected node to the destination. This balances local exploration with global progress, ensuring the path remains efficient while avoiding overly direct routes.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 0.7) and far from the destination (weighted 0.3), encouraging exploration of less direct routes while maintaining proximity to the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = 0.7 * (1 / distance_to_node) + 0.3 * distance_to_destination\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.97961,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, node connectivity, and alignment with the destination. It prioritizes shorter distances early in the tour (weight_immediate) and increases connectivity importance (weight_connectivity) as more nodes remain unvisited, while destination alignment (weight_alignment) becomes more significant later. The dynamic weights adjust based on remaining nodes, ensuring a trade-off between local optimization and global path planning.",
          "thought": "The new algorithm modifies the original by introducing a dynamic weight adjustment based on node centrality and a heuristic that prioritizes nodes with high connectivity while penalizing those that disrupt the path towards the destination, using a combination of immediate distance, future connectivity, and destination alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        connectivity_score = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < distance_matrix[node][destination_node]) / max(1, len(unvisited_nodes) - 1)\n        destination_alignment = 1 / (1 + distance_matrix[node][destination_node])\n\n        weight_immediate = 0.5 + 0.3 * (remaining_nodes / total_nodes)\n        weight_connectivity = 0.3 - 0.1 * (remaining_nodes / total_nodes)\n        weight_alignment = 0.2 + 0.1 * (remaining_nodes / total_nodes)\n\n        score = (weight_immediate * distance_to_node +\n                 weight_connectivity * (1 - connectivity_score) +\n                 weight_alignment * destination_alignment)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.99947,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity to the current node and the destination, prioritizing immediate distance in early stages (high `weight_factor`) and destination distance in later stages (lower `weight_factor`), while penalizing revisits to encourage exploration. It uses a weighted score combining these distances, adjusted by the remaining unvisited nodes, to select the next node. The `weight_factor` decreases as the number of unvisited nodes decreases, ensuring a smooth transition between early exploration and late-stage efficiency.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting factor that adjusts based on the remaining number of unvisited nodes, favoring immediate proximity in early stages and balancing with destination proximity in later stages, while also introducing a penalty for revisiting nodes to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.00423,
          "other_inf": null
     }
]