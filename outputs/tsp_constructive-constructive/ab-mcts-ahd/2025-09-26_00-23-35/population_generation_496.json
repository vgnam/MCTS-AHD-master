[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity (weighted higher early on) and global efficiency (weighted higher later) to select the next node, while penalizing outliers and rewarding central nodes, using a distance matrix and unvisited nodes set. The weights adjust based on remaining unvisited nodes, with proximity dominating early (60% initial) and future efficiency gaining importance later (40% later). The score combines weighted local distance, average future distances, outlier penalties, and centrality rewards to guide the path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment with global progress, where weights shift from local proximity to global efficiency as nodes are visited, and includes outlier penalties while balancing local and global scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality reward\n        centrality_reward = -0.4 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (distance to the next node) and centrality (node centrality in the remaining unvisited nodes) by adjusting weights based on the number of remaining unvisited nodes. Early in the search, proximity is prioritized (60% weight), while centrality gains importance (40% weight) later. Centrality is scored using variance-adjusted average distances, favoring nodes with balanced connections to remaining nodes. The weights transition smoothly from (60% proximity, 40% centrality) to (40% proximity, 60% centrality) as the search progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with centrality consideration, prioritizing proximity (60%) and centrality (40%) early in the search, with weights smoothly transitioning to proximity (40%) and centrality (60%) later, while using variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two objectives: minimizing the distance from the current node (weighted 2.0) and maximizing the distance to the destination (weighted 1.0). It prioritizes reducing immediate travel cost while indirectly encouraging progress toward the final destination. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node (weighted 2.0) while also considering the node's proximity to the destination (weighted 1.0), aiming to balance immediate efficiency with progress toward the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (favoring closer nodes with a higher weight of -1.5) and progress toward the destination (with a lower weight of 0.7), ensuring a trade-off between immediate optimization and long-term goal alignment. The scoring mechanism prioritizes minimizing distance from the current node while slightly encouraging nodes closer to the destination.",
          "thought": "The new algorithm modifies the provided one by adjusting the weights of distance to the current node and distance to the destination, favoring closer nodes while still considering progress toward the goal, creating a balance between immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -1.5 * distance_to_node + 0.7 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56632,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines distance, centrality, and exploration priorities, dynamically adjusting weights: early prioritizes proximity (high distance_weight), later balances centrality (centrality_weight), and penalizes high-variance nodes (variance_penalty) while rewarding less-visited nodes (exploration_bonus). The score favors closer nodes initially, shifts to more central nodes later, and avoids nodes with erratic distances. The weights are scaled by remaining unvisited nodes, ensuring adaptive behavior.",
          "thought": "The new algorithm combines dynamic weight adjustments from No.2 with proximity and centrality scoring from No.1, prioritizing distance early and balancing centrality and exploration later while penalizing high-variance nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('-inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    node_frequency = {node: sum(1 for n in unvisited_nodes if n == node) for node in unvisited_nodes}\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        distance_weight = 1.0 - (0.3 * (remaining_nodes / len(unvisited_nodes)))\n        centrality_weight = 0.4 + (0.5 * (remaining_nodes / len(unvisited_nodes)))\n        variance_penalty = 0.2 * (variance / (avg_distance + 1e-6))\n        exploration_bonus = 1.0 / (1.0 + node_frequency.get(node, 0))\n\n        score = (-distance_weight * distance_to_node +\n                centrality_weight * avg_distance -\n                variance_penalty * distance_to_node +\n                exploration_bonus)\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59803,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted 1.5) while also considering the node's average distance to other unvisited nodes (weighted 0.5), balancing short-term efficiency and long-term flexibility. The `select_next_node` function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 1.5) and have the highest average distance to the destination node (weighted 0.5), balancing proximity and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = -1.5 * distance_to_node + 0.5 * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity and centrality, prioritizing closer nodes early (high proximity weight) but gradually favoring central nodes (increasing centrality weight) as unvisited nodes decrease. It uses variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes, while proximity is weighted more heavily initially. The score combines proximity (distance to current node) and centrality (average distance to others), with weights dynamically adjusted based on the number of unvisited nodes.",
          "thought": "The new algorithm combines dynamic weighting of proximity and centrality, where proximity weight decreases as unvisited nodes decrease, while centrality weight increases, and adds variance-based centrality scoring to favor nodes with more balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.5 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        centrality_weight = 0.5 * (1 - variance / (avg_distance_to_dest + 1e-6)) * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68174,
          "other_inf": null
     }
]