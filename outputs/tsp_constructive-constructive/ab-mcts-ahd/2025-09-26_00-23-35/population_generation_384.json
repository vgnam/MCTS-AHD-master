[
     {
          "algorithm": "The algorithm selects the next node by balancing two objectives: minimizing the distance from the current node (weighted 2.0) and maximizing the distance to the destination (weighted 1.0). It prioritizes reducing immediate travel cost while indirectly encouraging progress toward the final destination. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node (weighted 2.0) while also considering the node's proximity to the destination (weighted 1.0), aiming to balance immediate efficiency with progress toward the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weighted 1.5) while also considering the node's average distance to other unvisited nodes (weighted 0.5), balancing short-term efficiency and long-term flexibility. The `select_next_node` function iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that are close to the current node (weighted 1.5) and have the highest average distance to the destination node (weighted 0.5), balancing proximity and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = -1.5 * distance_to_node + 0.5 * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.6162,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing proximity (weighted higher early on but increasing in importance as unvisited nodes decrease) while penalizing nodes with high distance variance to other unvisited nodes (favoring more \"central\" nodes). It balances these factors through a weighted scoring system, where proximity is inversely proportional to distance and centrality is proportional to average distance to other nodes. The weights themselves adjust based on the remaining problem size, ensuring local optimality in later stages.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes, where the weight for proximity increases as the number of unvisited nodes decreases to prioritize local optimality in the final stages. It also introduces a penalty term for nodes with high variance in their distances to other unvisited nodes, favoring nodes that are more \"central\" in the remaining subgraph.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.5 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.5)\n        centrality_weight = 0.5 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.69328,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity early in the process by heavily weighting the current distance (`distance_to_node`) with a high `weight_factor` (up to 1.5 when few nodes remain). As the number of unvisited nodes decreases, the `weight_factor` decreases, shifting focus to long-term efficiency by balancing the average future distances (`avg_future_distance`). The score combines these weighted terms, ensuring exploration early and optimization later.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 with the immediate proximity and long-term efficiency balance of No.2. It uses a weight factor that decreases as unvisited nodes decrease, prioritizing immediate distance early and long-term efficiency later, while penalizing revisits to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        if total_unvisited > 1:\n            weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n        else:\n            weight_factor = 1.5\n\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * avg_future_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.73404,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in a TSP tour by balancing short-term (immediate distance to the next node) and long-term (distance from the next node to the destination) priorities, with weights dynamically adjusted based on the remaining unvisited nodes. The weight for short-term optimization decreases more aggressively (from 1.5 to 0.4) as nodes are visited, while long-term optimization becomes more dominant. The score for each candidate node combines these weighted distances, and the node with the lowest score is chosen. The algorithm prioritizes immediate proximity early in the search but increasingly favors nodes that better align with the long-term path to the destination as the search progresses.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.2 with the weighted score balancing from No.1, using a more aggressive transition from short-term to long-term optimization as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment with more aggressive transition\n        weight_immediate = max(0.4, 1.5 * (remaining_nodes / total_nodes))\n        weight_long_term = 1.0 - weight_immediate\n        score = weight_immediate * distance_to_node + weight_long_term * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.79566,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (70% for proximity early, 30% for future efficiency later) with probabilistic selection (25% chance to pick the destination node) and centrality penalty (lower average distances prioritized). It balances immediate proximity and long-term optimization, with destination proximity and centrality bias playing secondary roles. The weights adapt based on remaining unvisited nodes, and the centrality penalty further refines node selection.",
          "thought": "The new algorithm combines dynamic weight adjustment (70% for proximity early, 30% for future efficiency later) with probabilistic selection (25% chance to pick the destination node) and centrality penalty (prioritizing nodes with lower average distances to others), inspired by the trade-off between immediate proximity and long-term optimization from No.1, while maintaining the dynamic weighting and centrality bias from No.2.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, num_unvisited - 1)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, destination proximity, and centrality penalty\n        score = weight_proximity * distance_to_node + 0.3 * distance_to_destination + weight_future * avg_future_distance + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.83065,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: **immediate proximity** (distance from current node), **destination proximity** (distance to the final node), and **centrality penalty** (average distance to remaining unvisited nodes). It prioritizes nodes that are close to the current node (highest weight) and close to the destination (medium weight), while penalizing nodes that are centrally located among unvisited nodes (lower weight). The score is computed as `distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance`, ensuring a trade-off between short-term efficiency and long-term path optimization.",
          "thought": "The new algorithm combines the immediate proximity from No.2 with the destination proximity and long-term penalty from No.1, balancing short-term efficiency and global path optimization by prioritizing nodes that are close to the current node, close to the destination, and not central to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        score = distance_to_node + 0.3 * distance_to_destination - 0.5 * avg_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86535,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by dynamically balancing immediate distance to the next node and long-term distance to the destination, weighted by the proportion of remaining nodes. As the tour progresses (fewer unvisited nodes remain), the algorithm prioritizes minimizing the immediate distance more heavily (`immediate_weight` increases, while `long_term_weight` decreases). The selection is made by evaluating a weighted score for each unvisited node, combining the current node's distance to it and its distance to the destination.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate and long-term efficiency based on the proportion of remaining nodes, ensuring a smoother transition from short-term to long-term optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = remaining_nodes + 1  # +1 to include current node\n    immediate_weight = max(0.5, 1.2 * (remaining_nodes / total_nodes))\n    long_term_weight = 1.0 - immediate_weight\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = immediate_weight * distance_to_node + long_term_weight * distance_to_destination\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91617,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, connectivity, and destination alignment to select the next node, dynamically adjusting weights: distance is prioritized early (high weight), while connectivity and alignment gain importance as more nodes are visited. The score function balances these factors, with connectivity weighted lower (0.3-0.1) and alignment weighted higher (0.2+0.1) as the algorithm progresses. The connectivity score measures local connectivity, while alignment ensures progress toward the destination.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate distance, connectivity, and alignment) with the simplicity of No.2's score function, using a dynamic weight for destination alignment that increases as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        connectivity_score = sum(1 for n in unvisited_nodes if distance_matrix[node][n] < distance_matrix[node][destination_node]) / max(1, len(unvisited_nodes) - 1)\n        destination_alignment = 1 / (1 + distance_matrix[node][destination_node])\n\n        weight_connectivity = 0.3 - 0.1 * (remaining_nodes / total_nodes)\n        weight_alignment = 0.2 + 0.1 * (remaining_nodes / total_nodes)\n\n        score = (distance_to_node +\n                 weight_connectivity * (1 - connectivity_score) +\n                 weight_alignment * destination_alignment)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.91963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity and destination distance with dynamic weights, adjusted by node centrality and probabilistic selection (via temperature). It prioritizes closer nodes (weighted by `weight_factor`) while considering destination proximity, with centrality influencing selection bias, especially as the temperature (decreasing with remaining nodes) and centrality factors adjust the scoring. The weight factor increases with remaining nodes, emphasizing proximity early, while centrality helps balance exploration.",
          "thought": "The new algorithm combines dynamic weight balancing from No.1 (prioritizing proximity and destination distance with a weight factor) with probabilistic selection and centrality-based bias from No.2 (using temperature and centrality to adjust node selection).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    # Temperature for probabilistic selection (decreases with remaining nodes)\n    temperature = max(0.1, 1.0 - (1.0 / len(unvisited_nodes)))\n\n    # Dynamic weight factor based on unvisited nodes\n    if total_unvisited > 1:\n        weight_factor = 1.0 + (0.5 * (total_unvisited - 1) / (len(distance_matrix) - 2))\n    else:\n        weight_factor = 1.5\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Centrality factor for bias adjustment\n        centrality_factor = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)\n\n        # Weighted score with centrality adjustment\n        score = weight_factor * distance_to_node + (1.0 - weight_factor) * distance_to_destination\n        score *= (1.0 + centrality_factor * temperature)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94945,
          "other_inf": null
     }
]