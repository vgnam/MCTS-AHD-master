[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (highest priority, weighted 2.0), centrality among unvisited nodes (medium priority, weighted 1.0), and indirect progress toward the destination (lowest priority, weighted 0.5). It uses a scoring mechanism to evaluate each unvisited node, favoring closer nodes while considering their role in the remaining path. The `distance_matrix` provides distances between nodes, and the loop iterates over `unvisited_nodes` to compute the best-scoring node.",
          "thought": "The new algorithm combines the strengths of the three existing algorithms by prioritizing proximity to the current node (weighted 2.0), considering centrality among unvisited nodes (weighted 1.0), and indirectly encouraging progress toward the destination (weighted 0.5), creating a balanced approach that minimizes immediate cost while optimizing long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distance_to_dest = distance_matrix[node][destination_node]\n        score = -2.0 * distance_to_node + 1.0 * avg_distance + 0.5 * distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.3005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), using adaptive weights to balance immediate and long-term optimization. It prioritizes proximity early (70% weight) but gradually shifts focus to future efficiency (30% weight) as unvisited nodes decrease, while penalizing outliers and rewarding nodes with lower average future distances. The probabilistic selection ensures occasional direct paths to the destination.",
          "thought": "The new algorithm combines dynamic weight adjustment (prioritizing proximity early and centrality later) with outlier penalties and probabilistic selection (25% chance to pick the destination node), while using adaptive weights based on remaining nodes to balance immediate and long-term optimization.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (70% proximity early, 30% future efficiency later)\n    weight_proximity = 0.7 * (0.6 + 0.4 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.3 * (0.4 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.37107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing **proximity to the current node** (prioritized early) and **centrality among unvisited nodes** (weighted more heavily as the problem size decreases). It calculates a score combining the negative distance to the current node (favoring nearby nodes) and the average distance to other unvisited nodes (favoring central nodes), with weights dynamically adjusted based on the remaining nodes. The variance of distances helps refine centrality, ensuring the selection shifts toward proximity as the number of unvisited nodes shrinks.",
          "thought": "The new algorithm prioritizes nodes with high average proximity to all unvisited nodes while dynamically adjusting selection based on the remaining problem size, favoring centrality early but shifting to proximity as unvisited nodes decrease.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n\n        proximity_weight = 1.0 * (1 + (1 - num_unvisited / len(distance_matrix)) * 0.8)\n        centrality_weight = 1.2 * (1 - variance / (avg_distance_to_dest + 1e-6))\n        score = -proximity_weight * distance_to_node + centrality_weight * avg_distance_to_dest\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.40809,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity (weighted higher early on) and global efficiency (weighted higher later) to select the next node, while penalizing outliers and rewarding central nodes, using a distance matrix and unvisited nodes set. The weights adjust based on remaining unvisited nodes, with proximity dominating early (60% initial) and future efficiency gaining importance later (40% later). The score combines weighted local distance, average future distances, outlier penalties, and centrality rewards to guide the path selection.",
          "thought": "The new algorithm combines dynamic weight adjustment with global progress, where weights shift from local proximity to global efficiency as nodes are visited, and includes outlier penalties while balancing local and global scores.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, total_unvisited - 1)\n\n        # Penalty for outliers\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality reward\n        centrality_reward = -0.4 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances proximity (distance to the next node) and centrality (node centrality in the remaining unvisited nodes) by adjusting weights based on the number of remaining unvisited nodes. Early in the search, proximity is prioritized (60% weight), while centrality gains importance (40% weight) later. Centrality is scored using variance-adjusted average distances, favoring nodes with balanced connections to remaining nodes. The weights transition smoothly from (60% proximity, 40% centrality) to (40% proximity, 60% centrality) as the search progresses.",
          "thought": "The new algorithm combines dynamic weight adjustment with centrality consideration, prioritizing proximity (60%) and centrality (40%) early in the search, with weights smoothly transitioning to proximity (40%) and centrality (60%) later, while using variance-based centrality scoring to prefer nodes with balanced distances to remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy proximity heuristic with dynamic centrality bias, prioritizing closer nodes early and central hubs as the tour progresses. It adjusts weights for proximity (initially higher) and centrality (initially lower) based on remaining unvisited nodes, using a score combining distance and centrality (average distance minus variance). The centrality score helps balance proximity and network centrality, with weights shifting toward centrality as the tour advances.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a dynamic bias toward centrality, adjusting weights based on the number of unvisited nodes to prioritize central hubs as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.7 * (num_unvisited / (num_unvisited + 1)) + 0.3\n    weight_centrality = 0.3 * (num_unvisited / (num_unvisited + 1)) + 0.7\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.41745,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines proximity (distance to current node) and centrality (node's average distance to others minus variance) in a dynamic weighted scoring system, where weights smoothly transition from proximity-heavy to centrality-heavy as unvisited nodes decrease. It prioritizes proximity early (with bias toward destination nodes when far) and centrality later, using a bias factor to boost scores for nodes that are closer to the destination. The scoring function balances these criteria to select the next node efficiently.",
          "thought": "The new algorithm combines the dynamic weighting approach of No.1 (balancing proximity and centrality) with the destination-biased selection of No.2, using a smoothly transitioning weight between the two criteria based on the number of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = -float('inf')\n    num_unvisited = len(unvisited_nodes)\n    weight_proximity = 0.6 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.4 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n    weight_centrality = 0.4 * (0.6 + 0.4 * (num_unvisited / (num_unvisited + 1))) + 0.6 * (0.4 * (1 - (num_unvisited / (num_unvisited + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        distances_to_others = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        variance = sum((d - avg_distance_to_dest) ** 2 for d in distances_to_others) / max(1, len(distances_to_others))\n        centrality_score = avg_distance_to_dest - variance\n\n        if node == destination_node:\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n        else:\n            dest_distance = distance_matrix[node][destination_node]\n            bias_factor = distance_to_node / (dest_distance + 1e-6)\n            score = -weight_proximity * distance_to_node + weight_centrality * centrality_score\n            if bias_factor > 0.7:\n                score *= 1.2\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.43114,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centrality-based selection with dynamic weight adjustment, prioritizing nodes with lower average distances to others (centrality) while balancing proximity and future efficiency through adaptive weights (60% proximity early, 40% future efficiency later). It includes a probabilistic 25% chance to select the destination node for occasional direct paths, with penalties for outliers and centrality adjustments to refine node selection.",
          "thought": "The new algorithm combines centrality-based selection with dynamic weight adjustment, prioritizing nodes with lower average distances to others while balancing proximity and future efficiency through adaptive weights, and includes a probabilistic 25% chance to select the destination node for occasional direct paths.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (total_unvisited / (total_unvisited + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (total_unvisited / (total_unvisited + 1))))\n\n    # Calculate centrality for each node (average distance to all other nodes)\n    centrality = {}\n    for node in unvisited_nodes:\n        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = centrality.get(node, 0)\n\n        # Penalty for outliers (nodes with extreme distance to current node)\n        penalty = max(0, distance_to_node - 2 * avg_future_distance)\n\n        # Centrality penalty (lower average distance is better)\n        centrality_penalty = -0.5 * avg_future_distance\n\n        # Score with dynamic weights, outlier penalty, and centrality penalty\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_penalty\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    # 25% chance to select destination node if not already selected\n    if random.random() < 0.25 and destination_node in unvisited_nodes:\n        next_node = destination_node\n\n    return next_node",
          "objective": 6.43218,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity (distance to current node and average distance to unvisited nodes), hub attraction (node connectivity), and visit frequency (reinforcement learning-inspired adjustment), with higher priority given to proximity and hub attraction while penalizing frequently visited nodes. The learning rate dynamically adjusts based on remaining nodes, and the hub factor normalizes connectivity scores. The code prioritizes nodes that are both close and highly connected, while avoiding over-explored nodes.",
          "thought": "The new algorithm introduces adaptive path diversity by incorporating a reinforcement learning-inspired mechanism that dynamically adjusts node selection based on both proximity and historical visit frequency, while also incorporating a novel \"hub-attraction\" factor that prefers nodes with higher connectivity (more connections to other nodes) to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    total_unvisited = len(unvisited_nodes)\n    hub_attraction = {}\n    visit_counts = {}\n\n    # Calculate hub attraction (connectivity) and initialize visit counts\n    for node in unvisited_nodes:\n        hub_attraction[node] = sum(1 for other in unvisited_nodes if distance_matrix[node][other] > 0)\n        visit_counts[node] = 0\n\n    # Dynamic learning rate based on remaining nodes\n    learning_rate = 0.1 + 0.9 * (1.0 - (total_unvisited / len(distance_matrix)))\n\n    # Reinforcement learning-inspired selection\n    next_node = None\n    best_score = -float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance_to_dest = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n\n        # Hub attraction factor\n        hub_factor = hub_attraction[node] / (max(hub_attraction.values()) + 1e-6)\n\n        # Visit frequency adjustment\n        visit_factor = visit_counts[node] * learning_rate\n\n        # Combined score with hub attraction and visit frequency\n        score = (-distance_to_node + avg_distance_to_dest) * (1.0 + hub_factor)\n        score -= visit_factor\n\n        if score > best_score:\n            best_score = score\n            next_node = node\n\n    # Update visit counts for the selected node\n    if next_node is not None:\n        visit_counts[next_node] += 1\n\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic combines proximity and future efficiency with dynamic weights (60% proximity early, 40% future efficiency later), adds a penalty for distant nodes when few remain, and rewards central nodes with lower average future distances. The algorithm prioritizes immediate proximity early in the search but shifts focus to future efficiency as fewer nodes remain, while penalizing distant nodes and rewarding central nodes to balance exploration and exploitation.",
          "thought": "The new algorithm combines dynamic weight adjustment for proximity and future efficiency from No.1, with exploration-exploitation balance from No.2, adding a penalty for distant nodes when few nodes remain and a centrality reward to prioritize nodes with lower average future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n\n    # Dynamic weights (60% proximity early, 40% future efficiency later)\n    weight_proximity = 0.6 * (0.7 + 0.3 * (remaining_nodes / (remaining_nodes + 1)))\n    weight_future = 0.4 * (0.3 * (1 - (remaining_nodes / (remaining_nodes + 1))))\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)\n\n        # Penalty for distant nodes when few nodes remain\n        penalty = 0.2 * distance_matrix[node][destination_node] if remaining_nodes <= 3 else 0\n\n        # Centrality reward\n        centrality_reward = -0.3 * avg_future_distance\n\n        # Score with dynamic weights, penalty, and centrality reward\n        score = weight_proximity * distance_to_node + weight_future * avg_future_distance + penalty + centrality_reward\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50112,
          "other_inf": null
     }
]