def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    remaining_nodes = len(unvisited_nodes)
    if remaining_nodes == 0:
        return destination_node

    dest_distance = distance_matrix[current_node][destination_node]
    candidates = []
    total_weight = 0.0

    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        if node == destination_node:
            candidates.append((node, 0.0, 1.0))  # Force destination selection when close
            continue

        # Dynamic weight combining distance and destination bias
        distance_weight = 1.0 / (distance + 1e-6)
        dest_bias = dest_distance / (distance + 1e-6)
        combined_weight = (0.7 * distance_weight) + (0.3 * dest_bias)

        # Temperature-based annealing for exploration
        temperature = max(0.1, 1.0 - (remaining_nodes / len(unvisited_nodes)))
        adjusted_weight = combined_weight ** (1.0 / temperature)

        candidates.append((node, distance, adjusted_weight))
        total_weight += adjusted_weight

    if not candidates:
        return destination_node

    # Probabilistic selection
    rand_val = random.random() * total_weight
    cumulative = 0.0
    for node, distance, weight in candidates:
        cumulative += weight
        if rand_val <= cumulative:
            next_node = node
            break

    # Force destination selection when few nodes remain
    if next_node != destination_node and remaining_nodes <= 2:
        next_node = destination_node if destination_node in unvisited_nodes else next_node

    return next_node
