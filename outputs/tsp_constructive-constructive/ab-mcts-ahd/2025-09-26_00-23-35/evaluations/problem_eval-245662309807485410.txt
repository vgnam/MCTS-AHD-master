importance" metric combining centrality, distance, and connectivity to balance exploration and exploitation more effectively.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    # Adaptive weight based on tour progress
    progress_factor = (total_nodes - remaining_nodes) / total_nodes
    weight_proximity = 1.0 - progress_factor
    weight_future = progress_factor

    # Memory factor (simplified reinforcement learning component)
    memory_factor = {}
    for node in unvisited_nodes:
        memory_factor[node] = 0.5  # Default value, could be updated with historical data

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]

        # Node importance: combines centrality, distance, and connectivity
        centrality = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)
        connectivity = len([n for n in unvisited_nodes if distance_matrix[node][n] < 1.5 * min(distance_to_node, distance_to_destination)])
        node_importance = (0.4 * centrality + 0.3 * distance_to_node + 0.3 * connectivity) / (1 + 0.1 * memory_factor[node])

        # Future potential with memory influence
        future_potential = distance_to_destination * (remaining_nodes / total_nodes) * (1 + 0.2 * memory_factor[node])

        # Combined score with adaptive weights
        score = (weight_proximity * distance_to_node +
                 weight_future * future_potential -
                 0.3 * node_importance +
                 0.1 * (distance_matrix[current_node][node] / max(distance_matrix[current_node])))

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
