def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    next_node = None
    best_score = float('-inf')
    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    # Precompute centrality scores for all unvisited nodes
    centrality_scores = {}
    for node in unvisited_nodes:
        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
        avg_distance = sum(distances) / max(1, len(distances))
        variance = sum((d - avg_distance) ** 2 for d in distances) / max(1, len(distances))
        centrality_scores[node] = (avg_distance, variance)

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        avg_future_distance, variance_future_distance = centrality_scores[node]

        # Dynamic weight for future distance (increases as more nodes are visited)
        weight_future = 0.7 * (1 - remaining_nodes / total_nodes)

        # Exploration bonus for high-variance nodes
        exploration_bonus = 0.2 * variance_future_distance

        # Centrality reward (favors nodes with lower average future distance)
        centrality_reward = -0.4 * avg_future_distance

        # Score combines proximity, weighted future distance, centrality, and exploration
        score = -distance_to_node + weight_future * (-distance_to_destination) + centrality_reward + exploration_bonus

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
