importance of immediate proximity, closeness to the destination, and average future distance based on the number of remaining unvisited nodes, while also penalizing revisits to recently visited nodes to encourage exploration.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('inf')
    remaining_nodes = len(unvisited_nodes)

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_destination = distance_matrix[node][destination_node]
        avg_future_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, remaining_nodes - 1)

        # Dynamic weights based on remaining nodes
        if remaining_nodes > 5:
            weight_immediate = 0.5
            weight_destination = 0.3
            weight_future = 0.2
        else:
            weight_immediate = 0.4
            weight_destination = 0.4
            weight_future = 0.2

        # Penalize revisits to recently visited nodes
        if node in [current_node]:  # Simple revisit penalty (can be expanded)
            penalty = 1.2
        else:
            penalty = 1.0

        score = (weight_immediate * distance_to_node +
                 weight_destination * distance_to_destination +
                 weight_future * avg_future_distance) * penalty

        if score < best_score:
            best_score = score
            next_node = node

    return next_node
