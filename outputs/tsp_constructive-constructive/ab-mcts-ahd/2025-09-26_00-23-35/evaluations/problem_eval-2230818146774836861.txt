importance scores that combine distance, centrality, and recency of visits, with a dynamic exploration factor that scales with path length and remaining nodes, while maintaining a balance between greedy nearest-neighbor selection and more global optimization through importance-weighted random walks.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    # Calculate node importance scores
    importance = {}
    for node in unvisited_nodes:
        # Distance component (inverse of distance)
        dist_score = 1.0 / (distance_matrix[current_node][node] + 1e-6)

        # Centrality component (average distance to other nodes)
        centrality_score = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)
        centrality_score = 1.0 / (centrality_score / (len(unvisited_nodes) - 1) + 1e-6) if len(unvisited_nodes) > 1 else 1.0

        # Recency component (favor recently visited nodes)
        recency_score = 1.0 / (len(unvisited_nodes) - unvisited_nodes.index(node) + 1) if node in unvisited_nodes else 0.0

        # Combined importance score with adaptive weights
        alpha = 0.6 + 0.4 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))
        beta = 0.3 * (1.0 - (len(unvisited_nodes) / (len(unvisited_nodes) + 1)))
        importance[node] = (alpha * dist_score + beta * centrality_score + (1 - alpha - beta) * recency_score)

    # Dynamic exploration factor
    exploration_factor = 0.7 * (1.0 - math.exp(-len(unvisited_nodes) / 10.0)) + 0.3

    # Probabilistic selection based on importance scores
    if random.random() < exploration_factor:
        # Exploration mode: select based on importance scores
        total_importance = sum(importance.values())
        if total_importance > 0:
            probs = [importance[node] / total_importance for node in unvisited_nodes]
            next_node = random.choices(unvisited_nodes, weights=probs, k=1)[0]
        else:
            next_node = random.choice(unvisited_nodes)
    else:
        # Exploitation mode: nearest neighbor
        next_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])

    # Special case: if destination is unvisited and path is long, prioritize it
    if destination_node in unvisited_nodes and len(unvisited_nodes) > 3:
        dest_importance = importance.get(destination_node, 0)
        if dest_importance > 1.5 * sum(importance.values()) / len(importance):
            next_node = destination_node

    return next_node
