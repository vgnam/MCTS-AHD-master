def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('-inf')
    total_unvisited = len(unvisited_nodes)

    if not unvisited_nodes:
        return destination_node

    # Calculate average pairwise distance among unvisited nodes
    avg_pairwise_distance = 0.0
    count = 0
    for i in unvisited_nodes:
        for j in unvisited_nodes:
            if i != j:
                avg_pairwise_distance += distance_matrix[i][j]
                count += 1
    avg_pairwise_distance /= max(1, count)

    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)

        # Dynamic weight based on remaining nodes' density
        weight = 0.7 if avg_pairwise_distance < 1.5 * avg_distance else 0.3
        # Novelty score: rewards high centrality and penalizes outliers
        novelty = (1 / (1 + avg_distance)) - (distance_to_node / avg_pairwise_distance)

        score = novelty - weight * distance_to_node

        if score > best_score:
            best_score = score
            next_node = node

    return next_node
