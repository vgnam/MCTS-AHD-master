import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    next_node = None
    dest_distance = distance_matrix[current_node][destination_node]
    candidates = []

    # Calculate centrality for each node (average distance to all other nodes)
    centrality = {}
    for node in unvisited_nodes:
        total_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)
        centrality[node] = total_distance / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0

    # Dynamic exploration factor based on remaining path length
    exploration_factor = max(0.1, 1.0 - (len(unvisited_nodes) / (len(unvisited_nodes) + len(distance_matrix))))

    # Select candidates based on distance and centrality
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        centrality_bias = centrality.get(node, 0) / (centrality.get(destination_node, 1) + 1e-6)
        score = (1.0 - centrality_bias) * (1.0 - exploration_factor) + (distance / (dest_distance + 1e-6)) * exploration_factor
        candidates.append((node, score))

    # Sort candidates by score and select probabilistically
    candidates.sort(key=lambda x: x[1])
    if random.random() < exploration_factor or len(unvisited_nodes) <= 2:
        next_node = candidates[0][0]
    else:
        # Probabilistic selection based on rank
        ranks = [i + 1 for i in range(len(candidates))]
        probs = [1.0 / (rank ** 2) for rank in ranks]
        probs = [p / sum(probs) for p in probs]
        next_node = random.choices([c[0] for c in candidates], weights=probs)[0]

    # Destination prioritization when centrality is low or exploration is high
    if next_node != destination_node and destination_node in unvisited_nodes:
        dest_centrality = centrality.get(destination_node, 0)
        if (dest_centrality < 0.5 and random.random() < 0.7) or (exploration_factor > 0.6 and random.random() < exploration_factor):
            next_node = destination_node

    return next_node
