def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node

    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    dest_distances = [distance_matrix[node][destination_node] for node in unvisited_nodes]

    # Calculate priorities using a softmax with temperature
    temperature = 0.5  # Controls randomness
    max_dist = max(distances) + 1e-6
    normalized_dist = [d / max_dist for d in distances]
    penalties = [dest_dist * 0.3 for dest_dist in dest_distances]  # Penalty for deviation
    priorities = [np.exp((-normalized_dist[i] - penalties[i]) / temperature) for i in range(len(unvisited_nodes))]

    # Select node with highest priority
    next_node = unvisited_nodes[np.argmax(priorities)]

    return next_node
