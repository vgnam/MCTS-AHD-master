def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return None

    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)
    exploration_factor = 0.5 * (remaining_nodes / total_nodes) ** 2

    # Calculate dynamic thresholds
    proximity_threshold = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / remaining_nodes
    novelty_threshold = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / remaining_nodes

    # Calculate scores
    scores = {}
    for node in unvisited_nodes:
        distance_to_node = distance_matrix[current_node][node]
        distance_to_dest = distance_matrix[node][destination_node]

        # Proximity score (inverse distance)
        proximity_score = 1 / (1 + distance_to_node / proximity_threshold)

        # Novelty score (inverse distance to destination)
        novelty_score = 1 / (1 + distance_to_dest / novelty_threshold)

        # Connectivity score (number of nearby nodes)
        connectivity_score = sum(1 for other in unvisited_nodes
                               if other != node and distance_matrix[node][other] < proximity_threshold)

        # Combined score with dynamic weights
        scores[node] = (1 - exploration_factor) * proximity_score + \
                      exploration_factor * (0.7 * novelty_score + 0.3 * connectivity_score)

    # Select node with highest score
    next_node = max(scores.items(), key=lambda x: x[1])[0] if scores else None
    return next_node
