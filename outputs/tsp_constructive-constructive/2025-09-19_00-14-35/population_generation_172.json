[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: a ratio prioritizing nodes that are closer to the destination relative to their distance from the current node (weighted 0.4), and a penalty for nodes farther from the destination (weighted -0.3). This ensures a trade-off between proximity to the destination and efficiency of the path, while avoiding premature convergence by penalizing long distances. The key design choice is the weighted sum, where the ratio term (distance to destination / distance from current node) has higher priority (0.4) than the penalty term (0.3).",
          "thought": "The new algorithm combines a weighted sum approach with a ratio-based selection, inspired by No.1's ratio prioritization and No.2's weighted balance, while introducing a penalty for proximity to the destination to avoid premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (0.4 * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.63507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of remaining distance to the destination over the current distance, while slightly penalizing nodes closer to the destination (via the `-0.3 * distance_matrix[node][destination_node]` term). This balances exploration (favoring nodes that reduce the remaining distance quickly) and exploitation (avoiding prematurely moving toward the destination). The key design choices prioritize maximizing the ratio while downweighting proximity to the destination.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted sum approach from No.2, favoring nodes that maximize the ratio of remaining distance to the destination over the current distance while slightly penalizing nodes closer to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (current distance), global connectivity (weighted average remaining distance), and a penalty for nodes near the destination (distance to destination). It prioritizes local proximity (0.5 weight) and global connectivity (0.4 weight) over the destination penalty (-0.2 weight), dynamically adjusting weights based on the number of unvisited nodes to favor broader exploration as the problem nears completion. The evaluation function combines these factors to guide the selection toward a globally optimal path.",
          "thought": "This new algorithm combines the dynamic weighting from No.1 and No.2, introduces a penalty for nodes near the destination to encourage broader exploration, and uses a more aggressive weight adjustment to prioritize global connectivity as the number of unvisited nodes decreases, while also considering local proximity with a balanced weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1) ** 2\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.5 * current_dist + 0.4 * weight * avg_remaining_dist - 0.2 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.65651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a two-stage selection process: first narrowing candidates using dynamic neighborhood size (larger early, smaller late), then evaluating nodes based on a weighted path potential (prioritizing immediate distance and connectivity early, with stronger destination bias late). Weights adapt non-linearly to exploration phase, emphasizing distance and connectivity earlier while increasing destination influence later.",
          "thought": "The new algorithm introduces a two-stage selection process where the first stage uses a local search with a dynamic neighborhood size that adapts to the exploration phase, while the second stage evaluates candidates using a novel \"path potential\" metric that combines immediate distance, connectivity, and a dynamic penalty based on the node's position relative to the destination, with weights adjusted by a non-linear exploration factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Stage 1: Dynamic neighborhood search\n    neighborhood_size = max(1, int(3 + 2 * (1 - exploration_factor)))\n    candidates = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:neighborhood_size]\n\n    # Stage 2: Path potential evaluation\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Connectivity score (variance of distances to remaining nodes)\n        if remaining_nodes > 1:\n            remaining_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            mean_dist = sum(remaining_dists) / (remaining_nodes - 1)\n            variance = sum((d - mean_dist) ** 2 for d in remaining_dists) / (remaining_nodes - 1)\n        else:\n            variance = 0\n\n        # Dynamic weights with non-linear adjustment\n        weight_dist = 0.3 + 0.4 * (1 - exploration_factor ** 2)\n        weight_connectivity = 0.2 + 0.3 * (1 - exploration_factor ** 2)\n        weight_penalty = 0.1 + 0.4 * (1 - exploration_factor)\n\n        return (weight_dist * current_dist +\n                weight_connectivity * variance -\n                weight_penalty * (dest_dist ** (1 + 0.5 * exploration_factor)))\n\n    next_node = min(candidates, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.66723,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two criteria: minimizing the distance from the current node (local distance) and the ratio of the local distance to the global distance (distance from the current node to the destination). The weights (0.5 each) ensure equal priority to both metrics, while the ratio term helps avoid local minima by considering the node's proximity to the destination. The code efficiently computes the weighted sum for each unvisited node and selects the one with the minimum value.",
          "thought": "The new algorithm selects the next node by minimizing a weighted sum of the local distance and the ratio of local to global distance, ensuring both proximity to the current node and the destination while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.5 * distance_matrix[current_node][node] + 0.5 * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing exploration (prioritizing local distances) and exploitation (prioritizing global distances) using a dynamically weighted ratio, where exploration dominates early (high remaining nodes) and exploitation dominates later (few remaining nodes). It penalizes nodes that were previously considered but not selected by implicitly favoring those with lower combined local/global ratios. The key variables are `exploration_weight`, which adjusts the balance, and the weighted sum of normalized local and global distances, ensuring a trade-off between proximity to the current node and potential path efficiency.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the local and global distance ratios, where the weight dynamically adjusts based on the remaining number of unvisited nodes, promoting a balance between exploration and exploitation. It also introduces a penalty for revisiting nodes that were previously considered but not selected, encouraging diversity in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_weight = remaining_nodes / total_nodes\n\n    next_node = min(unvisited_nodes, key=lambda node: (\n        exploration_weight * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]) +\n        (1 - exploration_weight) * (distance_matrix[current_node][node] / sum(distance_matrix[node]))\n    ))\n\n    return next_node",
          "objective": 6.68073,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for the TSP prioritizes global connectivity (70% weight) by evaluating the average remaining distances from a candidate node to unvisited nodes, balances local proximity (20% weight) with the direct distance from the current node, and slightly discourages nodes near the destination (10% negative weight) to promote broader exploration. The weight factor `1.0 / (len(unvisited_nodes) + 2)` dynamically increases priority as fewer nodes remain, encouraging more aggressive selection near the end. The algorithm selects the next node by minimizing the weighted sum of these factors.",
          "thought": "The new algorithm emphasizes global connectivity (70% weight) and local proximity (20% weight), while slightly discouraging nodes near the destination (10% negative weight) to encourage broader exploration, and dynamically adjusts priority with the weight factor `1.0 / (len(unvisited_nodes) + 2)` for more aggressive exploration as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 2)\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.7 * weight * avg_remaining_dist + 0.2 * current_dist - 0.1 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.69946,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weighting and two-stage filtering to select the next node in TSP. It prioritizes immediate distance (40\u201350%), connectivity (30\u201340%), and destination penalty (10\u201320%), with weights adjusted by exploration factor and remaining nodes. The first stage filters the closest 1\u20133 candidates, while the second stage evaluates them based on weighted criteria, favoring nodes that balance proximity to the current node, connectivity to remaining nodes, and closeness to the destination.",
          "thought": "The new algorithm combines No.1's dynamic weighting and proximity/connectivity balance with No.2's two-stage filtering, using a weighted score with dynamic weights for immediate distance (40-50%), connectivity (30-40%), and destination penalty (10-20%), adjusted by exploration factor and remaining nodes count.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Stage 1: Filter candidates based on immediate distance\n    candidates = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    candidate_size = max(1, min(3, len(candidates)))\n    top_candidates = candidates[:candidate_size]\n\n    # Stage 2: Evaluate candidates using weighted criteria\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Connectivity score (average distance to remaining nodes)\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n        else:\n            avg_remaining_dist = 0\n\n        # Dynamic weights based on exploration factor and remaining nodes\n        weight_dist = 0.4 + 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * (1 - exploration_factor)\n        weight_penalty = 0.1 + 0.1 * (1 - exploration_factor)\n        weight = 1.0 / (remaining_nodes + 1)\n\n        return (weight_dist * current_dist +\n                weight_connectivity * weight * avg_remaining_dist -\n                weight_penalty * dest_dist)\n\n    next_node = min(top_candidates, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.75314,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance two factors: (1) a ratio of the direct distance to the destination over the distance from the current node, scaled by a dynamic factor that decreases as more nodes are visited, and (2) a direct distance-based term adjusted by the distance to the destination. The higher weight is given to the ratio term, while the second term is modulated by a small factor (0.3) to avoid over-prioritizing proximity. This balances exploration (finding efficient paths to the destination) with exploitation (reducing immediate distance).",
          "thought": "The new algorithm combines the ratio-based selection from No.1 (favoring nodes that reduce remaining distance quickly) with the dynamic convergence from No.2 (prioritizing nearby nodes and progressively aligning with the destination). It balances exploration and exploitation by maximizing a weighted combination of the ratio and a dynamic factor that grows as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    next_node = max(unvisited_nodes, key=lambda node: (\n        (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) *\n        (remaining_nodes / (remaining_nodes + 1)) +\n        (1 / distance_matrix[current_node][node]) * (1 - 0.3 * distance_matrix[node][destination_node])\n    ))\n    return next_node",
          "objective": 6.87622,
          "other_inf": null
     }
]