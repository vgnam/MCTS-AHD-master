[
     {
          "algorithm": "This algorithm combines dynamic weighting with multi-criteria evaluation to select the next node in TSP. It prioritizes local proximity (60%-40% weight) while balancing connectivity (30%-40% weight) and destination awareness (negative weight), with weights adjusted by the exploration factor (remaining nodes/total nodes). The exploration factor dynamically shifts emphasis between local and global considerations, favoring local proximity early and connectivity/destination awareness later.",
          "thought": "The new algorithm combines the balanced weighting approach of No.1 (dynamic exploration factor) with the multi-criteria evaluation of No.2 (local proximity, connectivity, and destination penalty), but adjusts weights to prioritize local proximity more while maintaining connectivity and destination awareness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.1\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.35835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance, connectivity, and destination proximity, with dynamic weights adjusted by an exploration factor. It prioritizes minimizing immediate distance early (higher `weight_local`) and connectivity (higher `weight_connectivity`) in exploration, shifting toward destination proximity (higher `weight_dest`) as the tour nears completion. A penalty mechanism further discourages detours from the destination.",
          "thought": "The new algorithm combines the best features of the three algorithms: dynamic weight adjustment based on exploration factor, balanced consideration of local distance, connectivity, and destination proximity, with an enhanced penalty mechanism to improve tour completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n        penalty_factor = 1.0 + (dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6))\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score * penalty_factor) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.41572,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances three key factors: **local proximity** (weight 0.5), **connectivity** (weight 0.3, scaled by exploration factor), and **destination penalty** (weight -0.2). It prioritizes nearby nodes, favors paths that maintain good connectivity to unvisited nodes (adjusted dynamically by remaining nodes), and slightly penalizes nodes far from the destination. The exploration factor ensures adaptability as the search progresses.",
          "thought": "The new algorithm combines the balanced weighting of No.1 (local proximity, global connectivity, and destination penalty) with the dynamic exploration factor and penalty factor of No.2, using weights of 0.5 for local distance, 0.3 for connectivity (scaled by exploration factor), and -0.2 for destination penalty, while dynamically adjusting connectivity weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3 * exploration_factor\n        weight_dest = -0.2\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.4314,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance (current node to candidate) and global connectivity (candidate's average distance to remaining nodes), weighted dynamically by an exploration factor. It prioritizes immediate distance early (higher weight_local) and connectivity later (higher weight_connectivity), with selection probabilities inversely proportional to these scores. The exploration factor (remaining_nodes/total_nodes) adjusts weights to favor exploration early and exploitation later.",
          "thought": "The algorithm uses a probabilistic approach where nodes are selected based on a combination of immediate distance, global connectivity, and a dynamic exploration factor that favors nodes with high potential for creating shorter cycles, with selection probabilities inversely proportional to a weighted sum of these criteria.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Calculate scores for each candidate node\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Global connectivity score (inverse of average distance to remaining nodes)\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        # Weighted score combining local and global criteria\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.4 + 0.2 * exploration_factor\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score)\n\n        scores.append((node, score))\n\n    # Select node with the lowest score (inverse probability)\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.49873,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines **local distance, connectivity, and destination proximity** with dynamic weights. Early in the search, it prioritizes minimizing immediate travel distance (weight_local) and gradually shifts focus to connectivity (weight_connectivity) and reducing destination distance (weight_dest). Nodes are selected based on the lowest combined score, balancing proximity, network connections, and final destination proximity.",
          "thought": "The new algorithm combines the balanced weighting of No.1 (local proximity, connectivity, and destination penalty) with the dynamic exploration factor and score-based selection of No.2. It prioritizes local distance early, gradually shifts to connectivity and destination proximity, and uses an inverse score selection to favor nodes with the lowest combined cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.59471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate proximity (weighted higher early in the search) with long-term path potential (estimated via inverse distance sums) and a penalty for detours from the destination. It adjusts weights based on exploration progress (remaining nodes/total nodes) and prioritizes local distances early while incorporating connectivity estimates later. The penalty discourages excessive deviations from the destination path.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts node selection based on both immediate proximity and long-term path potential, incorporating a novel \"path potential score\" that estimates the node's contribution to future connectivity and a \"penalty factor\" that discourages excessive detours from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            path_potential = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node)\n            penalty_factor = max(0, (dest_dist - current_dist) / (dest_dist + 1e-6))\n        else:\n            path_potential = 0\n            penalty_factor = 0\n\n        weight_local = 0.4 + 0.1 * exploration_factor\n        weight_potential = 0.3 * (1 - exploration_factor)\n        weight_penalty = -0.3\n\n        return (weight_local * current_dist) + (weight_potential * path_potential) + (weight_penalty * penalty_factor)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.63432,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: a ratio prioritizing nodes that are closer to the destination relative to their distance from the current node (weighted 0.4), and a penalty for nodes farther from the destination (weighted -0.3). This ensures a trade-off between proximity to the destination and efficiency of the path, while avoiding premature convergence by penalizing long distances. The key design choice is the weighted sum, where the ratio term (distance to destination / distance from current node) has higher priority (0.4) than the penalty term (0.3).",
          "thought": "The new algorithm combines a weighted sum approach with a ratio-based selection, inspired by No.1's ratio prioritization and No.2's weighted balance, while introducing a penalty for proximity to the destination to avoid premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (0.4 * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.63507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic weight adjustment, local-global balance, and penalty-based exploitation by prioritizing immediate distance (weighted higher early) and connectivity (weighted higher later), while penalizing nodes farther from the destination as the tour progresses. It balances exploration and exploitation via an exploration factor and dynamically adjusts weights (local: 0.6\u20130.4, connectivity: 0.4\u20130.6) based on remaining unvisited nodes. The penalty factor amplifies the importance of destination proximity as the tour nears completion.",
          "thought": "The new algorithm combines dynamic weight adjustment, local-global balance, and penalty-based exploitation by prioritizing immediate distance (with higher weight early) and connectivity (with increasing weight later), while applying a penalty factor to favor nodes closer to the destination as the tour progresses, and uses an exploration factor to dynamically balance local and global criteria.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.4 + 0.2 * exploration_factor\n        penalty_factor = 1.0 + (dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6))\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score * penalty_factor)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.63542,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of remaining distance to the destination over the current distance, while slightly penalizing nodes closer to the destination (via the `-0.3 * distance_matrix[node][destination_node]` term). This balances exploration (favoring nodes that reduce the remaining distance quickly) and exploitation (avoiding prematurely moving toward the destination). The key design choices prioritize maximizing the ratio while downweighting proximity to the destination.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted sum approach from No.2, favoring nodes that maximize the ratio of remaining distance to the destination over the current distance while slightly penalizing nodes closer to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65199,
          "other_inf": null
     }
]