[
     {
          "algorithm": "This algorithm dynamically balances exploration and exploitation using a sigmoid-weighted scoring system that prioritizes proximity (exploitation) and connectivity (exploration) while penalizing revisited nodes and rewarding novel paths. It adjusts weights based on remaining unvisited nodes and incorporates historical path data for diversity, with local distance, connectivity, flow disruption, destination proximity, centrality, and novelty all contributing to the selection of the next node.",
          "thought": "The new algorithm modifies the scoring system to incorporate a dynamic exploration-exploitation balance using a sigmoid function to adjust weights, adds a penalty for revisiting nodes based on historical path data, and incorporates a novelty bonus for less-visited nodes to encourage diverse exploration while maintaining proximity and connectivity priorities.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, historical_path=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Sigmoid function for dynamic weight adjustment\n    def sigmoid(x):\n        return 1 / (1 + math.exp(-x))\n\n    exploration_weight = sigmoid(5 * (exploration_factor - 0.5))\n    exploitation_weight = 1 - exploration_weight\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n\n        # Novelty bonus based on historical visits\n        novelty_bonus = 0\n        if historical_path and node in historical_path:\n            novelty_bonus = -0.1 * (historical_path.count(node) / len(historical_path))\n\n        # Dynamic weight adjustments\n        weight_local = 0.4 * exploitation_weight + 0.2 * exploration_weight\n        weight_connectivity = 0.3 * exploitation_weight + 0.1 * exploration_weight\n        weight_dest = -0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_novelty = 0.3 * exploration_weight\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_flow * flow_disruption) + (weight_dest * dest_dist) + \\\n                (weight_centrality * centrality_score) + (weight_novelty * novelty_bonus)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.28604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance, connectivity, and destination proximity with dynamic weights, prioritizing local distance (0.5), connectivity (0.3), and destination proximity (-0.2, adjusted by exploration factor), while penalizing flow disruption (-0.2) and detours via a penalty factor. It dynamically balances these factors based on remaining nodes and current context.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (prioritizing local distance, connectivity, and destination proximity with exploration factor) with the balanced scoring approach of No.2 (using weights of 0.5 for local distance, 0.3 for connectivity, and -0.2 for flow disruption). It introduces a penalty factor to discourage detours and dynamically adjusts destination proximity weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3\n        weight_dest = -0.2 * (1 - exploration_factor)\n        weight_flow = -0.2 * flow_disruption if flow_disruption > 0 else 0\n        penalty_factor = 1.0 + dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist) + (weight_flow * flow_disruption) * penalty_factor\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.2894,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple heuristics: prioritizing immediate distance (weighted adaptively), balancing connectivity (weighted higher in exploration), aligning with the destination (weighted lower in exploration), and adding potential gain (weighted lower in later stages). Exploration factor dynamically adjusts weights, with immediate distance and connectivity dominating early, while destination alignment and gain become more relevant as the tour progresses. The potential gain term estimates future savings, while the connectivity score evaluates node centrality in the remaining graph.",
          "thought": "The new algorithm combines the multiplicative trade-off of No.1 with the dynamic weight balancing of No.2 and No.3, adds a novel potential gain term inspired by No.3, and incorporates a destination alignment term to prioritize nodes that reduce the distance to the destination early.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n\n        weight_local = 0.5 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.29988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines adaptive weighting and dynamic thresholds to balance local proximity, connectivity, and centrality during the TSP tour, prioritizing local distances early and connectivity mid-tour while penalizing flow disruptions to optimize global optimization. It dynamically adjusts weights for local distance (high early, lower later), connectivity (balanced mid-tour), and centrality (high when thresholds are met), while heavily penalizing flow disruptions. The dynamic threshold blends exploration factor and normalized path length to guide the selection of the next node.",
          "thought": "The new algorithm combines the adaptive weighting and dynamic threshold mechanisms from No.1 with the exploration-based weight balancing and flow disruption penalization from No.2, creating a hybrid approach that prioritizes local proximity early, balances connectivity and centrality mid-tour, and penalizes flow disruptions to improve global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)\n    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n    normalized_path_length = avg_path_length / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            variance_remaining_dist = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist) * (1.0 + (variance_remaining_dist ** 0.5))\n\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - local_distance\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n\n            dynamic_threshold = 0.7 * exploration_factor + 0.3 * (1 - normalized_path_length)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n            dynamic_threshold = 0\n\n        weight_local = 0.4 + 0.2 * exploration_factor - 0.1 * normalized_path_length\n        weight_connectivity = 0.3 + 0.1 * exploration_factor + 0.1 * normalized_path_length\n        weight_dest = -0.3 + 0.2 * (1 - exploration_factor)\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * dynamic_threshold\n\n        score = (weight_local * local_distance) + (weight_connectivity * connectivity_score) + (weight_flow * flow_disruption) + (weight_dest * dest_distance) + (weight_centrality * centrality_score)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.30413,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes **proximity to the current node** (weighted higher early) and **connectivity to remaining nodes** (weighted higher later) while balancing **destination alignment** (weighted lower early) and **potential future gains** (weighted lower later). Weights adapt dynamically based on the number of unvisited nodes, emphasizing local choices early and global structure later. The `evaluate_node` function computes a score combining these factors, selecting the node with the minimum score as the next step.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines proximity, connectivity, and destination alignment, using adaptive weights that emphasize local choices early and global structure later, while incorporating a novel \"node attractiveness\" metric based on historical visit patterns and potential future gains.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        # Novel: Node attractiveness based on potential future gains\n        potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n\n        weight_local = 0.6 - 0.4 * exploration_factor\n        weight_connectivity = 0.2 + 0.3 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n        weight_gain = 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.31684,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local proximity early in the search (via `weight_local`) while increasingly balancing connectivity (via `weight_connectivity`) and destination proximity (via `weight_dest`) as the number of unvisited nodes decreases. It dynamically adjusts weights based on exploration factors (`exploration_factor`), favoring local choices initially and global structure later, while penalizing distant nodes from the destination. The `connectivity_score` (inverse of average remaining distances) ensures the path remains efficient by considering node connectivity.",
          "thought": "The new algorithm combines adaptive weighting of local proximity, connectivity, and destination proximity with dynamic exploration factors, prioritizing local choices early and global structure later, while incorporating connectivity-aware scoring and destination distance penalties to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.31919,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local distance (40% weight) and connectivity (30% weight) early in the search, while destination proximity (up to -30% weight) only becomes significant in the final stages (when fewer than 30% of nodes remain unvisited). It also includes a penalty mechanism to discourage detours without scaling, using a connectivity score based on inverse distances to nearby nodes and a flow disruption term to balance path smoothness. The weights and exploration factor dynamically adjust the focus between local optimization and global path planning.",
          "thought": "The new algorithm prioritizes local distance and connectivity with fixed weights, emphasizes destination proximity only in the final stages, and uses a linear penalty mechanism to discourage detours without scaling.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n\n        weight_local = 0.4\n        weight_connectivity = 0.3\n        weight_dest = -0.3 * (1 - exploration_factor) if exploration_factor < 0.3 else 0\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        penalty_factor = 1.0 + dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist) + (weight_flow * flow_disruption) * penalty_factor\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.32111,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines reinforcement learning-inspired exploration with a balanced scoring system prioritizing local proximity, connectivity, and centrality, while dynamically adjusting weights based on exploration progress and penalizing flow disruptions. Higher priority is given to local proximity and connectivity (weights 0.4-0.6) as exploration progresses, while destination proximity and centrality (weights -0.2 to 0.4) are emphasized later. Flow disruptions are penalized (negative weight), and weights adapt to remaining nodes. The code iteratively evaluates unvisited nodes using these weighted scores to select the next node.",
          "thought": "The new algorithm combines No.2's reinforcement learning-inspired exploration with No.1's balanced scoring of local proximity, connectivity, and centrality, while dynamically adjusting weights based on exploration progress and penalizing flow disruptions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n\n        weight_local = 0.4 + 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.2 + 0.1 * (1 - exploration_factor)\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * exploration_factor\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_flow * flow_disruption) + (weight_dest * dest_dist) + (weight_centrality * centrality_score)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.32384,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with adaptive weighting of local proximity, connectivity, and destination proximity, dynamically adjusting these weights based on exploration progress (prioritizing local choices early and global structure later). Weights are set such that local distance (`weight_local`) dominates early (higher priority), while connectivity (`weight_connectivity`) and destination distance (`weight_dest`) gain importance later, with destination distance becoming negative (lower priority) when few nodes remain. The score for each candidate node is computed as a weighted sum of these factors, and the node with the minimum score is selected.",
          "thought": "The new algorithm combines nearest-neighbor selection with adaptive balancing of local proximity, connectivity, and destination proximity, where weights dynamically adjust based on exploration progress, prioritizing local choices early and global structure later, while occasionally considering destination distance when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 if exploration_factor < 0.3 else 0\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.33305,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance early (weighted higher at 60-20%) but gradually shifts to connectivity-based selection (weighted up to 40%) as the exploration factor decreases. Destination proximity (weighted negatively) becomes more relevant later, balancing local and global path structure. The exploration factor scales weights dynamically based on remaining unvisited nodes.",
          "thought": "The new algorithm prioritizes immediate distance and destination proximity early, gradually shifting to connectivity-based selection with increased weight on long-term path structure, using a different exploration factor scaling and weight distribution.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 2\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.4 * exploration_factor\n        weight_connectivity = 0.2 + 0.4 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.33628,
          "other_inf": null
     }
]