[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, ensuring a balance between local proximity and global progress by maximizing the ratio `distance_matrix[node][destination_node] / distance_matrix[current_node][node]`. The function iterates over unvisited nodes, choosing the one with the highest ratio, effectively favoring nodes that reduce the remaining distance to the destination while minimizing detours. The destination node is returned if no unvisited nodes remain.",
          "thought": "This algorithm selects the next node by maximizing the ratio of the distance to the destination over the distance from the current node, favoring nodes that are closer to the destination relative to their proximity to the current node, ensuring global optimization while avoiding excessive local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node] / distance_matrix[current_node][node])\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing two criteria: (1) a ratio of the distance from the node to the destination over the distance from the current node, weighted by a dynamic factor that decreases as more nodes are visited (encouraging convergence toward the destination), and (2) the inverse of the distance from the current node (prioritizing nearby nodes). The dynamic factor ensures progressive focus on the destination as the number of remaining unvisited nodes decreases. The code prioritizes nodes that are both close to the current node and progressively aligned with the destination, with the latter's influence growing stronger as the tour nears completion.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the original ratio and a heuristic that prioritizes nodes with the smallest distance to the current node, balanced by a dynamic factor that adjusts based on the number of remaining unvisited nodes to ensure progressive convergence toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    next_node = max(unvisited_nodes, key=lambda node: (\n        (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) *\n        (1 - (remaining_nodes / (remaining_nodes + 1))) +\n        (1 / distance_matrix[current_node][node])\n    ))\n    return next_node",
          "objective": 6.97471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node based on the distance matrix. If no unvisited nodes remain, it returns the destination node, prioritizing destination over other nodes when all are visited. The design emphasizes greedy selection (shortest distance) while ensuring the path ends at the destination.",
          "thought": "The algorithm selects the next node to visit based on the shortest distance from the current node, prioritizing unvisited nodes and considering the destination node if all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance from current node) and global connectivity (average distance to remaining unvisited nodes), with a dynamically adjusted weight that prioritizes local proximity early and global connectivity later. The weight decreases as more nodes are visited, ensuring the path becomes more globally optimized as the tour progresses. The evaluation function combines these factors to choose the node that minimizes the total cost, favoring immediate proximity when few nodes remain.",
          "thought": "The algorithm prioritizes nodes that minimize the sum of their distance to the current node and a weighted average of their distances to all other unvisited nodes, balancing local proximity with global connectivity by dynamically adjusting the weight based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1)\n        return current_dist + weight * avg_remaining_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 7.15549,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by prioritizing proximity to both the current node and the destination, balancing local and global considerations. The key design is the multiplicative heuristic `distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node])`, where the distance to the current node is multiplied by a factor that includes the distance to the destination. This ensures the algorithm avoids local minima by favoring nodes that are close to both the current position and the eventual destination, while still allowing flexibility in the path.",
          "thought": "The new algorithm combines the greedy selection of the nearest node (like No.2) with a multiplicative heuristic that balances proximity to the current node and the destination (inspired by No.1), favoring nodes that are both close to the current position and the destination to avoid local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 7.2688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are close to the current node while also considering their proximity to the destination, balancing immediate and long-term path optimization. It uses a multiplicative heuristic where the distance to the current node is weighted by a factor involving the squared distance to the destination, giving higher priority to nodes that are both nearby and closer to the destination. The key design idea is to trade off short-term efficiency (distance to current node) with long-term efficiency (distance to destination) using a multiplicative factor.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and the destination, with a multiplicative heuristic where the distance to the current node is multiplied by a factor that includes the square of the distance to the destination, encouraging longer-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node] ** 2))\n    return next_node",
          "objective": 7.29968,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing proximity to the current node (80% weight) while slightly favoring proximity to the destination (20% weight). It balances local optimization (short-term distance) with a small global consideration (distance to destination), ensuring a trade-off between speed and path quality. The `distance_matrix` and `unvisited_nodes` are key inputs, while the weights (0.8 and 0.2) reflect the prioritization.",
          "thought": "The new algorithm prioritizes local optimization by heavily favoring proximity to the current node (80% weight) while slightly considering global optimization by giving a smaller weight (20%) to proximity to the destination, aiming to balance speed with reasonable path quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.8 * distance_matrix[current_node][node] + 0.2 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity to the current node (70% weight) and proximity to the destination (30% weight), ensuring a trade-off between local and global optimization to avoid local minima. The `select_next_node` function prioritizes nodes with shorter distances from the current node while also considering their distance to the destination, using a weighted sum in the `min` function. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node with proximity to the destination, using a weighted sum of distances to ensure a more globally optimal path by avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.7 * distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy approach with a global perspective by selecting the next node that minimizes a weighted sum of the distance from the current node and the distance from the candidate node to the destination (with the latter weighted by 0.5). This balances local optimization (immediate travel cost) and global optimization (proximity to the destination), prioritizing the latter slightly. The `distance_matrix` provides the distances between nodes, while `current_node`, `destination_node`, and `unvisited_nodes` guide the selection process. The `min` function ensures the optimal node is chosen based on the weighted criterion.",
          "thought": "The new algorithm combines the greedy selection of No.2 with a global perspective by selecting the next node that minimizes the sum of the distance from the current node and the distance from the candidate node to the destination, weighted by a factor to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]