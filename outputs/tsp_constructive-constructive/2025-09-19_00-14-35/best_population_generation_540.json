{
     "algorithm": "The algorithm prioritizes local distance (40% weight) and connectivity (30% weight) early in the search, while destination proximity (up to -30% weight) only becomes significant in the final stages (when fewer than 30% of nodes remain unvisited). It also includes a penalty mechanism to discourage detours without scaling, using a connectivity score based on inverse distances to nearby nodes and a flow disruption term to balance path smoothness. The weights and exploration factor dynamically adjust the focus between local optimization and global path planning.",
     "thought": "The new algorithm prioritizes local distance and connectivity with fixed weights, emphasizes destination proximity only in the final stages, and uses a linear penalty mechanism to discourage detours without scaling.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n\n        weight_local = 0.4\n        weight_connectivity = 0.3\n        weight_dest = -0.3 * (1 - exploration_factor) if exploration_factor < 0.3 else 0\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        penalty_factor = 1.0 + dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist) + (weight_flow * flow_disruption) * penalty_factor\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
     "objective": 6.32111,
     "other_inf": null
}