{
     "algorithm": "The algorithm prioritizes immediate distance (higher weight) and destination proximity (lower weight) while dynamically adjusting weights based on tour progress (exploration_factor). It balances connectivity (medium weight) and potential gain (lower weight), with weights shifting toward immediate distance as the tour progresses. The exploration_factor (\u221a(remaining_nodes/total_nodes)) controls weight adjustments, giving higher priority to immediate distance and connectivity in early stages and more emphasis on destination proximity and potential gain in later stages.",
     "thought": "The new algorithm combines the multiplicative trade-off of No.2 with the dynamic weighting and exploration factor of No.1, prioritizing immediate distance, connectivity, and destination proximity while adjusting weights based on tour progress.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 0.5\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.2 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
     "objective": 6.28207,
     "other_inf": null
}