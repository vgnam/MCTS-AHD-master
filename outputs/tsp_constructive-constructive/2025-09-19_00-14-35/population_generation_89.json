[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local proximity (60% weight) and global connectivity (30% weight) via dynamic weighting, balancing exploration and efficiency. It slightly discourages nodes near the destination (10% negative weight) to encourage broader exploration, while the weight factor `1.0 / (len(unvisited_nodes) + 1)` adjusts priority dynamically as the number of remaining nodes decreases. The `evaluate_node` function computes a weighted score to select the next node, ensuring a mix of immediate and long-term considerations.",
          "thought": "The new algorithm combines the weighted balance of local and global factors from No.1 with the dynamic weighting approach of No.2, adjusting weights to prioritize local proximity early and global connectivity later, while also incorporating a slight bias toward nodes farther from the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1)\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.6 * current_dist + 0.3 * weight * avg_remaining_dist - 0.1 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.88627,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, ensuring a balance between local proximity and global progress by maximizing the ratio `distance_matrix[node][destination_node] / distance_matrix[current_node][node]`. The function iterates over unvisited nodes, choosing the one with the highest ratio, effectively favoring nodes that reduce the remaining distance to the destination while minimizing detours. The destination node is returned if no unvisited nodes remain.",
          "thought": "This algorithm selects the next node by maximizing the ratio of the distance to the destination over the distance from the current node, favoring nodes that are closer to the destination relative to their proximity to the current node, ensuring global optimization while avoiding excessive local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node] / distance_matrix[current_node][node])\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing two criteria: (1) a ratio of the distance from the node to the destination over the distance from the current node, weighted by a dynamic factor that decreases as more nodes are visited (encouraging convergence toward the destination), and (2) the inverse of the distance from the current node (prioritizing nearby nodes). The dynamic factor ensures progressive focus on the destination as the number of remaining unvisited nodes decreases. The code prioritizes nodes that are both close to the current node and progressively aligned with the destination, with the latter's influence growing stronger as the tour nears completion.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the original ratio and a heuristic that prioritizes nodes with the smallest distance to the current node, balanced by a dynamic factor that adjusts based on the number of remaining unvisited nodes to ensure progressive convergence toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    next_node = max(unvisited_nodes, key=lambda node: (\n        (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) *\n        (1 - (remaining_nodes / (remaining_nodes + 1))) +\n        (1 / distance_matrix[current_node][node])\n    ))\n    return next_node",
          "objective": 6.97471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node based on the distance matrix. If no unvisited nodes remain, it returns the destination node, prioritizing destination over other nodes when all are visited. The design emphasizes greedy selection (shortest distance) while ensuring the path ends at the destination.",
          "thought": "The algorithm selects the next node to visit based on the shortest distance from the current node, prioritizing unvisited nodes and considering the destination node if all other nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local proximity and global connectivity by using an *exploration factor* (higher in early stages) and a *promise factor* (higher in later stages), where the latter evaluates long-term potential via a weighted sum of average and minimum remaining distances. The code prioritizes minimizing immediate distances early on but gradually shifts focus to optimizing future steps, ensuring a trade-off between immediate gains and long-term efficiency.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that balances local proximity and global connectivity, but introduces a novel \"exploration factor\" that increases uncertainty in early stages to escape local optima, while a \"promise factor\" evaluates long-term potential through a weighted sum of remaining distances, ensuring global optimization as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    exploration_factor = 1.0 / (len(unvisited_nodes) + 1)\n    promise_factor = 1.0 - exploration_factor\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            remaining_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(remaining_dists) / (len(unvisited_nodes) - 1)\n            min_remaining_dist = min(remaining_dists)\n            promise = promise_factor * (0.7 * avg_remaining_dist + 0.3 * min_remaining_dist)\n        else:\n            promise = 0\n        return current_dist + exploration_factor * promise\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 7.12557,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (distance from current node) and global connectivity (average distance to remaining unvisited nodes), with a dynamically adjusted weight that prioritizes local proximity early and global connectivity later. The weight decreases as more nodes are visited, ensuring the path becomes more globally optimized as the tour progresses. The evaluation function combines these factors to choose the node that minimizes the total cost, favoring immediate proximity when few nodes remain.",
          "thought": "The algorithm prioritizes nodes that minimize the sum of their distance to the current node and a weighted average of their distances to all other unvisited nodes, balancing local proximity with global connectivity by dynamically adjusting the weight based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1)\n        return current_dist + weight * avg_remaining_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 7.15549,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes closer to the current node while slightly favoring those that are also closer to the destination (10% weight), balancing local and global path optimization to avoid local minima. The critical design is the weighted sum (`distance_matrix[current_node][node] + 0.1 * distance_matrix[node][destination_node]`), where the current node's distance dominates (90%) and the destination's distance has a minor influence (10%). The code efficiently handles unvisited nodes and defaults to the destination if none remain.",
          "thought": "The new algorithm combines the balanced approach of No.2 by minimizing the sum of current and destination distances with a slight preference for nodes closer to the destination, inspired by No.1's weighting scheme. It selects the next node by minimizing a weighted sum of distances from current and destination nodes, with a small weight (e.g., 10%) on the destination distance to avoid local minima while maintaining global awareness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.1 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.19899,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by prioritizing proximity to both the current node and the destination, balancing local and global considerations. The key design is the multiplicative heuristic `distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node])`, where the distance to the current node is multiplied by a factor that includes the distance to the destination. This ensures the algorithm avoids local minima by favoring nodes that are close to both the current position and the eventual destination, while still allowing flexibility in the path.",
          "thought": "The new algorithm combines the greedy selection of the nearest node (like No.2) with a multiplicative heuristic that balances proximity to the current node and the destination (inspired by No.1), favoring nodes that are both close to the current position and the destination to avoid local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 7.2688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are close to the current node while also considering their proximity to the destination, balancing immediate and long-term path optimization. It uses a multiplicative heuristic where the distance to the current node is weighted by a factor involving the squared distance to the destination, giving higher priority to nodes that are both nearby and closer to the destination. The key design idea is to trade off short-term efficiency (distance to current node) with long-term efficiency (distance to destination) using a multiplicative factor.",
          "thought": "The new algorithm prioritizes nodes that balance proximity to the current node and the destination, with a multiplicative heuristic where the distance to the current node is multiplied by a factor that includes the square of the distance to the destination, encouraging longer-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + distance_matrix[node][destination_node] ** 2))\n    return next_node",
          "objective": 7.29968,
          "other_inf": null
     }
]