{
     "algorithm": "The algorithm selects the next node in TSP by balancing local distance (current node to candidate) and global connectivity (candidate's average distance to remaining nodes), weighted dynamically by an exploration factor. It prioritizes immediate distance early (higher weight_local) and connectivity later (higher weight_connectivity), with selection probabilities inversely proportional to these scores. The exploration factor (remaining_nodes/total_nodes) adjusts weights to favor exploration early and exploitation later.",
     "thought": "The algorithm uses a probabilistic approach where nodes are selected based on a combination of immediate distance, global connectivity, and a dynamic exploration factor that favors nodes with high potential for creating shorter cycles, with selection probabilities inversely proportional to a weighted sum of these criteria.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Calculate scores for each candidate node\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Global connectivity score (inverse of average distance to remaining nodes)\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        # Weighted score combining local and global criteria\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.4 + 0.2 * exploration_factor\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score)\n\n        scores.append((node, score))\n\n    # Select node with the lowest score (inverse probability)\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
     "objective": 6.49873,
     "other_inf": null
}