{
     "algorithm": "The algorithm combines local distance, connectivity, and destination proximity with dynamic weights, prioritizing local distance (0.5), connectivity (0.3), and destination proximity (-0.2, adjusted by exploration factor), while penalizing flow disruption (-0.2) and detours via a penalty factor. It dynamically balances these factors based on remaining nodes and current context.",
     "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (prioritizing local distance, connectivity, and destination proximity with exploration factor) with the balanced scoring approach of No.2 (using weights of 0.5 for local distance, 0.3 for connectivity, and -0.2 for flow disruption). It introduces a penalty factor to discourage detours and dynamically adjusts destination proximity weight based on remaining nodes.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3\n        weight_dest = -0.2 * (1 - exploration_factor)\n        weight_flow = -0.2 * flow_disruption if flow_disruption > 0 else 0\n        penalty_factor = 1.0 + dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist) + (weight_flow * flow_disruption) * penalty_factor\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
     "objective": 6.2894,
     "other_inf": null
}