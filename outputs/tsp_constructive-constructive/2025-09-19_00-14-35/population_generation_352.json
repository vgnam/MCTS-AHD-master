[
     {
          "algorithm": "This algorithm combines dynamic weighting with multi-criteria evaluation to select the next node in TSP. It prioritizes local proximity (60%-40% weight) while balancing connectivity (30%-40% weight) and destination awareness (negative weight), with weights adjusted by the exploration factor (remaining nodes/total nodes). The exploration factor dynamically shifts emphasis between local and global considerations, favoring local proximity early and connectivity/destination awareness later.",
          "thought": "The new algorithm combines the balanced weighting approach of No.1 (dynamic exploration factor) with the multi-criteria evaluation of No.2 (local proximity, connectivity, and destination penalty), but adjusts weights to prioritize local proximity more while maintaining connectivity and destination awareness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.1\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.35835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance, connectivity, and destination proximity, with dynamic weights adjusted by an exploration factor. It prioritizes minimizing immediate distance early (higher `weight_local`) and connectivity (higher `weight_connectivity`) in exploration, shifting toward destination proximity (higher `weight_dest`) as the tour nears completion. A penalty mechanism further discourages detours from the destination.",
          "thought": "The new algorithm combines the best features of the three algorithms: dynamic weight adjustment based on exploration factor, balanced consideration of local distance, connectivity, and destination proximity, with an enhanced penalty mechanism to improve tour completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n        penalty_factor = 1.0 + (dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6))\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score * penalty_factor) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.41572,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances three key factors: **local proximity** (weight 0.5), **connectivity** (weight 0.3, scaled by exploration factor), and **destination penalty** (weight -0.2). It prioritizes nearby nodes, favors paths that maintain good connectivity to unvisited nodes (adjusted dynamically by remaining nodes), and slightly penalizes nodes far from the destination. The exploration factor ensures adaptability as the search progresses.",
          "thought": "The new algorithm combines the balanced weighting of No.1 (local proximity, global connectivity, and destination penalty) with the dynamic exploration factor and penalty factor of No.2, using weights of 0.5 for local distance, 0.3 for connectivity (scaled by exploration factor), and -0.2 for destination penalty, while dynamically adjusting connectivity weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3 * exploration_factor\n        weight_dest = -0.2\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.4314,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local distance (current node to candidate) and global connectivity (candidate's average distance to remaining nodes), weighted dynamically by an exploration factor. It prioritizes immediate distance early (higher weight_local) and connectivity later (higher weight_connectivity), with selection probabilities inversely proportional to these scores. The exploration factor (remaining_nodes/total_nodes) adjusts weights to favor exploration early and exploitation later.",
          "thought": "The algorithm uses a probabilistic approach where nodes are selected based on a combination of immediate distance, global connectivity, and a dynamic exploration factor that favors nodes with high potential for creating shorter cycles, with selection probabilities inversely proportional to a weighted sum of these criteria.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Calculate scores for each candidate node\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Global connectivity score (inverse of average distance to remaining nodes)\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        # Weighted score combining local and global criteria\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.4 + 0.2 * exploration_factor\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score)\n\n        scores.append((node, score))\n\n    # Select node with the lowest score (inverse probability)\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.49873,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate proximity (weighted higher early in the search) with long-term path potential (estimated via inverse distance sums) and a penalty for detours from the destination. It adjusts weights based on exploration progress (remaining nodes/total nodes) and prioritizes local distances early while incorporating connectivity estimates later. The penalty discourages excessive deviations from the destination path.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts node selection based on both immediate proximity and long-term path potential, incorporating a novel \"path potential score\" that estimates the node's contribution to future connectivity and a \"penalty factor\" that discourages excessive detours from the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            path_potential = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node)\n            penalty_factor = max(0, (dest_dist - current_dist) / (dest_dist + 1e-6))\n        else:\n            path_potential = 0\n            penalty_factor = 0\n\n        weight_local = 0.4 + 0.1 * exploration_factor\n        weight_potential = 0.3 * (1 - exploration_factor)\n        weight_penalty = -0.3\n\n        return (weight_local * current_dist) + (weight_potential * path_potential) + (weight_penalty * penalty_factor)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.63432,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: a ratio prioritizing nodes that are closer to the destination relative to their distance from the current node (weighted 0.4), and a penalty for nodes farther from the destination (weighted -0.3). This ensures a trade-off between proximity to the destination and efficiency of the path, while avoiding premature convergence by penalizing long distances. The key design choice is the weighted sum, where the ratio term (distance to destination / distance from current node) has higher priority (0.4) than the penalty term (0.3).",
          "thought": "The new algorithm combines a weighted sum approach with a ratio-based selection, inspired by No.1's ratio prioritization and No.2's weighted balance, while introducing a penalty for proximity to the destination to avoid premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (0.4 * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.63507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of remaining distance to the destination over the current distance, while slightly penalizing nodes closer to the destination (via the `-0.3 * distance_matrix[node][destination_node]` term). This balances exploration (favoring nodes that reduce the remaining distance quickly) and exploitation (avoiding prematurely moving toward the destination). The key design choices prioritize maximizing the ratio while downweighting proximity to the destination.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted sum approach from No.2, favoring nodes that maximize the ratio of remaining distance to the destination over the current distance while slightly penalizing nodes closer to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing local proximity (distance from current node) and global efficiency (distance to destination), with weights adjusted based on remaining unvisited nodes. When many nodes remain, it prioritizes a weighted ratio of destination-to-node over current-to-node distance (0.5 weight) while penalizing far nodes (0.3 weight). As nodes are exhausted, local proximity dominates (weights shift to 0.7 and 0.2). The key design is the adaptive weighting and the heuristic score combining normalized distances.",
          "thought": "The new algorithm dynamically adjusts the balance between local proximity and global efficiency, using a weighted sum where the ratio of destination-to-node distance over current-to-node distance is prioritized (weight 0.5) while penalizing nodes far from the destination (weight -0.3), and the weights are adjusted based on the number of remaining unvisited nodes to favor local proximity when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    local_weight = 0.5 if remaining_nodes > 1 else 0.7\n    global_weight = 0.3 if remaining_nodes > 1 else 0.2\n    next_node = max(unvisited_nodes, key=lambda node: (local_weight * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - global_weight * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (current distance), global connectivity (weighted average remaining distance), and a penalty for nodes near the destination (distance to destination). It prioritizes local proximity (0.5 weight) and global connectivity (0.4 weight) over the destination penalty (-0.2 weight), dynamically adjusting weights based on the number of unvisited nodes to favor broader exploration as the problem nears completion. The evaluation function combines these factors to guide the selection toward a globally optimal path.",
          "thought": "This new algorithm combines the dynamic weighting from No.1 and No.2, introduces a penalty for nodes near the destination to encourage broader exploration, and uses a more aggressive weight adjustment to prioritize global connectivity as the number of unvisited nodes decreases, while also considering local proximity with a balanced weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1) ** 2\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.5 * current_dist + 0.4 * weight * avg_remaining_dist - 0.2 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.65651,
          "other_inf": null
     }
]