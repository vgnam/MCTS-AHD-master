{
     "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance (high priority early), connectivity (increasing priority as exploration progresses), and destination proximity (low priority unless near completion), with adaptive weights adjusting based on remaining nodes. The score for each candidate node combines these factors, favoring closer nodes initially but gradually emphasizing connectivity, while occasionally considering destination distance when few nodes remain.",
     "thought": "This new algorithm dynamically balances local distance, global connectivity, and destination proximity with adaptive weights, where early exploration emphasizes immediate distance (high weight_local) and late stages prioritize connectivity (high weight_connectivity) while occasionally considering destination proximity (weight_dest) based on a probabilistic threshold to escape local optima.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2 if exploration_factor < 0.3 else 0\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
     "objective": 6.34966,
     "other_inf": null
}