{
     "algorithm": "The algorithm balances three key factors: **local proximity** (weight 0.5), **connectivity** (weight 0.3, scaled by exploration factor), and **destination penalty** (weight -0.2). It prioritizes nearby nodes, favors paths that maintain good connectivity to unvisited nodes (adjusted dynamically by remaining nodes), and slightly penalizes nodes far from the destination. The exploration factor ensures adaptability as the search progresses.",
     "thought": "The new algorithm combines the balanced weighting of No.1 (local proximity, global connectivity, and destination penalty) with the dynamic exploration factor and penalty factor of No.2, using weights of 0.5 for local distance, 0.3 for connectivity (scaled by exploration factor), and -0.2 for destination penalty, while dynamically adjusting connectivity weight based on remaining nodes.",
     "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3 * exploration_factor\n        weight_dest = -0.2\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
     "objective": 6.4314,
     "other_inf": null
}