[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: a ratio prioritizing nodes that are closer to the destination relative to their distance from the current node (weighted 0.4), and a penalty for nodes farther from the destination (weighted -0.3). This ensures a trade-off between proximity to the destination and efficiency of the path, while avoiding premature convergence by penalizing long distances. The key design choice is the weighted sum, where the ratio term (distance to destination / distance from current node) has higher priority (0.4) than the penalty term (0.3).",
          "thought": "The new algorithm combines a weighted sum approach with a ratio-based selection, inspired by No.1's ratio prioritization and No.2's weighted balance, while introducing a penalty for proximity to the destination to avoid premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (0.4 * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.63507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of remaining distance to the destination over the current distance, while slightly penalizing nodes closer to the destination (via the `-0.3 * distance_matrix[node][destination_node]` term). This balances exploration (favoring nodes that reduce the remaining distance quickly) and exploitation (avoiding prematurely moving toward the destination). The key design choices prioritize maximizing the ratio while downweighting proximity to the destination.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted sum approach from No.2, favoring nodes that maximize the ratio of remaining distance to the destination over the current distance while slightly penalizing nodes closer to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node to visit in TSP by balancing local proximity (distance from current node) and global efficiency (distance to destination), with weights adjusted based on remaining unvisited nodes. When many nodes remain, it prioritizes a weighted ratio of destination-to-node over current-to-node distance (0.5 weight) while penalizing far nodes (0.3 weight). As nodes are exhausted, local proximity dominates (weights shift to 0.7 and 0.2). The key design is the adaptive weighting and the heuristic score combining normalized distances.",
          "thought": "The new algorithm dynamically adjusts the balance between local proximity and global efficiency, using a weighted sum where the ratio of destination-to-node distance over current-to-node distance is prioritized (weight 0.5) while penalizing nodes far from the destination (weight -0.3), and the weights are adjusted based on the number of remaining unvisited nodes to favor local proximity when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    local_weight = 0.5 if remaining_nodes > 1 else 0.7\n    global_weight = 0.3 if remaining_nodes > 1 else 0.2\n    next_node = max(unvisited_nodes, key=lambda node: (local_weight * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - global_weight * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (current distance), global connectivity (weighted average remaining distance), and a penalty for nodes near the destination (distance to destination). It prioritizes local proximity (0.5 weight) and global connectivity (0.4 weight) over the destination penalty (-0.2 weight), dynamically adjusting weights based on the number of unvisited nodes to favor broader exploration as the problem nears completion. The evaluation function combines these factors to guide the selection toward a globally optimal path.",
          "thought": "This new algorithm combines the dynamic weighting from No.1 and No.2, introduces a penalty for nodes near the destination to encourage broader exploration, and uses a more aggressive weight adjustment to prioritize global connectivity as the number of unvisited nodes decreases, while also considering local proximity with a balanced weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1) ** 2\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.5 * current_dist + 0.4 * weight * avg_remaining_dist - 0.2 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.65651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a two-stage selection process: first narrowing candidates using dynamic neighborhood size (larger early, smaller late), then evaluating nodes based on a weighted path potential (prioritizing immediate distance and connectivity early, with stronger destination bias late). Weights adapt non-linearly to exploration phase, emphasizing distance and connectivity earlier while increasing destination influence later.",
          "thought": "The new algorithm introduces a two-stage selection process where the first stage uses a local search with a dynamic neighborhood size that adapts to the exploration phase, while the second stage evaluates candidates using a novel \"path potential\" metric that combines immediate distance, connectivity, and a dynamic penalty based on the node's position relative to the destination, with weights adjusted by a non-linear exploration factor.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Stage 1: Dynamic neighborhood search\n    neighborhood_size = max(1, int(3 + 2 * (1 - exploration_factor)))\n    candidates = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:neighborhood_size]\n\n    # Stage 2: Path potential evaluation\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Connectivity score (variance of distances to remaining nodes)\n        if remaining_nodes > 1:\n            remaining_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            mean_dist = sum(remaining_dists) / (remaining_nodes - 1)\n            variance = sum((d - mean_dist) ** 2 for d in remaining_dists) / (remaining_nodes - 1)\n        else:\n            variance = 0\n\n        # Dynamic weights with non-linear adjustment\n        weight_dist = 0.3 + 0.4 * (1 - exploration_factor ** 2)\n        weight_connectivity = 0.2 + 0.3 * (1 - exploration_factor ** 2)\n        weight_penalty = 0.1 + 0.4 * (1 - exploration_factor)\n\n        return (weight_dist * current_dist +\n                weight_connectivity * variance -\n                weight_penalty * (dest_dist ** (1 + 0.5 * exploration_factor)))\n\n    next_node = min(candidates, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.66723,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two criteria: minimizing the distance from the current node (local distance) and the ratio of the local distance to the global distance (distance from the current node to the destination). The weights (0.5 each) ensure equal priority to both metrics, while the ratio term helps avoid local minima by considering the node's proximity to the destination. The code efficiently computes the weighted sum for each unvisited node and selects the one with the minimum value.",
          "thought": "The new algorithm selects the next node by minimizing a weighted sum of the local distance and the ratio of local to global distance, ensuring both proximity to the current node and the destination while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.5 * distance_matrix[current_node][node] + 0.5 * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing exploration (prioritizing local distances) and exploitation (prioritizing global distances) using a dynamically weighted ratio, where exploration dominates early (high remaining nodes) and exploitation dominates later (few remaining nodes). It penalizes nodes that were previously considered but not selected by implicitly favoring those with lower combined local/global ratios. The key variables are `exploration_weight`, which adjusts the balance, and the weighted sum of normalized local and global distances, ensuring a trade-off between proximity to the current node and potential path efficiency.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the local and global distance ratios, where the weight dynamically adjusts based on the remaining number of unvisited nodes, promoting a balance between exploration and exploitation. It also introduces a penalty for revisiting nodes that were previously considered but not selected, encouraging diversity in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_weight = remaining_nodes / total_nodes\n\n    next_node = min(unvisited_nodes, key=lambda node: (\n        exploration_weight * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]) +\n        (1 - exploration_weight) * (distance_matrix[current_node][node] / sum(distance_matrix[node]))\n    ))\n\n    return next_node",
          "objective": 6.68073,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines dynamic neighborhood selection with adaptive weighted evaluation. It first narrows candidates to the closest nodes (neighborhood size adjusts based on progress) and then selects the next node by balancing the ratio of distance to the destination over the current step (weighted heavily early) with a penalty term (weighted less). The weights adapt non-linearly, prioritizing destination proximity early in the tour and efficiency later.",
          "thought": "The new algorithm combines the weighted ratio prioritization from No.1 with the dynamic neighborhood and adaptive weighting framework of No.2, creating a two-stage process that first narrows candidates based on dynamic neighborhood size and then evaluates nodes using a balance between proximity to the destination and efficiency of the path, with weights that adapt non-linearly to emphasize destination influence as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Stage 1: Dynamic neighborhood search\n    neighborhood_size = max(1, int(3 + 2 * (1 - exploration_factor)))\n    candidates = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:neighborhood_size]\n\n    # Stage 2: Weighted ratio evaluation with adaptive weights\n    def evaluate_node(node):\n        ratio = distance_matrix[node][destination_node] / distance_matrix[current_node][node]\n        penalty = distance_matrix[node][destination_node]\n\n        # Adaptive weights\n        weight_ratio = 0.4 + 0.2 * (1 - exploration_factor)\n        weight_penalty = -0.3 - 0.1 * (1 - exploration_factor)\n\n        return weight_ratio * ratio + weight_penalty * penalty\n\n    next_node = max(candidates, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.69132,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for the TSP prioritizes global connectivity (70% weight) by evaluating the average remaining distances from a candidate node to unvisited nodes, balances local proximity (20% weight) with the direct distance from the current node, and slightly discourages nodes near the destination (10% negative weight) to promote broader exploration. The weight factor `1.0 / (len(unvisited_nodes) + 2)` dynamically increases priority as fewer nodes remain, encouraging more aggressive selection near the end. The algorithm selects the next node by minimizing the weighted sum of these factors.",
          "thought": "The new algorithm emphasizes global connectivity (70% weight) and local proximity (20% weight), while slightly discouraging nodes near the destination (10% negative weight) to encourage broader exploration, and dynamically adjusts priority with the weight factor `1.0 / (len(unvisited_nodes) + 2)` for more aggressive exploration as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 2)\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.7 * weight * avg_remaining_dist + 0.2 * current_dist - 0.1 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.69946,
          "other_inf": null
     }
]