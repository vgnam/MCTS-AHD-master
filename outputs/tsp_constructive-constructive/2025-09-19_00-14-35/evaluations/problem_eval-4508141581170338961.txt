importance.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    temperature = 1.0 / (1.0 + len(unvisited_nodes))  # Dynamic temperature
    exploration_bias = temperature * (sum(distance_matrix[current_node]) / len(distance_matrix[current_node]))  # Centrality-based exploration

    candidate_scores = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Dynamic weight adjustment with node importance
        node_importance = 1.0 / (1.0 + sum(distance_matrix[node]))  # Higher importance for central nodes
        weight_current = 0.5 + 0.4 * (1 - temperature) * node_importance  # Exploitation increases with importance
        weight_dest = 1 - weight_current

        # Penalty for revisiting (node-specific and temperature-scaled)
        revisit_penalty = (hash(node) % 5) * temperature * (1.0 / (1.0 + sum(distance_matrix[node])))

        score = (current_dist * weight_current) + (dest_dist * weight_dest) + exploration_bias - revisit_penalty
        candidate_scores.append((node, score))

    # Probabilistic selection based on scores
    if candidate_scores:
        scores = [score for (node, score) in candidate_scores]
        min_score = min(scores)
        max_score = max(scores)
        normalized_scores = [(max_score - score + 1e-6) for score in scores]  # Invert and stabilize
        total = sum(normalized_scores)
        probs = [s / total for s in normalized_scores]
        next_node = np.random.choice([node for (node, _) in candidate_scores], p=probs)
    else:
        next_node = unvisited_nodes[0] if unvisited_nodes else destination_node

    return next_node
