def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node
    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 0 else 0

    # Sigmoid-based dynamic weighting
    local_weight = 1 / (1 + math.exp(-10 * (remaining_ratio - 0.5)))
    global_weight = 1 - local_weight

    # Novelty factor: penalize nodes with high average distances to others
    novelty_factor = 0.2  # weight for novelty
    novelty_scores = {}
    for node in unvisited_nodes:
        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1) if len(unvisited_nodes) > 1 else 0
        novelty_scores[node] = avg_distance

    min_novelty = min(novelty_scores.values()) if novelty_scores else 0
    max_novelty = max(novelty_scores.values()) if novelty_scores else 1
    normalized_novelty = {node: (novelty_scores[node] - min_novelty) / (max_novelty - min_novelty) if max_novelty != min_novelty else 0 for node in unvisited_nodes}

    # Combined score
    next_node = min(unvisited_nodes, key=lambda node: (
        local_weight * distance_matrix[current_node][node] +
        global_weight * distance_matrix[node][destination_node] +
        novelty_factor * normalized_novelty[node]
    ))

    return next_node
