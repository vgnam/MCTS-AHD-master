importance" metric derived from cumulative distances and a temperature-modulated randomness factor. It prioritizes nodes closest to the current position and destination, but also considers long-term connectivity via the importance metric, with exploration controlled by a cooling temperature and a probabilistic selection mechanism.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    temperature = 1.0 / (1.0 + len(unvisited_nodes))  # Dynamic temperature
    exploration_factor = temperature * (hash(current_node) % 10)  # Node-dependent exploration

    candidate_scores = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Novel node importance metric (cumulative distances to other unvisited nodes)
        importance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)

        # Dynamic weight adjustment with importance consideration
        weight_current = 0.6 * (1 - temperature)  # Stronger exploitation as temperature decreases
        weight_dest = 0.3 * (1 - temperature)
        weight_importance = 0.1 * (1 - temperature)

        # Temperature-modulated randomness
        random_factor = (hash(node) % 10) * temperature

        score = (current_dist * weight_current) + (dest_dist * weight_dest) + (importance * weight_importance) + random_factor
        candidate_scores.append((node, score))

    # Probabilistic selection based on scores
    if temperature > 0.1:  # More exploration at higher temperatures
        probabilities = [1.0 / (1.0 + score) for _, score in candidate_scores]
        total = sum(probabilities)
        probabilities = [p / total for p in probabilities]
        next_node = random.choices([node for node, _ in candidate_scores], weights=probabilities, k=1)[0]
    else:  # Greedy selection at low temperatures
        next_node = min(candidate_scores, key=lambda x: x[1])[0]

    return next_node
