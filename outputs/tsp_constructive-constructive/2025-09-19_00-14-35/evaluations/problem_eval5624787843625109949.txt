import math
import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    exploration_factor = remaining_nodes / total_nodes

    # Dynamic neighborhood size and temperature
    neighborhood_size = max(1, int(2 + 3 * (1 - exploration_factor)))
    temperature = 1.0 - math.exp(-5 * (1 - exploration_factor))

    # Get candidates
    candidates = sorted(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])[:neighborhood_size]

    # Evaluate candidates
    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Connectivity score (MST approximation)
        if remaining_nodes > 1:
            # Simplified MST approximation: sum of minimum distances to remaining nodes
            mst_approx = sum(min(distance_matrix[node][n] for n in unvisited_nodes if n != node)
                            for n in unvisited_nodes if n != node)
        else:
            mst_approx = 0

        # Dynamic weights
        weight_dist = 0.4 + 0.3 * exploration_factor
        weight_connectivity = 0.3 + 0.2 * (1 - exploration_factor)
        weight_penalty = 0.3 + 0.2 * (1 - exploration_factor)

        # Novelty: Add randomness with temperature
        random_factor = random.uniform(0, 1) * temperature

        return (weight_dist * current_dist +
                weight_connectivity * mst_approx -
                weight_penalty * (dest_dist ** (1 + 0.5 * exploration_factor)) +
                random_factor)

    # Probabilistic selection based on evaluation
    evaluations = [evaluate_node(node) for node in candidates]
    min_eval = min(evaluations)
    max_eval = max(evaluations)

    # Normalize and convert to probabilities
    if min_eval == max_eval:
        probabilities = [1.0 / len(candidates)] * len(candidates)
    else:
        normalized = [(max_eval - e) / (max_eval - min_eval) for e in evaluations]
        probabilities = [n ** (1/temperature) for n in normalized]
        total = sum(probabilities)
        probabilities = [p/total for p in probabilities]

    next_node = random.choices(candidates, weights=probabilities, k=1)[0]
    return next_node
