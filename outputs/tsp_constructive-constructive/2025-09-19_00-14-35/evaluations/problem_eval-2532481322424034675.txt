import math
import numpy as np

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    total_nodes = len(distance_matrix)
    remaining_nodes = len(unvisited_nodes)

    # Adaptive exploration factor based on remaining nodes and current position
    exploration_factor = (remaining_nodes / total_nodes) * (1 - (current_node / total_nodes))

    # Temporal difference learning component
    def temporal_difference_score(node):
        immediate_reward = -distance_matrix[current_node][node]
        future_reward = -distance_matrix[node][destination_node]
        return 0.7 * immediate_reward + 0.3 * future_reward

    # Centrality measure using eigenvector centrality approximation
    def node_centrality(node):
        neighbors = [n for n in range(total_nodes) if distance_matrix[node][n] > 0]
        if not neighbors:
            return 0
        return sum(1 / distance_matrix[node][n] for n in neighbors) / len(neighbors)

    # Dynamic weight adjustment
    exploration_weight = math.tanh(3 * exploration_factor)
    exploitation_weight = 1 - exploration_weight

    scores = []
    for node in unvisited_nodes:
        # Immediate distance component
        local_score = -distance_matrix[current_node][node]

        # Long-term path diversity component
        diversity_score = 0
        for n in unvisited_nodes:
            if n != node:
                diversity_score += distance_matrix[node][n] - distance_matrix[current_node][n]

        # Centrality component
        centrality_score = node_centrality(node)

        # Temporal difference component
        td_score = temporal_difference_score(node)

        # Combine components with adaptive weights
        score = (0.4 * exploitation_weight + 0.2 * exploration_weight) * local_score + \
                (0.3 * exploitation_weight + 0.1 * exploration_weight) * diversity_score + \
                (0.2 * exploitation_weight + 0.1 * exploration_weight) * centrality_score + \
                (0.1 * exploitation_weight + 0.3 * exploration_weight) * td_score

        scores.append((node, score))

    next_node = max(scores, key=lambda x: x[1])[0]
    return next_node
