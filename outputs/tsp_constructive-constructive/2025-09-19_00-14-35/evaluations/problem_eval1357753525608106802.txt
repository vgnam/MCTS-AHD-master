def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)

    # Dynamic weighting based on progress
    alpha = 0.6 if remaining_nodes > total_nodes / 2 else 0.4  # More focus on immediate distance early
    beta = 0.3 if remaining_nodes > total_nodes / 2 else 0.5   # More focus on path efficiency later
    gamma = 0.2 if remaining_nodes > total_nodes / 2 else 0.3 # Adjust revisit penalty

    # Local search: consider top-k candidates and their neighborhood
    k = min(3, len(unvisited_nodes))
    candidate_scores = []
    for node in unvisited_nodes:
        immediate_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]
        neighborhood_factor = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes)
        score = (alpha * immediate_dist) + (beta * (dest_dist + neighborhood_factor)) - (gamma * (1 if node in unvisited_nodes else 0))
        candidate_scores.append((node, score))

    # Select from top-k to refine decision
    top_candidates = sorted(candidate_scores, key=lambda x: x[1])[:k]
    next_node = min(top_candidates, key=lambda x: x[1])[0]
    return next_node
