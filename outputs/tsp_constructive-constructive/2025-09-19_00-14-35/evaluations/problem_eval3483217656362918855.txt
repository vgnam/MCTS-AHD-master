def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node
    if len(unvisited_nodes) == 1:
        return next(iter(unvisited_nodes))

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        remaining_nodes = [n for n in unvisited_nodes if n != node]

        if remaining_nodes:
            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)
            min_remaining_dist = min(distance_matrix[node][n] for n in remaining_nodes)
        else:
            avg_remaining_dist = 0
            min_remaining_dist = 0

        # Dynamic weight based on remaining nodes with square root scaling
        weight = (1.0 / (len(unvisited_nodes) ** 0.5 + 1)) ** 2

        # Penalty for revisiting and diversity encouragement
        penalty = 0.1 * (1.0 / len(unvisited_nodes)) if node in unvisited_nodes else 0.0
        diversity_penalty = 0.2 * (1.0 / (len(unvisited_nodes) + 1)) * (1.0 / (min_remaining_dist + 1e-6))

        # Balanced heuristic with shifting global priority
        global_weight = 0.4 - 0.1 * (1.0 / (len(unvisited_nodes) + 1))
        heuristic = (0.6 * current_dist) + (global_weight * avg_remaining_dist) + penalty + diversity_penalty
        return heuristic

    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))
    return next_node
