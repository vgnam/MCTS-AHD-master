def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Adaptive weights based on remaining unvisited nodes
    remaining = len(unvisited_nodes)
    alpha = 0.6 * (1 - 0.2 * (remaining / len(distance_matrix)))  # Decrease alpha as more nodes are visited
    beta = 0.4 * (0.5 + 0.5 * (remaining / len(distance_matrix)))   # Increase beta as more nodes are visited
    gamma = 0.2 * (0.1 + 0.9 * (remaining / len(distance_matrix)))  # Adjust gamma based on remaining nodes

    candidate_scores = []
    for node in unvisited_nodes:
        immediate_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        # Local search: consider closest unvisited node within a limited range
        local_range = min(3, len(unvisited_nodes))
        closest_local = min(unvisited_nodes, key=lambda n: distance_matrix[node][n], default=node)
        local_penalty = 0.1 * distance_matrix[node][closest_local] if closest_local != node else 0

        score = (alpha * immediate_dist) + (beta * dest_dist) - (gamma * local_penalty)
        candidate_scores.append((node, score))

    # Probabilistic selection based on scores
    total_score = sum(score for _, score in candidate_scores)
    probabilities = [(score / total_score) for _, score in candidate_scores]
    next_node = random.choices([node for node, _ in candidate_scores], weights=probabilities, k=1)[0]

    return next_node
