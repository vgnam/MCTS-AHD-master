importance in the remaining graph, and using a probabilistic selection mechanism to explore promising nodes while avoiding local minima, with weights balancing local distance, centrality, and destination proximity adaptively throughout the tour.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    remaining_nodes = len(unvisited_nodes)
    total_nodes = len(distance_matrix)
    progress = (total_nodes - remaining_nodes) / total_nodes

    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)
    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0

    scores = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]

        if remaining_nodes > 1:
            centrality_scores = []
            for n in unvisited_nodes:
                if n != node:
                    centrality = sum(distance_matrix[n][k] for k in unvisited_nodes if k != n) / (remaining_nodes - 1)
                    centrality_scores.append(centrality)
            avg_centrality = sum(centrality_scores) / len(centrality_scores) if centrality_scores else 0
            node_centrality = sum(distance_matrix[node][k] for k in unvisited_nodes if k != node) / (remaining_nodes - 1)
            centrality_score = (1 + node_centrality) / (1 + avg_centrality) if avg_centrality > 0 else 1.0
        else:
            centrality_score = 1.0

        weight_local = 0.5 - 0.3 * progress
        weight_centrality = 0.3 + 0.2 * progress
        weight_dest = 0.2 - 0.1 * progress

        score = (weight_local * current_dist) + (weight_centrality * centrality_score) + (weight_dest * dest_dist)
        scores.append((node, score))

    if scores:
        min_score = min(score[1] for score in scores)
        max_score = max(score[1] for score in scores)
        normalized_scores = [(node, (score - min_score) / (max_score - min_score)) for node, score in scores]
        probabilities = [(node, 1 - normalized_score) for node, normalized_score in normalized_scores]
        total_prob = sum(p for _, p in probabilities)
        probabilities = [(node, p / total_prob) for node, p in probabilities]
        import random
        next_node = random.choices([node for node, _ in probabilities], weights=[p for _, p in probabilities], k=1)[0]
    else:
        next_node = destination_node

    return next_node
