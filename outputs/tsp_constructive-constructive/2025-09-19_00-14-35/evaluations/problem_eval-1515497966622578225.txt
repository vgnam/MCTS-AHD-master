import math
import random

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic weights based on remaining tour progress
    progress = 1.0 - (len(unvisited_nodes) / len(distance_matrix))
    current_weight = 0.7 - (0.3 * progress)
    dest_weight = 0.3 + (0.4 * progress)

    # Calculate average remaining distances to destination
    avg_remaining_dist = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)

    # Novel temperature scaling
    temperature = (1.0 / (1.0 + len(unvisited_nodes))) * (avg_remaining_dist / max(distance_matrix[current_node]))

    # Calculate scores with softmax-like probabilistic selection
    candidate_scores = []
    for node in unvisited_nodes:
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]
        score = (current_dist * current_weight) + (dest_dist * dest_weight)
        score += temperature * random.uniform(-0.5, 0.5)  # Small random perturbation
        candidate_scores.append((node, score))

    # Probabilistic selection using softmax
    scores = [score for (_, score) in candidate_scores]
    exp_scores = [math.exp(-s / temperature) for s in scores]
    sum_exp = sum(exp_scores)
    probabilities = [exp / sum_exp for exp in exp_scores]

    next_node = random.choices([node for (node, _) in candidate_scores], weights=probabilities, k=1)[0]
    return next_node
