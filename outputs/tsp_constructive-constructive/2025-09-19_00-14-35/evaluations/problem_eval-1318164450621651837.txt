import random
import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    def evaluate_node(node):
        current_dist = distance_matrix[current_node][node]
        dest_dist = distance_matrix[node][destination_node]
        if len(unvisited_nodes) > 1:
            remaining_dists = [distance_matrix[node][n] for n in unvisited_nodes if n != node]
            avg_remaining = sum(remaining_dists) / len(remaining_dists) if remaining_dists else 0
            lookahead_factor = 0.8 * (1 - math.exp(-len(unvisited_nodes) / 10))
            return current_dist + lookahead_factor * (0.6 * dest_dist + 0.4 * avg_remaining)
        else:
            return current_dist + dest_dist

    evaluated_nodes = [(node, evaluate_node(node)) for node in unvisited_nodes]
    costs = [cost for _, cost in evaluated_nodes]
    min_cost = min(costs)
    max_cost = max(costs)

    if min_cost == max_cost:
        probabilities = [1.0 / len(unvisited_nodes)] * len(unvisited_nodes)
    else:
        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]
        temperature = 1.0 / (1 + 0.5 * len(unvisited_nodes))
        probabilities = [math.exp(nc / temperature) for nc in normalized_costs]
        total = sum(probabilities)
        probabilities = [p / total for p in probabilities]

    next_node = random.choices(unvisited_nodes, weights=probabilities, k=1)[0]
    return next_node
