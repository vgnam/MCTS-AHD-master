[
     {
          "algorithm": "The algorithm prioritizes immediate distance (higher weight) and destination proximity (lower weight) while dynamically adjusting weights based on tour progress (exploration_factor). It balances connectivity (medium weight) and potential gain (lower weight), with weights shifting toward immediate distance as the tour progresses. The exploration_factor (\u221a(remaining_nodes/total_nodes)) controls weight adjustments, giving higher priority to immediate distance and connectivity in early stages and more emphasis on destination proximity and potential gain in later stages.",
          "thought": "The new algorithm combines the multiplicative trade-off of No.2 with the dynamic weighting and exploration factor of No.1, prioritizing immediate distance, connectivity, and destination proximity while adjusting weights based on tour progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 0.5\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.2 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.28207,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance, connectivity, destination alignment, and potential gain with adaptive weights that prioritize local proximity and connectivity early (high weights) and refine the path based on destination alignment and potential gain later (lower weights). The exploration factor dynamically adjusts weights, favoring multiplicative trade-offs (distance \u00d7 average remaining distances) early and destination-aligned scores later. The critical variables are immediate distance (high early weight), connectivity (moderate), and destination alignment (low early weight).",
          "thought": "The new algorithm combines the multiplicative trade-off of immediate distance and average remaining distances from Algorithm 1 with the dynamic weight balancing of local proximity, connectivity, destination alignment, and potential gain from Algorithms 2-4, while introducing a novel adaptive exploration factor that prioritizes immediate distance and connectivity early, and refines the path based on destination alignment and potential gain later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n            multiplicative_score = immediate_dist * avg_remaining_dist\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n            multiplicative_score = immediate_dist\n\n        weight_local = 0.5 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.1 * (1 - exploration_factor)\n        weight_multiplicative = 0.1 * exploration_factor\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain) + \\\n                (weight_multiplicative * multiplicative_score)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.28352,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm dynamically balances exploration and exploitation by scoring candidate nodes using a sigmoid-weighted system that prioritizes local proximity (high exploitation), connectivity (moderate exploitation), and novelty (high exploration), while penalizing revisited nodes. The weights adapt based on remaining nodes, with centrality and flow disruption playing supporting roles. The final selection minimizes a composite score, favoring closer nodes early and more diverse paths later.",
          "thought": "The new algorithm dynamically balances exploration and exploitation using a sigmoid-weighted scoring system that incorporates local proximity, global connectivity, centrality, flow disruption, and novelty, while adjusting weights based on exploration progress and penalizing revisited nodes, resulting in a more refined path selection process.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, historical_path=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def sigmoid(x):\n        return 1 / (1 + math.exp(-x))\n\n    exploration_weight = sigmoid(5 * (exploration_factor - 0.5))\n    exploitation_weight = 1 - exploration_weight\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n\n        novelty_bonus = 0\n        if historical_path and node in historical_path:\n            novelty_bonus = -0.2 * (historical_path.count(node) / len(historical_path))\n\n        weight_local = 0.5 * exploitation_weight + 0.1 * exploration_weight\n        weight_connectivity = 0.3 * exploitation_weight + 0.2 * exploration_weight\n        weight_dest = -0.3 * exploitation_weight + 0.2 * exploration_weight\n        weight_flow = -0.2 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_novelty = 0.4 * exploration_weight\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_flow * flow_disruption) + (weight_dest * dest_dist) + \\\n                (weight_centrality * centrality_score) + (weight_novelty * novelty_bonus)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.28482,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm dynamically balances exploration and exploitation using a sigmoid-weighted scoring system that prioritizes proximity (exploitation) and connectivity (exploration) while penalizing revisited nodes and rewarding novel paths. It adjusts weights based on remaining unvisited nodes and incorporates historical path data for diversity, with local distance, connectivity, flow disruption, destination proximity, centrality, and novelty all contributing to the selection of the next node.",
          "thought": "The new algorithm modifies the scoring system to incorporate a dynamic exploration-exploitation balance using a sigmoid function to adjust weights, adds a penalty for revisiting nodes based on historical path data, and incorporates a novelty bonus for less-visited nodes to encourage diverse exploration while maintaining proximity and connectivity priorities.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, historical_path=None):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    # Sigmoid function for dynamic weight adjustment\n    def sigmoid(x):\n        return 1 / (1 + math.exp(-x))\n\n    exploration_weight = sigmoid(5 * (exploration_factor - 0.5))\n    exploitation_weight = 1 - exploration_weight\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n\n        # Novelty bonus based on historical visits\n        novelty_bonus = 0\n        if historical_path and node in historical_path:\n            novelty_bonus = -0.1 * (historical_path.count(node) / len(historical_path))\n\n        # Dynamic weight adjustments\n        weight_local = 0.4 * exploitation_weight + 0.2 * exploration_weight\n        weight_connectivity = 0.3 * exploitation_weight + 0.1 * exploration_weight\n        weight_dest = -0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_novelty = 0.3 * exploration_weight\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_flow * flow_disruption) + (weight_dest * dest_dist) + \\\n                (weight_centrality * centrality_score) + (weight_novelty * novelty_bonus)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.28604,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines local distance, connectivity, and destination proximity with dynamic weights, prioritizing local distance (0.5), connectivity (0.3), and destination proximity (-0.2, adjusted by exploration factor), while penalizing flow disruption (-0.2) and detours via a penalty factor. It dynamically balances these factors based on remaining nodes and current context.",
          "thought": "The new algorithm combines the dynamic weight adjustment of No.1 (prioritizing local distance, connectivity, and destination proximity with exploration factor) with the balanced scoring approach of No.2 (using weights of 0.5 for local distance, 0.3 for connectivity, and -0.2 for flow disruption). It introduces a penalty factor to discourage detours and dynamically adjusts destination proximity weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3\n        weight_dest = -0.2 * (1 - exploration_factor)\n        weight_flow = -0.2 * flow_disruption if flow_disruption > 0 else 0\n        penalty_factor = 1.0 + dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist) + (weight_flow * flow_disruption) * penalty_factor\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.2894,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing exploration and exploitation through dynamic weights, prioritizing immediate distance (0.4\u20130.5), connectivity (0.3\u20130.4), and potential gain (0\u20130.2), while penalizing destination proximity (-0.2 to 0) based on exploration factor. The exploration factor (\u221a(remaining_nodes/total_nodes)) adjusts weights to favor exploration early and exploitation later. The score minimizes immediate distance, maximizes connectivity, and optimizes potential path gains.",
          "thought": "The new algorithm combines dynamic weights based on exploration factor for immediate distance (0.4), connectivity (0.3), destination proximity (-0.2), and potential gain (0.2), with weights adjusted by exploration_factor to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 0.5\n\n    scores = []\n    for node in unvisited_nodes:\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n\n        weight_local = 0.4 + 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n        weight_gain = 0.2 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.29393,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines dynamic weight adjustment with reinforcement learning-inspired exploration, prioritizing immediate distance (weighted higher early) and connectivity (weighted higher early) while emphasizing potential savings (weighted higher late) and centrality (weighted higher late). The exploration_factor balances global and local optimization, with weights shifting from local to global as the algorithm progresses. The score is computed as a weighted sum of immediate distance, connectivity, destination distance, potential gain, and centrality, where local and connectivity factors dominate early, while gain and centrality dominate late.",
          "thought": "The new algorithm combines dynamic weight adjustment from No.2 with reinforcement learning-inspired exploration, prioritizing local proximity and connectivity early while emphasizing potential savings and centrality later, using exploration_factor to balance global and local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 2\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n            centrality_score = 0\n\n        weight_local = 0.4 + 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.1 * (1 - exploration_factor)\n        weight_centrality = 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain) + (weight_centrality * centrality_score)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.29924,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines multiple heuristics: prioritizing immediate distance (weighted adaptively), balancing connectivity (weighted higher in exploration), aligning with the destination (weighted lower in exploration), and adding potential gain (weighted lower in later stages). Exploration factor dynamically adjusts weights, with immediate distance and connectivity dominating early, while destination alignment and gain become more relevant as the tour progresses. The potential gain term estimates future savings, while the connectivity score evaluates node centrality in the remaining graph.",
          "thought": "The new algorithm combines the multiplicative trade-off of No.1 with the dynamic weight balancing of No.2 and No.3, adds a novel potential gain term inspired by No.3, and incorporates a destination alignment term to prioritize nodes that reduce the distance to the destination early.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n\n        weight_local = 0.5 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain)\n        return score\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.29988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by adjusting weights based on node centrality and historical path frequency, prioritizing local distances (40% exploitation, 20% exploration), global connectivity (30% exploitation, 10% exploration with adaptive tuning), and destination proximity (20% exploitation, 10% exploration). It uses sigmoid functions to normalize exploration-exploitation trade-offs and incorporates flow disruption and centrality scores for adaptive path selection. The scoring mechanism combines these weighted factors to select the next node, with lower scores indicating better choices.",
          "thought": "The new algorithm enhances the original by introducing adaptive weight tuning based on node centrality and historical path frequency, incorporating a dynamic exploration-exploitation balance through a novel scoring mechanism that combines local distance, global connectivity, and historical novelty with a reinforcement-based adjustment factor.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def sigmoid(x):\n        return 1 / (1 + math.exp(-x))\n\n    exploration_weight = sigmoid(5 * (exploration_factor - 0.5))\n    exploitation_weight = 1 - exploration_weight\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            flow_disruption = max(distance_matrix[node][n] for n in unvisited_nodes if n != node) - current_dist\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n        else:\n            connectivity_score = 0\n            flow_disruption = 0\n            centrality_score = 0\n\n        novelty_factor = 1.0 / (1.0 + math.log(1 + centrality_score)) if centrality_score > 0 else 1.0\n        adaptive_weight = sigmoid(3 * (novelty_factor - 0.5))\n\n        weight_local = 0.4 * exploitation_weight + 0.2 * exploration_weight\n        weight_connectivity = 0.3 * exploitation_weight + 0.1 * exploration_weight * adaptive_weight\n        weight_dest = -0.2 * exploitation_weight + 0.1 * exploration_weight\n        weight_flow = -0.1 * flow_disruption if flow_disruption > 0 else 0\n        weight_centrality = 0.2 * exploitation_weight + 0.1 * exploration_weight * adaptive_weight\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_flow * flow_disruption) + (weight_dest * dest_dist) + \\\n                (weight_centrality * centrality_score)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.30094,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for TSP dynamically balances exploration and exploitation by prioritizing immediate distance (30\u201340% weight), connectivity (20\u201330%), and potential path gains (0\u201320%), while penalizing proximity to the destination (-10% to 0%) and favoring hub nodes (0\u201310%) early. The exploration factor scales weights non-linearly, and a novelty score (0\u201310%) encourages visiting less-connected nodes later. The algorithm selects the next node by minimizing a weighted sum of these factors, ensuring a trade-off between local optimization and global exploration.",
          "thought": "The new algorithm enhances exploration-exploitation balance by dynamically adjusting weights for immediate distance (0.3\u20130.4), connectivity (0.2\u20130.3), and potential gain (0\u20130.2), while penalizing destination proximity (-0.1 to 0) and introducing a node centrality score (0\u20130.1) to prioritize hub nodes early. The exploration factor (\u221a(remaining_nodes/total_nodes)) scales weights non-linearly, and a novelty score (1 - avg_remaining_dist / max_dist) encourages visiting less-connected nodes later.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = (remaining_nodes / total_nodes) ** 0.5\n\n    max_dist = max(max(row) for row in distance_matrix)\n    scores = []\n    for node in unvisited_nodes:\n        immediate_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            remaining_nodes_list = [n for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in remaining_nodes_list) / len(remaining_nodes_list)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n            potential_gain = (distance_matrix[current_node][destination_node] - immediate_dist - dest_dist) / (1 + immediate_dist)\n            novelty_score = 1 - (avg_remaining_dist / max_dist)\n        else:\n            connectivity_score = 0\n            potential_gain = 0\n            novelty_score = 0\n\n        weight_local = 0.3 + 0.1 * exploration_factor\n        weight_connectivity = 0.2 + 0.1 * exploration_factor\n        weight_dest = -0.1 * (1 - exploration_factor)\n        weight_gain = 0.2 * (1 - exploration_factor)\n        weight_novelty = 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * immediate_dist) + (weight_connectivity * connectivity_score) + \\\n                (weight_dest * dest_dist) + (weight_gain * potential_gain) + \\\n                (weight_novelty * novelty_score)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.30298,
          "other_inf": null
     }
]