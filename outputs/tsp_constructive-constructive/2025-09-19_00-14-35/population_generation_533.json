[
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing immediate distance (high priority early), connectivity (increasing priority as exploration progresses), and destination proximity (low priority unless near completion), with adaptive weights adjusting based on remaining nodes. The score for each candidate node combines these factors, favoring closer nodes initially but gradually emphasizing connectivity, while occasionally considering destination distance when few nodes remain.",
          "thought": "This new algorithm dynamically balances local distance, global connectivity, and destination proximity with adaptive weights, where early exploration emphasizes immediate distance (high weight_local) and late stages prioritize connectivity (high weight_connectivity) while occasionally considering destination proximity (weight_dest) based on a probabilistic threshold to escape local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2 if exploration_factor < 0.3 else 0\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.34966,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local proximity, connectivity, destination distance, and centrality, with weights dynamically adjusted based on exploration progress and path length. It prioritizes local distance and connectivity early, shifting toward destination proximity and centrality as the tour progresses, using adaptive thresholds to ensure global optimization. The hybrid scoring mechanism integrates node degree and variance in remaining distances to guide decisions, with weights (e.g., `weight_local=0.4`, `weight_dest=-0.3`) reflecting their relative importance.",
          "thought": "The new algorithm enhances the original by incorporating adaptive weight adjustments based on node centrality and dynamic connectivity thresholds, prioritizing both immediate proximity and long-term path optimization through a hybrid scoring mechanism that balances local and global factors.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)\n    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n    normalized_path_length = avg_path_length / total_nodes\n\n    def weighted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            variance_remaining_dist = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist) * (1.0 + (variance_remaining_dist ** 0.5))\n\n            node_degree = sum(1 for n in range(total_nodes) if distance_matrix[node][n] > 0 and n != node)\n            centrality_score = node_degree / (total_nodes - 1)\n\n            dynamic_threshold = 0.7 * exploration_factor + 0.3 * (1 - normalized_path_length)\n        else:\n            connectivity_score = 0\n            centrality_score = 0\n            dynamic_threshold = 0\n\n        weight_local = 0.4 + 0.2 * exploration_factor - 0.1 * normalized_path_length\n        weight_connectivity = 0.3 + 0.1 * exploration_factor + 0.1 * normalized_path_length\n        weight_dest = -0.3 + 0.2 * (1 - exploration_factor)\n        weight_centrality = 0.2 * dynamic_threshold\n\n        return (weight_local * local_distance) + (weight_connectivity * connectivity_score) + (weight_dest * dest_distance) + (weight_centrality * centrality_score)\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 6.35766,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines dynamic weighting with multi-criteria evaluation to select the next node in TSP. It prioritizes local proximity (60%-40% weight) while balancing connectivity (30%-40% weight) and destination awareness (negative weight), with weights adjusted by the exploration factor (remaining nodes/total nodes). The exploration factor dynamically shifts emphasis between local and global considerations, favoring local proximity early and connectivity/destination awareness later.",
          "thought": "The new algorithm combines the balanced weighting approach of No.1 (dynamic exploration factor) with the multi-criteria evaluation of No.2 (local proximity, connectivity, and destination penalty), but adjusts weights to prioritize local proximity more while maintaining connectivity and destination awareness.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.2 * exploration_factor\n        weight_connectivity = 0.3 + 0.1 * exploration_factor\n        weight_dest = -0.1\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.35835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by balancing local distance (prioritized with higher weights early in the process), connectivity (considering distance variance to unvisited nodes), and destination proximity (deprioritized early on). Weights are adaptively adjusted based on remaining nodes and path length, with local distance given more importance initially and connectivity gaining prominence as the tour progresses. The connectivity score, derived from average and variance of remaining distances, ensures exploration of well-connected nodes while avoiding isolated ones.",
          "thought": "The new algorithm modifies the provided approach by incorporating adaptive weights that are dynamically adjusted based on both the remaining nodes and the current path length, while also introducing a novel connectivity metric that considers the variance of distances to unvisited nodes to better balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)\n    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            variance_remaining_dist = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist) * (1.0 + (variance_remaining_dist ** 0.5))\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.4 + 0.1 * (1 - exploration_factor) - 0.05 * (avg_path_length / total_nodes)\n        weight_connectivity = 0.3 + 0.2 * exploration_factor + 0.05 * (avg_path_length / total_nodes)\n        weight_dest = -0.2 + 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.36611,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node by balancing local distance, connectivity, and destination proximity, with adaptive weights that prioritize connectivity and bottleneck detection as nodes remain. Local distance has moderate priority (weighted by `weight_local`), while connectivity (weighted by `weight_connectivity`) and destination proximity (weighted by `weight_dest`) are adjusted based on exploration pressure and bottleneck factors. The weights shift toward connectivity and bottlenecks as the search progresses, ensuring efficient path selection.",
          "thought": "The new algorithm dynamically selects the next node by combining local distance, connectivity, and destination proximity with adaptive weights, incorporating a novel \"exploration pressure\" term that increases with remaining nodes and a \"bottleneck detection\" mechanism to prioritize nodes with high centrality when few options remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n    exploration_pressure = exploration_factor ** 2\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            connectivity_score = sum(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            bottleneck_factor = max(1.0 / (1.0 + distance_matrix[node][n]) for n in unvisited_nodes if n != node)\n        else:\n            connectivity_score = 0\n            bottleneck_factor = 0\n\n        weight_local = 0.4 - 0.3 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor + 0.1 * bottleneck_factor\n        weight_dest = -0.2 if exploration_factor < 0.3 else 0.1 * exploration_pressure\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.39635,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance (increased later) and connectivity (prioritized early), while slightly penalizing destination proximity. It uses a dynamic weighting scheme where local distance gets 30-70% weight and connectivity 70-30% weight as exploration progresses, with destination proximity fixed at -5% weight. The connectivity score is calculated using inverse average and variance of remaining distances to ensure balanced choices, while local distances are normalized by total nodes to penalize long routes more aggressively.",
          "thought": "The new algorithm adapts node selection by emphasizing connectivity (70-30% weight) early and local distance (30-70% weight) later, while destination proximity remains static (-5% weight), using inverse variance to prioritize balanced connectivity and penalizing long local distances more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)\n    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n    normalized_path_length = avg_path_length / total_nodes\n\n    def weighted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            variance_remaining_dist = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = (1.0 / (1.0 + avg_remaining_dist)) * (1.0 / (1.0 + variance_remaining_dist))\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.3 + 0.4 * (1 - exploration_factor)\n        weight_connectivity = 0.7 - 0.4 * exploration_factor\n        weight_dest = -0.05\n\n        return (weight_local * local_distance) + (weight_connectivity * connectivity_score) + (weight_dest * dest_distance)\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 6.39662,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing local distance, global connectivity, and destination proximity, with weights adjusted via an exploration-decay mechanism. Early in the search, it prioritizes immediate gains (higher local distance weight), while later it balances exploration and exploitation (higher connectivity and destination proximity weights). The `weighted_score` function combines these factors with decay-adjusted weights, ensuring adaptability to the remaining problem size.",
          "thought": "The new algorithm introduces a dynamic exploration-decay mechanism that adjusts node selection based on a combination of local distance, global connectivity, and destination proximity, while incorporating a decay factor to prioritize immediate gains early in the search and balance between exploration and exploitation as the search progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_decay = 1.0 - (remaining_nodes / total_nodes) ** 2\n\n    def weighted_score(node):\n        local_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            normalized_variance = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist) * (1.0 + (normalized_variance ** 0.5))\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.6 - 0.3 * exploration_decay\n        weight_connectivity = 0.4 + 0.3 * exploration_decay\n        weight_dest = -0.3 + 0.2 * exploration_decay\n\n        return (weight_local * local_distance) + (weight_connectivity * connectivity_score) + (weight_dest * dest_distance)\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 6.41132,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local distance, connectivity, and destination proximity, with dynamic weights adjusted by an exploration factor. It prioritizes minimizing immediate distance early (higher `weight_local`) and connectivity (higher `weight_connectivity`) in exploration, shifting toward destination proximity (higher `weight_dest`) as the tour nears completion. A penalty mechanism further discourages detours from the destination.",
          "thought": "The new algorithm combines the best features of the three algorithms: dynamic weight adjustment based on exploration factor, balanced consideration of local distance, connectivity, and destination proximity, with an enhanced penalty mechanism to improve tour completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.1 * exploration_factor\n        weight_connectivity = 0.3 + 0.2 * exploration_factor\n        weight_dest = -0.2 * (1 - exploration_factor)\n        penalty_factor = 1.0 + (dest_dist / (sum(distance_matrix[current_node][n] for n in unvisited_nodes) + 1e-6))\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score * penalty_factor) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.41572,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm for TSP combines dynamic weight adjustment, multi-criteria scoring (prioritizing local distance, connectivity, and destination proximity), and adaptive exploration/exploitation balancing through weights that adjust with remaining nodes and path length. Local distance is weighted highest (0.5 base) while destination proximity is weighted lowest (-0.2 base), with connectivity (0.3 base) serving as a middle ground. The algorithm normalizes path lengths and uses exploration factors to dynamically adjust weights, favoring exploitation early and exploration later.",
          "thought": "The new algorithm combines dynamic weight adjustment, multi-criteria scoring with local distance, connectivity (using average and variance), and destination proximity, while incorporating path length normalization and exploration factor to balance exploration and exploitation, ensuring better node selection through adaptive weighting and comprehensive evaluation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    current_path_length = sum(distance_matrix[current_node][n] for n in unvisited_nodes if n != current_node)\n    avg_path_length = current_path_length / (remaining_nodes - 1) if remaining_nodes > 1 else 0\n    normalized_path_length = avg_path_length / total_nodes\n\n    scores = []\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            distances_to_unvisited = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n            avg_remaining_dist = sum(distances_to_unvisited) / (remaining_nodes - 1)\n            variance_remaining_dist = sum((d - avg_remaining_dist) ** 2 for d in distances_to_unvisited) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist) * (1.0 + (variance_remaining_dist ** 0.5))\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5 - 0.2 * exploration_factor - 0.1 * normalized_path_length\n        weight_connectivity = 0.3 + 0.2 * exploration_factor + 0.1 * normalized_path_length\n        weight_dest = -0.2 + 0.1 * (1 - exploration_factor)\n\n        score = (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n        scores.append((node, score))\n\n    next_node = min(scores, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.42835,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances three key factors: **local proximity** (weight 0.5), **connectivity** (weight 0.3, scaled by exploration factor), and **destination penalty** (weight -0.2). It prioritizes nearby nodes, favors paths that maintain good connectivity to unvisited nodes (adjusted dynamically by remaining nodes), and slightly penalizes nodes far from the destination. The exploration factor ensures adaptability as the search progresses.",
          "thought": "The new algorithm combines the balanced weighting of No.1 (local proximity, global connectivity, and destination penalty) with the dynamic exploration factor and penalty factor of No.2, using weights of 0.5 for local distance, 0.3 for connectivity (scaled by exploration factor), and -0.2 for destination penalty, while dynamically adjusting connectivity weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_factor = remaining_nodes / total_nodes\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        if remaining_nodes > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (remaining_nodes - 1)\n            connectivity_score = 1.0 / (1.0 + avg_remaining_dist)\n        else:\n            connectivity_score = 0\n\n        weight_local = 0.5\n        weight_connectivity = 0.3 * exploration_factor\n        weight_dest = -0.2\n        return (weight_local * current_dist) + (weight_connectivity * connectivity_score) + (weight_dest * dest_dist)\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.4314,
          "other_inf": null
     }
]