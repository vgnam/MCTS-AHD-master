[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (60% weight) and distance to the destination (40% weight), prioritizing nearby nodes while slightly favoring those farther from the destination to encourage exploration. The `min` function evaluates nodes using a weighted sum of distances, with `distance_matrix[current_node][node]` (local) weighted higher than `distance_matrix[node][destination_node]` (global). The `destination_node` is returned if no unvisited nodes remain.",
          "thought": "The new algorithm focuses on balancing local and global optimization by prioritizing nodes with shorter distances to the current node (60% weight) and longer distances to the destination (40% weight), aiming to explore more diverse paths while still favoring proximity to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.6 * distance_matrix[current_node][node] - 0.4 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.51348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: a ratio prioritizing nodes that are closer to the destination relative to their distance from the current node (weighted 0.4), and a penalty for nodes farther from the destination (weighted -0.3). This ensures a trade-off between proximity to the destination and efficiency of the path, while avoiding premature convergence by penalizing long distances. The key design choice is the weighted sum, where the ratio term (distance to destination / distance from current node) has higher priority (0.4) than the penalty term (0.3).",
          "thought": "The new algorithm combines a weighted sum approach with a ratio-based selection, inspired by No.1's ratio prioritization and No.2's weighted balance, while introducing a penalty for proximity to the destination to avoid premature convergence.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (0.4 * distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.63507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by maximizing the ratio of remaining distance to the destination over the current distance, while slightly penalizing nodes closer to the destination (via the `-0.3 * distance_matrix[node][destination_node]` term). This balances exploration (favoring nodes that reduce the remaining distance quickly) and exploitation (avoiding prematurely moving toward the destination). The key design choices prioritize maximizing the ratio while downweighting proximity to the destination.",
          "thought": "The new algorithm combines the ratio-based selection from No.1 with the weighted sum approach from No.2, favoring nodes that maximize the ratio of remaining distance to the destination over the current distance while slightly penalizing nodes closer to the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.65199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local proximity (current distance), global connectivity (weighted average remaining distance), and a penalty for nodes near the destination (distance to destination). It prioritizes local proximity (0.5 weight) and global connectivity (0.4 weight) over the destination penalty (-0.2 weight), dynamically adjusting weights based on the number of unvisited nodes to favor broader exploration as the problem nears completion. The evaluation function combines these factors to guide the selection toward a globally optimal path.",
          "thought": "This new algorithm combines the dynamic weighting from No.1 and No.2, introduces a penalty for nodes near the destination to encourage broader exploration, and uses a more aggressive weight adjustment to prioritize global connectivity as the number of unvisited nodes decreases, while also considering local proximity with a balanced weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1) ** 2\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.5 * current_dist + 0.4 * weight * avg_remaining_dist - 0.2 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.65651,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two criteria: minimizing the distance from the current node (local distance) and the ratio of the local distance to the global distance (distance from the current node to the destination). The weights (0.5 each) ensure equal priority to both metrics, while the ratio term helps avoid local minima by considering the node's proximity to the destination. The code efficiently computes the weighted sum for each unvisited node and selects the one with the minimum value.",
          "thought": "The new algorithm selects the next node by minimizing a weighted sum of the local distance and the ratio of local to global distance, ensuring both proximity to the current node and the destination while avoiding local minima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: 0.5 * distance_matrix[current_node][node] + 0.5 * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing exploration (prioritizing local distances) and exploitation (prioritizing global distances) using a dynamically weighted ratio, where exploration dominates early (high remaining nodes) and exploitation dominates later (few remaining nodes). It penalizes nodes that were previously considered but not selected by implicitly favoring those with lower combined local/global ratios. The key variables are `exploration_weight`, which adjusts the balance, and the weighted sum of normalized local and global distances, ensuring a trade-off between proximity to the current node and potential path efficiency.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the local and global distance ratios, where the weight dynamically adjusts based on the remaining number of unvisited nodes, promoting a balance between exploration and exploitation. It also introduces a penalty for revisiting nodes that were previously considered but not selected, encouraging diversity in the path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    total_nodes = len(distance_matrix)\n    exploration_weight = remaining_nodes / total_nodes\n\n    next_node = min(unvisited_nodes, key=lambda node: (\n        exploration_weight * (distance_matrix[current_node][node] / distance_matrix[node][destination_node]) +\n        (1 - exploration_weight) * (distance_matrix[current_node][node] / sum(distance_matrix[node]))\n    ))\n\n    return next_node",
          "objective": 6.68073,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic for the TSP prioritizes global connectivity (70% weight) by evaluating the average remaining distances from a candidate node to unvisited nodes, balances local proximity (20% weight) with the direct distance from the current node, and slightly discourages nodes near the destination (10% negative weight) to promote broader exploration. The weight factor `1.0 / (len(unvisited_nodes) + 2)` dynamically increases priority as fewer nodes remain, encouraging more aggressive selection near the end. The algorithm selects the next node by minimizing the weighted sum of these factors.",
          "thought": "The new algorithm emphasizes global connectivity (70% weight) and local proximity (20% weight), while slightly discouraging nodes near the destination (10% negative weight) to encourage broader exploration, and dynamically adjusts priority with the weight factor `1.0 / (len(unvisited_nodes) + 2)` for more aggressive exploration as the number of remaining nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 2)\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.7 * weight * avg_remaining_dist + 0.2 * current_dist - 0.1 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.69946,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance two factors: (1) a ratio of the direct distance to the destination over the distance from the current node, scaled by a dynamic factor that decreases as more nodes are visited, and (2) a direct distance-based term adjusted by the distance to the destination. The higher weight is given to the ratio term, while the second term is modulated by a small factor (0.3) to avoid over-prioritizing proximity. This balances exploration (finding efficient paths to the destination) with exploitation (reducing immediate distance).",
          "thought": "The new algorithm combines the ratio-based selection from No.1 (favoring nodes that reduce remaining distance quickly) with the dynamic convergence from No.2 (prioritizing nearby nodes and progressively aligning with the destination). It balances exploration and exploitation by maximizing a weighted combination of the ratio and a dynamic factor that grows as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    remaining_nodes = len(unvisited_nodes)\n    next_node = max(unvisited_nodes, key=lambda node: (\n        (distance_matrix[node][destination_node] / distance_matrix[current_node][node]) *\n        (remaining_nodes / (remaining_nodes + 1)) +\n        (1 / distance_matrix[current_node][node]) * (1 - 0.3 * distance_matrix[node][destination_node])\n    ))\n    return next_node",
          "objective": 6.87622,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes local proximity (60% weight) and global connectivity (30% weight) via dynamic weighting, balancing exploration and efficiency. It slightly discourages nodes near the destination (10% negative weight) to encourage broader exploration, while the weight factor `1.0 / (len(unvisited_nodes) + 1)` adjusts priority dynamically as the number of remaining nodes decreases. The `evaluate_node` function computes a weighted score to select the next node, ensuring a mix of immediate and long-term considerations.",
          "thought": "The new algorithm combines the weighted balance of local and global factors from No.1 with the dynamic weighting approach of No.2, adjusting weights to prioritize local proximity early and global connectivity later, while also incorporating a slight bias toward nodes farther from the destination to encourage exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    if len(unvisited_nodes) == 1:\n        return next(iter(unvisited_nodes))\n\n    def evaluate_node(node):\n        current_dist = distance_matrix[current_node][node]\n        if len(unvisited_nodes) > 1:\n            avg_remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_remaining_dist = 0\n        weight = 1.0 / (len(unvisited_nodes) + 1)\n        dest_dist = distance_matrix[node][destination_node]\n        return 0.6 * current_dist + 0.3 * weight * avg_remaining_dist - 0.1 * dest_dist\n\n    next_node = min(unvisited_nodes, key=lambda node: evaluate_node(node))\n    return next_node",
          "objective": 6.88627,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, ensuring a balance between local proximity and global progress by maximizing the ratio `distance_matrix[node][destination_node] / distance_matrix[current_node][node]`. The function iterates over unvisited nodes, choosing the one with the highest ratio, effectively favoring nodes that reduce the remaining distance to the destination while minimizing detours. The destination node is returned if no unvisited nodes remain.",
          "thought": "This algorithm selects the next node by maximizing the ratio of the distance to the destination over the distance from the current node, favoring nodes that are closer to the destination relative to their proximity to the current node, ensuring global optimization while avoiding excessive local detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[node][destination_node] / distance_matrix[current_node][node])\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     }
]