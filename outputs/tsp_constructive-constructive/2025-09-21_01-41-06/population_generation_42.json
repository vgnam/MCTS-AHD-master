[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for the TSP, prioritizing the unvisited node closest to the current node to incrementally minimize the path length. The `select_next_node` function evaluates all unvisited nodes based on the distance matrix, always choosing the nearest one, which is computationally efficient but may not guarantee the globally optimal solution. The `destination_node` is only considered when no unvisited nodes remain, ensuring the path returns to the start.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor (immediate distance) and destination-aware (estimated remaining distance) strategies, prioritizing immediate proximity (weight 1.0) over long-term optimization (weight 0.3) by summing these weighted distances to select the next node. This balances greedy local optimization with a subtle consideration of the path's future direction.",
          "thought": "The new algorithm combines the nearest-neighbor strategy with a weighted consideration of the estimated remaining distance to the destination, balancing immediate proximity and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and estimated remaining distance to the destination, prioritizing nodes that minimize the sum of their direct distance from the current node and half their estimated distance to the destination. This hybrid approach leverages both short-term (current distance) and long-term (remaining distance) considerations, with the remaining distance given half the weight of the immediate distance.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a greedy heuristic that balances short-term and long-term path optimization by prioritizing nodes that are both close to the current node and have a favorable estimated remaining distance to the destination, aiming to reduce the objective value further than both existing algorithms.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node with the smallest product of its distance to the current node and its distance to the destination. This balances proximity to the current node (lower `distance_matrix[current_node][node]`) with potential benefit toward the destination (lower `distance_matrix[node][destination_node]`). The function returns the destination if no unvisited nodes remain, otherwise the node minimizing the product of these distances.",
          "thought": "The new algorithm, inspired by the nearest-neighbor heuristic, prioritizes the unvisited node with the smallest product of distance to the current node and distance to the destination node, balancing proximity to the current node and potential benefit toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance (60% weight) and future distance (40% weight) to the destination, ensuring a trade-off between short-term efficiency and long-term optimization. The `path_weight` function computes a weighted sum of the distance from the current node and the estimated distance to the destination, while the `min` function selects the node with the lowest combined weight from the unvisited nodes.",
          "thought": "The new algorithm combines the nearest-neighbor heuristic with a weighted balance between immediate distance (60%) and future distance (40%) to the destination, ensuring local efficiency while considering long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        return immediate + 0.6 * future\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 7.6086,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor approach with a weighted balance between immediate distance (70%) and future distance (30%) to the destination, prioritizing immediate proximity while still considering long-term efficiency. It selects the next node by minimizing a weighted sum of the distance from the current node and the estimated future distance to the destination.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with the balanced consideration of immediate and future distances from No.1, prioritizing immediate distance (weight 0.7) and future distance (weight 0.3) to enhance path quality while maintaining efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        return immediate + 0.7 * future\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 7.65655,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor approach with a weighted balance, prioritizing immediate distance (80%) over future distance (20%) to the destination. It selects the next node by minimizing a weighted sum of the current node's distance to the candidate and the candidate's distance to the destination. The function dynamically chooses the closest unvisited node while slightly favoring paths that lead closer to the final destination.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a weighted balance between immediate distance (80%) and future distance (20%) to the destination, prioritizing immediate proximity while still considering long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        return immediate + 0.8 * future\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 7.7386,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a bounded lookahead mechanism. It prioritizes immediate proximity (nearest neighbor) while evaluating up to `depth` (default 2) future steps to anticipate long-term path optimization, balancing efficiency and solution quality. The `evaluate_path` function recursively assesses potential paths, while the main function selects the next node by minimizing the sum of the immediate step and the lookahead evaluation.",
          "thought": "The new algorithm uses a hybrid approach combining nearest-neighbor selection with a lookahead mechanism that evaluates potential paths up to a fixed depth (e.g., 3 nodes ahead) to better anticipate long-term path optimization while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=2):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_nodes = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:depth]\n        return min(evaluate_path(n, depth - 1) for n in next_nodes)\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + evaluate_path(node))\n    return next_node",
          "objective": 7.92054,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a greedy heuristic to select the next node by prioritizing the sum of the current distance from the node and the estimated remaining distance to the destination, balancing short-term and long-term path optimization. The `distance_matrix[current_node][node]` term ensures proximity to the current node, while `distance_matrix[node][destination_node]` approximates the remaining path length, making the choice more informed than pure nearest-neighbor methods. The `min` function efficiently selects the optimal node based on these combined metrics.",
          "thought": "This algorithm uses a greedy approach that balances immediate distance savings with long-term path optimization by selecting the node that minimizes the sum of the current distance and the estimated remaining distance to the destination, ensuring a more informed choice than pure nearest-neighbor methods.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance, future distance to the destination (weighted higher), and a penalty for nodes that are too far from the current path (weighted lower). It balances exploration (penalty for distant nodes) and exploitation (minimizing immediate and future distances) with the weights 0.7 and 0.3, respectively. The code efficiently computes the weighted sum and selects the node with the minimal value.",
          "thought": "The algorithm prioritizes nodes that minimize the sum of immediate distance and a weighted average of distances to the destination, combined with a penalty for nodes that are too far from the current path to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        return immediate + 0.7 * future + 0.3 * penalty\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 8.06795,
          "other_inf": null
     }
]