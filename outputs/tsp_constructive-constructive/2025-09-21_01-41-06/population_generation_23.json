[
     {
          "algorithm": "The algorithm implements a **nearest-neighbor heuristic** for the TSP, prioritizing the unvisited node closest to the current node to incrementally minimize the path length. The `select_next_node` function evaluates all unvisited nodes based on the distance matrix, always choosing the nearest one, which is computationally efficient but may not guarantee the globally optimal solution. The `destination_node` is only considered when no unvisited nodes remain, ensuring the path returns to the start.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, aiming to minimize the total path length incrementally.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and estimated remaining distance to the destination, prioritizing nodes that minimize the sum of their direct distance from the current node and half their estimated distance to the destination. This hybrid approach leverages both short-term (current distance) and long-term (remaining distance) considerations, with the remaining distance given half the weight of the immediate distance.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a greedy heuristic that balances short-term and long-term path optimization by prioritizing nodes that are both close to the current node and have a favorable estimated remaining distance to the destination, aiming to reduce the objective value further than both existing algorithms.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + 0.5 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node with the smallest product of its distance to the current node and its distance to the destination. This balances proximity to the current node (lower `distance_matrix[current_node][node]`) with potential benefit toward the destination (lower `distance_matrix[node][destination_node]`). The function returns the destination if no unvisited nodes remain, otherwise the node minimizing the product of these distances.",
          "thought": "The new algorithm, inspired by the nearest-neighbor heuristic, prioritizes the unvisited node with the smallest product of distance to the current node and distance to the destination node, balancing proximity to the current node and potential benefit toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a bounded lookahead mechanism. It prioritizes immediate proximity (nearest neighbor) while evaluating up to `depth` (default 2) future steps to anticipate long-term path optimization, balancing efficiency and solution quality. The `evaluate_path` function recursively assesses potential paths, while the main function selects the next node by minimizing the sum of the immediate step and the lookahead evaluation.",
          "thought": "The new algorithm uses a hybrid approach combining nearest-neighbor selection with a lookahead mechanism that evaluates potential paths up to a fixed depth (e.g., 3 nodes ahead) to better anticipate long-term path optimization while maintaining computational efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=2):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_nodes = sorted(remaining_nodes, key=lambda n: distance_matrix[node][n])[:depth]\n        return min(evaluate_path(n, depth - 1) for n in next_nodes)\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + evaluate_path(node))\n    return next_node",
          "objective": 7.92054,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a greedy heuristic to select the next node by prioritizing the sum of the current distance from the node and the estimated remaining distance to the destination, balancing short-term and long-term path optimization. The `distance_matrix[current_node][node]` term ensures proximity to the current node, while `distance_matrix[node][destination_node]` approximates the remaining path length, making the choice more informed than pure nearest-neighbor methods. The `min` function efficiently selects the optimal node based on these combined metrics.",
          "thought": "This algorithm uses a greedy approach that balances immediate distance savings with long-term path optimization by selecting the node that minimizes the sum of the current distance and the estimated remaining distance to the destination, ensuring a more informed choice than pure nearest-neighbor methods.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing immediate distance, future distance to the destination (weighted higher), and a penalty for nodes that are too far from the current path (weighted lower). It balances exploration (penalty for distant nodes) and exploitation (minimizing immediate and future distances) with the weights 0.7 and 0.3, respectively. The code efficiently computes the weighted sum and selects the node with the minimal value.",
          "thought": "The algorithm prioritizes nodes that minimize the sum of immediate distance and a weighted average of distances to the destination, combined with a penalty for nodes that are too far from the current path to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        return immediate + 0.7 * future + 0.3 * penalty\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 8.06795,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, future distance to the destination, and a penalty based on average distance to remaining unvisited nodes. It prioritizes immediate distance most, followed by future distance (weighted 0.6), and penalizes nodes with high average distance to unvisited nodes (weighted 0.4). This hybrid approach aims to reduce short-term greedy choices while considering long-term path quality.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.2 with a penalty for distant nodes inspired by No.1, balancing immediate and future distances to improve path quality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def path_weight(node):\n        immediate = distance_matrix[current_node][node]\n        future = distance_matrix[node][destination_node]\n        penalty = sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n        return immediate + 0.6 * future + 0.4 * penalty\n\n    next_node = min(unvisited_nodes, key=path_weight)\n    return next_node",
          "objective": 8.0771,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a limited lookahead mechanism to balance immediate proximity and short-term optimization. It prioritizes the nearest unvisited node while evaluating short-term paths (depth=1) to avoid myopic decisions. The `evaluate_path` function recursively estimates the cost of a path from a given node to the destination, considering one additional step ahead, while the main function selects the node that minimizes the sum of the immediate step cost and the estimated path cost. The depth parameter in `evaluate_path` controls the lookahead horizon, and the algorithm defaults to a 1-step lookahead.",
          "thought": "The new algorithm combines the nearest-neighbor approach with a limited lookahead mechanism to balance immediate proximity and short-term path optimization, inspired by No.1's bounded lookahead but simplified to maintain No.2's efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_path(node, depth=1):\n        if depth == 0 or not unvisited_nodes:\n            return distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[node][destination_node]\n        next_node = min(remaining_nodes, key=lambda n: distance_matrix[node][n])\n        return distance_matrix[node][next_node] + evaluate_path(next_node, depth - 1)\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + evaluate_path(node))\n    return next_node",
          "objective": 8.8497,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a modified nearest-neighbor heuristic that selects the next node by prioritizing those with the highest combined distance to both the current node and the destination node, balancing proximity and destination alignment to diversify the path and potentially reduce total path length. The function takes the current node, destination node, unvisited nodes, and a distance matrix as inputs, then returns the node with the maximum sum of distances to the current and destination nodes. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm uses a modified nearest-neighbor heuristic that prioritizes nodes with the highest combined distance to the current node and the destination node, aiming to diversify the path and potentially reduce total path length by balancing proximity and destination alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] + distance_matrix[node][destination_node])\n    return next_node",
          "objective": 32.06483,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm implements a **farthest-insertion heuristic**, prioritizing the unvisited node farthest from the current node (highest priority) to encourage exploration of less-traveled routes, contrasting the nearest-neighbor approach. The `select_next_node` function uses the `distance_matrix` to evaluate distances and selects the node with the maximum distance from `current_node` (exploitation) from the `unvisited_nodes` set. If no unvisited nodes remain, it returns the `destination_node` (termination). The heuristic balances exploration and exploitation by favoring distant nodes, which may lead to longer but more diverse paths.",
          "thought": "The new algorithm implements a farthest-insertion heuristic, prioritizing the unvisited node farthest from the current node to explore less-traveled routes, balancing exploration and exploitation differently from the nearest-neighbor approach.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = max(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]