[
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: the distance from the current node (prioritized when few nodes remain) and the distance to the destination (prioritized when many nodes remain). The dynamic weight adjusts this balance based on the remaining unvisited nodes, giving higher priority to minimizing detours early and optimizing the path toward the destination later. The score function combines these factors inversely proportional to the distance, ensuring efficient node selection.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the destination distance and the distance from the current node, using a dynamic weight that prioritizes nodes closer to the destination while balancing detours based on the remaining number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * (destination_distance / distance) + weight * (1 / distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.65353,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance progress toward the destination (weighted 0.4) and distance from the current node, ensuring a trade-off between global (destination proximity) and local (short-term distance) optimization. It explicitly checks for the destination node first and skips invalid (zero-distance) nodes. The scoring formula `(0.4 * destination_distance / distance) - distance` emphasizes reducing the ratio of destination distance to current distance while penalizing longer local distances.",
          "thought": "The new algorithm combines the prioritization of the destination node with a weighted approach that balances the ratio of progress toward the destination (with a 0.4 weight) and the distance from the current node, ensuring both global and local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (0.4 * destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.66316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing progress toward the destination (70% weight) with path efficiency (30% weight), where the latter is based on the average distance of unvisited nodes to the destination. It prioritizes nodes that reduce the ratio of destination distance to current distance while favoring those closer to the average distance of remaining nodes. The code ensures the destination is chosen first if still unvisited, and handles edge cases like zero distances gracefully.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the ratio of destination distance to current distance and an additional heuristic that considers the average distance of the remaining unvisited nodes, ensuring a balance between progress toward the destination and overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    # Calculate average distance of unvisited nodes to the destination\n    total_destination_distance = 0\n    count = 0\n    for node in unvisited_nodes:\n        if node != destination_node:\n            total_destination_distance += distance_matrix[node][destination_node]\n            count += 1\n    avg_destination_distance = total_destination_distance / count if count > 0 else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Weighted score combining the original ratio and average distance heuristic\n        ratio = destination_distance / distance\n        distance_weight = 1 - (destination_distance / (avg_destination_distance + 1e-10))\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74418,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that are both geographically closer to the current node (higher proximity weight) and closer to the destination (lower ratio of destination distance to current distance), while always selecting the destination if unvisited. The score is calculated as the product of these two factors, ensuring a balance between proximity and destination alignment. The destination is given the highest priority when unvisited, and otherwise, the node with the highest score is chosen.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with a proximity-based term, prioritizing nodes that are both closer to the destination and geographically closer to the current node, while still ensuring the destination is always selected if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        proximity_weight = 1 / (distance + 1e-6)  # Avoid division by zero\n        score = ratio * proximity_weight\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76839,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node, normalized by the inverse of the remaining unvisited nodes. It ensures the destination is chosen if still unvisited, otherwise balances proximity to the current node and alignment with the destination path. The ratio calculation (`destination_distance / (distance / remaining)`) weights both factors, with `remaining` adjusting for the number of unvisited nodes.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the normalized Euclidean distance balance of No.1, selecting nodes that maximize the ratio of destination distance to current distance while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / (distance / remaining)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.88551,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring progress toward the destination while minimizing detours. It always selects the destination if it remains unvisited, and otherwise chooses the node that maximizes this ratio. The higher priority is given to nodes closer to the destination relative to their distance from the current node, while the destination itself is always prioritized when unvisited.",
          "thought": "The new algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring rapid progress toward the destination while minimizing detours, and it always selects the destination if it's unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that are closer to the destination while balancing detours, using a dynamic score that combines the ratio of destination distance to current distance with a normalization factor based on how close the node is to the average distance from the current node. Higher scores favor nodes that are both closer to the destination and relatively closer to the current node, ensuring a trade-off between progress and detour minimization. The function dynamically adjusts priorities by considering both the immediate and long-term implications of each choice.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines the ratio of destination distance to current distance with a normalization factor based on the average distance from the current node to unvisited nodes, ensuring balanced progress toward the destination while minimizing detours and favoring nodes that are both closer to the destination and relatively closer to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        normalization_factor = 1 / (1 + abs(distance - avg_distance))\n        score = ratio * normalization_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.9987,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node using the distance matrix. The function checks if the destination is in the unvisited set first, and if not, it iterates through all unvisited nodes to find the one with the minimum distance from the current node. The destination node is given higher priority than other unvisited nodes, while other nodes are selected based on proximity.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the remaining unvisited nodes. It balances local progress (distance from current node) with global progress (Euclidean distance to destination), with the latter's weight decreasing as more nodes are visited. The destination is prioritized if still unvisited, otherwise the node with the lowest combined score is selected.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the number of remaining unvisited nodes to balance local and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        euclidean_distance = ((distance_matrix[node][0] - distance_matrix[destination_node][0])**2 +\n                             (distance_matrix[node][1] - distance_matrix[destination_node][1])**2)**0.5\n        score = distance + euclidean_distance / remaining\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.19875,
          "other_inf": null
     }
]