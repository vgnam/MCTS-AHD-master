[
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: advancing toward the destination (prioritized with a dynamic weight) and minimizing detours (considering remaining unvisited nodes). The weight shifts from 70% toward destination progression to 30% toward detour minimization as fewer nodes remain. The score combines these factors to choose the best candidate node, with `ratio` (destination proximity) and `detour_factor` (average remaining distances) influencing selection. The destination is prioritized if it's still unvisited.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with the node's potential to reduce overall path length, prioritizing nodes that both advance toward the destination and minimize detours while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.7 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, using a dynamic weighting factor (destination_distance / distance)^0.5. It balances this with a term (1 + 1 / (1 + distance)) to favor nodes that reduce the overall path length, ensuring efficiency while avoiding infinite loops. The destination node is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the ratio calculation by incorporating a dynamic weighting factor that balances the distance to the destination and the distance from the current node, introducing a novel mechanism to prioritize nodes that are closer to the destination relative to their distance from the current node while also considering the node's potential to reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        # Dynamic weighting factor based on the ratio of destination distance to current distance\n        weight = (destination_distance / distance) ** 0.5\n        # Score combines the weighted ratio and a term to favor nodes that reduce overall path length\n        score = weight * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates that minimize the distance from the current node while steering more directly toward the destination, balancing the distance ratio (`destination_distance / distance`) with an angle factor (`1 / (1 + distance)`). Nodes closer to the current node and those that reduce the path's detour are favored, with the angle factor mitigating unnecessary turns. The destination is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the distance ratio and the node's proximity to the destination, while also considering the angle between the current node, candidate node, and destination to favor nodes that steer the path more directly toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Calculate the angle between current node, candidate node, and destination\n        # Using dot product formula: cos\u03b8 = (a\u00b7b) / (||a|| ||b||)\n        # Vectors: a = (distance_matrix[current_node][node], 0), b = (0, distance_matrix[node][destination_node])\n        # Dot product: a\u00b7b = 0 (since they are orthogonal in this simplified 2D projection)\n        # Angle is 90 degrees, so cos\u03b8 = 0, which is not useful here. Instead, use a different angle measure.\n        # Alternative: Use the ratio of distances to approximate the angle's effect.\n        angle_factor = 1.0 / (1.0 + distance)  # Smaller distance means steeper angle\n\n        # Combine ratio and angle factor\n        score = (destination_distance / distance) * angle_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing progress toward the destination (prioritized via the ratio of destination distance to current distance) while penalizing detours (via a distance-based penalty term). It avoids prematurely selecting distant nodes by dynamically adjusting the score with a penalty that scales with the current distance. The destination node is prioritized if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that combines the original ratio with a penalty term based on the node's distance from the current node, ensuring a balance between progress toward the destination and minimizing detours while avoiding prematurely selecting distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = (distance_matrix[current_node][node] ** 1.5) / (destination_distance + 1e-6)\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62216,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (higher `destination_distance / distance` ratio) while penalizing longer distances to the current node (subtracting `0.5 * distance`). If the destination is unvisited, it immediately selects it. Otherwise, it iteratively evaluates unvisited nodes using this weighted scoring mechanism. The destination is given the highest priority, followed by nodes that balance proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the balanced scoring approach of No.1, using a weighted ratio of destination distance to current distance while penalizing longer distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.5 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (higher `destination_distance / distance` ratio) while penalizing longer distances from the current node (subtracting `0.25 * distance`). It ensures the destination is visited first if still unvisited, otherwise selects the node with the highest adjusted score, balancing proximity to the destination and detour costs. The penalty term (0.25) weights detour avoidance moderately, favoring nodes that efficiently progress toward the destination.",
          "thought": "The new algorithm combines the prioritization of destination proximity from No.2 with a penalty for longer distances from No.1, creating a balanced scoring mechanism that maximizes the ratio of distance to destination over distance from current node while penalizing excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.25 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6331,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance progress toward the destination (60% weight) with minimizing detours (40% weight). It calculates a score combining the ratio of destination distance to current distance (60%) and the normalized distance to the destination (40%), favoring nodes that efficiently advance toward the goal while avoiding excessive detours. The code structure iteratively evaluates unvisited nodes to select the highest-scoring next node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with a weighted score inspired by No.1, using 60% weight on the ratio of destination distance to current distance and 40% weight on normalized distance to the destination, ensuring efficient progress while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        distance_weight = 1 - destination_distance\n        score = ratio * 0.6 + distance_weight * 0.4\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63489,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by balancing the ratio of destination distance to current distance (higher ratio preferred) while penalizing longer current distances (0.3 \u00d7 distance). The destination node is given absolute priority, while other nodes are scored based on this trade-off.",
          "thought": "The new algorithm combines the prioritization of the destination and the ratio of destination distance to current distance from No.2, while incorporating a penalty for longer distances from No.1. It selects the destination if unvisited, otherwise it chooses the node that maximizes the ratio of destination distance to current distance, penalized by a factor of 0.3 times the current distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.3 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.63704,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the destination (with a higher weight initially) and detour minimization (with increasing weight as nodes are visited). It dynamically adjusts the weighting (80% to 20%) between these factors, favoring destination proximity early on and minimizing detours later. The score is computed as a weighted sum of the ratio of destination distance to current distance and the average detour factor.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with a dynamic weight that balances destination proximity and detour minimization (like No.1), shifting from 80% to 20% as nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.8 if len(remaining_nodes) > 2 else 0.2\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63731,
          "other_inf": null
     }
]