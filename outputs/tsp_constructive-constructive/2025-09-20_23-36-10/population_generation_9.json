[
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing progress toward the destination (70% weight) with path efficiency (30% weight), where the latter is based on the average distance of unvisited nodes to the destination. It prioritizes nodes that reduce the ratio of destination distance to current distance while favoring those closer to the average distance of remaining nodes. The code ensures the destination is chosen first if still unvisited, and handles edge cases like zero distances gracefully.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the ratio of destination distance to current distance and an additional heuristic that considers the average distance of the remaining unvisited nodes, ensuring a balance between progress toward the destination and overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    # Calculate average distance of unvisited nodes to the destination\n    total_destination_distance = 0\n    count = 0\n    for node in unvisited_nodes:\n        if node != destination_node:\n            total_destination_distance += distance_matrix[node][destination_node]\n            count += 1\n    avg_destination_distance = total_destination_distance / count if count > 0 else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Weighted score combining the original ratio and average distance heuristic\n        ratio = destination_distance / distance\n        distance_weight = 1 - (destination_distance / (avg_destination_distance + 1e-10))\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74418,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node, normalized by the inverse of the remaining unvisited nodes. It ensures the destination is chosen if still unvisited, otherwise balances proximity to the current node and alignment with the destination path. The ratio calculation (`destination_distance / (distance / remaining)`) weights both factors, with `remaining` adjusting for the number of unvisited nodes.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the normalized Euclidean distance balance of No.1, selecting nodes that maximize the ratio of destination distance to current distance while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / (distance / remaining)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.88551,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring progress toward the destination while minimizing detours. It always selects the destination if it remains unvisited, and otherwise chooses the node that maximizes this ratio. The higher priority is given to nodes closer to the destination relative to their distance from the current node, while the destination itself is always prioritized when unvisited.",
          "thought": "The new algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring rapid progress toward the destination while minimizing detours, and it always selects the destination if it's unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node using the distance matrix. The function checks if the destination is in the unvisited set first, and if not, it iterates through all unvisited nodes to find the one with the minimum distance from the current node. The destination node is given higher priority than other unvisited nodes, while other nodes are selected based on proximity.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the remaining unvisited nodes. It balances local progress (distance from current node) with global progress (Euclidean distance to destination), with the latter's weight decreasing as more nodes are visited. The destination is prioritized if still unvisited, otherwise the node with the lowest combined score is selected.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the number of remaining unvisited nodes to balance local and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        euclidean_distance = ((distance_matrix[node][0] - distance_matrix[destination_node][0])**2 +\n                             (distance_matrix[node][1] - distance_matrix[destination_node][1])**2)**0.5\n        score = distance + euclidean_distance / remaining\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.19875,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node while also considering its proximity to the destination (with a 0.3 weight), balancing immediate proximity and progress toward the destination. The `weighted_distance` combines the distance from the current node and the distance to the destination, ensuring a trade-off between local and global optimization.",
          "thought": "This algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node, but with a bias towards nodes that are not too far from the destination, balancing proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weighted_distance = distance + 0.3 * destination_distance\n        if weighted_distance < min_distance:\n            min_distance = weighted_distance\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     }
]