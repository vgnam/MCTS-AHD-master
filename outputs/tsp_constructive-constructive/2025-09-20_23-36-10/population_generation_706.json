[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that maximize the ratio of their distance to the destination over their distance from the current node, while also considering a detour factor based on the average distance to remaining unvisited nodes. This balances proximity to the destination (higher priority) with detour potential (lower priority) to avoid getting stuck in local optima. The `ratio` and `detour_factor` are combined multiplicatively to compute a `score`, with the node having the highest score being chosen.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the detour factor of No.1, selecting nodes that maximize the ratio of distance to the destination over distance from the current node, weighted by the average distance to remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = ratio * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.48831,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing progress toward the destination (via `ratio`) and minimizing detours (via `detour_factor`), with a dynamic weight (`weight`) shifting from 0.6 to 0.4 as nodes are visited to adjust emphasis. The `ratio` (destination-distance-to-current-distance) is weighted more heavily early on, while `detour_factor` (average distance to remaining nodes) gains importance as the destination is approached. The `score` combines these factors to select the next node, ensuring a trade-off between direct progress and local optimization.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic weight and detour minimization of No.1, using a weight that decreases from 0.6 to 0.4 as nodes are visited to balance progress and detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {current_node}\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.6 if len(remaining_nodes) > 2 else 0.4\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50559,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (60% weight) while also considering average distances to remaining unvisited nodes (40% weight) to minimize detours. It dynamically balances progress toward the destination with path efficiency, ensuring both goal alignment and route optimization. The `ratio` (destination proximity) and `detour_factor` (detour minimization) are combined linearly, with the former given higher priority.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic balancing of destination proximity and detour minimization from No.1, using a fixed weight of 60% for destination proximity and 40% for detour minimization, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = (0.6 * ratio) + (0.4 * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it balances progress toward the destination (via the ratio) and detour minimization (via the detour factor), with a dynamic weight that gives more emphasis to the destination ratio when many nodes remain. The weight decreases from 0.5 to 0.3 as nodes are visited, ensuring the algorithm adapts to the remaining problem size.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 and the destination-focused ratio of No.2, dynamically balancing progress toward the destination and detour minimization based on remaining nodes, while always prioritizing the destination if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {current_node}\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.5 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5073,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if unvisited, otherwise selects the next node based on a weighted score combining the ratio of destination distance to current distance (0.5 weight) and a detour factor (average distance to remaining nodes divided by current distance, also 0.5 weight). This balances progress toward the destination with minimizing detours to unvisited nodes.",
          "thought": "The new algorithm combines the destination prioritization from No.2 with the detour minimization and weighted ratio approach from No.1, selecting nodes based on a weighted score of the ratio of destination distance to current distance and the average distance to remaining nodes, while always prioritizing the destination if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {current_node}\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.5 * ratio + 0.5 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5078,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of distance to the destination over distance from the current node (via `ratio`), while balancing this with a detour factor that considers average distances to remaining unvisited nodes (via `detour_factor`). The final score combines these two factors equally (0.5 each), ensuring progress toward the destination while avoiding excessive detours. The destination node is always chosen if still unvisited.",
          "thought": "The new algorithm will prioritize nodes that maximize the ratio of the distance to the destination over the distance from the current node, while also considering a detour factor to balance progress toward the destination and minimizing unnecessary deviations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.5 * ratio + 0.5 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5081,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the destination (via the `ratio` term) and detour minimization (via the `detour_factor`). It dynamically adjusts the weight between these two factors: higher weights favor destination proximity when many nodes remain, while lower weights emphasize detour minimization as the tour nears completion. The heuristic ensures progress toward the destination while avoiding excessive detours, making it adaptive to the remaining nodes.",
          "thought": "The new algorithm combines the idea of prioritizing destination proximity (like No.2) with a dynamic weighting between advancing toward the destination and minimizing detours (like No.1), adjusting the weight based on the number of remaining nodes to balance progress and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.6 if len(remaining_nodes) > 2 else 0.4\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50821,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the destination (via `ratio`) and detour minimization (via `detour_factor`), dynamically adjusting the weight (0.5 or 0.3) based on remaining nodes to favor destination proximity when more nodes are left. The `score` combines these factors, favoring nodes closer to the destination when options are plentiful but balancing detour minimization as the tour progresses.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 with the ratio-based selection of No.2, prioritizing nodes that balance destination proximity and detour minimization while dynamically adjusting the weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.5 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51194,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes progress toward the destination (with a weight of 0.4) while balancing detour minimization (with a weight of 0.6), using a ratio of destination distance to current distance and an average distance to remaining nodes. It first checks if the destination is unvisited and returns it immediately if so, otherwise it evaluates each unvisited node based on these weighted factors to select the next node. The destination is given higher priority (0.4) compared to detour minimization (0.6).",
          "thought": "The new algorithm prioritizes the destination when unvisited, otherwise balances progress toward the destination (via ratio) and detour minimization (via average distance to remaining nodes), using a fixed weight of 0.4 to emphasize progress while accounting for detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {current_node}\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.4 * ratio + 0.6 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51778,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes progress toward the destination (via the `ratio` of distance to the destination over the current distance) and detour minimization (via the `detour_factor`, which balances local detours with remaining distances). It dynamically adjusts the weight between these two factors, giving higher priority to the destination when many nodes remain (`weight=0.4`) and shifting toward detour minimization when fewer nodes remain (`weight=0.2`). The `select_next_node` function ensures the destination is visited first if still unvisited, otherwise it selects the next node based on the highest combined score.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with a dynamic weight balance between progress toward the destination (via ratio) and detour minimization (via detour factor), similar to No.1, but without the fixed weight transition.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    remaining_nodes = unvisited_nodes - {current_node}\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.4 if len(remaining_nodes) > 3 else 0.2\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.52494,
          "other_inf": null
     }
]