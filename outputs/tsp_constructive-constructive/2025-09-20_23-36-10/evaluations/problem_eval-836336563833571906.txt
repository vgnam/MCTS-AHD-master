def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if destination_node in unvisited_nodes:
        return destination_node

    max_score = -float('inf')
    next_node = None

    # Precompute centrality for all nodes
    centrality = {}
    for node in unvisited_nodes:
        centrality[node] = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)

    # Precompute total remaining distance to destination
    total_remaining = sum(distance_matrix[node][destination_node] for node in unvisited_nodes)

    for node in unvisited_nodes:
        if node == current_node:
            continue

        distance = distance_matrix[current_node][node]
        if distance == 0:
            continue

        # Original ratio: destination_distance / distance
        ratio = distance_matrix[node][destination_node] / distance

        # Centrality factor: normalized centrality
        centrality_factor = centrality[node] / max(centrality.values()) if centrality.values() else 1.0

        # Progress factor: remaining distance to destination
        progress_factor = distance_matrix[node][destination_node] / total_remaining if total_remaining > 0 else 1.0

        # Combined score with dynamic weights
        score = 0.5 * ratio + 0.3 * centrality_factor + 0.2 * progress_factor

        if score > max_score:
            max_score = score
            next_node = node

    return next_node
