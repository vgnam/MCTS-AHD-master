[
     {
          "algorithm": "The algorithm prioritizes progress toward the destination by balancing the ratio of destination distance to current distance (70% weight) with a detour factor (30% weight) to minimize unnecessary deviations. It dynamically selects the next node by evaluating unvisited nodes, favoring those that reduce the distance to the destination while considering the average remaining distances to avoid long detours. The destination node is always chosen if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic weight balancing of No.1, using a ratio of destination distance to current distance (70% weight) and a detour factor (30% weight) for remaining nodes, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.7 * ratio + 0.3 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5506,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: advancing toward the destination (prioritized with a dynamic weight) and minimizing detours (considering remaining unvisited nodes). The weight shifts from 70% toward destination progression to 30% toward detour minimization as fewer nodes remain. The score combines these factors to choose the best candidate node, with `ratio` (destination proximity) and `detour_factor` (average remaining distances) influencing selection. The destination is prioritized if it's still unvisited.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with the node's potential to reduce overall path length, prioritizing nodes that both advance toward the destination and minimize detours while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.7 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (maximizing the ratio of destination distance to current distance) while penalizing longer detours (subtracting a term proportional to the distance squared). It balances these two factors to select the next node, ensuring the path progresses toward the destination without excessive detours. The penalty term (`distance ** 1.5`) gives higher weight to longer distances, discouraging detours more aggressively than a linear penalty.",
          "thought": "The new algorithm combines the prioritization of nodes closer to the destination (from No.2) with a penalty for detours (from No.1), selecting the node that maximizes the ratio of destination distance to current distance while penalizing longer detours via a distance-based term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = distance ** 1.5\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, using a dynamic weighting factor (destination_distance / distance)^0.5. It balances this with a term (1 + 1 / (1 + distance)) to favor nodes that reduce the overall path length, ensuring efficiency while avoiding infinite loops. The destination node is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the ratio calculation by incorporating a dynamic weighting factor that balances the distance to the destination and the distance from the current node, introducing a novel mechanism to prioritize nodes that are closer to the destination relative to their distance from the current node while also considering the node's potential to reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        # Dynamic weighting factor based on the ratio of destination distance to current distance\n        weight = (destination_distance / distance) ** 0.5\n        # Score combines the weighted ratio and a term to favor nodes that reduce overall path length\n        score = weight * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates that minimize the distance from the current node while steering more directly toward the destination, balancing the distance ratio (`destination_distance / distance`) with an angle factor (`1 / (1 + distance)`). Nodes closer to the current node and those that reduce the path's detour are favored, with the angle factor mitigating unnecessary turns. The destination is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the distance ratio and the node's proximity to the destination, while also considering the angle between the current node, candidate node, and destination to favor nodes that steer the path more directly toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Calculate the angle between current node, candidate node, and destination\n        # Using dot product formula: cos\u03b8 = (a\u00b7b) / (||a|| ||b||)\n        # Vectors: a = (distance_matrix[current_node][node], 0), b = (0, distance_matrix[node][destination_node])\n        # Dot product: a\u00b7b = 0 (since they are orthogonal in this simplified 2D projection)\n        # Angle is 90 degrees, so cos\u03b8 = 0, which is not useful here. Instead, use a different angle measure.\n        # Alternative: Use the ratio of distances to approximate the angle's effect.\n        angle_factor = 1.0 / (1.0 + distance)  # Smaller distance means steeper angle\n\n        # Combine ratio and angle factor\n        score = (destination_distance / distance) * angle_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing progress toward the destination (prioritized via the ratio of destination distance to current distance) while penalizing detours (via a distance-based penalty term). It avoids prematurely selecting distant nodes by dynamically adjusting the score with a penalty that scales with the current distance. The destination node is prioritized if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that combines the original ratio with a penalty term based on the node's distance from the current node, ensuring a balance between progress toward the destination and minimizing detours while avoiding prematurely selecting distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = (distance_matrix[current_node][node] ** 1.5) / (destination_distance + 1e-6)\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62216,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (higher `destination_distance / distance` ratio) while penalizing longer distances to the current node (subtracting `0.5 * distance`). If the destination is unvisited, it immediately selects it. Otherwise, it iteratively evaluates unvisited nodes using this weighted scoring mechanism. The destination is given the highest priority, followed by nodes that balance proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the balanced scoring approach of No.1, using a weighted ratio of destination distance to current distance while penalizing longer distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.5 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that offer a good balance between progress toward the destination (via the ratio of destination distance to current distance) and avoiding excessive detours (via a penalty term for nodes too far from the current node). It assigns higher priority to nodes with a favorable ratio and lower priority to nodes with a high penalty, ensuring a compromise between efficiency and detour minimization. The code structure iterates through unvisited nodes, computes a weighted score, and selects the node with the highest score.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the ratio of destination distance to current distance and a penalty term for nodes that are too far from the current node, promoting a balance between progress toward the destination and minimizing excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = (distance_matrix[current_node][node] / max(distance_matrix[current_node].values())) if isinstance(distance_matrix[current_node], dict) else (distance_matrix[current_node][node] / max(distance_matrix[current_node]))\n        score = ratio - 0.5 * penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.63191,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local efficiency (proximity to the current node) and global coverage (average distance to unvisited nodes), prioritizing nodes closer to the destination while also considering the average distance to ensure broader exploration. The weight combines 70% of the ratio of destination proximity to current distance and 30% of the average distance ratio, favoring nodes that are both locally efficient and globally balanced. The function ensures the destination is prioritized if still unvisited.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight that balances the ratio of destination proximity with the current distance, while also considering the average distance of unvisited nodes to introduce a global perspective, ensuring both local efficiency and global coverage.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        weight = 0.7 * ratio + 0.3 * (avg_distance / distance)\n        if weight > max_score:\n            max_score = weight\n            next_node = node\n    return next_node",
          "objective": 6.63202,
          "other_inf": null
     }
]