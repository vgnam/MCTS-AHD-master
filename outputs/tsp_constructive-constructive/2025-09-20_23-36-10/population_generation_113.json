[
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, using a dynamic weighting factor (destination_distance / distance)^0.5. It balances this with a term (1 + 1 / (1 + distance)) to favor nodes that reduce the overall path length, ensuring efficiency while avoiding infinite loops. The destination node is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the ratio calculation by incorporating a dynamic weighting factor that balances the distance to the destination and the distance from the current node, introducing a novel mechanism to prioritize nodes that are closer to the destination relative to their distance from the current node while also considering the node's potential to reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        # Dynamic weighting factor based on the ratio of destination distance to current distance\n        weight = (destination_distance / distance) ** 0.5\n        # Score combines the weighted ratio and a term to favor nodes that reduce overall path length\n        score = weight * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates that minimize the distance from the current node while steering more directly toward the destination, balancing the distance ratio (`destination_distance / distance`) with an angle factor (`1 / (1 + distance)`). Nodes closer to the current node and those that reduce the path's detour are favored, with the angle factor mitigating unnecessary turns. The destination is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the distance ratio and the node's proximity to the destination, while also considering the angle between the current node, candidate node, and destination to favor nodes that steer the path more directly toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Calculate the angle between current node, candidate node, and destination\n        # Using dot product formula: cos\u03b8 = (a\u00b7b) / (||a|| ||b||)\n        # Vectors: a = (distance_matrix[current_node][node], 0), b = (0, distance_matrix[node][destination_node])\n        # Dot product: a\u00b7b = 0 (since they are orthogonal in this simplified 2D projection)\n        # Angle is 90 degrees, so cos\u03b8 = 0, which is not useful here. Instead, use a different angle measure.\n        # Alternative: Use the ratio of distances to approximate the angle's effect.\n        angle_factor = 1.0 / (1.0 + distance)  # Smaller distance means steeper angle\n\n        # Combine ratio and angle factor\n        score = (destination_distance / distance) * angle_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (higher `destination_distance / distance` ratio) while penalizing longer distances to the current node (subtracting `0.5 * distance`). If the destination is unvisited, it immediately selects it. Otherwise, it iteratively evaluates unvisited nodes using this weighted scoring mechanism. The destination is given the highest priority, followed by nodes that balance proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the balanced scoring approach of No.1, using a weighted ratio of destination distance to current distance while penalizing longer distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.5 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by balancing the ratio of destination distance to current distance (higher ratio preferred) while penalizing longer current distances (0.3 \u00d7 distance). The destination node is given absolute priority, while other nodes are scored based on this trade-off.",
          "thought": "The new algorithm combines the prioritization of the destination and the ratio of destination distance to current distance from No.2, while incorporating a penalty for longer distances from No.1. It selects the destination if unvisited, otherwise it chooses the node that maximizes the ratio of destination distance to current distance, penalized by a factor of 0.3 times the current distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.3 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.63704,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two heuristics: prioritizing the destination if unvisited (critical for TSP completeness) and selecting other nodes based on a weighted score (70% weight on the ratio of destination distance to current distance, 30% weight on normalized distance to the destination). This ensures efficiency while maintaining correctness. The destination is always chosen first if unvisited, otherwise, nodes are ranked by their balance between proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the weighted ratio and distance heuristic of No.1, where nodes are selected based on a weighted combination of the ratio of destination distance to current distance (70% weight) and the normalized distance to the destination (30% weight), while always prioritizing the destination if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        distance_weight = 1 - destination_distance\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63964,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes closer to the destination while penalizing longer distances from the current node, using a ratio-based scoring mechanism. It selects the node that maximizes the ratio of destination distance to current distance, adjusted by a penalty term (0.2 * current distance). If the destination is unvisited, it is chosen immediately.",
          "thought": "The new algorithm combines the prioritization of nodes closer to the destination with a penalty for longer distances from the current node, similar to No.1, but uses a ratio-based scoring mechanism like No.2, selecting the node that maximizes the ratio of destination distance to current distance while subtracting a penalty term for longer travel distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.2 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.64195,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: the distance from the current node (prioritized when few nodes remain) and the distance to the destination (prioritized when many nodes remain). The dynamic weight adjusts this balance based on the remaining unvisited nodes, giving higher priority to minimizing detours early and optimizing the path toward the destination later. The score function combines these factors inversely proportional to the distance, ensuring efficient node selection.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the destination distance and the distance from the current node, using a dynamic weight that prioritizes nodes closer to the destination while balancing detours based on the remaining number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * (destination_distance / distance) + weight * (1 / distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.65353,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes moving closer to the destination (destination_distance) while penalizing nodes that are far from the current node (proximity_penalty), balancing progress toward the destination with minimizing detours. The score is calculated as `ratio * (1 + proximity_penalty)`, where `ratio` (destination_distance / distance) favors nodes closer to the destination, and the penalty adjusts for detours. If the destination is still unvisited, it is always chosen first.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that combines the original ratio with a penalty factor based on the node's proximity to the current node, ensuring a balance between progress toward the destination and minimizing detours, while still prioritizing the destination if it remains unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        proximity_penalty = 1 - (distance_matrix[current_node][node] / max(distance_matrix[current_node][n] for n in unvisited_nodes if n != destination_node))\n        score = ratio * (1 + proximity_penalty)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.65438,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of destination distance to current distance, scaled by a dynamic factor that reduces the weight of longer edges. It balances proximity to the destination (high ratio) with local path efficiency (smaller distance), favoring nodes that both advance toward the destination and maintain shorter overall path segments. The score calculation `(destination_distance / distance) * (1 + 1 / (1 + distance))` ensures nodes closer to the destination are preferred, while the scaling factor `(1 + 1 / (1 + distance))` downweights excessively long edges.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with a dynamic weighting factor inspired by No.1, selecting nodes that maximize the ratio of destination distance to current distance, scaled by a factor of (1 + 1 / (1 + distance)) to favor nodes that reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        score = ratio * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.66007,
          "other_inf": null
     }
]