[
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (60% weight) while also considering average distances to remaining unvisited nodes (40% weight) to minimize detours. It dynamically balances progress toward the destination with path efficiency, ensuring both goal alignment and route optimization. The `ratio` (destination proximity) and `detour_factor` (detour minimization) are combined linearly, with the former given higher priority.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic balancing of destination proximity and detour minimization from No.1, using a fixed weight of 60% for destination proximity and 40% for detour minimization, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = (0.6 * ratio) + (0.4 * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes progress toward the destination by balancing the ratio of destination distance to current distance (70% weight) with a detour factor (30% weight) to minimize unnecessary deviations. It dynamically selects the next node by evaluating unvisited nodes, favoring those that reduce the distance to the destination while considering the average remaining distances to avoid long detours. The destination node is always chosen if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic weight balancing of No.1, using a ratio of destination distance to current distance (70% weight) and a detour factor (30% weight) for remaining nodes, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.7 * ratio + 0.3 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5506,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: advancing toward the destination (prioritized with a dynamic weight) and minimizing detours (considering remaining unvisited nodes). The weight shifts from 70% toward destination progression to 30% toward detour minimization as fewer nodes remain. The score combines these factors to choose the best candidate node, with `ratio` (destination proximity) and `detour_factor` (average remaining distances) influencing selection. The destination is prioritized if it's still unvisited.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with the node's potential to reduce overall path length, prioritizing nodes that both advance toward the destination and minimize detours while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.7 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (maximizing the ratio of destination distance to current distance) while penalizing longer detours (subtracting a term proportional to the distance squared). It balances these two factors to select the next node, ensuring the path progresses toward the destination without excessive detours. The penalty term (`distance ** 1.5`) gives higher weight to longer distances, discouraging detours more aggressively than a linear penalty.",
          "thought": "The new algorithm combines the prioritization of nodes closer to the destination (from No.2) with a penalty for detours (from No.1), selecting the node that maximizes the ratio of destination distance to current distance while penalizing longer detours via a distance-based term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = distance ** 1.5\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: **distance ratio** (prioritizing nodes that are closer to the destination relative to their distance from the current node) and **deviation penalty** (discouraging nodes that significantly detour from the straight-line path to the destination). The score is computed as `ratio - 0.5 * deviation`, where the ratio is weighted higher than deviation. If the destination is still unvisited, it is prioritized immediately.",
          "thought": "The new algorithm extends the original by incorporating a dynamic weighting mechanism that adjusts the priority based on both the distance ratio and the node's proximity to the destination, while also penalizing nodes that deviate significantly from the straight-line path to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    current_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = dest_distance / distance\n        deviation = abs(distance + dest_distance - current_to_dest)\n        score = ratio - 0.5 * deviation\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60446,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in the TSP path by prioritizing nodes that maximize the ratio of their distance to the destination over their distance from the current node, while heavily penalizing longer local distances (using `distance ** 2`). It ensures the destination is prioritized if still unvisited, otherwise it balances progress toward the destination with minimizing detours by favoring nodes with high `score = (destination_distance / distance) - (distance ** 2)`.",
          "thought": "The common ideas in No.1 algorithm are penalizing longer local distances and balancing progress toward the destination with minimizing detours. The new algorithm, inspired by No.2, will prioritize nodes by maximizing the ratio of destination distance to local distance while penalizing longer local distances more heavily.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (distance ** 2)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.60691,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, using a dynamic weighting factor (destination_distance / distance)^0.5. It balances this with a term (1 + 1 / (1 + distance)) to favor nodes that reduce the overall path length, ensuring efficiency while avoiding infinite loops. The destination node is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the ratio calculation by incorporating a dynamic weighting factor that balances the distance to the destination and the distance from the current node, introducing a novel mechanism to prioritize nodes that are closer to the destination relative to their distance from the current node while also considering the node's potential to reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        # Dynamic weighting factor based on the ratio of destination distance to current distance\n        weight = (destination_distance / distance) ** 0.5\n        # Score combines the weighted ratio and a term to favor nodes that reduce overall path length\n        score = weight * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61833,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates that minimize the distance from the current node while steering more directly toward the destination, balancing the distance ratio (`destination_distance / distance`) with an angle factor (`1 / (1 + distance)`). Nodes closer to the current node and those that reduce the path's detour are favored, with the angle factor mitigating unnecessary turns. The destination is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the distance ratio and the node's proximity to the destination, while also considering the angle between the current node, candidate node, and destination to favor nodes that steer the path more directly toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Calculate the angle between current node, candidate node, and destination\n        # Using dot product formula: cos\u03b8 = (a\u00b7b) / (||a|| ||b||)\n        # Vectors: a = (distance_matrix[current_node][node], 0), b = (0, distance_matrix[node][destination_node])\n        # Dot product: a\u00b7b = 0 (since they are orthogonal in this simplified 2D projection)\n        # Angle is 90 degrees, so cos\u03b8 = 0, which is not useful here. Instead, use a different angle measure.\n        # Alternative: Use the ratio of distances to approximate the angle's effect.\n        angle_factor = 1.0 / (1.0 + distance)  # Smaller distance means steeper angle\n\n        # Combine ratio and angle factor\n        score = (destination_distance / distance) * angle_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61967,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing progress toward the destination (prioritized via the ratio of destination distance to current distance) while penalizing detours (via a distance-based penalty term). It avoids prematurely selecting distant nodes by dynamically adjusting the score with a penalty that scales with the current distance. The destination node is prioritized if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that combines the original ratio with a penalty term based on the node's distance from the current node, ensuring a balance between progress toward the destination and minimizing detours while avoiding prematurely selecting distant nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = (distance_matrix[current_node][node] ** 1.5) / (destination_distance + 1e-6)\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62216,
          "other_inf": null
     }
]