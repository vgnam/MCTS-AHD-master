[
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (60% weight) while also considering average distances to remaining unvisited nodes (40% weight) to minimize detours. It dynamically balances progress toward the destination with path efficiency, ensuring both goal alignment and route optimization. The `ratio` (destination proximity) and `detour_factor` (detour minimization) are combined linearly, with the former given higher priority.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic balancing of destination proximity and detour minimization from No.1, using a fixed weight of 60% for destination proximity and 40% for detour minimization, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = (0.6 * ratio) + (0.4 * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50707,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the destination (via the `ratio` term) and detour minimization (via the `detour_factor`). It dynamically adjusts the weight between these two factors: higher weights favor destination proximity when many nodes remain, while lower weights emphasize detour minimization as the tour nears completion. The heuristic ensures progress toward the destination while avoiding excessive detours, making it adaptive to the remaining nodes.",
          "thought": "The new algorithm combines the idea of prioritizing destination proximity (like No.2) with a dynamic weighting between advancing toward the destination and minimizing detours (like No.1), adjusting the weight based on the number of remaining nodes to balance progress and efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.6 if len(remaining_nodes) > 2 else 0.4\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.50821,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance proximity to the destination (via `ratio`) and detour minimization (via `detour_factor`), dynamically adjusting the weight (0.5 or 0.3) based on remaining nodes to favor destination proximity when more nodes are left. The `score` combines these factors, favoring nodes closer to the destination when options are plentiful but balancing detour minimization as the tour progresses.",
          "thought": "The new algorithm combines the adaptive weighting of No.1 with the ratio-based selection of No.2, prioritizing nodes that balance destination proximity and detour minimization while dynamically adjusting the weight based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        weight = 0.5 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.51194,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes progress toward the destination by balancing the ratio of destination distance to current distance (70% weight) with a detour factor (30% weight) to minimize unnecessary deviations. It dynamically selects the next node by evaluating unvisited nodes, favoring those that reduce the distance to the destination while considering the average remaining distances to avoid long detours. The destination node is always chosen if still unvisited, ensuring efficiency.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the dynamic weight balancing of No.1, using a ratio of destination distance to current distance (70% weight) and a detour factor (30% weight) for remaining nodes, ensuring progress toward the destination while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        score = 0.7 * ratio + 0.3 * detour_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5506,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: advancing toward the destination (prioritized with a dynamic weight) and minimizing detours (considering remaining unvisited nodes). The weight shifts from 70% toward destination progression to 30% toward detour minimization as fewer nodes remain. The score combines these factors to choose the best candidate node, with `ratio` (destination proximity) and `detour_factor` (average remaining distances) influencing selection. The destination is prioritized if it's still unvisited.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with the node's potential to reduce overall path length, prioritizing nodes that both advance toward the destination and minimize detours while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        if node == current_node:\n            continue\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Compute the ratio of destination distance to current distance\n        ratio = destination_distance / distance\n\n        # Compute the potential to minimize detours by considering the remaining unvisited nodes\n        remaining_nodes = unvisited_nodes - {node}\n        if remaining_nodes:\n            avg_distance = sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n            detour_factor = avg_distance / distance\n        else:\n            detour_factor = 1.0\n\n        # Combine the ratio and detour factor with a dynamic weight\n        weight = 0.7 if len(remaining_nodes) > 2 else 0.3\n        score = (weight * ratio) + ((1 - weight) * detour_factor)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.55786,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (maximizing the ratio of destination distance to current distance) while penalizing longer detours (subtracting a term proportional to the distance squared). It balances these two factors to select the next node, ensuring the path progresses toward the destination without excessive detours. The penalty term (`distance ** 1.5`) gives higher weight to longer distances, discouraging detours more aggressively than a linear penalty.",
          "thought": "The new algorithm combines the prioritization of nodes closer to the destination (from No.2) with a penalty for detours (from No.1), selecting the node that maximizes the ratio of destination distance to current distance while penalizing longer detours via a distance-based term.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        penalty = distance ** 1.5\n        score = ratio - penalty\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.6005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two key factors: **distance ratio** (prioritizing nodes that are closer to the destination relative to their distance from the current node) and **deviation penalty** (discouraging nodes that significantly detour from the straight-line path to the destination). The score is computed as `ratio - 0.5 * deviation`, where the ratio is weighted higher than deviation. If the destination is still unvisited, it is prioritized immediately.",
          "thought": "The new algorithm extends the original by incorporating a dynamic weighting mechanism that adjusts the priority based on both the distance ratio and the node's proximity to the destination, while also penalizing nodes that deviate significantly from the straight-line path to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    current_to_dest = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = dest_distance / distance\n        deviation = abs(distance + dest_distance - current_to_dest)\n        score = ratio - 0.5 * deviation\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60446,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node in the TSP path by prioritizing nodes that maximize the ratio of their distance to the destination over their distance from the current node, while heavily penalizing longer local distances (using `distance ** 2`). It ensures the destination is prioritized if still unvisited, otherwise it balances progress toward the destination with minimizing detours by favoring nodes with high `score = (destination_distance / distance) - (distance ** 2)`.",
          "thought": "The common ideas in No.1 algorithm are penalizing longer local distances and balancing progress toward the destination with minimizing detours. The new algorithm, inspired by No.2, will prioritize nodes by maximizing the ratio of destination distance to local distance while penalizing longer local distances more heavily.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (distance ** 2)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.60691,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those closest to the destination relative to their distance from the current node, using a dynamic weighting factor (destination_distance / distance)^0.5. It balances this with a term (1 + 1 / (1 + distance)) to favor nodes that reduce the overall path length, ensuring efficiency while avoiding infinite loops. The destination node is always prioritized if still unvisited.",
          "thought": "The new algorithm modifies the ratio calculation by incorporating a dynamic weighting factor that balances the distance to the destination and the distance from the current node, introducing a novel mechanism to prioritize nodes that are closer to the destination relative to their distance from the current node while also considering the node's potential to reduce overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        # Dynamic weighting factor based on the ratio of destination distance to current distance\n        weight = (destination_distance / distance) ** 0.5\n        # Score combines the weighted ratio and a term to favor nodes that reduce overall path length\n        score = weight * (1 + 1 / (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.61833,
          "other_inf": null
     }
]