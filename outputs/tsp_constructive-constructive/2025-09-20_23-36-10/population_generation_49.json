[
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node while penalizing longer local distances. It ensures progress toward the destination by favoring nodes closer to it and maintains efficiency by penalizing larger distances from the current node. The score calculation (`destination_distance / distance - distance`) balances these two factors, with higher scores indicating better candidates.",
          "thought": "The new algorithm prioritizes nodes that balance the ratio of distance to the destination over the distance from the current node, while also penalizing longer local distances to ensure both progress toward the destination and efficiency in the path, similar to No.1 but structured like No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination (higher `destination_distance / distance` ratio) while penalizing longer distances to the current node (subtracting `0.5 * distance`). If the destination is unvisited, it immediately selects it. Otherwise, it iteratively evaluates unvisited nodes using this weighted scoring mechanism. The destination is given the highest priority, followed by nodes that balance proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the balanced scoring approach of No.1, using a weighted ratio of destination distance to current distance while penalizing longer distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance / distance) - (0.5 * distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines two heuristics: prioritizing the destination if unvisited (critical for TSP completeness) and selecting other nodes based on a weighted score (70% weight on the ratio of destination distance to current distance, 30% weight on normalized distance to the destination). This ensures efficiency while maintaining correctness. The destination is always chosen first if unvisited, otherwise, nodes are ranked by their balance between proximity to the destination and distance from the current node.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the weighted ratio and distance heuristic of No.1, where nodes are selected based on a weighted combination of the ratio of destination distance to current distance (70% weight) and the normalized distance to the destination (30% weight), while always prioritizing the destination if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        ratio = destination_distance / distance\n        distance_weight = 1 - destination_distance\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63964,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: the distance from the current node (prioritized when few nodes remain) and the distance to the destination (prioritized when many nodes remain). The dynamic weight adjusts this balance based on the remaining unvisited nodes, giving higher priority to minimizing detours early and optimizing the path toward the destination later. The score function combines these factors inversely proportional to the distance, ensuring efficient node selection.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the destination distance and the distance from the current node, using a dynamic weight that prioritizes nodes closer to the destination while balancing detours based on the remaining number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * (destination_distance / distance) + weight * (1 / distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.65353,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance progress toward the destination (weighted 0.4) and distance from the current node, ensuring a trade-off between global (destination proximity) and local (short-term distance) optimization. It explicitly checks for the destination node first and skips invalid (zero-distance) nodes. The scoring formula `(0.4 * destination_distance / distance) - distance` emphasizes reducing the ratio of destination distance to current distance while penalizing longer local distances.",
          "thought": "The new algorithm combines the prioritization of the destination node with a weighted approach that balances the ratio of progress toward the destination (with a 0.4 weight) and the distance from the current node, ensuring both global and local optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (0.4 * destination_distance / distance) - distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.66316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing progress toward the destination (70% weight) with path efficiency (30% weight), where the latter is based on the average distance of unvisited nodes to the destination. It prioritizes nodes that reduce the ratio of destination distance to current distance while favoring those closer to the average distance of remaining nodes. The code ensures the destination is chosen first if still unvisited, and handles edge cases like zero distances gracefully.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the ratio of destination distance to current distance and an additional heuristic that considers the average distance of the remaining unvisited nodes, ensuring a balance between progress toward the destination and overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    # Calculate average distance of unvisited nodes to the destination\n    total_destination_distance = 0\n    count = 0\n    for node in unvisited_nodes:\n        if node != destination_node:\n            total_destination_distance += distance_matrix[node][destination_node]\n            count += 1\n    avg_destination_distance = total_destination_distance / count if count > 0 else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Weighted score combining the original ratio and average distance heuristic\n        ratio = destination_distance / distance\n        distance_weight = 1 - (destination_distance / (avg_destination_distance + 1e-10))\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74418,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that are both geographically closer to the current node (higher proximity weight) and closer to the destination (lower ratio of destination distance to current distance), while always selecting the destination if unvisited. The score is calculated as the product of these two factors, ensuring a balance between proximity and destination alignment. The destination is given the highest priority when unvisited, and otherwise, the node with the highest score is chosen.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting factor that balances the ratio of destination distance to current distance with a proximity-based term, prioritizing nodes that are both closer to the destination and geographically closer to the current node, while still ensuring the destination is always selected if unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        proximity_weight = 1 / (distance + 1e-6)  # Avoid division by zero\n        score = ratio * proximity_weight\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.76839,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing nodes that both progress toward the destination (via a distance ratio) and are closer in direct distance (via inverse distance), balancing these factors with weights (0.6 for ratio, 0.4 for direct distance) while ensuring the destination is always chosen if unvisited. The code iterates through unvisited nodes, computes a weighted score for each, and selects the node with the highest score.",
          "thought": "The new algorithm modifies the provided algorithm by introducing a weighted combination of the distance ratio and the direct distance from the current node to the potential next node, favoring nodes that both progress toward the destination and are closer in direct distance, while still prioritizing the destination when unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        direct_distance = distance_matrix[current_node][node]\n        score = 0.6 * ratio + 0.4 * (1 / direct_distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.8183,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances progress toward the destination (prioritized via the `ratio` of destination distance to current distance) with detour minimization (prioritized via a centrality score, weighted at 0.3). Nodes with higher ratios or lower centrality scores (indicating less centrality in the remaining graph) are favored, dynamically adjusting the trade-off between proximity and centrality. The `centrality_weight` (0.3) ensures centrality influences the selection without dominating progress, while the ratio prioritizes direct progress toward the destination.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines the original ratio-based selection with a node's centrality score, favoring nodes that are both closer to the destination and more central in the remaining unvisited graph to balance progress and detour minimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Calculate centrality score: sum of distances to all other unvisited nodes\n        centrality = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n\n        # Combine ratio and centrality with dynamic weighting\n        if centrality == 0:\n            score = float('inf')\n        else:\n            ratio = destination_distance / distance\n            centrality_weight = 0.3  # Adjustable weight for centrality\n            score = ratio + centrality_weight * (1 / centrality)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.87807,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node, normalized by the inverse of the remaining unvisited nodes. It ensures the destination is chosen if still unvisited, otherwise balances proximity to the current node and alignment with the destination path. The ratio calculation (`destination_distance / (distance / remaining)`) weights both factors, with `remaining` adjusting for the number of unvisited nodes.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the normalized Euclidean distance balance of No.1, selecting nodes that maximize the ratio of destination distance to current distance while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / (distance / remaining)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.88551,
          "other_inf": null
     }
]