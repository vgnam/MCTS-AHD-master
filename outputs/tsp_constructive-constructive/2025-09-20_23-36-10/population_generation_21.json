[
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: the distance from the current node (prioritized when few nodes remain) and the distance to the destination (prioritized when many nodes remain). The dynamic weight adjusts this balance based on the remaining unvisited nodes, giving higher priority to minimizing detours early and optimizing the path toward the destination later. The score function combines these factors inversely proportional to the distance, ensuring efficient node selection.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the destination distance and the distance from the current node, using a dynamic weight that prioritizes nodes closer to the destination while balancing detours based on the remaining number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    remaining_nodes = len(unvisited_nodes)\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n        score = (1 - weight) * (destination_distance / distance) + weight * (1 / distance)\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.65353,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing progress toward the destination (70% weight) with path efficiency (30% weight), where the latter is based on the average distance of unvisited nodes to the destination. It prioritizes nodes that reduce the ratio of destination distance to current distance while favoring those closer to the average distance of remaining nodes. The code ensures the destination is chosen first if still unvisited, and handles edge cases like zero distances gracefully.",
          "thought": "The new algorithm modifies the original by incorporating a weighted combination of the ratio of destination distance to current distance and an additional heuristic that considers the average distance of the remaining unvisited nodes, ensuring a balance between progress toward the destination and overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n\n    # Calculate average distance of unvisited nodes to the destination\n    total_destination_distance = 0\n    count = 0\n    for node in unvisited_nodes:\n        if node != destination_node:\n            total_destination_distance += distance_matrix[node][destination_node]\n            count += 1\n    avg_destination_distance = total_destination_distance / count if count > 0 else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n\n        # Weighted score combining the original ratio and average distance heuristic\n        ratio = destination_distance / distance\n        distance_weight = 1 - (destination_distance / (avg_destination_distance + 1e-10))\n        score = ratio * 0.7 + distance_weight * 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.74418,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of their distance to the destination over their distance from the current node, normalized by the inverse of the remaining unvisited nodes. It ensures the destination is chosen if still unvisited, otherwise balances proximity to the current node and alignment with the destination path. The ratio calculation (`destination_distance / (distance / remaining)`) weights both factors, with `remaining` adjusting for the number of unvisited nodes.",
          "thought": "The new algorithm combines the destination prioritization of No.2 with the normalized Euclidean distance balance of No.1, selecting nodes that maximize the ratio of destination distance to current distance while considering the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / (distance / remaining)\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.88551,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring progress toward the destination while minimizing detours. It always selects the destination if it remains unvisited, and otherwise chooses the node that maximizes this ratio. The higher priority is given to nodes closer to the destination relative to their distance from the current node, while the destination itself is always prioritized when unvisited.",
          "thought": "The new algorithm prioritizes nodes that maximize the ratio of the distance to the destination over the distance from the current node, ensuring rapid progress toward the destination while minimizing detours, and it always selects the destination if it's unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_ratio = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        if ratio > max_ratio:\n            max_ratio = ratio\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those that are closer to the destination while balancing detours, using a dynamic score that combines the ratio of destination distance to current distance with a normalization factor based on how close the node is to the average distance from the current node. Higher scores favor nodes that are both closer to the destination and relatively closer to the current node, ensuring a trade-off between progress and detour minimization. The function dynamically adjusts priorities by considering both the immediate and long-term implications of each choice.",
          "thought": "The new algorithm introduces a dynamic priority mechanism that combines the ratio of destination distance to current distance with a normalization factor based on the average distance from the current node to unvisited nodes, ensuring balanced progress toward the destination while minimizing detours and favoring nodes that are both closer to the destination and relatively closer to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    avg_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        ratio = destination_distance / distance\n        normalization_factor = 1 / (1 + abs(distance - avg_distance))\n        score = ratio * normalization_factor\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.9987,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node using the distance matrix. The function checks if the destination is in the unvisited set first, and if not, it iterates through all unvisited nodes to find the one with the minimum distance from the current node. The destination node is given higher priority than other unvisited nodes, while other nodes are selected based on proximity.",
          "thought": "The algorithm selects the next node to visit by choosing the closest unvisited node from the current node, prioritizing the destination node if it is among the unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the remaining unvisited nodes. It balances local progress (distance from current node) with global progress (Euclidean distance to destination), with the latter's weight decreasing as more nodes are visited. The destination is prioritized if still unvisited, otherwise the node with the lowest combined score is selected.",
          "thought": "The new algorithm prioritizes nodes that minimize the sum of the distance from the current node and the Euclidean distance to the destination, normalized by the number of remaining unvisited nodes to balance local and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        euclidean_distance = ((distance_matrix[node][0] - distance_matrix[destination_node][0])**2 +\n                             (distance_matrix[node][1] - distance_matrix[destination_node][1])**2)**0.5\n        score = distance + euclidean_distance / remaining\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 7.19875,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that are closer to the destination while balancing their distance from the current node, using a dynamic weighting mechanism where the score is calculated as `(destination_distance ** 2) / (distance * (1 + distance))`. This ensures the destination is always chosen if unvisited, otherwise, nodes closer to the destination and farther from the current node are favored. The exponential term (`destination_distance ** 2`) amplifies the importance of proximity to the destination, while the denominator penalizes nodes too close to the current node (`distance * (1 + distance)`).",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a dynamic weighting mechanism that balances the distance to the destination with the distance from the current node, using a novel ratio calculation that includes an exponential term to prioritize nodes that are both close to the destination and far from the current node, while still ensuring the destination is always prioritized when unvisited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        score = (destination_distance ** 2) / (distance * (1 + distance))\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 7.29514,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node while also considering its proximity to the destination (with a 0.3 weight), balancing immediate proximity and progress toward the destination. The `weighted_distance` combines the distance from the current node and the distance to the destination, ensuring a trade-off between local and global optimization.",
          "thought": "This algorithm prioritizes the destination node if it's unvisited, otherwise it selects the closest unvisited node from the current node, but with a bias towards nodes that are not too far from the destination, balancing proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        weighted_distance = distance + 0.3 * destination_distance\n        if weighted_distance < min_distance:\n            min_distance = weighted_distance\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes the destination node if it's unvisited, otherwise it selects the next node by minimizing the sum of the distance from the current node and half the distance to the destination, ensuring a balance between immediate proximity and progress toward the goal. The code highlights the importance of the destination by giving it explicit priority, while other nodes are chosen based on a weighted combination of current distance and remaining distance to the destination.",
          "thought": "The new algorithm prioritizes nodes that minimize the distance from the current node while considering the distance to the destination, ensuring efficient progress toward the destination with minimal detours. It always selects the destination if it is unvisited, otherwise it chooses the node that minimizes the distance from the current node while balancing the distance to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if destination_node in unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n        if distance == 0:\n            continue\n        combined_metric = distance + 0.5 * destination_distance\n        if combined_metric < min_distance:\n            min_distance = combined_metric\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]