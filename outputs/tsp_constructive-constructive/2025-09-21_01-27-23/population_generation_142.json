[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the highest ratio of distance from the current node to the destination over the distance from the current node to the candidate node, balancing proximity and progress toward the destination. If ratios are equal, it chooses the node closer to the destination. The code efficiently handles edge cases (like zero distance) and ensures progress toward the goal while minimizing detours.",
          "thought": "The new algorithm prioritizes selecting the next node by considering not only the closest unvisited node to the current node but also the node that maximizes the ratio of distance to the destination over the distance from the current node, balancing proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_ratio = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_current == 0:\n            ratio = float('inf')  # Avoid division by zero (current node is the same)\n        else:\n            ratio = distance_to_dest / distance_to_current\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            next_node = node\n        elif ratio == best_ratio:\n            # If ratios are equal, choose the node closer to the destination\n            if distance_to_dest < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the smallest ratio of distance from the current node to the node, divided by the distance from the node to the destination. This ensures the path balances proximity to the current location while progressively aligning toward the destination, avoiding division by zero for the destination node.",
          "thought": "The new algorithm prioritizes nodes with the smallest ratio of distance to the current node divided by distance to the destination, ensuring a balance between proximity to the current node and alignment towards the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_ratio = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        if distance_matrix[node][destination_node] == 0:\n            continue  # Avoid division by zero if node is the destination\n\n        ratio = distance_matrix[current_node][node] / distance_matrix[node][destination_node]\n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy proximity heuristic with a penalty mechanism to balance local and global path considerations. It prioritizes selecting the nearest unvisited node unless it is too close to the destination (penalized by a factor of 1.3), ensuring a compromise between short-term optimality and avoiding premature convergence to the destination. The `penalty` parameter (default 1.3) adjusts the trade-off between local and global objectives.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a penalty mechanism from No.1 to avoid nodes that are too close to the destination prematurely, balancing local and global path considerations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, penalty=1.3):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        score = distance\n        if distance_to_destination < distance_matrix[current_node][destination_node]:\n            score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.90842,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node from the distance matrix, and among nodes with equal minimal distance, it chooses the one closer to the destination. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, iterates through unvisited nodes to find the closest one, and handles ties by comparing distances to the destination. The code efficiently balances proximity to the current node and the destination, ensuring a heuristic path selection.",
          "thought": "The algorithm selects the next node by choosing the unvisited node closest to the current node from the distance matrix, prioritizing nodes that are closer to the destination if multiple nodes have the same minimal distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n        elif distance == min_distance:\n            # If distances are equal, choose the node closer to the destination\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing proximity to the current node and the destination, using a dynamic weight that prioritizes current distance more as fewer unvisited nodes remain. It calculates a weighted score for each unvisited node, combining current and destination distances, and chooses the node with the lowest score. The weight adaptively shifts focus from destination proximity to immediate travel efficiency as the tour nears completion.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight that balances the proximity to the current node and the destination, using a weighted sum of distances with adaptive weights based on the remaining unvisited nodes, ensuring a more nuanced path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        dest_distance = distance_matrix[node][destination_node]\n\n        # Dynamic weight: prioritize current distance more when fewer nodes remain\n        weight = 0.5 + (0.5 * (total_unvisited / (total_unvisited + 1)))\n        score = (weight * current_distance) + ((1 - weight) * dest_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.12709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. Early in the tour, it prioritizes nodes close to the current node, while later stages favor nodes closer to the destination. The selection criterion combines these distances with weights that decrease and increase, respectively, as more nodes are visited, ensuring a flexible trade-off between local and global optimization.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of distance to the current node and distance to the destination, where the weight is dynamically adjusted based on the proportion of unvisited nodes remaining. This balances proximity to the current node and the destination more flexibly, favoring nodes that are closer to the current node early on and closer to the destination as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_current = total_unvisited / (total_unvisited + 1)  # Decreases as more nodes are visited\n    weight_destination = 1 - weight_current\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n        elif combined_score == min_score:\n            if distance_to_destination < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically balancing local (distance from current node) and global (distance to destination) considerations, using a weight that adjusts based on the remaining path length. It prioritizes nodes closer to the current node when the destination is far, and vice versa. The weight is computed as \\( 0.5 \\times (1 + \\frac{dest\\_dist}{current\\_dist + dest\\_dist + \\epsilon}) \\), ensuring a smooth transition between local and global optimization.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the distance to the current node and the distance to the destination, where weights are dynamically adjusted based on the remaining path length, promoting a balance between local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        weight = 0.5 * (1 + (dest_dist / (current_dist + dest_dist + 1e-6)))  # Dynamic weight\n        score = weight * current_dist + (1 - weight) * dest_dist\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.17274,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing proximity to the current node and influence from the destination, using a tunable weight (0.3) to prioritize nodes closer to the current node while still considering their distance to the destination. The scoring function (`current_distance + 0.3 * destination_distance`) ensures a trade-off between immediate and long-term path efficiency, with a tiebreaker favoring nodes closer to the current node when scores are equal.",
          "thought": "The new algorithm modifies the provided heuristic by incorporating a dynamic weighting mechanism that prioritizes nodes based on both proximity to the current node and a weighted influence of the destination's distance, using a novel scoring function that balances these factors with tunable parameters.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        # Dynamic weighting: prioritize nodes closer to current node, but also consider destination influence\n        current_distance = distance_matrix[current_node][node]\n        destination_distance = distance_matrix[node][destination_node]\n\n        # Novel scoring function: balances proximity and destination influence with tunable weights\n        score = current_distance + 0.3 * destination_distance\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n        elif score == best_score:\n            # Tiebreaker: choose node with smaller current distance\n            if current_distance < distance_matrix[current_node][next_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines greedy proximity selection with dynamic weight adjustment: it prioritizes proximity to the current node (weighted 0.8 or 0.6) and progress toward the destination (weighted 0.2 or 0.4), while switching to stronger proximity focus (lower weight for destination) when only a few nodes remain. It balances exploration (weighted distance to current) and exploitation (weighted distance to destination) dynamically.",
          "thought": "The new algorithm combines the greedy proximity selection of No.2 with a dynamic weight adjustment inspired by No.1, balancing distance to the current node and progress toward the destination, while prioritizing proximity when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Dynamic weight adjustment: prioritize distance to current node when few nodes remain\n        weight_current = 0.8 if remaining_nodes > 2 else 0.6\n        weight_dest = 1.0 - weight_current\n\n        # Combined score: weighted sum of distances\n        score = (weight_current * distance_to_current) + (weight_dest * distance_to_dest)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n        elif score == best_score:\n            # Tie-breaker: prefer node with lower distance to destination\n            if distance_to_dest < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.37374,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (with weight `alpha=0.7`) and closeness to the destination (with weight `1-alpha`), while penalizing nodes too close to the destination to encourage exploration. It uses a weighted score to prioritize nodes that are both nearby and on the path to the destination, avoiding revisits by adjusting scores based on distance thresholds.",
          "thought": "The new algorithm modifies the provided one by incorporating a weighted combination of proximity to the current node and the destination, using a parameterized factor to balance these priorities, and adds a penalty for nodes already visited in nearby paths to avoid revisiting areas.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_score = float('inf')\n    next_node = None\n    alpha = 0.7  # Weight for proximity to current node (higher = more greedy)\n\n    for node in unvisited_nodes:\n        # Weighted score: alpha * distance to current node + (1-alpha) * distance to destination\n        score = alpha * distance_matrix[current_node][node] + (1 - alpha) * distance_matrix[node][destination_node]\n\n        # Penalize nodes that are too close to the destination to encourage exploration\n        if distance_matrix[node][destination_node] < 0.5 * distance_matrix[current_node][destination_node]:\n            score *= 1.5\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.40606,
          "other_inf": null
     }
]