[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the highest ratio of distance from the current node to the destination over the distance from the current node to the candidate node, balancing proximity and progress toward the destination. If ratios are equal, it chooses the node closer to the destination. The code efficiently handles edge cases (like zero distance) and ensures progress toward the goal while minimizing detours.",
          "thought": "The new algorithm prioritizes selecting the next node by considering not only the closest unvisited node to the current node but also the node that maximizes the ratio of distance to the destination over the distance from the current node, balancing proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    best_ratio = -float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        if distance_to_current == 0:\n            ratio = float('inf')  # Avoid division by zero (current node is the same)\n        else:\n            ratio = distance_to_dest / distance_to_current\n\n        if ratio > best_ratio:\n            best_ratio = ratio\n            next_node = node\n        elif ratio == best_ratio:\n            # If ratios are equal, choose the node closer to the destination\n            if distance_to_dest < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node from the distance matrix, and among nodes with equal minimal distance, it chooses the one closer to the destination. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, iterates through unvisited nodes to find the closest one, and handles ties by comparing distances to the destination. The code efficiently balances proximity to the current node and the destination, ensuring a heuristic path selection.",
          "thought": "The algorithm selects the next node by choosing the unvisited node closest to the current node from the distance matrix, prioritizing nodes that are closer to the destination if multiple nodes have the same minimal distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n        elif distance == min_distance:\n            # If distances are equal, choose the node closer to the destination\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. Early in the tour, it prioritizes nodes close to the current node, while later stages favor nodes closer to the destination. The selection criterion combines these distances with weights that decrease and increase, respectively, as more nodes are visited, ensuring a flexible trade-off between local and global optimization.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of distance to the current node and distance to the destination, where the weight is dynamically adjusted based on the proportion of unvisited nodes remaining. This balances proximity to the current node and the destination more flexibly, favoring nodes that are closer to the current node early on and closer to the destination as more nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_unvisited = len(unvisited_nodes)\n    weight_current = total_unvisited / (total_unvisited + 1)  # Decreases as more nodes are visited\n    weight_destination = 1 - weight_current\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = (weight_current * distance_to_current) + (weight_destination * distance_to_destination)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n        elif combined_score == min_score:\n            if distance_to_destination < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance to the current node (prioritized with weight `alpha`) and the distance to the destination node (prioritized with weight `1-alpha`). It penalizes nodes that are closer to the destination than the current node to avoid cycles, using a tunable `penalty` factor. The function returns the node with the lowest combined score, ensuring a trade-off between proximity to the current path and progress toward the destination.",
          "thought": "This new algorithm modifies the original by incorporating a weighted combination of distances to the current node and the destination node, using a tunable parameter to balance exploration and exploitation, and introduces a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.7, penalty=1.5):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Weighted score combining distance to current and destination\n        score = alpha * distance_to_current + (1 - alpha) * distance_to_destination\n\n        # Apply penalty if node was recently visited (simulated by higher penalty for nodes closer to destination)\n        if node in unvisited_nodes and distance_to_destination < distance_matrix[current_node][destination_node]:\n            score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.42574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing the distance to the current node (weighted at 70%) and the distance to the destination (weighted at 30%), ensuring a trade-off between proximity and progress toward the goal. The function iterates through unvisited nodes, calculates a combined score, and selects the node with the lowest score, effectively guiding the path toward the destination while avoiding unnecessary detours.",
          "thought": "The new algorithm prioritizes selecting the next node by considering both the distance to the current node and a weighted combination of the distance to the current node and the distance to the destination, allowing for a more balanced path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight = 0.7  # Weight for distance to current node (higher weight = more emphasis on proximity)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = weight * distance_to_current + (1 - weight) * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity to the current node and distance to the destination, with a penalty factor (0.5) prioritizing closer destination nodes. It iteratively evaluates unvisited nodes using a weighted sum of their distance to the current node and a penalized distance to the destination, ensuring a trade-off between immediate and long-term path optimality. The structure efficiently handles node selection with a clear scoring mechanism, where the penalty factor adjusts the bias toward destination proximity.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the selection criterion based on the proximity to the current node and the destination, incorporating a penalty factor for nodes far from the destination to balance exploration and exploitation, while the original algorithm only uses a simple tie-breaker.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    penalty_factor = 0.5  # Adjusts the influence of destination distance\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current + penalty_factor * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the product of distances to the current node and the destination, ensuring a balance between proximity and alignment with the destination. It breaks ties by preferring nodes closer to the current node, with the destination alignment as the primary and distance to current as the secondary criterion. The function uses the `score` (product of distances) to guide selection, ensuring efficiency and a heuristic path toward the destination.",
          "thought": "The new algorithm prioritizes the unvisited node closest to the current node, but among nodes with equal minimal distance, it chooses the one with the highest closeness to the destination by considering the product of distances to the current node and the destination, ensuring a balance between proximity and destination alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if distance_to_current < distance_matrix[next_node][current_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances proximity to the current node and distance to the destination, prioritizing the former with a weight `alpha` (default 0.6) while penalizing nodes closer to the destination than the current node by multiplying their score by `penalty` (default 1.3). It iteratively selects the next node with the lowest weighted score to avoid cycles and ensure a near-optimal path.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with the distance-to-destination consideration of No.1, using a weighted score to balance both factors, while penalizing nodes closer to the destination than the current node to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.6, penalty=1.3):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        score = alpha * distance_to_current + (1 - alpha) * distance_to_destination\n\n        if distance_to_destination < distance_matrix[current_node][destination_node]:\n            score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.58293,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines nearest-neighbor (prioritizing the closest unvisited node) with destination proximity (prioritizing nodes closer to the destination) and neighbor connectivity (considering average distances to remaining unvisited nodes). The scoring function weights current distance (1.0), destination distance (0.5), and neighbor connectivity (0.2), balancing exploration and efficiency. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm combines the No.2 algorithm's nearest-neighbor approach with the No.1 algorithm's consideration of destination proximity and neighbor connectivity, prioritizing the closest unvisited node but also balancing destination proximity and neighbor exploration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n\n        # Calculate a combined score considering current distance, destination distance, and neighbor connectivity\n        neighbors = [n for n in unvisited_nodes if n != node]\n        if neighbors:\n            avg_neighbor_dist = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)\n            score = current_dist + 0.5 * dest_dist + 0.2 * avg_neighbor_dist\n        else:\n            score = current_dist + 0.5 * dest_dist\n\n        if score < min_distance:\n            min_distance = score\n            next_node = node\n\n    return next_node",
          "objective": 7.64313,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing proximity to the current node (weighted 60%) and the destination (weighted 40%), while slightly favoring nodes with better connectivity to unvisited neighbors (weighted 10%). It prioritizes local and global distance considerations while ensuring some exploration of neighboring nodes.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a weighted combination of distances to the current node and the destination node, using a tunable parameter to balance their influence, and also considers the average distance of neighboring nodes to refine the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    alpha = 0.6  # Weight for current node distance (higher alpha prioritizes proximity)\n    beta = 0.4   # Weight for destination distance (higher beta prioritizes destination proximity)\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        # Calculate weighted score combining current and destination distances\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        score = alpha * current_dist + beta * dest_dist\n\n        # Adjust score by considering average distance to neighboring nodes\n        neighbors = [n for n in unvisited_nodes if n != node]\n        if neighbors:\n            avg_neighbor_dist = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)\n            score += 0.1 * avg_neighbor_dist  # Small weight for neighbor connectivity\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.77936,
          "other_inf": null
     }
]