[
     {
          "algorithm": "The algorithm selects the next node by prioritizing the unvisited node closest to the current node from the distance matrix, and among nodes with equal minimal distance, it chooses the one closer to the destination. The function takes the current node, destination, unvisited nodes, and distance matrix as inputs, iterates through unvisited nodes to find the closest one, and handles ties by comparing distances to the destination. The code efficiently balances proximity to the current node and the destination, ensuring a heuristic path selection.",
          "thought": "The algorithm selects the next node by choosing the unvisited node closest to the current node from the distance matrix, prioritizing nodes that are closer to the destination if multiple nodes have the same minimal distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n        elif distance == min_distance:\n            # If distances are equal, choose the node closer to the destination\n            if distance_matrix[node][destination_node] < distance_matrix[next_node][destination_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing the distance to the current node (prioritized with weight `alpha`) and the distance to the destination node (prioritized with weight `1-alpha`). It penalizes nodes that are closer to the destination than the current node to avoid cycles, using a tunable `penalty` factor. The function returns the node with the lowest combined score, ensuring a trade-off between proximity to the current path and progress toward the destination.",
          "thought": "This new algorithm modifies the original by incorporating a weighted combination of distances to the current node and the destination node, using a tunable parameter to balance exploration and exploitation, and introduces a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, alpha=0.7, penalty=1.5):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Weighted score combining distance to current and destination\n        score = alpha * distance_to_current + (1 - alpha) * distance_to_destination\n\n        # Apply penalty if node was recently visited (simulated by higher penalty for nodes closer to destination)\n        if node in unvisited_nodes and distance_to_destination < distance_matrix[current_node][destination_node]:\n            score *= penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.42574,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing the distance to the current node (weighted at 70%) and the distance to the destination (weighted at 30%), ensuring a trade-off between proximity and progress toward the goal. The function iterates through unvisited nodes, calculates a combined score, and selects the node with the lowest score, effectively guiding the path toward the destination while avoiding unnecessary detours.",
          "thought": "The new algorithm prioritizes selecting the next node by considering both the distance to the current node and a weighted combination of the distance to the current node and the distance to the destination, allowing for a more balanced path selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    weight = 0.7  # Weight for distance to current node (higher weight = more emphasis on proximity)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        combined_score = weight * distance_to_current + (1 - weight) * distance_to_destination\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the product of distances to the current node and the destination, ensuring a balance between proximity and alignment with the destination. It breaks ties by preferring nodes closer to the current node, with the destination alignment as the primary and distance to current as the secondary criterion. The function uses the `score` (product of distances) to guide selection, ensuring efficiency and a heuristic path toward the destination.",
          "thought": "The new algorithm prioritizes the unvisited node closest to the current node, but among nodes with equal minimal distance, it chooses the one with the highest closeness to the destination by considering the product of distances to the current node and the destination, ensuring a balance between proximity and destination alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n        score = distance_to_current * distance_to_destination\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n        elif score == min_score:\n            if distance_to_current < distance_matrix[next_node][current_node]:\n                next_node = node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing proximity to the current node (weighted 60%) and the destination (weighted 40%), while slightly favoring nodes with better connectivity to unvisited neighbors (weighted 10%). It prioritizes local and global distance considerations while ensuring some exploration of neighboring nodes.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a weighted combination of distances to the current node and the destination node, using a tunable parameter to balance their influence, and also considers the average distance of neighboring nodes to refine the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    alpha = 0.6  # Weight for current node distance (higher alpha prioritizes proximity)\n    beta = 0.4   # Weight for destination distance (higher beta prioritizes destination proximity)\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        # Calculate weighted score combining current and destination distances\n        current_dist = distance_matrix[current_node][node]\n        dest_dist = distance_matrix[node][destination_node]\n        score = alpha * current_dist + beta * dest_dist\n\n        # Adjust score by considering average distance to neighboring nodes\n        neighbors = [n for n in unvisited_nodes if n != node]\n        if neighbors:\n            avg_neighbor_dist = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)\n            score += 0.1 * avg_neighbor_dist  # Small weight for neighbor connectivity\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.77936,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances the selection of the next node by prioritizing proximity to the current node early in the path and balancing it with proximity to the destination as the path progresses. It uses a weighted combination of these distances, where weights are adjusted based on the remaining number of nodes, favoring closer nodes initially and gradually shifting focus to the destination. The score for each candidate node is computed as a weighted sum of its distance to the current node and its distance to the destination, with the weights dynamically adjusted to ensure a smooth transition between these priorities.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a weighted combination of distance to the current node and distance to the destination, where weights are dynamically adjusted based on the remaining path length, favoring closer nodes early and balancing both factors as the path progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes) + 1  # +1 for the destination\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Dynamically adjust weights: prioritize distance_to_current early, balance later\n        weight_current = max(0.5, 1.0 - (remaining_nodes / 20))  # Decreases as remaining_nodes decreases\n        weight_dest = 1.0 - weight_current\n\n        score = (weight_current * distance_to_current) + (weight_dest * distance_to_dest)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.84882,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by prioritizing nodes that minimize the sum of the distance from the current node to the candidate and from the candidate to the destination, ensuring the path remains as short as possible. It iterates through unvisited nodes, calculates the sum of these distances for each, and selects the node with the smallest sum. The function handles edge cases (e.g., empty unvisited nodes) and returns the destination if no nodes remain. The key design idea is to greedily optimize the remaining path length at each step.",
          "thought": "This algorithm prioritizes nodes that reduce the remaining path length the most by considering the sum of distances from the current node to the candidate node and from the candidate node to the destination, then selects the candidate with the smallest sum.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_total_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        total_distance = distance_matrix[current_node][node] + distance_matrix[node][destination_node]\n        if total_distance < min_total_distance:\n            min_total_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing candidates with the smallest average distance to all remaining unvisited nodes, balancing local (current node to candidate) and global (candidate to unvisited nodes) distances. It avoids revisiting the same node by excluding it from the average calculation and defaults to the destination when no unvisited nodes remain. The distance matrix and unvisited nodes set are central inputs, while the current node and destination node guide the selection.",
          "thought": "The new algorithm selects the next node by considering the average distance of each candidate node to all unvisited nodes, balancing local and global path optimization to minimize the total tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_avg_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / max(1, len(unvisited_nodes) - 1)\n        total_distance = distance_matrix[current_node][node] + avg_distance\n        if total_distance < min_avg_distance:\n            min_avg_distance = total_distance\n            next_node = node\n\n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing local (distance from current node) and global (distance to destination) optimization, with weights dynamically adjusted based on the number of remaining unvisited nodes. Local priority increases as unvisited nodes decrease, while global priority dominates early in the search. The score combines weighted local and global distances to guide node selection, favoring closer nodes when few remain but balancing with destination proximity when many nodes are left.",
          "thought": "The algorithm selects the next node by considering a weighted combination of the distance to the current node and the distance to the destination, where the weights are dynamically adjusted based on the remaining unvisited nodes to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Calculate weights based on the remaining unvisited nodes\n    weight_local = 1.0 / (len(unvisited_nodes) + 1)\n    weight_global = 1.0 - weight_local\n\n    for node in unvisited_nodes:\n        local_distance = distance_matrix[current_node][node]\n        global_distance = distance_matrix[node][destination_node]\n        score = weight_local * local_distance + weight_global * global_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 14.21124,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by balancing local (distance from current node) and global (distance to destination) factors, using a dynamic weight that prioritizes global optimization as the number of remaining nodes decreases. The weight adjusts from 0.5 to 1.0, giving higher priority to local distances early and gradually shifting to global distances as the problem nears completion. The score combines these weighted distances to choose the next node.",
          "thought": "The new algorithm modifies the provided approach by incorporating a weighted combination of distance to the current node and distance to the destination, using a dynamic weight factor that adjusts based on the remaining nodes' proximity to the destination, ensuring a balance between local and global path optimality.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    best_score = float('inf')\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Dynamic weight factor based on remaining nodes' proximity to destination\n        remaining_nodes = len(unvisited_nodes)\n        weight = 0.5 + 0.5 * (remaining_nodes / (remaining_nodes + 1))  # Adjusts between 0.5 and 1.0\n\n        # Weighted score combining local and global factors\n        score = (1 - weight) * distance_to_current + weight * distance_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 15.88437,
          "other_inf": null
     }
]