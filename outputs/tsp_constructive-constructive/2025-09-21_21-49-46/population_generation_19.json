[
     {
          "algorithm": "The algorithm combines angular progress and distance factors with weights (60% angular progress, 40% distance) to balance efficiency and proximity, prioritizing angular progress while still considering distance. It selects the next node by maximizing a weighted score, where angular progress (ratio of distance to destination over current distance) is emphasized, and distance is penalized. The function iterates through unvisited nodes, computes the score, and returns the node with the highest score.",
          "thought": "The new algorithm combines the angular progress and distance factors from No.1 and No.2, using a weighted sum (60% angular progress, 40% distance) to balance efficiency and proximity, similar to No.1 but with adjusted weights to prioritize angular progress more while still considering distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = 0.6 * angular_progress - 0.4 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing the trade-off between minimizing the distance from the current node and maximizing angular progress toward the destination, computed as the ratio of the distance from the node to the destination over the distance from the current node to the node. The score combines these factors (angular progress minus distance), favoring nodes that improve angular progress while keeping the distance manageable. The function iterates through unvisited nodes, computes the score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that create a balance between minimizing the distance to the current node and maximizing the angular progress toward the destination, using trigonometric functions to dynamically adjust selection based on the relative positions of nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = angular_progress - dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing angular progress (the ratio of distance to the destination over distance from the current node) and distance, dynamically weighted using a sigmoid function to prioritize angular progress when it is high and distance when it is low. The score is computed as a weighted combination of these factors, ensuring adaptability to varying tour configurations. The angular progress is given higher priority when it is significant, while distance dominates when angular progress is low.",
          "thought": "The new algorithm modifies the provided method by incorporating a dynamic weighting mechanism that adjusts the balance between angular progress and distance based on the current state of the tour, using a sigmoid function to scale the influence of angular progress relative to the distance, thereby enhancing adaptability to varying tour configurations.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Dynamic weighting using sigmoid function\n        weight = 1 / (1 + math.exp(-(angular_progress - 1)))\n        score = (angular_progress * weight) - (dist_current * (1 - weight))\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59837,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by scoring nodes based on angular progress (60% weight), distance (40% weight, penalized), and a novelty bonus (weighted by exploration rate). It aggressively penalizes revisits and prioritizes less frequently visited nodes, with the exploration weight adjusting based on path progress. The score combines these factors to guide the selection of the next node.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic exploration-exploitation trade-off, where the score combines angular progress, distance cost, and a novelty bonus that rewards nodes less frequently visited in the current path, while penalizing revisits more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = 1.0 - visited_ratio\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Novelty bonus: rewards less frequently visited nodes\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight\n\n        # Dynamic score combining angular progress, distance, and novelty\n        score = (angular_progress * 0.6) - (dist_current * 0.4) + novelty_bonus\n\n        # Stronger penalty for revisiting nodes\n        if node in [current_node, destination_node]:\n            score *= 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61506,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with higher angular progress (ratio of distance to destination over distance from current node) while accounting for distance cost, using a static weight (0.5) to balance these factors. It aggressively penalizes revisits (reducing score by 10.0) and selects the node with the highest combined score. The code structure iterates through unvisited nodes, calculates a weighted score, and updates the best choice dynamically.",
          "thought": "The new algorithm balances angular progress and distance cost with a static weight for angular progress, prioritizes nodes with higher angular progress while accounting for distance cost, and penalizes revisits more aggressively by reducing the score by a fixed penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Static weight for angular progress\n        weighted_angular = angular_progress * 0.5\n        score = weighted_angular - dist_current\n\n        # Aggressive penalty for revisiting nodes\n        if node in [current_node, destination_node]:\n            score -= 10.0\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61554,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, angular progress (ratio of destination distance to current node distance), and average distance to unvisited nodes. Higher priority is given to nodes that maximize angular progress (directing toward the destination) while minimizing immediate distance and the average distance to remaining unvisited nodes (to avoid detours). The score combines these factors: `angular_progress - dist_current - 0.2 * avg_dist`, where angular progress is weighted highest, followed by immediate distance, and average distance has a lower weight (0.2).",
          "thought": "The new algorithm combines the angular progress metric from No.2 with a weighted average distance component from No.1, balancing immediate distance, angular progress, and average distance to unvisited nodes to prioritize nodes that improve direction while minimizing overall path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        if len(unvisited_nodes) > 1:\n            avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_dist = 0\n\n        score = angular_progress - dist_current - 0.2 * avg_dist\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62319,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that make significant angular progress toward the destination (by favoring high `angular_progress`) while balancing distance from the current node (penalizing large `dist_current`). The `angular_progress` is defined as the ratio of distances from the candidate node to the destination and from the current node to the candidate, with a special case for zero distance. The score combines these factors, where angular progress is weighted more heavily than distance (via the `-0.5 * dist_current` term). The node with the highest score is selected as the next node to visit.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.1 with the angular progress and distance trade-off from No.2, prioritizing nodes that are closer to the current node and also make angular progress toward the destination, but with a stronger emphasis on angular progress to reduce the objective value further.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = angular_progress - 0.5 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: prioritizing nodes that maximize angular progress (distance from node to destination divided by distance from current node) and minimizing the direct distance from the current node. The score is computed as a weighted sum (70% angular progress, 30% distance), favoring nodes that improve path efficiency while keeping distances manageable. The highest-scoring node is chosen, ensuring the path progresses toward the destination while minimizing detours.",
          "thought": "The new algorithm prioritizes nodes by balancing the trade-off between minimizing the distance from the current node and maximizing the ratio of the distance from the node to the destination over the distance from the current node, using a weighted sum of these factors to favor nodes that improve angular progress while keeping the distance manageable.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = 0.7 * angular_progress - 0.3 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes angular progress (70% weight) to guide the path toward the destination, while penalizing longer distances (30% weight) to avoid detours. It balances exploration (via dynamic weighting) and exploitation (via angular progress) to avoid cycles and inefficient paths. The exploration weight adjusts based on remaining unvisited nodes, ensuring adaptability.",
          "thought": "The new algorithm modifies the scoring mechanism by combining angular progress with a normalized distance term, introducing a weighting factor to balance exploration and exploitation, and incorporating a penalty for revisiting nodes to avoid cycles.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        normalized_distance = dist_current / max(distance_matrix[current_node])\n        exploration_weight = 0.5 * (1 - (total_unvisited - len(unvisited_nodes)) / total_unvisited)\n        score = (0.7 * angular_progress - 0.3 * normalized_distance) * (1 + exploration_weight)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63365,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing angular progress (ratio of distance to destination over distance from current node) and distance cost, dynamically weighted by the visited-to-total node ratio. It prioritizes nodes that improve angular progress more significantly while penalizing revisits, ensuring exploration of less traversed paths. The score calculation favors nodes with higher angular progress (scaled by visited ratio) while accounting for distance cost, with a small penalty for revisiting nodes.",
          "thought": "The new algorithm modifies the score calculation by incorporating a dynamic weight for angular progress based on the remaining unvisited nodes, scaling the angular progress term by the ratio of visited to total nodes, and adding a penalty for revisiting nodes based on historical path data to encourage exploration of less traversed paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for the current node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Dynamic weight for angular progress\n        weighted_angular = angular_progress * visited_ratio\n        score = weighted_angular - dist_current\n\n        # Penalty for revisiting nodes (simulated here by a simple multiplier)\n        if node in [current_node, destination_node]:  # Placeholder for historical data\n            score *= 0.7\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.87061,
          "other_inf": null
     }
]