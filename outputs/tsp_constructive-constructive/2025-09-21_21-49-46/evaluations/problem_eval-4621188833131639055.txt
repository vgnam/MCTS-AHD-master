importance of angular progress and distance based on the current phase of the tour (early vs. late) and incorporates a penalty for revisiting recently visited nodes to avoid cycles. It selects the next node by maximizing a score that combines a phase-dependent weighted sum of angular progress and distance, with a recency penalty.}

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix, visited_nodes=None, max_visits=10):
    if not unvisited_nodes:
        return destination_node

    if visited_nodes is None:
        visited_nodes = []

    total_nodes = len(distance_matrix)
    phase = len(visited_nodes) / total_nodes if total_nodes > 0 else 0.0
    phase_weight = 0.7 if phase < 0.5 else 0.3

    next_node = None
    max_score = -float('inf')

    for node in unvisited_nodes:
        dist_current = distance_matrix[current_node][node]
        dist_dest = distance_matrix[node][destination_node]

        if dist_current == 0:
            angular_progress = 1.0
        else:
            angular_progress = dist_dest / dist_current

        recency_penalty = 0.0
        if visited_nodes:
            last_k_visits = visited_nodes[-max_visits:]
            if node in last_k_visits:
                recency_penalty = 0.2 * (last_k_visits.count(node) / max_visits)

        score = (phase_weight * angular_progress) + ((1 - phase_weight) * (1 / (dist_current + 1e-6))) - recency_penalty

        if score > max_score:
            max_score = score
            next_node = node

    return next_node
