def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate distances to all unvisited nodes
    distances = {node: distance_matrix[current_node][node] for node in unvisited_nodes}

    # Determine the nearest node
    nearest_node = min(distances, key=distances.get)
    nearest_distance = distances[nearest_node]

    # If destination is unvisited, introduce a probabilistic bias
    if destination_node in unvisited_nodes:
        destination_distance = distance_matrix[current_node][destination_node]

        # Calculate a weighted probability for destination
        if destination_distance < nearest_distance:
            probability = 0.7  # Higher probability to prioritize destination if closer
        else:
            probability = 0.3  # Lower probability if destination is not closer

        # Randomly decide between nearest node and destination
        if random.random() < probability:
            return destination_node

    return next_node
