def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    next_node = None
    max_score = -float('inf')
    total_nodes = len(unvisited_nodes) + 1
    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes

    # Calculate local density for each node
    node_density = {}
    for node in unvisited_nodes:
        neighbors = [n for n in unvisited_nodes if n != node]
        if not neighbors:
            node_density[node] = 0
            continue
        avg_dist = sum(distance_matrix[node][n] for n in neighbors) / len(neighbors)
        node_density[node] = 1 / (1 + avg_dist)  # Higher density for closer nodes

    for node in unvisited_nodes:
        dist_current = distance_matrix[current_node][node]
        dist_dest = distance_matrix[node][destination_node]

        if dist_current == 0:
            angular_progress = 1.0
        else:
            angular_progress = dist_dest / dist_current

        # Dynamic angular momentum based on local density
        angular_momentum = angular_progress * (1 + node_density[node])

        # Probabilistic bias for tighter loops
        loop_factor = 1 / (1 + dist_current + dist_dest)
        score = angular_momentum * visited_ratio * loop_factor - dist_current

        # Penalty for revisiting nodes
        if node in [current_node, destination_node]:
            score *= 0.7

        if score > max_score:
            max_score = score
            next_node = node

    return next_node
