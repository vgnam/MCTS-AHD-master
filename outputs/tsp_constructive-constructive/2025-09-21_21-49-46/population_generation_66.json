[
     {
          "algorithm": "The algorithm balances progress toward the destination with exploration of unvisited nodes, using a sigmoid-weighted score to prioritize nodes that reduce distance to the destination (angular progress) while rewarding less visited nodes (novelty bonus) and penalizing revisits (halving scores for current/destination nodes). The exploration weight adapts dynamically based on visit ratio, and the score combines angular progress, distance, and novelty, with weights adjusted by a sigmoid function to emphasize progress over distance as the algorithm advances.",
          "thought": "The new algorithm combines dynamic angular progress prioritization (like No.1) with exploration-driven novelty bonuses (like No.2), using a sigmoid-weighted score to balance progress and distance, while penalizing revisits and rewarding less visited nodes with an adaptive exploration weight.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = 1.0 - visited_ratio\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight\n\n        weight = 1 / (1 + math.exp(-(angular_progress - 1)))\n        score = (angular_progress * weight) - (dist_current * (1 - weight)) + novelty_bonus\n\n        if node in [current_node, destination_node]:\n            score *= 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56771,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines angular progress and distance factors with weights (60% angular progress, 40% distance) to balance efficiency and proximity, prioritizing angular progress while still considering distance. It selects the next node by maximizing a weighted score, where angular progress (ratio of distance to destination over current distance) is emphasized, and distance is penalized. The function iterates through unvisited nodes, computes the score, and returns the node with the highest score.",
          "thought": "The new algorithm combines the angular progress and distance factors from No.1 and No.2, using a weighted sum (60% angular progress, 40% distance) to balance efficiency and proximity, similar to No.1 but with adjusted weights to prioritize angular progress more while still considering distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = 0.6 * angular_progress - 0.4 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes by balancing the trade-off between minimizing the distance from the current node and maximizing angular progress toward the destination, computed as the ratio of the distance from the node to the destination over the distance from the current node to the node. The score combines these factors (angular progress minus distance), favoring nodes that improve angular progress while keeping the distance manageable. The function iterates through unvisited nodes, computes the score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that create a balance between minimizing the distance to the current node and maximizing the angular progress toward the destination, using trigonometric functions to dynamically adjust selection based on the relative positions of nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = angular_progress - dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing angular progress (the ratio of distance to the destination over distance from the current node) and distance, dynamically weighted using a sigmoid function to prioritize angular progress when it is high and distance when it is low. The score is computed as a weighted combination of these factors, ensuring adaptability to varying tour configurations. The angular progress is given higher priority when it is significant, while distance dominates when angular progress is low.",
          "thought": "The new algorithm modifies the provided method by incorporating a dynamic weighting mechanism that adjusts the balance between angular progress and distance based on the current state of the tour, using a sigmoid function to scale the influence of angular progress relative to the distance, thereby enhancing adaptability to varying tour configurations.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Dynamic weighting using sigmoid function\n        weight = 1 / (1 + math.exp(-(angular_progress - 1)))\n        score = (angular_progress * weight) - (dist_current * (1 - weight))\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.59837,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that maximize angular progress (distance to destination divided by distance from current node) while penalizing longer distances, dynamically adjusting exploration weights based on remaining unvisited nodes. It balances progress and distance with a 60:40 ratio, favoring nodes that guide toward the destination while avoiding long detours, and scales scores by exploration and balance factors.",
          "thought": "This new algorithm combines angular progress prioritization with distance minimization, dynamic exploration weighting, and adaptive balancing between progress and distance, ensuring efficient path selection by adjusting weights based on remaining nodes and penalizing long detours while favoring nodes that guide toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        normalized_distance = dist_current / max(distance_matrix[current_node])\n        exploration_weight = 0.6 * (1 - (total_unvisited - len(unvisited_nodes)) / total_unvisited)\n        balance_factor = 0.5 + 0.5 * (1 - exploration_weight)\n        score = (0.6 * angular_progress - 0.4 * normalized_distance) * (1 + exploration_weight) * balance_factor\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.60406,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances exploration and exploitation by scoring nodes based on angular progress (60% weight), distance (40% weight, penalized), and a novelty bonus (weighted by exploration rate). It aggressively penalizes revisits and prioritizes less frequently visited nodes, with the exploration weight adjusting based on path progress. The score combines these factors to guide the selection of the next node.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic exploration-exploitation trade-off, where the score combines angular progress, distance cost, and a novelty bonus that rewards nodes less frequently visited in the current path, while penalizing revisits more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = 1.0 - visited_ratio\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Novelty bonus: rewards less frequently visited nodes\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight\n\n        # Dynamic score combining angular progress, distance, and novelty\n        score = (angular_progress * 0.6) - (dist_current * 0.4) + novelty_bonus\n\n        # Stronger penalty for revisiting nodes\n        if node in [current_node, destination_node]:\n            score *= 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61506,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes with higher angular progress (ratio of distance to destination over distance from current node) while accounting for distance cost, using a static weight (0.5) to balance these factors. It aggressively penalizes revisits (reducing score by 10.0) and selects the node with the highest combined score. The code structure iterates through unvisited nodes, calculates a weighted score, and updates the best choice dynamically.",
          "thought": "The new algorithm balances angular progress and distance cost with a static weight for angular progress, prioritizes nodes with higher angular progress while accounting for distance cost, and penalizes revisits more aggressively by reducing the score by a fixed penalty.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Static weight for angular progress\n        weighted_angular = angular_progress * 0.5\n        score = weighted_angular - dist_current\n\n        # Aggressive penalty for revisiting nodes\n        if node in [current_node, destination_node]:\n            score -= 10.0\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61554,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing angular momentum (a ratio of distances to the destination), proximity bonuses (prioritizing closer nodes), and exploration factors (scaling with remaining nodes), while penalizing revisits to avoid cycles. The score combines these factors with weights (0.6 for angular progress, 0.4 for proximity), adjusted by exploration (0.5 \u00d7 remaining nodes) and cycle penalties (0.1). The highest-scoring node is chosen, ensuring a mix of efficiency (exploitation) and flexibility (exploration).",
          "thought": "The new algorithm introduces a dynamic angular momentum factor that scales with the number of remaining nodes, combined with a proximity bonus to encourage closer nodes, and a penalty for revisiting nodes to prevent cycles, while maintaining a balance between exploration and exploitation through adaptive weights.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_momentum = 1.0\n        else:\n            angular_momentum = dist_dest / dist_current\n\n        normalized_distance = dist_current / max(distance_matrix[current_node])\n        proximity_bonus = 1 / (1 + normalized_distance)\n        angular_progress = angular_momentum * proximity_bonus\n\n        exploration_factor = 0.5 * (total_unvisited / (total_unvisited + 1))\n        cycle_penalty = 0.1 if node in unvisited_nodes else 0.0\n\n        score = (0.6 * angular_progress + 0.4 * proximity_bonus) * (1 + exploration_factor) - cycle_penalty\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61644,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes minimizing distance (50% weight) while dynamically adjusting exploration based on path progress, rewarding nodes with higher angular progress (30% weight) and penalizing revisits (20% novelty weight). It balances distance, direction, and novelty, with scores dynamically recalculated at each step. The `exploration_weight` increases as progress continues, encouraging more novel paths.",
          "thought": "The new algorithm prioritizes distance minimization with a dynamic exploration factor that increases with path progress, while penalizing revisits and rewarding nodes with higher angular progress, using a 50% weight for distance and 30% for angular progress in the scoring equation, with the remaining 20% allocated to novelty based on exploration rate.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = visited_ratio\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight\n\n        score = (angular_progress * 0.3) - (dist_current * 0.5) + novelty_bonus\n\n        if node in [current_node, destination_node]:\n            score *= 0.3\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61847,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing distance reduction (60% weight) and angular progress (40% weight), with an adaptive exploration weight that increases as fewer nodes remain unvisited. It prioritizes shorter distances from the current node while favoring nodes that reduce the remaining path to the destination, dynamically adjusting exploration to avoid detours as the solution nears completion.",
          "thought": "The new algorithm prioritizes distance reduction (60% weight) to minimize path length, while balancing angular progress (40% weight) for directional guidance. It dynamically adjusts exploration weight based on remaining nodes, ensuring efficient pathfinding without excessive detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_unvisited = len(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        normalized_distance = dist_current / max(distance_matrix[current_node])\n        exploration_weight = 0.3 * (1 - (total_unvisited - len(unvisited_nodes)) / total_unvisited)\n        score = (0.6 * (1 - normalized_distance) + 0.4 * angular_progress) * (1 + exploration_weight)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.61902,
          "other_inf": null
     }
]