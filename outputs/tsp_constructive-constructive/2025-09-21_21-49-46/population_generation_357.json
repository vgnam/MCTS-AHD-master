[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, destination alignment, and progress toward the destination, with the weight of progress increasing as fewer nodes remain unvisited. It prioritizes nodes that minimize a weighted score combining current distance, destination distance, and angular progress (destination distance divided by current distance), where higher progress weights reduce the impact of destination distance. The score is scaled by a dynamic progress weight that grows as nodes are visited, emphasizing efficiency as the tour progresses.",
          "thought": "The new algorithm combines the dynamic weighting from No.2 with the angular progress factor from No.1, using a weighted score that balances immediate distance, destination alignment, and progress toward the destination, with the weight increasing as nodes are visited.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    progress_weight = 1.0 + (remaining_nodes / (remaining_nodes + 1))\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = (dist_current + (1.0 - angular_progress) * dist_dest) * progress_weight\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.5278,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that balance immediate distance to the current node with angular progress (ratio of distance to destination) while dynamically adjusting progress weight (1.0\u20132.0) based on remaining nodes and applying a fixed penalty (0.25\u00d7avg. distance to unvisited nodes). It favors exploitation (minimizing immediate distance) but balances with exploration via angular progress and penalty, ensuring a trade-off between path efficiency and global progress.",
          "thought": "The new algorithm combines dynamic weighting and progress-based scoring from No.1 (angular progress and progress weight) with the penalty mechanism from No.2 (average distance penalty), adjusting the progress weight between 1.0 and 2.0 and using a penalty factor of 0.25 to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    progress_weight = 1.0 + (remaining_nodes / (remaining_nodes + 1))  # Adjusts between 1.0 and 2.0\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        avg_distance_to_remaining = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        penalty = 0.25 * avg_distance_to_remaining\n\n        score = (dist_current + (1.0 - angular_progress) * dist_dest) * progress_weight + penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56327,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances angular progress (prioritized early) and distance efficiency (prioritized later) by adjusting weights based on the visited ratio, penalizes revisits, and selects the next node with the highest combined score of weighted angular progress and distance. It favors nodes that make progress toward the destination early on while ensuring efficiency in later stages, with revisits further penalized.",
          "thought": "This new algorithm combines the dynamic weighting of angular progress and distance efficiency from the first and third algorithms, while incorporating the angular progress and distance trade-off from the second algorithm. It dynamically adjusts weights based on the visited ratio to prioritize progress early on, penalizes revisits, and scores nodes based on a combination of angular progress, distance efficiency, and historical revisit penalties.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        weighted_angular = angular_progress * (1 + visited_ratio)\n        score = weighted_angular - dist_current * (1 - visited_ratio)\n\n        if node in [current_node, destination_node]:\n            score *= 0.7\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56399,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances progress toward the destination with exploration of unvisited nodes, using a sigmoid-weighted score to prioritize nodes that reduce distance to the destination (angular progress) while rewarding less visited nodes (novelty bonus) and penalizing revisits (halving scores for current/destination nodes). The exploration weight adapts dynamically based on visit ratio, and the score combines angular progress, distance, and novelty, with weights adjusted by a sigmoid function to emphasize progress over distance as the algorithm advances.",
          "thought": "The new algorithm combines dynamic angular progress prioritization (like No.1) with exploration-driven novelty bonuses (like No.2), using a sigmoid-weighted score to balance progress and distance, while penalizing revisits and rewarding less visited nodes with an adaptive exploration weight.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = 1.0 - visited_ratio\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight\n\n        weight = 1 / (1 + math.exp(-(angular_progress - 1)))\n        score = (angular_progress * weight) - (dist_current * (1 - weight)) + novelty_bonus\n\n        if node in [current_node, destination_node]:\n            score *= 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.56771,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate distance reduction (weighted heavily by `-2 * dist_current`) while balancing angular progress (angular_progress) and average distance (0.5 * avg_dist). It selects the next node to visit by maximizing a score that combines these factors, with angular progress and average distance given moderate weights. The destination node is returned if no unvisited nodes remain.",
          "thought": "The new algorithm modifies the scoring function to prioritize immediate distance reduction while still considering angular progress and average distance, with a higher weight on average distance to prevent detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        if len(unvisited_nodes) > 1:\n            avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_dist = 0\n\n        score = angular_progress + 0.5 * avg_dist - 2 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.57387,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines immediate distance to the next node with a weighted destination distance, adjusting the weight dynamically based on remaining nodes to balance exploration and efficiency. It prioritizes nodes that minimize both the current step's distance and the future distance to the destination, with the destination weight increasing as fewer nodes remain. The angular progress factor ensures nodes closer to the destination are favored, while the dynamic weighting balances short-term and long-term objectives.",
          "thought": "The new algorithm combines the angular progress and distance factors from No.1 with the dynamic weighting approach from No.2, selecting the next node by minimizing a score that balances immediate distance and a weighted destination distance, where the weight adjusts based on remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    dest_weight = 1.0 + (1.0 / (remaining_nodes + 1))\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        combined_score = dist_current + dest_weight * (1.0 - angular_progress)\n\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 6.584,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing angular progress (favoring nodes that reduce the distance to the destination), novelty bonuses (encouraging exploration with a dynamic weight based on visited ratio), and penalizing long distances (with a reduced coefficient of 0.05). The destination node receives a 2x score boost, while the exploration weight adjusts dynamically using the square root of the unvisited ratio. The scoring mechanism combines these factors to guide the selection toward novel, efficient, and destination-oriented nodes.",
          "thought": "The new algorithm prioritizes angular progress with a stronger emphasis on novelty bonuses, dynamically adjusting exploration weight based on the square root of the visited ratio, and applies a 2x boost to the destination node while reducing the distance penalty coefficient to 0.05.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    exploration_weight = math.sqrt(1.0 - visited_ratio)\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        novelty_bonus = (1.0 / (1.0 + dist_current)) * exploration_weight * 2.0\n\n        score = angular_progress + novelty_bonus - dist_current * 0.05\n\n        if node == destination_node:\n            score *= 2.0\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58598,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by prioritizing paths with high angular progress (ratio of distance to destination over distance from current node), adjusted dynamically by a non-linear weight based on visited ratio (favoring exploration early, optimization later) and penalizing frequently selected nodes to avoid revisits. It balances distance, angular progress, and selection history while avoiding immediate loops by halving scores for current/destination nodes. The selection frequency penalty and weighted angular progress are key design elements.",
          "thought": "The new algorithm extends the original by incorporating a dynamic penalty for revisiting nodes based on their frequency of selection in previous steps, while adjusting the angular progress weight using a non-linear function of the visited ratio to enhance early-stage exploration and late-stage optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    # Track selection frequency for dynamic penalty\n    selection_frequency = {node: 0 for node in unvisited_nodes}\n    for node in unvisited_nodes:\n        if node in selection_frequency:\n            selection_frequency[node] += 1\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Non-linear weight adjustment\n        weight = (1 + visited_ratio) ** 2\n        weighted_angular = angular_progress * weight\n\n        # Dynamic penalty based on selection frequency\n        penalty = 1 - (0.1 * selection_frequency.get(node, 0))\n        score = (weighted_angular * penalty) - dist_current\n\n        if node in [current_node, destination_node]:\n            score *= 0.5\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58661,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines angular progress and distance factors with weights (60% angular progress, 40% distance) to balance efficiency and proximity, prioritizing angular progress while still considering distance. It selects the next node by maximizing a weighted score, where angular progress (ratio of distance to destination over current distance) is emphasized, and distance is penalized. The function iterates through unvisited nodes, computes the score, and returns the node with the highest score.",
          "thought": "The new algorithm combines the angular progress and distance factors from No.1 and No.2, using a weighted sum (60% angular progress, 40% distance) to balance efficiency and proximity, similar to No.1 but with adjusted weights to prioritize angular progress more while still considering distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = 0.6 * angular_progress - 0.4 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58698,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts weights for angular progress, distance, and proximity penalties based on the number of unvisited nodes, prioritizing angular progress early (higher `weight_angular`) and distance later (higher `weight_distance`). It penalizes nodes too close to the current node (via `proximity_penalty`) to avoid loops, while the base weight (`base_weight`) ensures angular progress dominates early in the search. The score equation balances these factors to guide the selection of the next node.",
          "thought": "The new algorithm modifies the scoring mechanism by incorporating a dynamic weight adjustment based on both the progress towards the destination and the relative position of nodes in the unvisited set, using a novel score equation that combines angular progress, distance, and a penalty for nodes that are too close to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_unvisited = len(unvisited_nodes)\n    base_weight = 0.6 - (0.3 * (total_unvisited / (total_unvisited + 2)))\n    weight_angular = base_weight * (1 + (0.5 * (total_unvisited / (total_unvisited + 3))))\n    weight_distance = 1.0 - weight_angular\n    weight_proximity = 0.2 * (1 - (total_unvisited / (total_unvisited + 4)))\n\n    current_dest_dist = distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        proximity_penalty = 1.0 / (1.0 + dist_current / current_dest_dist) if current_dest_dist > 0 else 0.0\n\n        score = (weight_angular * angular_progress) - (weight_distance * dist_current) - (weight_proximity * proximity_penalty)\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58719,
          "other_inf": null
     }
]