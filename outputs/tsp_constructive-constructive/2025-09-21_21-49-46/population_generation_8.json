[
     {
          "algorithm": "The algorithm prioritizes nodes by balancing the trade-off between minimizing the distance from the current node and maximizing angular progress toward the destination, computed as the ratio of the distance from the node to the destination over the distance from the current node to the node. The score combines these factors (angular progress minus distance), favoring nodes that improve angular progress while keeping the distance manageable. The function iterates through unvisited nodes, computes the score for each, and selects the node with the highest score.",
          "thought": "The new algorithm prioritizes nodes that create a balance between minimizing the distance to the current node and maximizing the angular progress toward the destination, using trigonometric functions to dynamically adjust selection based on the relative positions of nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = angular_progress - dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.58744,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that make significant angular progress toward the destination (by favoring high `angular_progress`) while balancing distance from the current node (penalizing large `dist_current`). The `angular_progress` is defined as the ratio of distances from the candidate node to the destination and from the current node to the candidate, with a special case for zero distance. The score combines these factors, where angular progress is weighted more heavily than distance (via the `-0.5 * dist_current` term). The node with the highest score is selected as the next node to visit.",
          "thought": "The new algorithm combines the nearest-neighbor approach from No.1 with the angular progress and distance trade-off from No.2, prioritizing nodes that are closer to the current node and also make angular progress toward the destination, but with a stronger emphasis on angular progress to reduce the objective value further.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = angular_progress - 0.5 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.62683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing two factors: prioritizing nodes that maximize angular progress (distance from node to destination divided by distance from current node) and minimizing the direct distance from the current node. The score is computed as a weighted sum (70% angular progress, 30% distance), favoring nodes that improve path efficiency while keeping distances manageable. The highest-scoring node is chosen, ensuring the path progresses toward the destination while minimizing detours.",
          "thought": "The new algorithm prioritizes nodes by balancing the trade-off between minimizing the distance from the current node and maximizing the ratio of the distance from the node to the destination over the distance from the current node, using a weighted sum of these factors to favor nodes that improve angular progress while keeping the distance manageable.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        score = 0.7 * angular_progress - 0.3 * dist_current\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.63354,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit in TSP by balancing angular progress (ratio of distance to destination over distance from current node) and distance cost, dynamically weighted by the visited-to-total node ratio. It prioritizes nodes that improve angular progress more significantly while penalizing revisits, ensuring exploration of less traversed paths. The score calculation favors nodes with higher angular progress (scaled by visited ratio) while accounting for distance cost, with a small penalty for revisiting nodes.",
          "thought": "The new algorithm modifies the score calculation by incorporating a dynamic weight for angular progress based on the remaining unvisited nodes, scaling the angular progress term by the ratio of visited to total nodes, and adding a penalty for revisiting nodes based on historical path data to encourage exploration of less traversed paths.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    max_score = -float('inf')\n    total_nodes = len(unvisited_nodes) + 1  # +1 for the current node\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if dist_current == 0:\n            angular_progress = 1.0\n        else:\n            angular_progress = dist_dest / dist_current\n\n        # Dynamic weight for angular progress\n        weighted_angular = angular_progress * visited_ratio\n        score = weighted_angular - dist_current\n\n        # Penalty for revisiting nodes (simulated here by a simple multiplier)\n        if node in [current_node, destination_node]:  # Placeholder for historical data\n            score *= 0.7\n\n        if score > max_score:\n            max_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.87061,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by first finding the unvisited node closest to the current node; if the destination node is unvisited and closer than the nearest node, it prioritizes the destination. The function handles edge cases (empty unvisited nodes) and ensures the destination is always selected if it remains unvisited. The distance matrix guides node selection, with destination prioritization as the overriding rule.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing the destination node if it is unvisited and closer than any other node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    # Prioritize destination_node if it's unvisited and closer than the nearest node\n    if destination_node in unvisited_nodes:\n        destination_distance = distance_matrix[current_node][destination_node]\n        if destination_distance < min_distance:\n            next_node = destination_node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node and progress toward the destination, prioritizing the shortest distance to the current node while slightly weighting the distance to the destination (0.5 multiplier). It iterates through unvisited nodes, computes a combined score for each, and selects the node with the lowest score, ensuring the path stays efficient while making progress toward the goal.",
          "thought": "The algorithm selects the next node by considering both the minimum distance to the current node and the minimum distance to the destination node, combining these factors with a weighted sum to balance proximity and progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance_to_current = float('inf')\n    min_distance_to_dest = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        combined_score = distance_to_current + 0.5 * distance_to_dest\n\n        if combined_score < min_distance_to_current + 0.5 * min_distance_to_dest:\n            min_distance_to_current = distance_to_current\n            min_distance_to_dest = distance_to_dest\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance to the current node and destination, while also considering the node's average distance to remaining unvisited nodes (with lower weight). The score is computed as `dist_current + dist_dest + 0.3 * avg_dist`, prioritizing nodes that minimize this weighted sum. The destination node is returned if no unvisited nodes remain.",
          "thought": "The algorithm selects the next node by prioritizing nodes that minimize the sum of the distance to the current node and the distance to the destination, while also accounting for the potential future path length by considering the average distance of the node to all other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    for node in unvisited_nodes:\n        dist_current = distance_matrix[current_node][node]\n        dist_dest = distance_matrix[node][destination_node]\n\n        if len(unvisited_nodes) > 1:\n            avg_dist = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node) / (len(unvisited_nodes) - 1)\n        else:\n            avg_dist = 0\n\n        score = dist_current + dist_dest + 0.3 * avg_dist\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.41458,
          "other_inf": null
     }
]