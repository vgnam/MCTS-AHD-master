def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    visit_counts = {}
    for node in unvisited_nodes:
        visit_counts[node] = 1  # Initialize with default weight

    # Simulate historical visits (placeholder for actual tracking)
    for node in unvisited_nodes:
        if node in visit_counts:
            visit_counts[node] += 0.1  # Small penalty to less visited nodes

    def score(node):
        distance = distance_matrix[current_node][node]
        penalty = visit_counts.get(node, 1)
        return distance / penalty  # Lower score is better

    next_node = min(unvisited_nodes, key=score)
    return next_node
