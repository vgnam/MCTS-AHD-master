def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic weights for each candidate node
    def compute_weight(node):
        local_distance = distance_matrix[current_node][node]
        global_heuristic = distance_matrix[node][destination_node] if node != destination_node else 0
        return local_distance + 0.3 * global_heuristic  # Weighted sum of local and global factors

    next_node = min(unvisited_nodes, key=compute_weight)
    return next_node
