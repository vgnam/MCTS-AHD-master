def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate dynamic weights for each candidate node
    weights = {}
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        # Penalize revisits with a dynamic factor (e.g., inverse of distance)
        penalty = 1.0 / (distance + 1e-6) if distance > 0 else 1.0
        weights[node] = distance * penalty

    # Select the node with the minimum weighted distance
    next_node = min(unvisited_nodes, key=lambda node: weights[node])
    return next_node
