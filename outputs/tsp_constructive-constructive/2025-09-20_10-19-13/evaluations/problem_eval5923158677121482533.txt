def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    num_nodes = len(distance_matrix)
    centrality_weights = {node: sum(distance_matrix[node]) / num_nodes for node in unvisited_nodes}

    def weighted_score(node):
        distance = distance_matrix[current_node][node]
        centrality = centrality_weights[node]
        weight = 0.7 if len(unvisited_nodes) > num_nodes / 2 else 0.3
        return (1 - weight) * distance + weight * centrality

    next_node = min(unvisited_nodes, key=weighted_score)
    return next_node
