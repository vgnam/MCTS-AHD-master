[
     {
          "algorithm": "The algorithm balances immediate distance savings (`current_dist`) with future potential savings (`remaining_dist`), prioritizing the latter (weighted at 0.7) to guide long-term efficiency. It selects the next node by minimizing the heuristic score, which trades off short-term gains and long-term average distances. The `remaining_dist` calculation normalizes by the number of remaining nodes to avoid bias.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with a weighted balance between current distance and average remaining distance, similar to No.1, but uses a different weight to prioritize future savings more strongly.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return current_dist - 0.7 * remaining_dist\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.3683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing immediate proximity (current distance) and future optimization (average remaining distances), using a heuristic that subtracts the average remaining distance from the current distance to determine the best candidate. It gives higher priority to minimizing the immediate distance while also considering the potential for future path optimization, ensuring a trade-off between short-term and long-term gains. The `distance_matrix` and `unvisited_nodes` are central to the heuristic calculation, while `current_node` and `destination_node` guide the selection process.",
          "thought": "The new algorithm prioritizes selecting the unvisited node that maximizes the reduction in total path length by considering both the distance to the current node and the average distance to the remaining unvisited nodes, ensuring a balance between immediate proximity and future optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return current_dist - remaining_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.46367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with a heuristic that balances immediate (current) distances and future (remaining) distances. It prioritizes nodes that are both close to the current node (`current_dist`) and have favorable average distances to unvisited nodes (`remaining_dist`), with the latter given half the weight (`-0.5 * remaining_dist`). The heuristic ensures a trade-off between short-term and long-term efficiency, dynamically selecting the next node based on both proximity and potential future savings.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with the heuristic balancing immediate and future distances from No.1, prioritizing nodes that are both close to the current node and have favorable average remaining distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return current_dist - 0.5 * remaining_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.48571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (prioritized by `current_dist`) and long-term efficiency (prioritized by `remaining_dist`, but weighted negatively to favor closer nodes). The heuristic function `heuristic(node)` computes a weighted sum where `current_dist` is the direct distance from the current node, and `remaining_dist` is the average distance from the candidate node to all remaining unvisited nodes (scaled by -0.3). The node with the smallest heuristic value is chosen, ensuring a trade-off between short-term and long-term optimization.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with the weighted balance between current and future distances from No.1, prioritizing nodes that are both close to the current node and have favorable average distances to remaining unvisited nodes, with the latter given a weight of -0.3 to ensure a trade-off between short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return current_dist - 0.3 * remaining_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.62942,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with multiplicative weighting to balance proximity to the current node and alignment toward the destination. It prioritizes nodes that are both close to the current node and have a shorter distance to the destination, ensuring efficient path progression. The key design idea is the weighted selection using `distance_matrix[current_node][node] * (1 + 1 / distance_matrix[node][destination_node])`, where proximity to the current node is the primary factor, while the inverse of the distance to the destination acts as a secondary weighting.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with the multiplicative weighting of distances inspired by No.1, ensuring efficient path progression while balancing proximity to the current node and alignment toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 1 / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (prioritized) and future potential (weighted at 0.25), using the nearest-neighbor approach while considering the average distance to remaining unvisited nodes. The heuristic prioritizes minimizing `current_dist` (distance from the current node) while slightly favoring nodes with lower average distances to unvisited nodes. The function iteratively evaluates unvisited nodes, returning the one with the minimal combined score.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with a heuristic that balances immediate distance (prioritized) and future potential (given a quarter weight), similar to No.1, but simplifies the heuristic calculation by using the average distance to all remaining nodes (excluding the current node) to guide the selection.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes) / max(1, len(unvisited_nodes))\n        return current_dist - 0.25 * remaining_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.70779,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a greedy nearest-neighbor approach with a heuristic that balances immediate distance (prioritized) and future potential (given a quarter weight). It selects the next node by minimizing a weighted sum of the current distance and the average distance to remaining unvisited nodes, effectively trading off short-term and long-term considerations. The heuristic prioritizes nodes closer to the current node while slightly favoring those with better average connections to unvisited nodes.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with a heuristic that balances immediate distance and future potential, similar to No.1, by prioritizing nodes that are both close to the current node and have favorable average distances to unvisited nodes, with the latter given a quarter weight.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def heuristic(node):\n        current_dist = distance_matrix[current_node][node]\n        remaining_dist = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / max(1, len(unvisited_nodes) - 1)\n        return current_dist - 0.25 * remaining_dist\n\n    next_node = min(unvisited_nodes, key=heuristic)\n    return next_node",
          "objective": 6.70845,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the nearest unvisited node to the current node (greedy approach) while slightly favoring nodes farther from the destination (exploration bias). The key design is the weighted sum in the `min` function: `distance_matrix[current_node][node] - 0.3 * distance_matrix[node][destination_node]`, where the distance to the current node is given higher priority (positive weight) and the distance to the destination is given lower priority (negative weight). This balances local optimization and global progress toward the destination.",
          "thought": "The new algorithm combines the greedy nearest-neighbor approach of No.2 with the exploration bias of No.1 by prioritizing nodes that are close to the current node while slightly favoring those farther from the destination, balancing local optimization and global progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] - 0.3 * distance_matrix[node][destination_node])\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor approach with a multiplicative bias toward the destination, prioritizing nodes closer to the current node while also favoring those with shorter distances to the destination. The formula `distance_matrix[current_node][node] * (1 + 0.6 / distance_matrix[node][destination_node])` balances proximity to the current node (higher priority) and proximity to the destination (lower priority, scaled by 0.6). The `min` function selects the node with the smallest weighted distance, ensuring a trade-off between local and global path optimization.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with a multiplicative bias toward the destination, using the formula `distance_matrix[current_node][node] * (1 + 0.6 / distance_matrix[node][destination_node])` to balance proximity to the current node and the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.6 / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.77254,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines the nearest-neighbor heuristic with a weighted balance between proximity to the current node and alignment with the destination, prioritizing nodes closer to the current node while slightly favoring those with shorter distances to the destination. The key design idea is the weighted scoring function `distance_matrix[current_node][node] * (1 + 0.5 / distance_matrix[node][destination_node])`, where proximity to the current node is given higher priority than destination alignment (scaled by 0.5). The code efficiently selects the next node by minimizing this score across unvisited nodes.",
          "thought": "The new algorithm combines the nearest-neighbor approach of No.2 with the weighted balance of proximity and destination alignment from No.1, prioritizing nodes that are close to the current node while slightly favoring those with shorter distances to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node] * (1 + 0.5 / distance_matrix[node][destination_node]))\n    return next_node",
          "objective": 6.78776,
          "other_inf": null
     }
]