[
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes closest to the current node, with no explicit prioritization for nodes closer to the destination. The function uses a distance matrix to evaluate distances and returns the closest unvisited node, defaulting to the destination if no unvisited nodes remain. The design prioritizes local proximity over global path optimization.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by weighting their contributions based on the remaining unvisited nodes (higher local weight when few nodes remain). It uses an adaptive threshold (30% of combined costs) to decide between local/global choices, defaulting to the weighted option when neither meets the threshold. The code prioritizes local optimization early (high `remaining_ratio`) and shifts to global optimization later (low `remaining_ratio`), with the `min_max_distance` function ensuring long-term connectivity.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting mechanism between local and global optimization, where the weight is determined by the ratio of remaining unvisited nodes to total nodes, and it uses a hybrid selection criterion combining nearest neighbor and min-max distance with adaptive thresholds to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)  # Adaptive threshold\n\n    if local_cost <= threshold:\n        next_node = local_score\n    elif global_cost <= threshold:\n        next_node = global_score\n    else:\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.05005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when an odd number of nodes remain) and the node that balances immediate distance and future minimum distance (prioritizing global optimization when an even number of nodes remain). The alternation is controlled by the parity of remaining unvisited nodes, ensuring a balance between short-term and long-term path efficiency.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes the sum of immediate distance and the minimum future distance to remaining nodes (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of remaining unvisited nodes (odd/even).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            return immediate_cost + distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        lookahead_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + lookahead_cost\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=evaluate_node)\n\n    return next_node",
          "objective": 7.67393,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between prioritizing immediate proximity (nearest unvisited node) and global efficiency (balancing immediate distance and maximum distance to remaining nodes) based on the parity of remaining unvisited nodes. When the count is odd, it selects the nearest node for local optimization, while even counts use a combined cost function to favor nodes that minimize immediate distance while maximizing coverage of remaining nodes. The `evaluate_node` function computes this trade-off, and the parity check (`len(unvisited_nodes) % 2`) determines the selection strategy.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that balances immediate distance and maximum distance to remaining unvisited nodes (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of remaining unvisited nodes (odd/even), with a combined cost function for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_cost + distance_matrix[node][destination_node]\n        max_remaining_cost = max(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + max_remaining_cost\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=evaluate_node)\n\n    return next_node",
          "objective": 8.33437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the next node while also considering the minimum future distance from that node to remaining unvisited nodes. It balances short-term and long-term path costs by evaluating each candidate node's immediate cost and the best possible future cost from it, then selecting the node that minimizes the sum of these two values. The function uses the `distance_matrix` to compute costs and the `unvisited_nodes` set to determine the remaining path options.",
          "thought": "This algorithm uses a hybrid approach that combines nearest neighbor selection with a lookahead mechanism that evaluates the impact of each candidate node on the remaining path, selecting the node that minimizes the total path length while considering both immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            return immediate_cost + distance_matrix[node][destination_node]\n\n        remaining_nodes = unvisited_nodes - {node}\n        lookahead_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + lookahead_cost\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max) criteria, alternating between them based on the parity of remaining unvisited nodes. When few nodes remain, it prioritizes the nearest neighbor, while with more nodes, it combines a weighted global-min-max distance with local distances, using a probabilistic weight that increases with remaining nodes. Centrality is used to filter candidates, ensuring the algorithm adapts between exploration and exploitation.",
          "thought": "The new algorithm modifies the selection strategy by incorporating a dynamic weighting mechanism that combines local (nearest neighbor) and global (min-max) criteria, where the weight alternates based on the number of remaining unvisited nodes and a probabilistic factor derived from node centrality, introducing stochasticity to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    def node_centrality(node):\n        return sum(distance_matrix[node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        global_weight = 0.5 + (0.5 * (len(unvisited_nodes) / len(distance_matrix)))\n        local_candidates = [node for node in unvisited_nodes if distance_matrix[current_node][node] <= node_centrality(node)]\n        if local_candidates:\n            next_node = min(local_candidates, key=lambda node: global_weight * min_max_distance(node) + (1 - global_weight) * distance_matrix[current_node][node])\n        else:\n            next_node = min(unvisited_nodes, key=min_max_distance)\n\n    return next_node",
          "objective": 9.66291,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (when the number of remaining nodes is odd) and a node balancing local distance (weighted by `1 - global_weight`) and global min-max distance (weighted by `global_weight`) (when even). The global weight adapts dynamically based on remaining nodes, prioritizing global optimization as the problem size decreases. The parity-based alternation ensures diversity in node selection.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node and a node that balances local distance and global min-max distance, using a weighted combination inspired by No.1's adaptive strategy, while maintaining the parity-based alternation from No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        global_weight = 0.5 + (0.5 * (len(unvisited_nodes) / len(distance_matrix)))\n        next_node = min(unvisited_nodes, key=lambda node: global_weight * min_max_distance(node) + (1 - global_weight) * distance_matrix[current_node][node])\n\n    return next_node",
          "objective": 10.22837,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines probabilistic selection with regret-based weighting, where weights prioritize nodes with shorter distances (higher `1/distance\u00b2`) and higher regret (longer alternative paths). It alternates between probabilistic selection (when remaining nodes are odd) and deterministic selection (when even), with the latter favoring nodes that maximize the same regret-weighted distance metric. The code dynamically adjusts selection strategy based on node parity, balancing local optimization (distance) and global optimization (regret).",
          "thought": "The new algorithm combines the probabilistic selection of No.1 with the alternating strategy of No.2, using regret-based weights to balance local and global optimization, with selection probabilities dynamically adjusted based on the parity of remaining nodes.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def compute_weight(node):\n        distance = distance_matrix[current_node][node]\n        if distance == 0:\n            return float('inf')\n        regret = max(distance_matrix[node][n] for n in unvisited_nodes - {node}) if (unvisited_nodes - {node}) else 0\n        return (1 / distance**2) * (1 + regret)\n\n    weights = [compute_weight(node) for node in unvisited_nodes]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = random.choices(list(unvisited_nodes), weights=probabilities, k=1)[0]\n    else:\n        next_node = max(unvisited_nodes, key=lambda node: (1 / distance_matrix[current_node][node]**2) * (1 + max(distance_matrix[node][n] for n in unvisited_nodes - {node})))\n\n    return next_node",
          "objective": 10.40364,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that maximizes the minimum distance to remaining unvisited nodes (global optimization), controlled by the parity of remaining unvisited nodes, with `max_min_distance` being the critical function for global optimization. Local optimization is prioritized when the number of unvisited nodes is odd, while global optimization is prioritized when even, balancing immediate proximity and long-term path efficiency. The `distance_matrix` parameter is central, while `current_node`, `destination_node`, and `unvisited_nodes` are secondary in the selection process.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that maximizes the minimum distance to remaining unvisited nodes (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency, controlled by the parity of remaining unvisited nodes, with `max_min_distance` as the critical function for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def max_min_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return min(distance_matrix[node][n] for n in remaining_nodes)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = max(unvisited_nodes, key=max_min_distance)\n\n    return next_node",
          "objective": 12.96587,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines probabilistic selection with regret-based prioritization, favoring closer nodes (weighted by inverse squared distance) while penalizing long-term suboptimal choices (via regret). Closer nodes have higher selection probabilities, but regret ensures long-term efficiency by discouraging nodes with high future costs. The code dynamically computes weights for unvisited nodes, normalizes them into probabilities, and randomly selects the next node based on these weighted choices.",
          "thought": "The new algorithm combines a probabilistic selection with a regret-based approach, where nodes are chosen with a probability proportional to their inverse squared distance, introducing randomness while favoring closer nodes, and includes a regret term that penalizes long-term suboptimal choices to balance exploration and exploitation.",
          "code": "import random\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def compute_weight(node):\n        distance = distance_matrix[current_node][node]\n        if distance == 0:\n            return float('inf')\n        regret = max(distance_matrix[node][n] for n in unvisited_nodes - {node}) if (unvisited_nodes - {node}) else 0\n        return (1 / distance**2) * (1 + regret)\n\n    weights = [compute_weight(node) for node in unvisited_nodes]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n\n    next_node = random.choices(list(unvisited_nodes), weights=probabilities, k=1)[0]\n    return next_node",
          "objective": 13.13473,
          "other_inf": null
     }
]