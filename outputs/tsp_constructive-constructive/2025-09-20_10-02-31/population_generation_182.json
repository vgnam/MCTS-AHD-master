[
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes closest to the current node, with no explicit prioritization for nodes closer to the destination. The function uses a distance matrix to evaluate distances and returns the closest unvisited node, defaulting to the destination if no unvisited nodes remain. The design prioritizes local proximity over global path optimization.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between nearest-neighbor (local) and min-max distance (global) selection by alternating between them based on the parity of remaining nodes. It uses a weighted threshold (30% of the sum of local and global costs) to decide priorities, with local selection favored when the remaining node ratio is high, while global selection dominates in later stages. The threshold and weights adapt to the problem state, ensuring a mix of short-term and long-term optimization.",
          "thought": "The common ideas in the No.1 algorithm that may give good performances are dynamic balancing between local and global optimization, adaptive weighting based on remaining nodes, and an adaptive threshold for decision-making. The new algorithm will alternate between nearest neighbor and min-max distance selection, but use dynamic weights based on the remaining nodes and an adaptive threshold to decide between them, similar to No.1's approach, but in the alternating framework of No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)\n\n    if len(unvisited_nodes) % 2 == 1:\n        if local_cost <= threshold:\n            next_node = local_score\n        else:\n            next_node = local_score if local_weight > global_weight else global_score\n    else:\n        if global_cost <= threshold:\n            next_node = global_score\n        else:\n            next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.03678,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by weighting their contributions based on the remaining unvisited nodes (higher local weight when few nodes remain). It uses an adaptive threshold (30% of combined costs) to decide between local/global choices, defaulting to the weighted option when neither meets the threshold. The code prioritizes local optimization early (high `remaining_ratio`) and shifts to global optimization later (low `remaining_ratio`), with the `min_max_distance` function ensuring long-term connectivity.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting mechanism between local and global optimization, where the weight is determined by the ratio of remaining unvisited nodes to total nodes, and it uses a hybrid selection criterion combining nearest neighbor and min-max distance with adaptive thresholds to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)  # Adaptive threshold\n\n    if local_cost <= threshold:\n        next_node = local_score\n    elif global_cost <= threshold:\n        next_node = global_score\n    else:\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.05005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining nodes (global optimization), dynamically adjusting the balance between them based on the number of unvisited nodes. It prioritizes local optimization when few nodes remain (odd counts) and balances local and global factors (weighted by `balance_factor`) otherwise. The `balance_factor` increases as more nodes remain, emphasizing global optimization early in the process.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node and the node that minimizes the average distance to remaining unvisited nodes, using a weighted combination of local and global optimization based on the remaining nodes' count, introducing a dynamic balance factor that adjusts with the number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    remaining_count = len(unvisited_nodes)\n    balance_factor = 0.5 + (remaining_count / (remaining_count + 1)) * 0.5\n\n    if remaining_count % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: balance_factor * distance_matrix[current_node][node] + (1 - balance_factor) * avg_distance(node))\n\n    return next_node",
          "objective": 7.05646,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when the number of remaining nodes is odd) and the node that minimizes a weighted combination of immediate distance and average distance to remaining nodes (prioritizing global optimization when even), with weights dynamically adjusted to favor local decisions early in the process. The weighted combination balances proximity and long-term efficiency, with `local_weight` increasing as nodes are visited, while `global_weight` decreases.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of distances to balance immediate proximity and long-term efficiency, with weights dynamically adjusted based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance_to_remaining(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        total_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n        return total_distance / len(remaining_nodes)\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_avg = avg_distance_to_remaining(node)\n        return local_weight * local + global_weight * global_avg\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.05893,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between prioritizing the nearest unvisited node (local optimization) and a balanced approach considering both local and global distances (weighted combination), dynamically adjusting weights based on remaining nodes. When few nodes remain, it emphasizes minimizing the maximum distance to unvisited nodes (global optimization). The weight is calculated as `len(unvisited_nodes) / (len(unvisited_nodes) + 1)`, giving higher priority to local distances early and increasing global influence as nodes are visited.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes, with global optimization emphasizing the node that minimizes the maximum distance to remaining unvisited nodes when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return local_dist\n        global_dist = max(distance_matrix[node][n] for n in remaining_nodes)\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.06539,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (local optimization) and weighted selection based on both local and global criteria (global optimization), with weights dynamically adjusted by the remaining unvisited nodes to balance exploration and exploitation. The `avg_distance` function computes the average distance to unvisited nodes, while the weight parameter prioritizes local criteria when few nodes remain. The algorithm iteratively refines the path by switching between these strategies, ensuring a trade-off between immediate proximity and long-term optimality.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of local and global criteria based on the remaining node count to balance exploration and exploitation, with the critical function `avg_distance` for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: weight * distance_matrix[current_node][node] + (1 - weight) * avg_distance(node))\n\n    return next_node",
          "objective": 7.07262,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes (with weights inversely proportional to the number of unvisited nodes). Local distance is given higher priority when few nodes remain, while global distance is emphasized when more nodes are left. The `weighted_distance` function balances these distances, and the decision alternates between greedy (local) and weighted (global-local) selection based on parity of remaining nodes.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes, with weights inversely proportional to the number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        global_dist = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes) if unvisited_nodes - {node} else 0\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.07473,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between local and global optimization: odd steps prioritize the nearest unvisited node (local), while even steps use a weighted combination of immediate distance and maximum distance to remaining nodes (global), with weights dynamically adjusted to favor local decisions early. The `local_weight` decreases as unvisited nodes decrease, while `global_weight` increases, balancing exploration and exploitation. The `weighted_distance` function ensures global decisions consider both immediate and long-term implications.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes a weighted combination of immediate distance and maximum distance to remaining nodes (prioritizing global optimization), with weights dynamically adjusted to favor local decisions early in the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_max = max(distance_matrix[node][n] for n in unvisited_nodes - {node}) if unvisited_nodes - {node} else local\n        return local_weight * local + global_weight * global_max\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.08973,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (every 3 steps) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes. Local distance is prioritized more when few nodes remain, while global coverage is emphasized otherwise. The weighted sum balances proximity and coverage, with weights inversely proportional to the number of unvisited nodes.",
          "thought": "The new algorithm alternates between selecting nodes that balance local proximity and global coverage by combining nearest-neighbor selection with a weighted sum of distances to unvisited nodes, introducing dynamic weighting based on the number of remaining nodes to adaptively prioritize optimization strategies.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        global_dist = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes) if unvisited_nodes - {node} else 0\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 3 == 0:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.1152,
          "other_inf": null
     }
]