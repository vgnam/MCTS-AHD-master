[
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes closest to the current node, with no explicit prioritization for nodes closer to the destination. The function uses a distance matrix to evaluate distances and returns the closest unvisited node, defaulting to the destination if no unvisited nodes remain. The design prioritizes local proximity over global path optimization.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by weighting their contributions based on the remaining unvisited nodes (higher local weight when few nodes remain). It uses an adaptive threshold (30% of combined costs) to decide between local/global choices, defaulting to the weighted option when neither meets the threshold. The code prioritizes local optimization early (high `remaining_ratio`) and shifts to global optimization later (low `remaining_ratio`), with the `min_max_distance` function ensuring long-term connectivity.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting mechanism between local and global optimization, where the weight is determined by the ratio of remaining unvisited nodes to total nodes, and it uses a hybrid selection criterion combining nearest neighbor and min-max distance with adaptive thresholds to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)  # Adaptive threshold\n\n    if local_cost <= threshold:\n        next_node = local_score\n    elif global_cost <= threshold:\n        next_node = global_score\n    else:\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.05005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when the number of remaining nodes is odd) and the node that minimizes a weighted combination of immediate distance and average distance to remaining nodes (prioritizing global optimization when even), with weights dynamically adjusted to favor local decisions early in the process. The weighted combination balances proximity and long-term efficiency, with `local_weight` increasing as nodes are visited, while `global_weight` decreases.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of distances to balance immediate proximity and long-term efficiency, with weights dynamically adjusted based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance_to_remaining(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        total_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n        return total_distance / len(remaining_nodes)\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_avg = avg_distance_to_remaining(node)\n        return local_weight * local + global_weight * global_avg\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.05893,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (local optimization) and weighted selection based on both local and global criteria (global optimization), with weights dynamically adjusted by the remaining unvisited nodes to balance exploration and exploitation. The `avg_distance` function computes the average distance to unvisited nodes, while the weight parameter prioritizes local criteria when few nodes remain. The algorithm iteratively refines the path by switching between these strategies, ensuring a trade-off between immediate proximity and long-term optimality.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of local and global criteria based on the remaining node count to balance exploration and exploitation, with the critical function `avg_distance` for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: weight * distance_matrix[current_node][node] + (1 - weight) * avg_distance(node))\n\n    return next_node",
          "objective": 7.07262,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between local and global optimization: odd steps prioritize the nearest unvisited node (local), while even steps use a weighted combination of immediate distance and maximum distance to remaining nodes (global), with weights dynamically adjusted to favor local decisions early. The `local_weight` decreases as unvisited nodes decrease, while `global_weight` increases, balancing exploration and exploitation. The `weighted_distance` function ensures global decisions consider both immediate and long-term implications.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes a weighted combination of immediate distance and maximum distance to remaining nodes (prioritizing global optimization), with weights dynamically adjusted to favor local decisions early in the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_max = max(distance_matrix[node][n] for n in unvisited_nodes - {node}) if unvisited_nodes - {node} else local\n        return local_weight * local + global_weight * global_max\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.08973,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (every 3 steps) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes. Local distance is prioritized more when few nodes remain, while global coverage is emphasized otherwise. The weighted sum balances proximity and coverage, with weights inversely proportional to the number of unvisited nodes.",
          "thought": "The new algorithm alternates between selecting nodes that balance local proximity and global coverage by combining nearest-neighbor selection with a weighted sum of distances to unvisited nodes, introducing dynamic weighting based on the number of remaining nodes to adaptively prioritize optimization strategies.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        global_dist = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes) if unvisited_nodes - {node} else 0\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 3 == 0:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.1152,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by adjusting weights inversely proportional to the current path's deviation from the average distance. It prioritizes nodes with lower local distances when the path is efficient (weight skew toward local) and shifts to global considerations when the path deviates (weight skew toward global). The `weighted_score` function combines these factors, favoring nodes that minimize either criterion based on the current path's performance.",
          "thought": "The new algorithm modifies the provided one by incorporating a dynamic weight adjustment mechanism that balances local and global optimization based on the current path's efficiency, using a weighted combination of nearest neighbor and min-max distance criteria, with weights inversely proportional to the path's current deviation from the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    def weighted_score(node):\n        local_score = distance_matrix[current_node][node]\n        global_score = min_max_distance(node)\n        avg_distance = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weight = 0.5 + 0.5 * (1 - min(local_score, global_score) / avg_distance)\n        return weight * local_score + (1 - weight) * global_score\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 7.32774,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local distance) and the node that balances local distance (70%) and the maximum remaining distance to unvisited nodes (30%), ensuring a trade-off between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of unvisited nodes, with odd counts favoring local distance and even counts favoring the weighted combination.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local) and the node that minimizes a weighted combination of local distance and maximum remaining distance (global), balancing immediate proximity and long-term path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: (0.7 * distance_matrix[current_node][node] + 0.3 * min_max_distance(node)))\n\n    return next_node",
          "objective": 7.42075,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between prioritizing the nearest unvisited node (local) and the node that minimizes average distance to remaining nodes (global), switching every iteration. The local selection (odd iterations) chooses the closest node, while the global selection (even iterations) blends 70% local distance and 30% average remaining distance. This balances exploration (global) and exploitation (local) dynamically.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local) and the node that minimizes the average distance to remaining unvisited nodes (global), using a weighted combination of these criteria based on the remaining unvisited nodes' count to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_remaining_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    remaining_count = len(unvisited_nodes)\n    if remaining_count % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: (0.7 * distance_matrix[current_node][node] + 0.3 * avg_remaining_distance(node)))\n\n    return next_node",
          "objective": 7.51023,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local and global optimization by alternating between nearest-neighbor (local) and farthest-neighbor (global) strategies, with a weighted decision based on the remaining nodes' ratio. Local decisions prioritize immediate cost, while global decisions consider future constraints, with a dynamic threshold adjusting based on the sum of local and global costs. The alternation pattern ensures diversity, and the weights adapt to the remaining nodes, favoring global decisions as the problem progresses.",
          "thought": "The new algorithm combines the alternating strategy of No.2 with the adaptive threshold and weighted contributions of No.1, using a dynamic balance between local and global optimization based on the remaining nodes, while maintaining the alternation pattern to ensure diverse decisions.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = local_score if local_cost <= threshold else global_score\n    else:\n        local_weight = remaining_ratio\n        global_weight = 1 - remaining_ratio\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.63576,
          "other_inf": null
     }
]