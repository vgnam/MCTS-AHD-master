[
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes closest to the current node, with no explicit prioritization for nodes closer to the destination. The function uses a distance matrix to evaluate distances and returns the closest unvisited node, defaulting to the destination if no unvisited nodes remain. The design prioritizes local proximity over global path optimization.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by weighting their contributions based on the remaining unvisited nodes (higher local weight when few nodes remain). It uses an adaptive threshold (30% of combined costs) to decide between local/global choices, defaulting to the weighted option when neither meets the threshold. The code prioritizes local optimization early (high `remaining_ratio`) and shifts to global optimization later (low `remaining_ratio`), with the `min_max_distance` function ensuring long-term connectivity.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting mechanism between local and global optimization, where the weight is determined by the ratio of remaining unvisited nodes to total nodes, and it uses a hybrid selection criterion combining nearest neighbor and min-max distance with adaptive thresholds to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)  # Adaptive threshold\n\n    if local_cost <= threshold:\n        next_node = local_score\n    elif global_cost <= threshold:\n        next_node = global_score\n    else:\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.05005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when the number of remaining nodes is odd) and the node that minimizes a weighted combination of immediate distance and average distance to remaining nodes (prioritizing global optimization when even), with weights dynamically adjusted to favor local decisions early in the process. The weighted combination balances proximity and long-term efficiency, with `local_weight` increasing as nodes are visited, while `global_weight` decreases.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of distances to balance immediate proximity and long-term efficiency, with weights dynamically adjusted based on the number of remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance_to_remaining(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        total_distance = sum(distance_matrix[node][n] for n in remaining_nodes)\n        return total_distance / len(remaining_nodes)\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_avg = avg_distance_to_remaining(node)\n        return local_weight * local + global_weight * global_avg\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.05893,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between prioritizing the nearest unvisited node (local optimization) and a balanced approach considering both local and global distances (weighted combination), dynamically adjusting weights based on remaining nodes. When few nodes remain, it emphasizes minimizing the maximum distance to unvisited nodes (global optimization). The weight is calculated as `len(unvisited_nodes) / (len(unvisited_nodes) + 1)`, giving higher priority to local distances early and increasing global influence as nodes are visited.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes, with global optimization emphasizing the node that minimizes the maximum distance to remaining unvisited nodes when few nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return local_dist\n        global_dist = max(distance_matrix[node][n] for n in remaining_nodes)\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.06539,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (local optimization) and weighted selection based on both local and global criteria (global optimization), with weights dynamically adjusted by the remaining unvisited nodes to balance exploration and exploitation. The `avg_distance` function computes the average distance to unvisited nodes, while the weight parameter prioritizes local criteria when few nodes remain. The algorithm iteratively refines the path by switching between these strategies, ensuring a trade-off between immediate proximity and long-term optimality.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of local and global criteria based on the remaining node count to balance exploration and exploitation, with the critical function `avg_distance` for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: weight * distance_matrix[current_node][node] + (1 - weight) * avg_distance(node))\n\n    return next_node",
          "objective": 7.07262,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes (with weights inversely proportional to the number of unvisited nodes). Local distance is given higher priority when few nodes remain, while global distance is emphasized when more nodes are left. The `weighted_distance` function balances these distances, and the decision alternates between greedy (local) and weighted (global-local) selection based on parity of remaining nodes.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes, with weights inversely proportional to the number of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        global_dist = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes) if unvisited_nodes - {node} else 0\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.07473,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between local and global optimization: odd steps prioritize the nearest unvisited node (local), while even steps use a weighted combination of immediate distance and maximum distance to remaining nodes (global), with weights dynamically adjusted to favor local decisions early. The `local_weight` decreases as unvisited nodes decrease, while `global_weight` increases, balancing exploration and exploitation. The `weighted_distance` function ensures global decisions consider both immediate and long-term implications.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes a weighted combination of immediate distance and maximum distance to remaining nodes (prioritizing global optimization), with weights dynamically adjusted to favor local decisions early in the process.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_weight = 0.3 + 0.7 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        global_weight = 1 - local_weight\n        local = distance_matrix[current_node][node]\n        global_max = max(distance_matrix[node][n] for n in unvisited_nodes - {node}) if unvisited_nodes - {node} else local\n        return local_weight * local + global_weight * global_max\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.08973,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (every 3 steps) and a weighted combination of local and global distances, dynamically adjusting weights based on remaining nodes. Local distance is prioritized more when few nodes remain, while global coverage is emphasized otherwise. The weighted sum balances proximity and coverage, with weights inversely proportional to the number of unvisited nodes.",
          "thought": "The new algorithm alternates between selecting nodes that balance local proximity and global coverage by combining nearest-neighbor selection with a weighted sum of distances to unvisited nodes, introducing dynamic weighting based on the number of remaining nodes to adaptively prioritize optimization strategies.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def weighted_distance(node):\n        local_dist = distance_matrix[current_node][node]\n        global_dist = sum(distance_matrix[node][n] for n in unvisited_nodes - {node}) / len(unvisited_nodes) if unvisited_nodes - {node} else 0\n        weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n        return weight * local_dist + (1 - weight) * global_dist\n\n    if len(unvisited_nodes) % 3 == 0:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_distance)\n\n    return next_node",
          "objective": 7.1152,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines a local-first (nearest-neighbor) approach for odd-length unvisited nodes with a balanced local-global optimization (weighted score) for even-length unvisited nodes, where weights adjust dynamically based on deviation from average distance. Local distances dominate when close to the average, while global (max remaining distances) influences selection when deviations are large. The alternation strategy prioritizes efficiency over exploration parity.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing local and global optimization) with the alternation strategy from No.2 (odd/even node count), using weighted scores to select nodes based on the current path's efficiency, where weights are inversely proportional to the path's deviation from the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    def weighted_score(node):\n        local_score = distance_matrix[current_node][node]\n        global_score = min_max_distance(node)\n        avg_distance = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weight = 0.5 + 0.5 * (1 - min(local_score, global_score) / avg_distance)\n        return weight * local_score + (1 - weight) * global_score\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=weighted_score)\n\n    return next_node",
          "objective": 7.24223,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by adjusting weights inversely proportional to the current path's deviation from the average distance. It prioritizes nodes with lower local distances when the path is efficient (weight skew toward local) and shifts to global considerations when the path deviates (weight skew toward global). The `weighted_score` function combines these factors, favoring nodes that minimize either criterion based on the current path's performance.",
          "thought": "The new algorithm modifies the provided one by incorporating a dynamic weight adjustment mechanism that balances local and global optimization based on the current path's efficiency, using a weighted combination of nearest neighbor and min-max distance criteria, with weights inversely proportional to the path's current deviation from the average distance.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    def weighted_score(node):\n        local_score = distance_matrix[current_node][node]\n        global_score = min_max_distance(node)\n        avg_distance = sum(distance_matrix[current_node][n] for n in unvisited_nodes) / len(unvisited_nodes)\n        weight = 0.5 + 0.5 * (1 - min(local_score, global_score) / avg_distance)\n        return weight * local_score + (1 - weight) * global_score\n\n    next_node = min(unvisited_nodes, key=weighted_score)\n    return next_node",
          "objective": 7.32774,
          "other_inf": null
     }
]