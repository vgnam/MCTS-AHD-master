[
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes closest to the current node, with no explicit prioritization for nodes closer to the destination. The function uses a distance matrix to evaluate distances and returns the closest unvisited node, defaulting to the destination if no unvisited nodes remain. The design prioritizes local proximity over global path optimization.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that are closer to the destination to guide the path toward the end.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances local (nearest neighbor) and global (min-max distance) optimization by weighting their contributions based on the remaining unvisited nodes (higher local weight when few nodes remain). It uses an adaptive threshold (30% of combined costs) to decide between local/global choices, defaulting to the weighted option when neither meets the threshold. The code prioritizes local optimization early (high `remaining_ratio`) and shifts to global optimization later (low `remaining_ratio`), with the `min_max_distance` function ensuring long-term connectivity.",
          "thought": "The new algorithm modifies the provided approach by incorporating a dynamic weighting mechanism between local and global optimization, where the weight is determined by the ratio of remaining unvisited nodes to total nodes, and it uses a hybrid selection criterion combining nearest neighbor and min-max distance with adaptive thresholds to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1  # +1 for current_node\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_weight = remaining_ratio\n    global_weight = 1 - remaining_ratio\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)  # Adaptive threshold\n\n    if local_cost <= threshold:\n        next_node = local_score\n    elif global_cost <= threshold:\n        next_node = global_score\n    else:\n        next_node = local_score if local_weight > global_weight else global_score\n\n    return next_node",
          "objective": 7.05005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between nearest-neighbor selection (local optimization) and weighted selection based on both local and global criteria (global optimization), with weights dynamically adjusted by the remaining unvisited nodes to balance exploration and exploitation. The `avg_distance` function computes the average distance to unvisited nodes, while the weight parameter prioritizes local criteria when few nodes remain. The algorithm iteratively refines the path by switching between these strategies, ensuring a trade-off between immediate proximity and long-term optimality.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (local optimization) and the node that minimizes the average distance to remaining unvisited nodes (global optimization), using a weighted combination of local and global criteria based on the remaining node count to balance exploration and exploitation, with the critical function `avg_distance` for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    weight = len(unvisited_nodes) / (len(unvisited_nodes) + 1)\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: weight * distance_matrix[current_node][node] + (1 - weight) * avg_distance(node))\n\n    return next_node",
          "objective": 7.07262,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically alternates between local and global optimization by switching strategies based on the parity of remaining unvisited nodes (odd/even). When the count is odd, it prioritizes local optimization (choosing the nearest neighbor) if the local cost is below a threshold, otherwise global optimization (choosing the node with the smallest maximum distance to remaining nodes). For even counts, the priority reverses. The threshold is set at 30% of the combined local and global costs to balance both approaches.",
          "thought": "The new algorithm combines the adaptive weighting from No.1 (balancing local and global optimization based on remaining nodes) with the alternation strategy from No.2 (switching between local and global optimization based on parity of remaining nodes), creating a hybrid approach that dynamically adjusts between the two strategies.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    total_nodes = len(unvisited_nodes) + 1\n    remaining_ratio = len(unvisited_nodes) / total_nodes if total_nodes > 1 else 0\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.3 * (local_cost + global_cost)\n\n    if len(unvisited_nodes) % 2 == 1:\n        if local_cost <= threshold:\n            next_node = local_score\n        else:\n            next_node = global_score\n    else:\n        if global_cost <= threshold:\n            next_node = global_score\n        else:\n            next_node = local_score\n\n    return next_node",
          "objective": 7.65952,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when an odd number of nodes remain) and the node that balances immediate distance and future minimum distance (prioritizing global optimization when an even number of nodes remain). The alternation is controlled by the parity of remaining unvisited nodes, ensuring a balance between short-term and long-term path efficiency.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes the sum of immediate distance and the minimum future distance to remaining nodes (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of remaining unvisited nodes (odd/even).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            return immediate_cost + distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        lookahead_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + lookahead_cost\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=evaluate_node)\n\n    return next_node",
          "objective": 7.67393,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between local and global optimization based on the parity of unvisited nodes, choosing the next node by comparing local (nearest neighbor) and global (minimum maximum distance) costs against a dynamic threshold (25% of their sum). When the number of unvisited nodes is odd, it prioritizes local optimization if the local cost is below the threshold; otherwise, it defaults to global optimization. When even, the opposite logic applies. The threshold adapts to the combined costs, balancing exploration and exploitation.",
          "thought": "The new algorithm combines the alternating strategy of No.2 with the threshold-based decision of No.1, prioritizing local optimization when the local cost is below a dynamic threshold (set as 25% of the combined local and global costs) and global optimization otherwise, but still alternates between them based on the parity of remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def min_max_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return max(distance_matrix[node][n] for n in remaining_nodes)\n\n    local_score = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    global_score = min(unvisited_nodes, key=min_max_distance)\n\n    local_cost = distance_matrix[current_node][local_score]\n    global_cost = min_max_distance(global_score)\n\n    threshold = 0.25 * (local_cost + global_cost)\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = local_score if local_cost <= threshold else global_score\n    else:\n        next_node = global_score if global_cost <= threshold else local_score\n\n    return next_node",
          "objective": 7.98042,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between prioritizing immediate proximity (nearest unvisited node) and global efficiency (balancing immediate distance and maximum distance to remaining nodes) based on the parity of remaining unvisited nodes. When the count is odd, it selects the nearest node for local optimization, while even counts use a combined cost function to favor nodes that minimize immediate distance while maximizing coverage of remaining nodes. The `evaluate_node` function computes this trade-off, and the parity check (`len(unvisited_nodes) % 2`) determines the selection strategy.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that balances immediate distance and maximum distance to remaining unvisited nodes (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of remaining unvisited nodes (odd/even), with a combined cost function for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return immediate_cost + distance_matrix[node][destination_node]\n        max_remaining_cost = max(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + max_remaining_cost\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=evaluate_node)\n\n    return next_node",
          "objective": 8.33437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the next node while also considering the minimum future distance from that node to remaining unvisited nodes. It balances short-term and long-term path costs by evaluating each candidate node's immediate cost and the best possible future cost from it, then selecting the node that minimizes the sum of these two values. The function uses the `distance_matrix` to compute costs and the `unvisited_nodes` set to determine the remaining path options.",
          "thought": "This algorithm uses a hybrid approach that combines nearest neighbor selection with a lookahead mechanism that evaluates the impact of each candidate node on the remaining path, selecting the node that minimizes the total path length while considering both immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            return immediate_cost + distance_matrix[node][destination_node]\n\n        remaining_nodes = unvisited_nodes - {node}\n        lookahead_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + lookahead_cost\n\n    next_node = min(unvisited_nodes, key=evaluate_node)\n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization when the number of unvisited nodes is odd) and a node that balances immediate distance, future minimum distance, and maximum distance to remaining nodes (prioritizing global optimization when even). The evaluation function combines these factors, with immediate and lookahead costs weighted more heavily than the maximum cost. The alternation between strategies ensures a trade-off between short-term and long-term efficiency.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node (prioritizing local optimization) and the node that minimizes the maximum distance to remaining unvisited nodes while also considering the immediate distance and future minimum distance (prioritizing global optimization), balancing trade-offs between immediate proximity and long-term path efficiency. The alternation is controlled by the parity of remaining unvisited nodes (odd/even), with a combined evaluation function for global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def evaluate_node(node):\n        immediate_cost = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            return immediate_cost + distance_matrix[node][destination_node]\n        remaining_nodes = unvisited_nodes - {node}\n        lookahead_cost = min(distance_matrix[node][n] for n in remaining_nodes)\n        max_cost = max(distance_matrix[node][n] for n in remaining_nodes)\n        return immediate_cost + lookahead_cost + max_cost\n\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=evaluate_node)\n\n    return next_node",
          "objective": 9.09184,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm alternates between selecting the nearest unvisited node (local optimization) and the node minimizing average distance to remaining nodes (global optimization), using a dynamic weight factor that prioritizes local optimization when few nodes remain and balances both when more nodes are left. The weight depends on the number of unvisited nodes, and the selection strategy switches based on whether the count is odd or even. The distance matrix and unvisited nodes set are key inputs, while the current and destination nodes guide the path construction.",
          "thought": "The new algorithm alternates between selecting the nearest unvisited node and the node that minimizes the average distance to remaining unvisited nodes, using a weighted combination of both strategies based on the number of unvisited nodes, with a dynamic weight factor that adjusts over iterations to balance local and global optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    def avg_distance(node):\n        remaining_nodes = unvisited_nodes - {node}\n        if not remaining_nodes:\n            return distance_matrix[current_node][node]\n        return sum(distance_matrix[node][n] for n in remaining_nodes) / len(remaining_nodes)\n\n    weight = len(unvisited_nodes) / (len(distance_matrix) - 1)\n    if len(unvisited_nodes) % 2 == 1:\n        next_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node][node])\n    else:\n        next_node = min(unvisited_nodes, key=lambda node: weight * distance_matrix[current_node][node] + (1 - weight) * avg_distance(node))\n\n    return next_node",
          "objective": 9.56679,
          "other_inf": null
     }
]