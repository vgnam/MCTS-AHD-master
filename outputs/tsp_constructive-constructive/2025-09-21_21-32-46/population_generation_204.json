[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, prioritizing nodes with a higher combined score. The `score` is calculated as `-immediate_distance + 0.5 * future_distance`, emphasizing efficiency in the short term while slightly favoring progress toward the destination. The loop iterates through unvisited nodes to find the node with the highest score, ensuring a trade-off between local and global optimization.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a weighted combination of immediate distance and potential future distance to the destination, using a heuristic to balance exploration of nearby nodes with progress toward the destination. It iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score, ensuring a balance between immediate efficiency and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        score = -immediate_distance + 0.5 * future_distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting weights based on unvisited nodes. It prioritizes minimizing immediate travel cost when many nodes remain, while emphasizing future flexibility (average distances to remaining nodes) as the number of unvisited nodes decreases. The weight factor (1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5) ensures a smooth transition, with immediate cost dominating early on and future flexibility gaining importance later. The algorithm handles the final node by forcing a return to the destination when no unvisited nodes remain.",
          "thought": "The new algorithm modifies the original approach by incorporating a dynamic weighting factor that adjusts the balance between immediate distance and future connectivity based on the number of unvisited nodes, using a logarithmic scaling to prioritize future flexibility as the number of remaining nodes decreases, while still ensuring the path returns to the destination when no nodes are left.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (remaining_nodes - 1)\n        weight = 1.0 + (remaining_nodes / (remaining_nodes + 1)) * 0.5\n        total_score = (current_distance * weight) + (future_average * (1 - weight))\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 6.62523,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance (current_node to node) and future distance (node to destination_node), prioritizing nodes that minimize the sum of immediate distance and a fraction of future distance (current_distance / future_distance). If future_distance is zero, it avoids the node. The structure iterates through unvisited nodes, computes the score, and selects the node with the lowest score, ensuring both short-term and long-term efficiency.",
          "thought": "The new algorithm combines the proximity prioritization of No.2 with the future-distance balancing of No.1, selecting nodes that minimize the sum of immediate distance and a fraction of future distance, ensuring both short-term and long-term efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            score = current_distance + float('inf')\n        else:\n            score = current_distance + (current_distance / future_distance)\n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
          "objective": 6.67121,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the closest unvisited node (minimizing immediate distance) while slightly favoring nodes that are closer to the destination (0.3 weight on future distance). This balances local optimization with progress toward the goal, using a score-based selection where immediate distance is weighted more heavily. The function returns the destination node if no unvisited nodes remain.",
          "thought": "The new algorithm combines the immediate distance minimization of No.2 with the balanced score calculation of No.1, selecting the next node by prioritizing the closest unvisited node while slightly favoring progress toward the destination, calculated as `score = -immediate_distance + 0.3 * future_distance`.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        score = -immediate_distance + 0.3 * future_distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.71255,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance minimization (prioritized heavily) and progress toward the destination (given lower weight via a 0.25 multiplier). It iterates through unvisited nodes, computes a score favoring closer nodes while slightly incentivizing paths that advance toward the destination, and returns the node with the highest score. The structure ensures dynamic path selection based on both local and global considerations.",
          "thought": "The new algorithm combines the immediate distance minimization of No.2 with the balanced scoring approach of No.1, using a score that prioritizes closer nodes while slightly favoring progress toward the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        score = -immediate_distance + 0.25 * future_distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.77543,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the lowest ratio of immediate distance to future distance, balancing proximity and potential future connections. It iterates through unvisited nodes, calculates the ratio score (current distance / future distance), and chooses the node with the minimal score, ensuring efficiency and optimal path selection. The algorithm avoids division by zero by setting the ratio to infinity if the future distance is zero.",
          "thought": "The new algorithm prioritizes minimizing the ratio of the immediate distance to the future distance, favoring nodes that offer a better balance between proximity and potential future connections, iterating through unvisited nodes to select the node with the lowest ratio score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        if ratio_score < min_score:\n            min_score = ratio_score\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that minimize the immediate distance traveled, with the destination node being the final step. It iterates through unvisited nodes, compares their distances from the current node, and selects the closest one, ensuring the path remains efficient. The `destination_node` is only returned if no unvisited nodes remain, indicating the end of the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that reduce the remaining path length to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance, future connectivity, and future variance, using a dynamic weight that prioritizes immediate distance early and future connectivity later. It calculates a weighted score combining current distance, average future distance, and variance of future distances, with variance given lower weight (0.1) to reduce sensitivity to outliers. The weight adjusts based on remaining unvisited nodes, favoring immediate distance when few nodes remain.",
          "thought": "This new algorithm modifies the original by incorporating a dynamic weighting factor that adjusts the balance between immediate distance and future connectivity based on the remaining unvisited nodes, using a normalized score that accounts for both proximity and potential future paths, while also considering the variance of future distances to ensure robustness against outliers.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining == 1:\n            future_distance = distance_matrix[node][destination_node]\n            future_variance = 0.0\n        else:\n            future_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n            future_distance = sum(future_distances) / (remaining - 1)\n            future_variance = sum((d - future_distance) ** 2 for d in future_distances) / (remaining - 1)\n        weight = 0.5 + 0.5 * (remaining / len(unvisited_nodes))\n        total_score = (current_distance * weight) + (future_distance * (1 - weight)) + (0.1 * future_variance)\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.05587,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate travel distance (given higher weight later in the tour) with future flexibility (averaged distances to remaining unvisited nodes, weighted more heavily early on). The weight dynamically shifts from future flexibility (high weight) to immediate proximity (high weight) as the number of remaining nodes decreases. The score combines these factors, selecting the node that minimizes the weighted sum of immediate and future costs.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate and future distances) with the average future distance calculation from No.2, creating a score that prioritizes nodes offering a good trade-off between immediate travel and future flexibility, while dynamically adjusting the weight based on remaining nodes to shift priority from future flexibility to immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if remaining_nodes == 1:\n            future_average = future_distance\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (remaining_nodes - 1)\n        weight = 1 / (1 + remaining_nodes)\n        score = (1 - weight) * immediate_distance + weight * future_average\n        total_score = immediate_distance * score\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.10318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity (current distance) and future potential (distance to destination), combining a ratio-based score (prioritizing nodes closer to the destination) with a sum-based score (prioritizing nodes nearby) to minimize the combined cost, while handling division by zero by assigning infinity to the ratio score. The code iterates through unvisited nodes, computes scores, and selects the node with the lowest combined score.",
          "thought": "The new algorithm combines the ratio-based scoring from No.1 with the sum-based scoring from No.2, prioritizing nodes that balance proximity and future potential, while avoiding division by zero by setting the ratio to infinity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        total_score = current_distance + future_distance\n        combined_score = ratio_score + total_score\n        if combined_score < min_score:\n            min_score = combined_score\n            next_node = node\n    return next_node",
          "objective": 7.11609,
          "other_inf": null
     }
]