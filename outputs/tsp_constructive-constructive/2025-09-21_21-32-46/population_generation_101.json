[
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance from the current node and potential future distance to the destination, prioritizing nodes with a higher combined score. The `score` is calculated as `-immediate_distance + 0.5 * future_distance`, emphasizing efficiency in the short term while slightly favoring progress toward the destination. The loop iterates through unvisited nodes to find the node with the highest score, ensuring a trade-off between local and global optimization.",
          "thought": "The new algorithm modifies the provided algorithm by incorporating a weighted combination of immediate distance and potential future distance to the destination, using a heuristic to balance exploration of nearby nodes with progress toward the destination. It iterates through unvisited nodes, calculates a weighted score for each, and selects the node with the highest score, ensuring a balance between immediate efficiency and long-term path optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    max_score = -float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        score = -immediate_distance + 0.5 * future_distance\n        if score > max_score:\n            max_score = score\n            next_node = node\n    return next_node",
          "objective": 6.5107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the lowest ratio of immediate distance to future distance, balancing proximity and potential future connections. It iterates through unvisited nodes, calculates the ratio score (current distance / future distance), and chooses the node with the minimal score, ensuring efficiency and optimal path selection. The algorithm avoids division by zero by setting the ratio to infinity if the future distance is zero.",
          "thought": "The new algorithm prioritizes minimizing the ratio of the immediate distance to the future distance, favoring nodes that offer a better balance between proximity and potential future connections, iterating through unvisited nodes to select the node with the lowest ratio score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        if ratio_score < min_score:\n            min_score = ratio_score\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that minimize the immediate distance traveled, with the destination node being the final step. It iterates through unvisited nodes, compares their distances from the current node, and selects the closest one, ensuring the path remains efficient. The `destination_node` is only returned if no unvisited nodes remain, indicating the end of the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that reduce the remaining path length to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes balancing immediate travel distance (given higher weight later in the tour) with future flexibility (averaged distances to remaining unvisited nodes, weighted more heavily early on). The weight dynamically shifts from future flexibility (high weight) to immediate proximity (high weight) as the number of remaining nodes decreases. The score combines these factors, selecting the node that minimizes the weighted sum of immediate and future costs.",
          "thought": "The new algorithm combines the dynamic weight adjustment from No.1 (balancing immediate and future distances) with the average future distance calculation from No.2, creating a score that prioritizes nodes offering a good trade-off between immediate travel and future flexibility, while dynamically adjusting the weight based on remaining nodes to shift priority from future flexibility to immediate proximity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if remaining_nodes == 1:\n            future_average = future_distance\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (remaining_nodes - 1)\n        weight = 1 / (1 + remaining_nodes)\n        score = (1 - weight) * immediate_distance + weight * future_average\n        total_score = immediate_distance * score\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.10318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate and future distances by computing a weighted score, where immediate distance is prioritized more when fewer nodes remain unvisited (weight decreases with remaining nodes). The score is the product of the immediate distance and a weighted sum of immediate and future distances, ensuring flexibility while favoring closer nodes. The weight adjusts based on remaining nodes, dynamically shifting priority from future flexibility to immediate proximity.",
          "thought": "The new algorithm combines the dynamic weighting of No.1 (balancing immediate and future distances) with the product-based scoring of No.2 (prioritizing nodes that offer a good trade-off between immediate travel and future flexibility). It dynamically adjusts the weight of immediate and future distances based on remaining nodes and computes the score as the product of the weighted sum of immediate and future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight = 1 / (1 + remaining_nodes)\n        score = (1 - weight) * immediate_distance + weight * future_distance\n        total_score = immediate_distance * score\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.12243,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting a weight factor based on the number of unvisited nodes, prioritizing shorter current distances early but favoring better future connectivity as the tour progresses. It includes a penalty term to discourage revisiting nodes, ensuring the path efficiently returns to the destination when no unvisited nodes remain. The weight factor (`weight_factor`) and penalty (`penalty`) are key design elements, dynamically adjusting priorities between short-term and long-term objectives.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight factor that adjusts based on the remaining number of unvisited nodes, blending immediate distance and future connectivity more adaptively, and includes a penalty term to discourage revisiting nodes that were recently considered, while still ensuring the path returns to the destination when no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    weight_factor = 1.0 / (len(unvisited_nodes) + 1)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (len(unvisited_nodes) - 1)\n        penalty = 0.1 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        total_score = (1 - weight_factor) * current_distance + weight_factor * future_average + penalty\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances local and global optimization by dynamically weighting the immediate distance to the next node and the future distance to the destination, with higher priority given to the immediate distance as more nodes remain unvisited (weight decreases as `remaining_nodes` increases). The score is computed as `(1 - weight) * immediate_distance + weight * future_distance`, ensuring the path adapts between short-term and long-term efficiency. The weight adjusts inversely with the number of remaining nodes, favoring local optimization early and global optimization later.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of the immediate distance to the next node and the potential future distance to the destination, balancing local and global path optimization through a dynamic weight adjustment based on the remaining unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    next_node = None\n    best_score = float('inf')\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight = 1 / (1 + remaining_nodes)\n        score = (1 - weight) * immediate_distance + weight * future_distance\n        if score < best_score:\n            best_score = score\n            next_node = node\n    return next_node",
          "objective": 7.15156,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting a weight factor based on remaining unvisited nodes, prioritizing closer nodes early while considering long-term connectivity as the tour progresses. It uses a linear combination of current distance and a weighted average of future distances to the remaining nodes, ensuring the path returns to the destination when no nodes remain. The weight factor decreases as remaining nodes decrease, shifting focus from exploration to exploitation.",
          "thought": "The new algorithm modifies the original approach by incorporating a dynamic weighting factor that adjusts based on the number of remaining unvisited nodes, blending immediate distance with a normalized future connectivity score to balance exploration and exploitation, while ensuring the path returns to the destination when no nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_score = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_avg = future_sum / (remaining_nodes - 1)\n            weight = 1 / (1 + remaining_nodes)  # Dynamic weight based on remaining nodes\n            future_score = weight * future_avg\n        total_score = current_distance + future_score  # Linear combination instead of product\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.15549,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by using an exponential decay factor that prioritizes short-term gains as the tour progresses, while still considering long-term flexibility through a weighted average of distances to remaining nodes. The decay factor decreases as more nodes are visited, giving higher weight to immediate distances early on and gradually shifting focus to future flexibility. The total score combines the current distance (weighted by the decay factor) and the average future distance (weighted by 1 minus the decay factor), ensuring a trade-off between proximity and connectivity.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate distance and future connectivity based on the number of remaining unvisited nodes, using an exponential decay factor to prioritize immediate gains as the tour progresses, while still considering future flexibility through a weighted average of distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    decay_factor = 0.5 ** (1 / remaining_nodes) if remaining_nodes > 1 else 1.0\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (remaining_nodes - 1)\n        total_score = (current_distance * decay_factor) + (future_average * (1 - decay_factor))\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.15821,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity (current distance) and long-term connectivity (future distance metric) by adjusting a weight based on remaining unvisited nodes. It prioritizes nodes closer to the current node early on but increasingly values future connectivity as the tour progresses, while penalizing nodes with high variability in future distances. The weight decreases as more nodes are visited, shifting focus from immediate gains to overall tour optimization.",
          "thought": "The new algorithm modifies the score calculation by incorporating a weighted sum of the current distance and a normalized future distance metric, where the weight adjusts dynamically based on the remaining nodes, favoring nodes that balance immediate proximity with long-term connectivity while penalizing nodes with high variability in future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_metric = distance_matrix[node][destination_node]\n        else:\n            future_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n            future_mean = sum(future_distances) / len(future_distances)\n            future_std = (sum((d - future_mean) ** 2 for d in future_distances) / len(future_distances)) ** 0.5\n            future_metric = future_mean + 0.5 * future_std  # Mean + penalty for variability\n        total_score = (1 - weight) * current_distance + weight * future_metric\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.20236,
          "other_inf": null
     }
]