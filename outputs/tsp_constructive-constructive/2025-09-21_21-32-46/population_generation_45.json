[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the lowest ratio of immediate distance to future distance, balancing proximity and potential future connections. It iterates through unvisited nodes, calculates the ratio score (current distance / future distance), and chooses the node with the minimal score, ensuring efficiency and optimal path selection. The algorithm avoids division by zero by setting the ratio to infinity if the future distance is zero.",
          "thought": "The new algorithm prioritizes minimizing the ratio of the immediate distance to the future distance, favoring nodes that offer a better balance between proximity and potential future connections, iterating through unvisited nodes to select the node with the lowest ratio score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        if ratio_score < min_score:\n            min_score = ratio_score\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that minimize the immediate distance traveled, with the destination node being the final step. It iterates through unvisited nodes, compares their distances from the current node, and selects the closest one, ensuring the path remains efficient. The `destination_node` is only returned if no unvisited nodes remain, indicating the end of the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that reduce the remaining path length to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting a weight factor based on the number of unvisited nodes, prioritizing shorter current distances early but favoring better future connectivity as the tour progresses. It includes a penalty term to discourage revisiting nodes, ensuring the path efficiently returns to the destination when no unvisited nodes remain. The weight factor (`weight_factor`) and penalty (`penalty`) are key design elements, dynamically adjusting priorities between short-term and long-term objectives.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight factor that adjusts based on the remaining number of unvisited nodes, blending immediate distance and future connectivity more adaptively, and includes a penalty term to discourage revisiting nodes that were recently considered, while still ensuring the path returns to the destination when no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    weight_factor = 1.0 / (len(unvisited_nodes) + 1)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (len(unvisited_nodes) - 1)\n        penalty = 0.1 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        total_score = (1 - weight_factor) * current_distance + weight_factor * future_average + penalty\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by using an exponential decay factor that prioritizes short-term gains as the tour progresses, while still considering long-term flexibility through a weighted average of distances to remaining nodes. The decay factor decreases as more nodes are visited, giving higher weight to immediate distances early on and gradually shifting focus to future flexibility. The total score combines the current distance (weighted by the decay factor) and the average future distance (weighted by 1 minus the decay factor), ensuring a trade-off between proximity and connectivity.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts the balance between immediate distance and future connectivity based on the number of remaining unvisited nodes, using an exponential decay factor to prioritize immediate gains as the tour progresses, while still considering future flexibility through a weighted average of distances to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    decay_factor = 0.5 ** (1 / remaining_nodes) if remaining_nodes > 1 else 1.0\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (remaining_nodes - 1)\n        total_score = (current_distance * decay_factor) + (future_average * (1 - decay_factor))\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.15821,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity (current distance) and long-term connectivity (future distance metric) by adjusting a weight based on remaining unvisited nodes. It prioritizes nodes closer to the current node early on but increasingly values future connectivity as the tour progresses, while penalizing nodes with high variability in future distances. The weight decreases as more nodes are visited, shifting focus from immediate gains to overall tour optimization.",
          "thought": "The new algorithm modifies the score calculation by incorporating a weighted sum of the current distance and a normalized future distance metric, where the weight adjusts dynamically based on the remaining nodes, favoring nodes that balance immediate proximity with long-term connectivity while penalizing nodes with high variability in future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_metric = distance_matrix[node][destination_node]\n        else:\n            future_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n            future_mean = sum(future_distances) / len(future_distances)\n            future_std = (sum((d - future_mean) ** 2 for d in future_distances) / len(future_distances)) ** 0.5\n            future_metric = future_mean + 0.5 * future_std  # Mean + penalty for variability\n        total_score = (1 - weight) * current_distance + weight * future_metric\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.20236,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance prioritization (with a weight of 0.8 when many nodes remain unvisited) and future distance to the destination (weighted 0.2 or adaptively adjusted). It dynamically adjusts weights based on remaining nodes, favoring immediate distances early and future distances later. The weights are calculated as `weight_current = 0.8` if more than half of the nodes are unvisited, otherwise `0.2`, ensuring a smooth transition between exploration and exploitation. The scoring mechanism combines these weighted distances to determine the optimal next node.",
          "thought": "The new algorithm combines the immediate-distance prioritization of No.2 with a dynamic weighting of future distances inspired by No.1, adjusting weights based on remaining unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight_current = 0.8 if remaining_nodes > len(unvisited_nodes) / 2 else 0.2\n        weight_future = 1 - weight_current\n        total_score = weight_current * current_distance + weight_future * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate distance and potential return distance, prioritizing nodes with the smallest combined score (70% immediate distance + 30% potential return distance). It ensures the destination is selected only when no unvisited nodes remain. The heuristic score is calculated for each unvisited node, and the node with the minimum score is chosen.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a weighted combination of immediate distance and the potential reduction in total tour length, using a heuristic that balances proximity and global path efficiency, while still ensuring the destination node is only selected when no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][node]\n        potential_return_distance = distance_matrix[node][destination_node]\n        heuristic_score = immediate_distance + 0.3 * potential_return_distance\n        if heuristic_score < min_score:\n            min_score = heuristic_score\n            next_node = node\n    return next_node",
          "objective": 7.37192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the immediate distance from the current node and the future distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. Early in the tour (many nodes left), it prioritizes minimizing future distances to the destination, while later (fewer nodes left), it shifts focus to minimizing the immediate distance to the next node. The weighted sum ensures a trade-off between exploration (future-oriented) and exploitation (current-oriented) as the tour progresses.",
          "thought": "The new algorithm modifies the original by incorporating a weighted sum of current and future distances, where the weights are dynamically adjusted based on the number of remaining unvisited nodes, promoting exploration early and exploitation later in the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight_current = 0.7 if remaining_nodes > len(unvisited_nodes) / 2 else 0.3\n        weight_future = 1 - weight_current\n        total_score = weight_current * current_distance + weight_future * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity and future connectivity by selecting the next node to visit based on the sum of the current distance to the node and a scaled (0.5x) future distance from that node to the destination. This ensures the algorithm prioritizes nodes that are both close to the current position and likely to lead to the destination efficiently. The code structure iteratively evaluates all unvisited nodes, computes the weighted score, and selects the node with the minimum total score.",
          "thought": "The new algorithm combines the idea of prioritizing immediate proximity from No.1 with the balanced scoring approach of No.2. It selects the next node by minimizing the sum of the immediate distance and a scaled future distance to the destination, ensuring efficiency while considering future connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + 0.5 * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the current distance from the last visited node and the future distance to the destination, balancing immediate proximity and strategic positioning. It evaluates each unvisited node by computing `current_distance * future_distance` and selects the node with the smallest product, ensuring a trade-off between short-term and long-term connectivity. The `distance_matrix` provides the necessary distance data, while `current_node`, `destination_node`, and `unvisited_nodes` guide the selection process.",
          "thought": "The new algorithm prioritizes balancing immediate distance and future potential connections by considering the product of current and future distances, aiming to find a node that offers a good trade-off between proximity and strategic positioning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     }
]