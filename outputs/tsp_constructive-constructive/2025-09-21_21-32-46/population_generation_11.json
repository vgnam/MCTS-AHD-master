[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the lowest ratio of immediate distance to future distance, balancing proximity and potential future connections. It iterates through unvisited nodes, calculates the ratio score (current distance / future distance), and chooses the node with the minimal score, ensuring efficiency and optimal path selection. The algorithm avoids division by zero by setting the ratio to infinity if the future distance is zero.",
          "thought": "The new algorithm prioritizes minimizing the ratio of the immediate distance to the future distance, favoring nodes that offer a better balance between proximity and potential future connections, iterating through unvisited nodes to select the node with the lowest ratio score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        if ratio_score < min_score:\n            min_score = ratio_score\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that minimize the immediate distance traveled, with the destination node being the final step. It iterates through unvisited nodes, compares their distances from the current node, and selects the closest one, ensuring the path remains efficient. The `destination_node` is only returned if no unvisited nodes remain, indicating the end of the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that reduce the remaining path length to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity and future connectivity by selecting the next node to visit based on the sum of the current distance to the node and a scaled (0.5x) future distance from that node to the destination. This ensures the algorithm prioritizes nodes that are both close to the current position and likely to lead to the destination efficiently. The code structure iteratively evaluates all unvisited nodes, computes the weighted score, and selects the node with the minimum total score.",
          "thought": "The new algorithm combines the idea of prioritizing immediate proximity from No.1 with the balanced scoring approach of No.2. It selects the next node by minimizing the sum of the immediate distance and a scaled future distance to the destination, ensuring efficiency while considering future connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + 0.5 * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the current distance from the last visited node and the future distance to the destination, balancing immediate proximity and strategic positioning. It evaluates each unvisited node by computing `current_distance * future_distance` and selects the node with the smallest product, ensuring a trade-off between short-term and long-term connectivity. The `distance_matrix` provides the necessary distance data, while `current_node`, `destination_node`, and `unvisited_nodes` guide the selection process.",
          "thought": "The new algorithm prioritizes balancing immediate distance and future potential connections by considering the product of current and future distances, aiming to find a node that offers a good trade-off between proximity and strategic positioning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (60% weight), future distance to the destination (30% weight), and a heuristic term (10% weight) that penalizes nodes farther than the average distance to unvisited nodes, avoiding local optima while prioritizing progress toward the destination. The heuristic term is squared to emphasize larger deviations, while the distance terms ensure efficient path progression. The weighted sum ensures a trade-off between local and global considerations in the path selection.",
          "thought": "This new algorithm modifies the original by incorporating a weighted sum of immediate distance, future distance, and a heuristic term that considers the average distance of the unvisited nodes to the current node, aiming to balance immediate progress and global connectivity while avoiding local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    avg_unvisited_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        heuristic_term = (current_distance - avg_unvisited_distance) ** 2\n        total_score = 0.6 * current_distance + 0.3 * future_distance + 0.1 * heuristic_term\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.50449,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in the TSP path by balancing proximity to the current node and future connectivity to the destination, prioritizing the latter with a weighting factor of 0.75. It iterates through unvisited nodes, computes a weighted sum of current and future distances, and chooses the node with the minimum score, effectively trading off immediate distance with long-term path efficiency.",
          "thought": "The new algorithm combines the balanced scoring approach from No.1 (weighting future distance) with the straightforward sum of distances from No.2, using a scaling factor of 0.75 to prioritize future connectivity while maintaining proximity awareness. It iterates through unvisited nodes, computes a weighted sum of current and future distances, and selects the node with the minimum score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + 0.75 * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.71965,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by minimizing a score that combines the immediate distance from the current node with the average future distances to unvisited nodes, balancing proximity and potential future connectivity. The score is computed as the product of `current_distance` (distance from current node to candidate node) and `future_average` (average distance from candidate node to other unvisited nodes), prioritizing nodes that offer a good trade-off between immediate travel and future flexibility. The algorithm ensures the path returns to the destination node when no unvisited nodes remain.",
          "thought": "The new algorithm prioritizes selecting the next node based on the product of the current distance to the node and the average of the distances from the node to all other unvisited nodes, aiming to balance immediate proximity with potential future connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (len(unvisited_nodes) - 1)\n        total_score = current_distance * future_average\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.7792,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing the sum of the immediate distance from the current node and the future distance to the destination node, ensuring a balance between proximity and potential future connections. It iterates through unvisited nodes, calculates a score for each, and chooses the node with the lowest total score, effectively minimizing the estimated total tour length. The design prioritizes minimizing the sum of current and future distances over other factors.",
          "thought": "This algorithm selects the next node by considering not only the immediate distance to the current node but also the potential future connections, using a heuristic that balances the current and future distances to minimize the total tour length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: immediate distance from the current node, future distance to the destination, and average distance to remaining unvisited nodes. It prioritizes minimizing the sum of these three metrics, favoring shorter immediate steps while also considering long-term connectivity and path flexibility. The function iterates through unvisited nodes, computes each factor, and selects the node with the lowest combined score.",
          "thought": "The algorithm selects the next node by considering the immediate distance from the current node, the future distance to the destination, and the average distance to all other unvisited nodes, balancing proximity, potential future connectivity, and overall path flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if len(unvisited_nodes) == 1:\n            future_average = 0\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (len(unvisited_nodes) - 1)\n        total_score = current_distance + future_distance + future_average\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 9.53671,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances between immediate proximity (current distance) and long-term connectivity (future distance) by adjusting weights based on remaining unvisited nodes. As the tour progresses (fewer nodes left), the weight shifts more toward future distances, ensuring better long-term path optimization. The score combines distances with a dynamic weight, favoring future distances early and immediate distances later, while the remaining nodes count drives this balance.",
          "thought": "The new algorithm extends the original by incorporating a dynamic weighting mechanism that adjusts the priority between current and future distances based on the number of remaining unvisited nodes, ensuring a balance between immediate proximity and long-term connectivity. It calculates a weighted score for each node, where the weight dynamically shifts from favoring future distances to current distances as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight = remaining_nodes / (remaining_nodes + 1)\n        total_score = (1 - weight) * current_distance + weight * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 14.21124,
          "other_inf": null
     }
]