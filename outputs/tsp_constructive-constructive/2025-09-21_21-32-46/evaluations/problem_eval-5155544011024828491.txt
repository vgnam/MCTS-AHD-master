def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    if not unvisited_nodes:
        return destination_node

    # Calculate inverse distances and their sum for probability weights
    distances = [distance_matrix[current_node][node] for node in unvisited_nodes]
    inverse_distances = [1 / d for d in distances]
    total_inverse = sum(inverse_distances)

    # Calculate probabilities
    probabilities = [inv / total_inverse for inv in inverse_distances]

    # Introduce exploration factor (e.g., 0.3) to balance exploitation and exploration
    exploration_factor = 0.3
    adjusted_probabilities = [
        (1 - exploration_factor) * prob + exploration_factor / len(unvisited_nodes)
        for prob in probabilities
    ]

    # Select node based on adjusted probabilities
    next_node = random.choices(unvisited_nodes, weights=adjusted_probabilities, k=1)[0]
    return next_node
