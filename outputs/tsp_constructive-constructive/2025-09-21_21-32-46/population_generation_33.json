[
     {
          "algorithm": "The algorithm selects the next node by prioritizing those with the lowest ratio of immediate distance to future distance, balancing proximity and potential future connections. It iterates through unvisited nodes, calculates the ratio score (current distance / future distance), and chooses the node with the minimal score, ensuring efficiency and optimal path selection. The algorithm avoids division by zero by setting the ratio to infinity if the future distance is zero.",
          "thought": "The new algorithm prioritizes minimizing the ratio of the immediate distance to the future distance, favoring nodes that offer a better balance between proximity and potential future connections, iterating through unvisited nodes to select the node with the lowest ratio score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        if future_distance == 0:\n            ratio_score = float('inf')\n        else:\n            ratio_score = current_distance / future_distance\n        if ratio_score < min_score:\n            min_score = ratio_score\n            next_node = node\n    return next_node",
          "objective": 6.89499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that minimize the immediate distance traveled, with the destination node being the final step. It iterates through unvisited nodes, compares their distances from the current node, and selects the closest one, ensuring the path remains efficient. The `destination_node` is only returned if no unvisited nodes remain, indicating the end of the tour.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, prioritizing nodes that reduce the remaining path length to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_distance = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate distance and future connectivity by adjusting a weight factor based on the number of unvisited nodes, prioritizing shorter current distances early but favoring better future connectivity as the tour progresses. It includes a penalty term to discourage revisiting nodes, ensuring the path efficiently returns to the destination when no unvisited nodes remain. The weight factor (`weight_factor`) and penalty (`penalty`) are key design elements, dynamically adjusting priorities between short-term and long-term objectives.",
          "thought": "The new algorithm modifies the original by incorporating a dynamic weight factor that adjusts based on the remaining number of unvisited nodes, blending immediate distance and future connectivity more adaptively, and includes a penalty term to discourage revisiting nodes that were recently considered, while still ensuring the path returns to the destination when no unvisited nodes remain.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    weight_factor = 1.0 / (len(unvisited_nodes) + 1)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            future_average = distance_matrix[node][destination_node]\n        else:\n            future_sum = sum(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n            future_average = future_sum / (len(unvisited_nodes) - 1)\n        penalty = 0.1 * (len(unvisited_nodes) / (len(unvisited_nodes) + 1))\n        total_score = (1 - weight_factor) * current_distance + weight_factor * future_average + penalty\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.1493,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances immediate proximity (current distance) and long-term connectivity (future distance metric) by adjusting a weight based on remaining unvisited nodes. It prioritizes nodes closer to the current node early on but increasingly values future connectivity as the tour progresses, while penalizing nodes with high variability in future distances. The weight decreases as more nodes are visited, shifting focus from immediate gains to overall tour optimization.",
          "thought": "The new algorithm modifies the score calculation by incorporating a weighted sum of the current distance and a normalized future distance metric, where the weight adjusts dynamically based on the remaining nodes, favoring nodes that balance immediate proximity with long-term connectivity while penalizing nodes with high variability in future distances.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    weight = 1.0 / (1.0 + remaining_nodes)  # Dynamic weight based on remaining nodes\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if remaining_nodes == 1:\n            future_metric = distance_matrix[node][destination_node]\n        else:\n            future_distances = [distance_matrix[node][other] for other in unvisited_nodes if other != node]\n            future_mean = sum(future_distances) / len(future_distances)\n            future_std = (sum((d - future_mean) ** 2 for d in future_distances) / len(future_distances)) ** 0.5\n            future_metric = future_mean + 0.5 * future_std  # Mean + penalty for variability\n        total_score = (1 - weight) * current_distance + weight * future_metric\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.20236,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing the immediate distance from the current node and the future distance to the destination, with weights dynamically adjusted based on the number of remaining unvisited nodes. Early in the tour (many nodes left), it prioritizes minimizing future distances to the destination, while later (fewer nodes left), it shifts focus to minimizing the immediate distance to the next node. The weighted sum ensures a trade-off between exploration (future-oriented) and exploitation (current-oriented) as the tour progresses.",
          "thought": "The new algorithm modifies the original by incorporating a weighted sum of current and future distances, where the weights are dynamically adjusted based on the number of remaining unvisited nodes, promoting exploration early and exploitation later in the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    remaining_nodes = len(unvisited_nodes)\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        weight_current = 0.7 if remaining_nodes > len(unvisited_nodes) / 2 else 0.3\n        weight_future = 1 - weight_current\n        total_score = weight_current * current_distance + weight_future * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate proximity and future connectivity by selecting the next node to visit based on the sum of the current distance to the node and a scaled (0.5x) future distance from that node to the destination. This ensures the algorithm prioritizes nodes that are both close to the current position and likely to lead to the destination efficiently. The code structure iteratively evaluates all unvisited nodes, computes the weighted score, and selects the node with the minimum total score.",
          "thought": "The new algorithm combines the idea of prioritizing immediate proximity from No.1 with the balanced scoring approach of No.2. It selects the next node by minimizing the sum of the immediate distance and a scaled future distance to the destination, ensuring efficiency while considering future connections.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + 0.5 * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes nodes that minimize the product of the current distance from the last visited node and the future distance to the destination, balancing immediate proximity and strategic positioning. It evaluates each unvisited node by computing `current_distance * future_distance` and selects the node with the smallest product, ensuring a trade-off between short-term and long-term connectivity. The `distance_matrix` provides the necessary distance data, while `current_node`, `destination_node`, and `unvisited_nodes` guide the selection process.",
          "thought": "The new algorithm prioritizes balancing immediate distance and future potential connections by considering the product of current and future distances, aiming to find a node that offers a good trade-off between proximity and strategic positioning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate travel distance (prioritized) and future flexibility (maximizing the worst-case distance to remaining unvisited nodes). It prioritizes nodes with lower current distances and higher future flexibility, ensuring a trade-off between short-term efficiency and long-term adaptability. The `total_score` combines these factors multiplicatively, favoring nodes that minimize the product of immediate distance and future worst-case distance.",
          "thought": "The new algorithm selects the next node by minimizing a score that combines the immediate distance from the current node with the maximum future distance to unvisited nodes, prioritizing nodes that offer a balance between immediate travel and future flexibility.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if len(unvisited_nodes) == 1:\n            future_max = distance_matrix[node][destination_node]\n        else:\n            future_max = max(distance_matrix[node][other] for other in unvisited_nodes if other != node)\n        total_score = current_distance * future_max\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.48487,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node to visit by balancing immediate distance (60% weight), future distance to the destination (30% weight), and a heuristic term (10% weight) that penalizes nodes farther than the average distance to unvisited nodes, avoiding local optima while prioritizing progress toward the destination. The heuristic term is squared to emphasize larger deviations, while the distance terms ensure efficient path progression. The weighted sum ensures a trade-off between local and global considerations in the path selection.",
          "thought": "This new algorithm modifies the original by incorporating a weighted sum of immediate distance, future distance, and a heuristic term that considers the average distance of the unvisited nodes to the current node, aiming to balance immediate progress and global connectivity while avoiding local optima.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    avg_unvisited_distance = sum(distance_matrix[current_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        heuristic_term = (current_distance - avg_unvisited_distance) ** 2\n        total_score = 0.6 * current_distance + 0.3 * future_distance + 0.1 * heuristic_term\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.50449,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm balances immediate distance to the next node and future distance to the destination, prioritizing future connectivity with a weighting factor of 0.6. It selects the next node by minimizing the weighted sum of the current distance and the future distance to the destination, ensuring a trade-off between proximity and global path efficiency. The weighting factor (0.6) reflects a stronger emphasis on future connectivity than immediate distance, aligning with the design goal of balancing local and global considerations.",
          "thought": "The common idea in No.1 is prioritizing future connectivity with a weighting factor. The new algorithm will balance immediate distance and future distance to the destination, using a weighting factor between 0.5 and 0.75 to prioritize future connectivity more than No.1 but less than No.2.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n    min_score = float('inf')\n    next_node = None\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        future_distance = distance_matrix[node][destination_node]\n        total_score = current_distance + 0.6 * future_distance\n        if total_score < min_score:\n            min_score = total_score\n            next_node = node\n    return next_node",
          "objective": 7.6086,
          "other_inf": null
     }
]