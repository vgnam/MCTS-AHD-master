[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while penalizing nodes that deviate from the centroid of unvisited nodes' distances to the destination. It balances local (distance to current node) and global (centroid-based penalty) considerations, with the penalty given lower weight (0.3) to avoid over-optimizing for the centroid. The centroid is computed as the average distance from unvisited nodes to the destination, ensuring the path remains efficient toward the goal.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted penalty for nodes far from the destination, inspired by No.1's focus on minimizing the sum of distances to the current and destination nodes, while also incorporating a centroid-based penalty similar to No.2. The main steps are: compute the centroid of unvisited nodes based on distances to the destination, then select the next node by minimizing a weighted sum of the distance to the current node and a penalty for deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    if unvisited_nodes:\n        centroid = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Weighted score: prioritize proximity to current node and penalize deviation from centroid\n        score = distance_to_current + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.3639,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically weighting distances to the current node, destination node, and a normalized centroid penalty, with higher priority given to the current node\u2019s distance (dynamic_weight_current = 1.0 + 0.2 * remaining_nodes / (remaining_nodes + 1)), followed by the destination distance (dynamic_weight_dest = 0.5 + 0.1 * remaining_nodes / (remaining_nodes + 1)), and a lower-priority centroid penalty (dynamic_weight_centroid = 0.3 * remaining_nodes / (remaining_nodes + 2)). The centroid penalty is normalized by the number of unvisited nodes to balance exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting scheme that adjusts priorities based on the remaining path length and node density, using a normalized centroid penalty that scales with the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute dynamic weights based on remaining path length and node density\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight_current = 1.0 + (0.2 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_dest = 0.5 + (0.1 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_centroid = 0.3 * (remaining_nodes / (remaining_nodes + 2))\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize centroid penalty by the number of unvisited nodes\n        normalized_centroid = centroid_penalty / (remaining_nodes + 1)\n\n        # Dynamic weighted score\n        score = (dynamic_weight_current * distance_to_current +\n                 dynamic_weight_dest * distance_to_dest +\n                 dynamic_weight_centroid * normalized_centroid)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node, closeness to the destination, and penalizing nodes far from the centroid of unvisited nodes, balancing immediate progress with avoiding detours. The weighted score combines `distance_to_current` (highest priority), `distance_to_dest` (medium priority), and `centroid_penalty` (lowest priority), with weights of 1.0, 0.5, and 0.3 respectively. The centroid is computed based on distances to the destination, ensuring the path stays centrally aligned with unvisited nodes.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize a weighted combination of the immediate distance from the current node, the distance to the destination, and a penalty for nodes that are far from the centroid of the remaining unvisited nodes, aiming to balance progress toward the destination while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and destination, penalize deviation from centroid\n        score = distance_to_current + 0.5 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.55979,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the current node (weight 2.0), closeness to the destination (weight 1.5), and centroid deviation (weight 0.5), while also considering future steps (weight 0.3) to balance exploration and exploitation. The centroid is calculated based on distances from the destination to guide the path toward unvisited nodes, and the lookahead evaluates the best possible next step from each candidate node.",
          "thought": "The new algorithm selects the next node by combining the nearest-neighbor approach with a lookahead mechanism that evaluates the potential impact of choosing a node on both immediate and future steps, using a weighted score that balances proximity to the current node, closeness to the destination, and the node's position relative to the centroid of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    centroid = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        # Immediate distance to current node\n        distance_to_current = distance_matrix[current_node][node]\n\n        # Distance to destination\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Centroid deviation penalty\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Lookahead: evaluate the best possible next step from this node\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if remaining_nodes:\n            best_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n        else:\n            best_future_distance = 0\n\n        # Weighted score combining immediate, destination, centroid, and lookahead\n        score = (2.0 * distance_to_current +\n                 1.5 * distance_to_dest +\n                 0.5 * centroid_penalty +\n                 0.3 * best_future_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.64863,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing immediate proximity (weight 1.0), destination closeness (weight 0.5), centroid alignment (weight 0.3), and a lookahead step (weight 0.2), ensuring the path prioritizes proximity while considering long-term efficiency through centroid guidance and short-term optimization via the lookahead mechanism.",
          "thought": "The new algorithm combines the centroid-based guidance from No.1 with the weighted scoring structure of No.2, adding a lookahead mechanism to evaluate future steps while prioritizing immediate proximity, destination closeness, and centroid alignment with weights of 1.0, 0.5, 0.3, and 0.2 respectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    centroid = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        # Immediate distance to current node\n        distance_to_current = distance_matrix[current_node][node]\n\n        # Distance to destination\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Centroid deviation penalty\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Lookahead: evaluate the best possible next step from this node\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if remaining_nodes:\n            best_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n        else:\n            best_future_distance = 0\n\n        # Weighted score combining immediate, destination, centroid, and lookahead\n        score = (1.0 * distance_to_current +\n                 0.5 * distance_to_dest +\n                 0.3 * centroid_penalty +\n                 0.2 * best_future_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.66115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in TSP by balancing proximity to the current node, alignment with the destination, and node density, using weighted scores where immediate distance (`distance_to_current`) is prioritized most (weight `w1`), followed by destination alignment (`distance_to_dest`, weight `w2`), and a density penalty (`density_penalty`, weight `w3`) to avoid clustering. Weights adjust based on remaining distance and node density, ensuring adaptability to sparse or dense unvisited nodes.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the remaining distance to the destination and the density of unvisited nodes, using a novel score equation that combines proximity to the current node, destination alignment, and a density-based penalty to balance immediate progress with centralized path planning.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Dynamic weights based on remaining distance and node density\n    remaining_distance = distance_matrix[current_node][destination_node]\n    node_density = len(unvisited_nodes) / sum(distance_matrix[destination_node][node] for node in unvisited_nodes) if unvisited_nodes else 0\n\n    # Compute dynamic weights\n    w1 = 1.0 + 0.2 * (remaining_distance / (sum(distance_matrix[current_node][node] for node in unvisited_nodes) + 1e-6))\n    w2 = 0.5 + 0.3 * (node_density / (node_density + 1e-6))\n    w3 = 0.3 * (1.0 / (1.0 + node_density))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        density_penalty = (sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / (len(unvisited_nodes) - 1)) if len(unvisited_nodes) > 1 else 0\n\n        # Dynamic weighted score\n        score = w1 * distance_to_current + w2 * distance_to_dest + w3 * density_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.9151,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing unvisited nodes that minimize the sum of the distance from the current node and the distance to the destination node, ensuring progress toward the end of the tour. The `distance_matrix` is used to compute these distances, and the `destination_node` is given higher priority by incorporating its distance into the selection criterion. The `current_node` and `unvisited_nodes` are used to iterate and evaluate potential next nodes.",
          "thought": "The algorithm selects the next node to visit by choosing the unvisited node closest to the current node, with a bias toward the destination node to ensure progress toward the end of the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        # Prioritize nodes closer to the destination\n        if distance + distance_matrix[node][destination_node] < min_distance:\n            min_distance = distance + distance_matrix[node][destination_node]\n            next_node = node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing nodes that minimize the sum of the immediate distance from the current node and the average distance from that node to all other unvisited nodes. This balances short-term progress (distance from current node) with long-term potential (average distances to remaining nodes), ensuring a more informed choice than purely greedy nearest-neighbor approaches. The `distance_to_node` is given higher priority than `avg_distance`, as it directly affects the immediate step, while the average acts as a heuristic for future steps.",
          "thought": "This algorithm selects the next node by prioritizing nodes that minimize the sum of the distance from the current node and the average of distances from all unvisited nodes, ensuring a balanced approach toward both immediate and long-term progress in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    for node in unvisited_nodes:\n        distance_to_node = distance_matrix[current_node][node]\n        avg_distance = sum(distance_matrix[node][n] for n in unvisited_nodes if n != node) / len(unvisited_nodes) if unvisited_nodes else 0\n        score = distance_to_node + avg_distance\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.40257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the destination (weight 0.7) while balancing it with the distance to the current node (weight 0.2) and penalizing detours from the centroid of unvisited nodes (weight 0.4). It ensures the path stays close to the destination and avoids excessive deviations from the unvisited nodes' average position.",
          "thought": "The new algorithm prioritizes minimizing the distance to the destination while balancing it with the distance to the current node and a penalty based on the unvisited nodes' centroid, using weights of 0.7, 0.2, and 0.4 respectively to emphasize destination proximity and penalize detours more aggressively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to destination, balance with current distance, penalize centroid deviation\n        score = 0.7 * distance_to_dest + 0.2 * distance_to_current + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.85052,
          "other_inf": null
     }
]