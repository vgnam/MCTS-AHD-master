[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node (80% weight), penalizing distance to the destination (50% weight), and aligning with the centroid of unvisited nodes (20% weight). It computes the centroid as the average distance of unvisited nodes to the destination and penalizes nodes that deviate from this centroid. The weighted scoring ensures a trade-off between immediate progress and path centralization.",
          "thought": "The new algorithm prioritizes immediate distance to the current node and centroid alignment with unvisited nodes, while penalizing distance to the destination, creating a more centralized path with less emphasis on direct progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and centroid, penalize distance to destination\n        score = 0.8 * distance_to_current + 0.2 * centroid_penalty - 0.5 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64951,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing detours from the destination (weight -0.6), and aligning with the centroid of unvisited nodes (weight 0.3). It prioritizes proximity and detour avoidance over centroid alignment, as the negative weight for destination distance heavily influences the selection. The centroid penalty ensures some balance but has a smaller impact.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a stronger penalization for distance to the destination (weight -0.6) and a balanced centroid penalty (weight 0.3), inspired by the No.1 algorithm's effective detour discouragement while maintaining the No.2 algorithm's centroid alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing distance to the current node (weight 0.8), balancing distance to the destination (weight -0.4), and penalizing deviation from the centroid of unvisited nodes (weight 0.2). It ensures a trade-off between proximity to the current node and strategic detours toward the destination while avoiding unnecessary deviations from the centroid. The score is computed for each unvisited node, and the node with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and minimizing the deviation from the centroid of unvisited nodes, with weights of 0.8, 0.4, and 0.2 respectively, ensuring a balance between proximity and strategic detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, balance destination distance, and penalize centroid deviation\n        score = 0.8 * distance_to_current - 0.4 * distance_to_dest + 0.2 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.72045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (highest weight: 1.0), balancing it with a penalty for long distances to the destination (weight: -0.3), and adjusting for deviations from the unvisited nodes' centroid (weight: 0.2). This ensures the path progresses efficiently while avoiding detours, balancing local and global considerations. The score calculation (distance_to_current - 0.3 * distance_to_dest + 0.2 * centroid_penalty) reflects these priorities.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a balanced penalty for long distances to the destination (weight -0.3) and deviations from the unvisited nodes' centroid (weight 0.2), ensuring a path that progresses efficiently while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.3 * distance_to_dest + 0.2 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.82917,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (highest weight), while penalizing detours (negative weight) and aligning with the centroid of unvisited nodes (lower weight). It balances immediate progress, detour avoidance, and central alignment through a weighted scoring structure. The code uses a distance matrix for calculations and iterates through unvisited nodes to compute scores, selecting the node with the lowest score.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), detour avoidance (weight -0.4), and centroid alignment (weight 0.2) from No.1, while using the weighted scoring structure of No.2. It selects the next node by balancing immediate progress, avoiding detours, and staying centrally aligned with unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.2 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.83733,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes immediate proximity to the current node (weight 1.0) while balancing detour avoidance (weight -0.8) and alignment with unvisited nodes' centroid (weight 0.4). It selects the next node by minimizing a score that combines these factors, ensuring the path progresses efficiently while avoiding long detours and staying centrally aligned with remaining destinations. The centroid calculation helps maintain a balanced tour by favoring nodes closer to the average distance from the destination.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a stronger emphasis on avoiding detours to the destination (weight -0.8) and a moderate alignment with the centroid of unvisited nodes (weight 0.4), balancing immediate progress with detour prevention and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.8 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.86852,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing distance to the current node (highest weight), balancing it with maximizing distance to the destination (medium weight) to avoid premature detours, and adjusting for the centroid of unvisited nodes (lowest weight) to ensure central alignment. The weighted score (`distance_to_current - 0.7 * distance_to_dest - 0.4 * centroid_penalty`) combines these factors, with proximity to the current node being the dominant criterion.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination (to avoid premature detours), and minimizing the distance to the centroid of unvisited nodes, using weights of 1.0, 0.7, and 0.4 respectively, ensuring a balance between immediate progress and central alignment with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, maximize distance to destination, and minimize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest - 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.92769,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.0), while penalizing long distances to the destination (weight -0.4) and deviations from the unvisited nodes' centroid (weight 0.3). The centroid is calculated as the average distance from the destination to all unvisited nodes, ensuring the path stays centrally aligned while avoiding detours. The node with the lowest computed score (balancing these factors) is chosen as the next step.",
          "thought": "The new algorithm prioritizes proximity to the current node (weight 1.0), penalizes long distances to the destination (weight -0.4), and penalizes deviations from the centroid of unvisited nodes (weight 0.3), balancing immediate progress with staying centrally aligned while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9431,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing distance to the destination (weight 0.5), and moderately penalizing deviation from the centroid of unvisited nodes (weight 0.4). It prioritizes immediate progress while slightly discouraging detours and ensuring the path stays roughly centered relative to the unvisited nodes. The score calculation ensures the next node is chosen based on these weighted criteria.",
          "thought": "The new algorithm combines proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.5), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), similar to No.1 but with a lower weight for centroid penalty to balance detour avoidance and immediate progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.5 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96975,
          "other_inf": null
     }
]