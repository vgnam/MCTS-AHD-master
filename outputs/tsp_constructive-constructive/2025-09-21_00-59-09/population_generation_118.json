[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid proximity, destination proximity, and dynamic weight adjustment to select the next node in TSP. It prioritizes minimizing immediate distance to the current node (weighted heavily) while balancing destination proximity and centroid alignment (weighted lower), with dynamic weights adjusting based on remaining path length. The centroid penalty ensures nodes are close to the average distance from the destination, while the weight factor balances short-term and long-term optimization.",
          "thought": "The new algorithm combines the centroid and destination proximity heuristics from No.1 with the weighted scoring approach of No.2, while adding dynamic weight adjustment based on remaining path length to balance immediate progress with long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)\n\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing closer nodes (weighted by `distance_to_current`) while balancing destination proximity (`distance_to_dest`), centroid alignment (`centroid_penalty`), and angular deviation (`angle_deviation`). The dynamic weight factor (`weight_factor`) scales these priorities based on remaining path length, favoring short-term gains early and long-term optimization later. The centroid and angle heuristics guide the path toward a global direction, penalizing deviations.",
          "thought": "The new algorithm modifies the scoring mechanism by introducing a dynamic weight adjustment based on the remaining path length, incorporating a heuristic to favor nodes that align with a global path direction while penalizing those that deviate from a local trend, and using a combination of distance and angular deviation metrics to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Compute remaining path length estimate\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Dynamic weight adjustment based on remaining path length\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)  # Normalize based on typical path lengths\n\n        # Angle deviation heuristic: favor nodes that align with global direction\n        angle_deviation = abs(distance_matrix[current_node][destination_node] - (distance_matrix[current_node][node] + distance_matrix[node][destination_node]))\n\n        # Weighted score with dynamic adjustments\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty + \\\n                0.2 * angle_deviation\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.20089,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing the distance to the current node while dynamically balancing it with a penalty for deviation from the centroid of unvisited nodes and a slight consideration for the number of remaining nodes. The weighted score (distance_to_current + 0.2 * centroid_penalty + 0.1 * len(unvisited_nodes)) gives higher priority to proximity (distance_to_current) and moderate emphasis on centroid alignment (centroid_penalty) and node count (len(unvisited_nodes)). The centroid is calculated as the average distance from the destination node to all unvisited nodes, ensuring the path stays roughly centered.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node while also considering the number of remaining unvisited nodes to balance immediate progress with future efficiency, using a weighted score with higher emphasis on proximity and a dynamic penalty for node density.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize deviation from centroid, and consider remaining nodes\n        score = distance_to_current + 0.2 * centroid_penalty + 0.1 * len(unvisited_nodes)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.23079,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, distance to the destination, and frontier exploration, with dynamic weight adjustment based on unvisited node density. It prioritizes minimizing distances to the current node and destination while encouraging exploration of boundary nodes (frontier score), with weights adjusted based on the number of remaining unvisited nodes. The score is computed as a weighted sum of these factors, with density weight increasing when few nodes remain.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where the centroid penalty is replaced by a \"frontier score\" that rewards nodes near the boundary of unvisited clusters, promoting exploration of more diverse paths while still prioritizing proximity to the current node and destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid and frontier score\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        frontier_score = max(distance_matrix[destination_node][node] for node in unvisited_nodes)\n    else:\n        centroid_x = 0\n        frontier_score = 0\n\n    # Dynamic weight adjustment based on remaining nodes\n    density_weight = 0.3 if len(unvisited_nodes) > 3 else 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        frontier_penalty = abs(distance_matrix[node][destination_node] - frontier_score)\n\n        # Weighted score with dynamic adjustments\n        score = distance_to_current + 0.5 * distance_to_dest + density_weight * frontier_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24287,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: prioritizing proximity to the current node (weight 1.0), penalizing long distances to the destination (weight -0.3), and penalizing deviations from the centroid of unvisited nodes (weight 0.4). The centroid is calculated as the average distance from the destination to all unvisited nodes, ensuring the path stays centered while favoring nearby nodes and avoiding excessive detours. The node with the lowest combined score is chosen.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes long distances to the destination (weight -0.3), and penalizes deviation from the centroid (weight 0.4), inspired by No.1's weighted trade-off but with No.2's form.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.3 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.2464,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by balancing three key factors: prioritizing proximity to the current node (weight 1.2), discouraging long distances to the destination (weight -0.4), and penalizing nodes far from the centroid of unvisited nodes (weight 0.5). The weighted scoring ensures a trade-off between minimizing travel distance, encouraging exploration, and maintaining central alignment with unvisited nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination (to encourage exploration), and penalizing nodes far from the centroid of unvisited nodes, with weights of 1.2, -0.4, and 0.5 respectively, to balance proximity, exploration, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and penalize distance to destination, penalize deviation from centroid\n        score = 1.2 * distance_to_current - 0.4 * distance_to_dest + 0.5 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.29897,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (highest priority), distance to the destination (negative weight, encouraging closer nodes), and deviation from the centroid of unvisited nodes (moderate weight, promoting centrality). The weighted sum (`distance_to_current - 0.4 * distance_to_dest + 0.5 * centroid_penalty`) ensures a trade-off between immediate progress and path centrality, with the centroid penalty acting as a detour deterrent. The code efficiently iterates through unvisited nodes to find the node with the minimal score, handling edge cases like an empty unvisited set.",
          "thought": "The new algorithm combines the centroid-centering approach of No.1 with the weighted prioritization of No.2, using weights of 1.0 for proximity to current node, -0.4 for distance to destination, and 0.5 for centroid deviation, to balance immediate progress and path centrality while minimizing detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.5 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.31437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while penalizing nodes that deviate from the centroid of unvisited nodes' distances to the destination. It balances local (distance to current node) and global (centroid-based penalty) considerations, with the penalty given lower weight (0.3) to avoid over-optimizing for the centroid. The centroid is computed as the average distance from unvisited nodes to the destination, ensuring the path remains efficient toward the goal.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted penalty for nodes far from the destination, inspired by No.1's focus on minimizing the sum of distances to the current and destination nodes, while also incorporating a centroid-based penalty similar to No.2. The main steps are: compute the centroid of unvisited nodes based on distances to the destination, then select the next node by minimizing a weighted sum of the distance to the current node and a penalty for deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    if unvisited_nodes:\n        centroid = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Weighted score: prioritize proximity to current node and penalize deviation from centroid\n        score = distance_to_current + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.3639,
          "other_inf": null
     }
]