[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing detours from the destination (weight -0.6), and aligning with the centroid of unvisited nodes (weight 0.3). It prioritizes proximity and detour avoidance over centroid alignment, as the negative weight for destination distance heavily influences the selection. The centroid penalty ensures some balance but has a smaller impact.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a stronger penalization for distance to the destination (weight -0.6) and a balanced centroid penalty (weight 0.3), inspired by the No.1 algorithm's effective detour discouragement while maintaining the No.2 algorithm's centroid alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing distance to the current node (weight 0.8), balancing distance to the destination (weight -0.4), and penalizing deviation from the centroid of unvisited nodes (weight 0.2). It ensures a trade-off between proximity to the current node and strategic detours toward the destination while avoiding unnecessary deviations from the centroid. The score is computed for each unvisited node, and the node with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and minimizing the deviation from the centroid of unvisited nodes, with weights of 0.8, 0.4, and 0.2 respectively, ensuring a balance between proximity and strategic detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, balance destination distance, and penalize centroid deviation\n        score = 0.8 * distance_to_current - 0.4 * distance_to_dest + 0.2 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.72045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.0), while penalizing long distances to the destination (weight -0.4) and deviations from the unvisited nodes' centroid (weight 0.3). The centroid is calculated as the average distance from the destination to all unvisited nodes, ensuring the path stays centrally aligned while avoiding detours. The node with the lowest computed score (balancing these factors) is chosen as the next step.",
          "thought": "The new algorithm prioritizes proximity to the current node (weight 1.0), penalizes long distances to the destination (weight -0.4), and penalizes deviations from the centroid of unvisited nodes (weight 0.3), balancing immediate progress with staying centrally aligned while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9431,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing distance to the destination (weight 0.5), and moderately penalizing deviation from the centroid of unvisited nodes (weight 0.4). It prioritizes immediate progress while slightly discouraging detours and ensuring the path stays roughly centered relative to the unvisited nodes. The score calculation ensures the next node is chosen based on these weighted criteria.",
          "thought": "The new algorithm combines proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.5), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), similar to No.1 but with a lower weight for centroid penalty to balance detour avoidance and immediate progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.5 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96975,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid proximity, destination proximity, and dynamic weight adjustment to select the next node in TSP. It prioritizes minimizing immediate distance to the current node (weighted heavily) while balancing destination proximity and centroid alignment (weighted lower), with dynamic weights adjusting based on remaining path length. The centroid penalty ensures nodes are close to the average distance from the destination, while the weight factor balances short-term and long-term optimization.",
          "thought": "The new algorithm combines the centroid and destination proximity heuristics from No.1 with the weighted scoring approach of No.2, while adding dynamic weight adjustment based on remaining path length to balance immediate progress with long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)\n\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing the immediate distance to the current node, the distance to the destination, and penalties/bonuses for node centrality and outlier status, with dynamic weights adjusting based on remaining path length. It prioritizes minimizing direct distance early (higher weight) but shifts focus to destination proximity and cluster coherence as the tour progresses (lower weight). The robust centroid (median distance) penalizes outliers, while harmonic mean rewards central nodes, creating a trade-off between exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining path length, a penalty for nodes that are outliers in the unvisited set (using a robust centroid measure), and a bonus for nodes that are central to the unvisited cluster (using a harmonic mean of distances). The score is computed as a weighted sum of these components, with weights inversely proportional to the remaining path length to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute robust centroid of unvisited nodes (median of distances)\n    if unvisited_nodes:\n        distances_to_dest = [distance_matrix[destination_node][node] for node in unvisited_nodes]\n        distances_to_dest_sorted = sorted(distances_to_dest)\n        median_idx = len(distances_to_dest_sorted) // 2\n        centroid_x = distances_to_dest_sorted[median_idx]\n    else:\n        centroid_x = 0\n\n    # Dynamic weight based on remaining path length\n    remaining_length = len(unvisited_nodes)\n    weight_dynamic = 1.0 / (1.0 + remaining_length)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Harmonic mean of distances to other unvisited nodes\n        if len(unvisited_nodes) > 1:\n            other_nodes = [n for n in unvisited_nodes if n != node]\n            harmonic_mean = len(other_nodes) / sum(1.0 / (1.0 + distance_matrix[node][n]) for n in other_nodes)\n        else:\n            harmonic_mean = 0\n\n        # Weighted score with dynamic adjustment\n        score = (1.0 - weight_dynamic) * distance_to_current + \\\n                0.5 * weight_dynamic * distance_to_dest + \\\n                0.3 * centroid_penalty - \\\n                0.2 * harmonic_mean\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1599,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm combines centroid-based selection with dynamic weight adjustment, prioritizing distance to the current node and destination while incorporating a subtle angle deviation penalty and centroid penalty to guide the path toward a global direction. The score calculation balances these factors, with higher weights on distance to current node (1.0 + weight_factor) and lower weights on centroid penalty (0.3) and angle deviation (0.1), while dynamically adjusting weights based on remaining path length. The centroid guides global direction, and angle deviation ensures alignment with the overall path.",
          "thought": "The new algorithm combines No.2's centroid-based selection with No.1's dynamic weight adjustment for distance to current node and destination, while adding a subtle angle deviation penalty to guide the path toward a global direction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Compute remaining path length estimate\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Dynamic weight adjustment based on remaining path length\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)\n\n        # Angle deviation heuristic: favor nodes that align with global direction\n        angle_deviation = abs(distance_matrix[current_node][destination_node] - (distance_matrix[current_node][node] + distance_matrix[node][destination_node]))\n\n        # Weighted score with dynamic adjustments\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty + \\\n                0.1 * angle_deviation\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.16074,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing closer nodes (weighted by `distance_to_current`) while balancing destination proximity (`distance_to_dest`), centroid alignment (`centroid_penalty`), and angular deviation (`angle_deviation`). The dynamic weight factor (`weight_factor`) scales these priorities based on remaining path length, favoring short-term gains early and long-term optimization later. The centroid and angle heuristics guide the path toward a global direction, penalizing deviations.",
          "thought": "The new algorithm modifies the scoring mechanism by introducing a dynamic weight adjustment based on the remaining path length, incorporating a heuristic to favor nodes that align with a global path direction while penalizing those that deviate from a local trend, and using a combination of distance and angular deviation metrics to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Compute remaining path length estimate\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Dynamic weight adjustment based on remaining path length\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)  # Normalize based on typical path lengths\n\n        # Angle deviation heuristic: favor nodes that align with global direction\n        angle_deviation = abs(distance_matrix[current_node][destination_node] - (distance_matrix[current_node][node] + distance_matrix[node][destination_node]))\n\n        # Weighted score with dynamic adjustments\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty + \\\n                0.2 * angle_deviation\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.20089,
          "other_inf": null
     }
]