[
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing detours from the destination (weight -0.6), and aligning with the centroid of unvisited nodes (weight 0.3). It prioritizes proximity and detour avoidance over centroid alignment, as the negative weight for destination distance heavily influences the selection. The centroid penalty ensures some balance but has a smaller impact.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a stronger penalization for distance to the destination (weight -0.6) and a balanced centroid penalty (weight 0.3), inspired by the No.1 algorithm's effective detour discouragement while maintaining the No.2 algorithm's centroid alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.0), while penalizing long distances to the destination (weight -0.4) and deviations from the unvisited nodes' centroid (weight 0.3). The centroid is calculated as the average distance from the destination to all unvisited nodes, ensuring the path stays centrally aligned while avoiding detours. The node with the lowest computed score (balancing these factors) is chosen as the next step.",
          "thought": "The new algorithm prioritizes proximity to the current node (weight 1.0), penalizes long distances to the destination (weight -0.4), and penalizes deviations from the centroid of unvisited nodes (weight 0.3), balancing immediate progress with staying centrally aligned while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9431,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing distance to the destination (weight 0.5), and moderately penalizing deviation from the centroid of unvisited nodes (weight 0.4). It prioritizes immediate progress while slightly discouraging detours and ensuring the path stays roughly centered relative to the unvisited nodes. The score calculation ensures the next node is chosen based on these weighted criteria.",
          "thought": "The new algorithm combines proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.5), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), similar to No.1 but with a lower weight for centroid penalty to balance detour avoidance and immediate progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.5 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96975,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid proximity, destination proximity, and dynamic weight adjustment to select the next node in TSP. It prioritizes minimizing immediate distance to the current node (weighted heavily) while balancing destination proximity and centroid alignment (weighted lower), with dynamic weights adjusting based on remaining path length. The centroid penalty ensures nodes are close to the average distance from the destination, while the weight factor balances short-term and long-term optimization.",
          "thought": "The new algorithm combines the centroid and destination proximity heuristics from No.1 with the weighted scoring approach of No.2, while adding dynamic weight adjustment based on remaining path length to balance immediate progress with long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)\n\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing the immediate distance to the current node, the distance to the destination, and penalties/bonuses for node centrality and outlier status, with dynamic weights adjusting based on remaining path length. It prioritizes minimizing direct distance early (higher weight) but shifts focus to destination proximity and cluster coherence as the tour progresses (lower weight). The robust centroid (median distance) penalizes outliers, while harmonic mean rewards central nodes, creating a trade-off between exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining path length, a penalty for nodes that are outliers in the unvisited set (using a robust centroid measure), and a bonus for nodes that are central to the unvisited cluster (using a harmonic mean of distances). The score is computed as a weighted sum of these components, with weights inversely proportional to the remaining path length to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute robust centroid of unvisited nodes (median of distances)\n    if unvisited_nodes:\n        distances_to_dest = [distance_matrix[destination_node][node] for node in unvisited_nodes]\n        distances_to_dest_sorted = sorted(distances_to_dest)\n        median_idx = len(distances_to_dest_sorted) // 2\n        centroid_x = distances_to_dest_sorted[median_idx]\n    else:\n        centroid_x = 0\n\n    # Dynamic weight based on remaining path length\n    remaining_length = len(unvisited_nodes)\n    weight_dynamic = 1.0 / (1.0 + remaining_length)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Harmonic mean of distances to other unvisited nodes\n        if len(unvisited_nodes) > 1:\n            other_nodes = [n for n in unvisited_nodes if n != node]\n            harmonic_mean = len(other_nodes) / sum(1.0 / (1.0 + distance_matrix[node][n]) for n in other_nodes)\n        else:\n            harmonic_mean = 0\n\n        # Weighted score with dynamic adjustment\n        score = (1.0 - weight_dynamic) * distance_to_current + \\\n                0.5 * weight_dynamic * distance_to_dest + \\\n                0.3 * centroid_penalty - \\\n                0.2 * harmonic_mean\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1599,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically adjusts node selection by prioritizing closer nodes (weighted by `distance_to_current`) while balancing destination proximity (`distance_to_dest`), centroid alignment (`centroid_penalty`), and angular deviation (`angle_deviation`). The dynamic weight factor (`weight_factor`) scales these priorities based on remaining path length, favoring short-term gains early and long-term optimization later. The centroid and angle heuristics guide the path toward a global direction, penalizing deviations.",
          "thought": "The new algorithm modifies the scoring mechanism by introducing a dynamic weight adjustment based on the remaining path length, incorporating a heuristic to favor nodes that align with a global path direction while penalizing those that deviate from a local trend, and using a combination of distance and angular deviation metrics to balance immediate and long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Compute remaining path length estimate\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Dynamic weight adjustment based on remaining path length\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)  # Normalize based on typical path lengths\n\n        # Angle deviation heuristic: favor nodes that align with global direction\n        angle_deviation = abs(distance_matrix[current_node][destination_node] - (distance_matrix[current_node][node] + distance_matrix[node][destination_node]))\n\n        # Weighted score with dynamic adjustments\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty + \\\n                0.2 * angle_deviation\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.20089,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid-based penalization with dynamic weight adjustment and harmonic mean centrality reward to balance immediate proximity, destination alignment, and cluster coherence. It prioritizes minimizing distance to the current node (weighted by `1.0 - weight_dynamic`) and destination (weighted by `0.5 * weight_dynamic`), while penalizing deviation from the centroid (`0.3 * centroid_penalty`) and rewarding harmonic mean centrality (`0.2 * harmonic_mean`). The dynamic weight (`weight_dynamic`) shifts focus based on remaining path length, ensuring adaptability to the problem's scale.",
          "thought": "The new algorithm combines the centroid-based penalization from No.2 with the dynamic weight adjustment and harmonic mean centrality reward from No.1, creating a balanced approach that prioritizes immediate proximity, destination alignment, and cluster coherence while dynamically shifting focus based on remaining path length.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic weight based on remaining path length\n    remaining_length = len(unvisited_nodes)\n    weight_dynamic = 1.0 / (1.0 + remaining_length)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Harmonic mean of distances to other unvisited nodes\n        if len(unvisited_nodes) > 1:\n            other_nodes = [n for n in unvisited_nodes if n != node]\n            harmonic_mean = len(other_nodes) / sum(1.0 / (1.0 + distance_matrix[node][n]) for n in other_nodes)\n        else:\n            harmonic_mean = 0\n\n        # Weighted score with dynamic adjustment\n        score = (1.0 - weight_dynamic) * distance_to_current + \\\n                0.5 * weight_dynamic * distance_to_dest + \\\n                0.3 * centroid_penalty - \\\n                0.2 * harmonic_mean\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.20144,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing two key factors: minimizing the ratio of distance from the current node to the destination node (to ensure progress toward the goal), while also penalizing nodes far from the centroid of unvisited nodes (to maintain overall path efficiency). The centroid penalty is weighted lower (0.3) than the distance ratio, ensuring the ratio remains the primary objective. The score calculation handles edge cases (e.g., zero distance to destination) separately to avoid division errors.",
          "thought": "The new algorithm prioritizes minimizing the ratio of distance to the current node and distance to the destination, while also penalizing nodes far from the centroid of unvisited nodes, ensuring a balance between immediate progress and overall path efficiency.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize minimizing the ratio of distance_to_current to distance_to_dest, penalize deviation from centroid\n        if distance_to_dest == 0:\n            score = distance_to_current + 0.3 * centroid_penalty\n        else:\n            score = (distance_to_current / distance_to_dest) + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.22341,
          "other_inf": null
     }
]