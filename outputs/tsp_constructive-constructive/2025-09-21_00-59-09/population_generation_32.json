[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, distance to the destination, and frontier exploration, with dynamic weight adjustment based on unvisited node density. It prioritizes minimizing distances to the current node and destination while encouraging exploration of boundary nodes (frontier score), with weights adjusted based on the number of remaining unvisited nodes. The score is computed as a weighted sum of these factors, with density weight increasing when few nodes remain.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where the centroid penalty is replaced by a \"frontier score\" that rewards nodes near the boundary of unvisited clusters, promoting exploration of more diverse paths while still prioritizing proximity to the current node and destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid and frontier score\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        frontier_score = max(distance_matrix[destination_node][node] for node in unvisited_nodes)\n    else:\n        centroid_x = 0\n        frontier_score = 0\n\n    # Dynamic weight adjustment based on remaining nodes\n    density_weight = 0.3 if len(unvisited_nodes) > 3 else 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        frontier_penalty = abs(distance_matrix[node][destination_node] - frontier_score)\n\n        # Weighted score with dynamic adjustments\n        score = distance_to_current + 0.5 * distance_to_dest + density_weight * frontier_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24287,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while penalizing nodes that deviate from the centroid of unvisited nodes' distances to the destination. It balances local (distance to current node) and global (centroid-based penalty) considerations, with the penalty given lower weight (0.3) to avoid over-optimizing for the centroid. The centroid is computed as the average distance from unvisited nodes to the destination, ensuring the path remains efficient toward the goal.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted penalty for nodes far from the destination, inspired by No.1's focus on minimizing the sum of distances to the current and destination nodes, while also incorporating a centroid-based penalty similar to No.2. The main steps are: compute the centroid of unvisited nodes based on distances to the destination, then select the next node by minimizing a weighted sum of the distance to the current node and a penalty for deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    if unvisited_nodes:\n        centroid = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Weighted score: prioritize proximity to current node and penalize deviation from centroid\n        score = distance_to_current + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.3639,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in a TSP tour by balancing three priorities: proximity to the current node (highest weight), proximity to the destination (moderate weight), and deviation from the centroid of unvisited nodes (lowest weight). Weights adjust based on remaining nodes, favoring proximity early and centroid alignment later. The scoring formula combines normalized distances and a centroid-bias term to adapt to different tour construction stages.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the remaining path length and centroid deviation, using a novel scoring formula that combines normalized distances and a centroid-bias term, ensuring adaptability to different stages of the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic weights based on remaining path length\n    remaining_nodes = len(unvisited_nodes)\n    if remaining_nodes == 1:\n        weight_current = 1.0\n        weight_dest = 0.0\n        weight_centroid = 0.0\n    else:\n        weight_current = 0.7\n        weight_dest = 0.2 * (remaining_nodes / (remaining_nodes + 1))\n        weight_centroid = 0.1 * (1 - remaining_nodes / (remaining_nodes + 2))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize distances\n        max_distance = max(distance_matrix[current_node][n] for n in unvisited_nodes) if unvisited_nodes else 1\n        norm_distance_to_current = distance_to_current / max_distance if max_distance > 0 else 0\n        norm_distance_to_dest = distance_to_dest / max_distance if max_distance > 0 else 0\n        norm_centroid_penalty = centroid_penalty / max_distance if max_distance > 0 else 0\n\n        # Novel scoring formula\n        score = (weight_current * norm_distance_to_current +\n                 weight_dest * norm_distance_to_dest +\n                 weight_centroid * norm_centroid_penalty)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.38782,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0), closeness to the centroid of unvisited nodes (weight 0.3), and proximity to the destination (weight 0.2). It prioritizes minimizing the total weighted score, favoring nodes that are nearby, centrally located among unvisited nodes, and close to the destination. The centroid penalty helps avoid detours by penalizing nodes that deviate from the average distance to the destination.",
          "thought": "The new algorithm combines the proximity to the current node and destination from No.2 with the centroid penalty and additional distance to destination weighting from No.1, using weights 1.0, 0.3, and 0.2 for distance to current, centroid penalty, and distance to destination respectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current + 0.3 * centroid_penalty + 0.2 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.42436,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically weighting distances to the current node, destination node, and a normalized centroid penalty, with higher priority given to the current node\u2019s distance (dynamic_weight_current = 1.0 + 0.2 * remaining_nodes / (remaining_nodes + 1)), followed by the destination distance (dynamic_weight_dest = 0.5 + 0.1 * remaining_nodes / (remaining_nodes + 1)), and a lower-priority centroid penalty (dynamic_weight_centroid = 0.3 * remaining_nodes / (remaining_nodes + 2)). The centroid penalty is normalized by the number of unvisited nodes to balance exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting scheme that adjusts priorities based on the remaining path length and node density, using a normalized centroid penalty that scales with the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute dynamic weights based on remaining path length and node density\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight_current = 1.0 + (0.2 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_dest = 0.5 + (0.1 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_centroid = 0.3 * (remaining_nodes / (remaining_nodes + 2))\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize centroid penalty by the number of unvisited nodes\n        normalized_centroid = centroid_penalty / (remaining_nodes + 1)\n\n        # Dynamic weighted score\n        score = (dynamic_weight_current * distance_to_current +\n                 dynamic_weight_dest * distance_to_dest +\n                 dynamic_weight_centroid * normalized_centroid)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.2, implicit), penalizing deviation from the centroid of unvisited nodes (weight 0.4), and slightly considering distance to the destination (weight 0.1). The centroid is calculated as the average distance from the destination to all unvisited nodes. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the lowest score. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes that are closest to the current node, penalizes nodes far from the centroid of unvisited nodes, and slightly considers distance to the destination, with weights 1.2, 0.4, and 0.1 respectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Weighted score: prioritize proximity to current node, penalize centroid deviation, slightly consider destination\n        score = distance_to_current + 0.4 * centroid_penalty + 0.1 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47633,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, distance to the destination, and a dynamically adjusted centroid penalty (prioritized via a decay factor). It favors nodes closer to the current node and destination while gradually reducing the influence of centroid alignment as more nodes are visited, ensuring a smooth transition to the destination. The centroid penalty is weighted lower (0.3) than direct distances (1.0 and 0.5), while the decay factor dynamically adjusts its impact based on remaining unvisited nodes.",
          "thought": "The new algorithm modifies the selection process by incorporating a dynamic weight adjustment for the centroid penalty based on the remaining unvisited nodes, using a decay factor to prioritize central alignment as the path progresses, while retaining the primary focus on proximity to the current node and destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic decay factor for centroid penalty based on remaining nodes\n    decay_factor = 1.0 / (len(unvisited_nodes) + 1)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Adjust centroid penalty with decay factor\n        adjusted_penalty = centroid_penalty * decay_factor\n\n        # Weighted score with dynamic centroid penalty\n        score = distance_to_current + 0.5 * distance_to_dest + 0.3 * adjusted_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.48345,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), closeness to the destination (weight 0.4), and avoiding detours via a centroid penalty (weight 0.3). It prioritizes minimizing the immediate path while also steering toward the destination and discouraging large deviations from the average distance to the destination. The centroid penalty helps maintain a more direct route by penalizing nodes that are too far from the average distance to the destination.",
          "thought": "The new algorithm combines the prioritization of proximity to the current node (weight 1.0) and closeness to the destination (weight 0.4) from No.2, while adding a centroid penalty (weight 0.3) to avoid detours, similar to No.1 but with adjusted weights to balance these factors more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current + 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.50023,
          "other_inf": null
     }
]