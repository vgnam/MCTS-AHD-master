[
     {
          "algorithm": "The algorithm prioritizes selecting the next node by balancing proximity to the current node (80% weight), penalizing distance to the destination (50% weight), and aligning with the centroid of unvisited nodes (20% weight). It computes the centroid as the average distance of unvisited nodes to the destination and penalizes nodes that deviate from this centroid. The weighted scoring ensures a trade-off between immediate progress and path centralization.",
          "thought": "The new algorithm prioritizes immediate distance to the current node and centroid alignment with unvisited nodes, while penalizing distance to the destination, creating a more centralized path with less emphasis on direct progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and centroid, penalize distance to destination\n        score = 0.8 * distance_to_current + 0.2 * centroid_penalty - 0.5 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.64951,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing detours from the destination (weight -0.6), and aligning with the centroid of unvisited nodes (weight 0.3). It prioritizes proximity and detour avoidance over centroid alignment, as the negative weight for destination distance heavily influences the selection. The centroid penalty ensures some balance but has a smaller impact.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0) with a stronger penalization for distance to the destination (weight -0.6) and a balanced centroid penalty (weight 0.3), inspired by the No.1 algorithm's effective detour discouragement while maintaining the No.2 algorithm's centroid alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.68316,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing distance to the current node (weight 0.8), balancing distance to the destination (weight -0.4), and penalizing deviation from the centroid of unvisited nodes (weight 0.2). It ensures a trade-off between proximity to the current node and strategic detours toward the destination while avoiding unnecessary deviations from the centroid. The score is computed for each unvisited node, and the node with the lowest score is chosen.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and minimizing the deviation from the centroid of unvisited nodes, with weights of 0.8, 0.4, and 0.2 respectively, ensuring a balance between proximity and strategic detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, balance destination distance, and penalize centroid deviation\n        score = 0.8 * distance_to_current - 0.4 * distance_to_dest + 0.2 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.72045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes selecting the next node by minimizing distance to the current node (highest weight), balancing it with maximizing distance to the destination (medium weight) to avoid premature detours, and adjusting for the centroid of unvisited nodes (lowest weight) to ensure central alignment. The weighted score (`distance_to_current - 0.7 * distance_to_dest - 0.4 * centroid_penalty`) combines these factors, with proximity to the current node being the dominant criterion.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination (to avoid premature detours), and minimizing the distance to the centroid of unvisited nodes, using weights of 1.0, 0.7, and 0.4 respectively, ensuring a balance between immediate progress and central alignment with remaining nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, maximize distance to destination, and minimize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest - 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.92769,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.0), while penalizing long distances to the destination (weight -0.4) and deviations from the unvisited nodes' centroid (weight 0.3). The centroid is calculated as the average distance from the destination to all unvisited nodes, ensuring the path stays centrally aligned while avoiding detours. The node with the lowest computed score (balancing these factors) is chosen as the next step.",
          "thought": "The new algorithm prioritizes proximity to the current node (weight 1.0), penalizes long distances to the destination (weight -0.4), and penalizes deviations from the centroid of unvisited nodes (weight 0.3), balancing immediate progress with staying centrally aligned while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.9431,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), penalizing distance to the destination (weight 0.5), and moderately penalizing deviation from the centroid of unvisited nodes (weight 0.4). It prioritizes immediate progress while slightly discouraging detours and ensuring the path stays roughly centered relative to the unvisited nodes. The score calculation ensures the next node is chosen based on these weighted criteria.",
          "thought": "The new algorithm combines proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.5), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), similar to No.1 but with a lower weight for centroid penalty to balance detour avoidance and immediate progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.5 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.96975,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid proximity, destination proximity, and dynamic weight adjustment to select the next node in TSP. It prioritizes minimizing immediate distance to the current node (weighted heavily) while balancing destination proximity and centroid alignment (weighted lower), with dynamic weights adjusting based on remaining path length. The centroid penalty ensures nodes are close to the average distance from the destination, while the weight factor balances short-term and long-term optimization.",
          "thought": "The new algorithm combines the centroid and destination proximity heuristics from No.1 with the weighted scoring approach of No.2, while adding dynamic weight adjustment based on remaining path length to balance immediate progress with long-term optimization.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    remaining_length = sum(distance_matrix[current_node][node] for node in unvisited_nodes) + distance_matrix[current_node][destination_node]\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        weight_factor = 1.0 / (1.0 + remaining_length / 1000)\n\n        score = (1.0 + weight_factor) * distance_to_current + \\\n                0.5 * (1.0 - weight_factor) * distance_to_dest + \\\n                0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.15607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in a TSP tour by balancing the immediate distance to the current node, the distance to the destination, and penalties/bonuses for node centrality and outlier status, with dynamic weights adjusting based on remaining path length. It prioritizes minimizing direct distance early (higher weight) but shifts focus to destination proximity and cluster coherence as the tour progresses (lower weight). The robust centroid (median distance) penalizes outliers, while harmonic mean rewards central nodes, creating a trade-off between exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weight adjustment based on the remaining path length, a penalty for nodes that are outliers in the unvisited set (using a robust centroid measure), and a bonus for nodes that are central to the unvisited cluster (using a harmonic mean of distances). The score is computed as a weighted sum of these components, with weights inversely proportional to the remaining path length to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute robust centroid of unvisited nodes (median of distances)\n    if unvisited_nodes:\n        distances_to_dest = [distance_matrix[destination_node][node] for node in unvisited_nodes]\n        distances_to_dest_sorted = sorted(distances_to_dest)\n        median_idx = len(distances_to_dest_sorted) // 2\n        centroid_x = distances_to_dest_sorted[median_idx]\n    else:\n        centroid_x = 0\n\n    # Dynamic weight based on remaining path length\n    remaining_length = len(unvisited_nodes)\n    weight_dynamic = 1.0 / (1.0 + remaining_length)\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Harmonic mean of distances to other unvisited nodes\n        if len(unvisited_nodes) > 1:\n            other_nodes = [n for n in unvisited_nodes if n != node]\n            harmonic_mean = len(other_nodes) / sum(1.0 / (1.0 + distance_matrix[node][n]) for n in other_nodes)\n        else:\n            harmonic_mean = 0\n\n        # Weighted score with dynamic adjustment\n        score = (1.0 - weight_dynamic) * distance_to_current + \\\n                0.5 * weight_dynamic * distance_to_dest + \\\n                0.3 * centroid_penalty - \\\n                0.2 * harmonic_mean\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.1599,
          "other_inf": null
     }
]