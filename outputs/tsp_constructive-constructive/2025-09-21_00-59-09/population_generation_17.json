[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, distance to the destination, and frontier exploration, with dynamic weight adjustment based on unvisited node density. It prioritizes minimizing distances to the current node and destination while encouraging exploration of boundary nodes (frontier score), with weights adjusted based on the number of remaining unvisited nodes. The score is computed as a weighted sum of these factors, with density weight increasing when few nodes remain.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where the centroid penalty is replaced by a \"frontier score\" that rewards nodes near the boundary of unvisited clusters, promoting exploration of more diverse paths while still prioritizing proximity to the current node and destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid and frontier score\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        frontier_score = max(distance_matrix[destination_node][node] for node in unvisited_nodes)\n    else:\n        centroid_x = 0\n        frontier_score = 0\n\n    # Dynamic weight adjustment based on remaining nodes\n    density_weight = 0.3 if len(unvisited_nodes) > 3 else 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        frontier_penalty = abs(distance_matrix[node][destination_node] - frontier_score)\n\n        # Weighted score with dynamic adjustments\n        score = distance_to_current + 0.5 * distance_to_dest + density_weight * frontier_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24287,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while penalizing nodes that deviate from the centroid of unvisited nodes' distances to the destination. It balances local (distance to current node) and global (centroid-based penalty) considerations, with the penalty given lower weight (0.3) to avoid over-optimizing for the centroid. The centroid is computed as the average distance from unvisited nodes to the destination, ensuring the path remains efficient toward the goal.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted penalty for nodes far from the destination, inspired by No.1's focus on minimizing the sum of distances to the current and destination nodes, while also incorporating a centroid-based penalty similar to No.2. The main steps are: compute the centroid of unvisited nodes based on distances to the destination, then select the next node by minimizing a weighted sum of the distance to the current node and a penalty for deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    if unvisited_nodes:\n        centroid = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Weighted score: prioritize proximity to current node and penalize deviation from centroid\n        score = distance_to_current + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.3639,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically weighting distances to the current node, destination node, and a normalized centroid penalty, with higher priority given to the current node\u2019s distance (dynamic_weight_current = 1.0 + 0.2 * remaining_nodes / (remaining_nodes + 1)), followed by the destination distance (dynamic_weight_dest = 0.5 + 0.1 * remaining_nodes / (remaining_nodes + 1)), and a lower-priority centroid penalty (dynamic_weight_centroid = 0.3 * remaining_nodes / (remaining_nodes + 2)). The centroid penalty is normalized by the number of unvisited nodes to balance exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting scheme that adjusts priorities based on the remaining path length and node density, using a normalized centroid penalty that scales with the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute dynamic weights based on remaining path length and node density\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight_current = 1.0 + (0.2 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_dest = 0.5 + (0.1 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_centroid = 0.3 * (remaining_nodes / (remaining_nodes + 2))\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize centroid penalty by the number of unvisited nodes\n        normalized_centroid = centroid_penalty / (remaining_nodes + 1)\n\n        # Dynamic weighted score\n        score = (dynamic_weight_current * distance_to_current +\n                 dynamic_weight_dest * distance_to_dest +\n                 dynamic_weight_centroid * normalized_centroid)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47471,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.2, implicit), penalizing deviation from the centroid of unvisited nodes (weight 0.4), and slightly considering distance to the destination (weight 0.1). The centroid is calculated as the average distance from the destination to all unvisited nodes. The function iterates through unvisited nodes, computes a weighted score for each, and selects the node with the lowest score. If no unvisited nodes remain, it returns the destination node.",
          "thought": "The new algorithm prioritizes nodes that are closest to the current node, penalizes nodes far from the centroid of unvisited nodes, and slightly considers distance to the destination, with weights 1.2, 0.4, and 0.1 respectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Weighted score: prioritize proximity to current node, penalize centroid deviation, slightly consider destination\n        score = distance_to_current + 0.4 * centroid_penalty + 0.1 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47633,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node (weight 1.0), closeness to the destination (weight 0.4), and avoiding detours via a centroid penalty (weight 0.3). It prioritizes minimizing the immediate path while also steering toward the destination and discouraging large deviations from the average distance to the destination. The centroid penalty helps maintain a more direct route by penalizing nodes that are too far from the average distance to the destination.",
          "thought": "The new algorithm combines the prioritization of proximity to the current node (weight 1.0) and closeness to the destination (weight 0.4) from No.2, while adding a centroid penalty (weight 0.3) to avoid detours, similar to No.1 but with adjusted weights to balance these factors more effectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current + 0.4 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.50023,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically balances three factors\u2014proximity to the current node, proximity to the destination, and node connectivity (visibility)\u2014with weights that adjust based on remaining unvisited nodes. Early in the path, it prioritizes proximity to the current node and visibility, while later stages emphasize proximity to the destination. The score function combines these factors with dynamically adjusted weights to select the next node efficiently.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the proximity to the destination and the remaining path length, while also incorporating a \"visibility\" factor to favor nodes that offer better overall connectivity to unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute dynamic weights based on remaining path length\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = 1.0 - (0.5 / (remaining_nodes + 1))  # Decreases as remaining nodes decrease\n    weight_dest = 0.5 + (0.3 / (remaining_nodes + 1))      # Increases as remaining nodes decrease\n    weight_visibility = 0.3 * (1.0 / (remaining_nodes + 1)) # Decreases as remaining nodes decrease\n\n    # Precompute visibility scores (average distance to other unvisited nodes)\n    visibility_scores = {}\n    for node in unvisited_nodes:\n        if unvisited_nodes:\n            avg_distance = sum(distance_matrix[node][other] for other in unvisited_nodes) / len(unvisited_nodes)\n            visibility_scores[node] = avg_distance\n        else:\n            visibility_scores[node] = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        visibility_score = visibility_scores[node]\n\n        # Dynamic score with adjusted weights\n        score = (weight_current * distance_to_current +\n                 weight_dest * distance_to_dest +\n                 weight_visibility * visibility_score)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.53499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node, closeness to the destination, and penalizing nodes far from the centroid of unvisited nodes, balancing immediate progress with avoiding detours. The weighted score combines `distance_to_current` (highest priority), `distance_to_dest` (medium priority), and `centroid_penalty` (lowest priority), with weights of 1.0, 0.5, and 0.3 respectively. The centroid is computed based on distances to the destination, ensuring the path stays centrally aligned with unvisited nodes.",
          "thought": "The new algorithm selects the next node by prioritizing nodes that minimize a weighted combination of the immediate distance from the current node, the distance to the destination, and a penalty for nodes that are far from the centroid of the remaining unvisited nodes, aiming to balance progress toward the destination while avoiding detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and destination, penalize deviation from centroid\n        score = distance_to_current + 0.5 * distance_to_dest + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.55979,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines nearest-neighbor selection with a lookahead mechanism, prioritizing immediate distance to the current node (weight 2.0), closeness to the destination (weight 1.5), and centroid deviation (weight 0.5), while also considering future steps (weight 0.3) to balance exploration and exploitation. The centroid is calculated based on distances from the destination to guide the path toward unvisited nodes, and the lookahead evaluates the best possible next step from each candidate node.",
          "thought": "The new algorithm selects the next node by combining the nearest-neighbor approach with a lookahead mechanism that evaluates the potential impact of choosing a node on both immediate and future steps, using a weighted score that balances proximity to the current node, closeness to the destination, and the node's position relative to the centroid of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    centroid = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes) if unvisited_nodes else 0\n\n    for node in unvisited_nodes:\n        # Immediate distance to current node\n        distance_to_current = distance_matrix[current_node][node]\n\n        # Distance to destination\n        distance_to_dest = distance_matrix[node][destination_node]\n\n        # Centroid deviation penalty\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Lookahead: evaluate the best possible next step from this node\n        remaining_nodes = [n for n in unvisited_nodes if n != node]\n        if remaining_nodes:\n            best_future_distance = min(distance_matrix[node][n] for n in remaining_nodes)\n        else:\n            best_future_distance = 0\n\n        # Weighted score combining immediate, destination, centroid, and lookahead\n        score = (2.0 * distance_to_current +\n                 1.5 * distance_to_dest +\n                 0.5 * centroid_penalty +\n                 0.3 * best_future_distance)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.64863,
          "other_inf": null
     }
]