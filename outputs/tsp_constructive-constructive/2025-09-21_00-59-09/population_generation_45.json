[
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node (weight 1.5), penalizing distance to the destination (weight 0.7), and penalizing deviation from the centroid of unvisited nodes (weight 0.4). It balances immediate progress, detour avoidance, and central alignment to guide the tour efficiently. The weighted scoring ensures a trade-off between minimizing distance to the current node and avoiding long detours or isolated nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination, and penalizing nodes far from the centroid of unvisited nodes, using weights of 1.5, 0.7, and 0.4 respectively, to balance immediate progress, detour avoidance, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node, penalize distance to destination, and penalize deviation from centroid\n        score = distance_to_current - 0.7 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 6.94055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0, highest priority), penalizing distance to the destination (weight 0.6, moderate priority), and penalizing deviation from the centroid of unvisited nodes (weight 0.4, lowest priority). It calculates a score for each unvisited node and chooses the one with the lowest score, ensuring a trade-off between immediate progress, detour avoidance, and central alignment.",
          "thought": "The new algorithm combines the proximity to the current node (weight 1.0), penalizes distance to the destination (weight 0.6), and penalizes deviation from the centroid of unvisited nodes (weight 0.4), balancing immediate progress, detour avoidance, and central alignment to achieve a lower objective value.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current - 0.6 * distance_to_dest + 0.4 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.05729,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing proximity to the current node, distance to the destination, and frontier exploration, with dynamic weight adjustment based on unvisited node density. It prioritizes minimizing distances to the current node and destination while encouraging exploration of boundary nodes (frontier score), with weights adjusted based on the number of remaining unvisited nodes. The score is computed as a weighted sum of these factors, with density weight increasing when few nodes remain.",
          "thought": "The new algorithm modifies the selection criteria by incorporating a dynamic weight adjustment based on the remaining unvisited nodes' density, where the centroid penalty is replaced by a \"frontier score\" that rewards nodes near the boundary of unvisited clusters, promoting exploration of more diverse paths while still prioritizing proximity to the current node and destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid and frontier score\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n        frontier_score = max(distance_matrix[destination_node][node] for node in unvisited_nodes)\n    else:\n        centroid_x = 0\n        frontier_score = 0\n\n    # Dynamic weight adjustment based on remaining nodes\n    density_weight = 0.3 if len(unvisited_nodes) > 3 else 0.5\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        frontier_penalty = abs(distance_matrix[node][destination_node] - frontier_score)\n\n        # Weighted score with dynamic adjustments\n        score = distance_to_current + 0.5 * distance_to_dest + density_weight * frontier_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.24287,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by balancing three key factors: prioritizing proximity to the current node (weight 1.2), discouraging long distances to the destination (weight -0.4), and penalizing nodes far from the centroid of unvisited nodes (weight 0.5). The weighted scoring ensures a trade-off between minimizing travel distance, encouraging exploration, and maintaining central alignment with unvisited nodes.",
          "thought": "The new algorithm prioritizes minimizing the distance to the current node, maximizing the distance to the destination (to encourage exploration), and penalizing nodes far from the centroid of unvisited nodes, with weights of 1.2, -0.4, and 0.5 respectively, to balance proximity, exploration, and central alignment.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score: prioritize proximity to current node and penalize distance to destination, penalize deviation from centroid\n        score = 1.2 * distance_to_current - 0.4 * distance_to_dest + 0.5 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.29897,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by prioritizing proximity to the current node while penalizing nodes that deviate from the centroid of unvisited nodes' distances to the destination. It balances local (distance to current node) and global (centroid-based penalty) considerations, with the penalty given lower weight (0.3) to avoid over-optimizing for the centroid. The centroid is computed as the average distance from unvisited nodes to the destination, ensuring the path remains efficient toward the goal.",
          "thought": "The new algorithm combines the proximity to the current node with a weighted penalty for nodes far from the destination, inspired by No.1's focus on minimizing the sum of distances to the current and destination nodes, while also incorporating a centroid-based penalty similar to No.2. The main steps are: compute the centroid of unvisited nodes based on distances to the destination, then select the next node by minimizing a weighted sum of the distance to the current node and a penalty for deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes based on distances to destination\n    if unvisited_nodes:\n        centroid = sum(distance_matrix[node][destination_node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid)\n\n        # Weighted score: prioritize proximity to current node and penalize deviation from centroid\n        score = distance_to_current + 0.3 * centroid_penalty\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.3639,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm dynamically selects the next node in a TSP tour by balancing three priorities: proximity to the current node (highest weight), proximity to the destination (moderate weight), and deviation from the centroid of unvisited nodes (lowest weight). Weights adjust based on remaining nodes, favoring proximity early and centroid alignment later. The scoring formula combines normalized distances and a centroid-bias term to adapt to different tour construction stages.",
          "thought": "The new algorithm introduces a dynamic weighting mechanism that adjusts priorities based on the remaining path length and centroid deviation, using a novel scoring formula that combines normalized distances and a centroid-bias term, ensuring adaptability to different stages of the tour construction.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic weights based on remaining path length\n    remaining_nodes = len(unvisited_nodes)\n    if remaining_nodes == 1:\n        weight_current = 1.0\n        weight_dest = 0.0\n        weight_centroid = 0.0\n    else:\n        weight_current = 0.7\n        weight_dest = 0.2 * (remaining_nodes / (remaining_nodes + 1))\n        weight_centroid = 0.1 * (1 - remaining_nodes / (remaining_nodes + 2))\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize distances\n        max_distance = max(distance_matrix[current_node][n] for n in unvisited_nodes) if unvisited_nodes else 1\n        norm_distance_to_current = distance_to_current / max_distance if max_distance > 0 else 0\n        norm_distance_to_dest = distance_to_dest / max_distance if max_distance > 0 else 0\n        norm_centroid_penalty = centroid_penalty / max_distance if max_distance > 0 else 0\n\n        # Novel scoring formula\n        score = (weight_current * norm_distance_to_current +\n                 weight_dest * norm_distance_to_dest +\n                 weight_centroid * norm_centroid_penalty)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.38782,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by balancing three factors: proximity to the current node (weight 1.0), closeness to the centroid of unvisited nodes (weight 0.3), and proximity to the destination (weight 0.2). It prioritizes minimizing the total weighted score, favoring nodes that are nearby, centrally located among unvisited nodes, and close to the destination. The centroid penalty helps avoid detours by penalizing nodes that deviate from the average distance to the destination.",
          "thought": "The new algorithm combines the proximity to the current node and destination from No.2 with the centroid penalty and additional distance to destination weighting from No.1, using weights 1.0, 0.3, and 0.2 for distance to current, centroid penalty, and distance to destination respectively.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        score = distance_to_current + 0.3 * centroid_penalty + 0.2 * distance_to_dest\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.42436,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid bias, weighted proximity, and destination prioritization, dynamically adjusting weights to prioritize immediate progress (70%) over destination alignment (20%) and centroid deviation (10%) when many nodes remain. It penalizes nodes deviating from the centroid of unvisited nodes, ensuring the path stays aligned with the overall goal while avoiding detours. The weights shift to focus solely on destination proximity when only one node remains.",
          "thought": "The new algorithm combines the centroid bias from No.1 with the weighted proximity and destination prioritization from No.2, dynamically adjusting weights to balance immediate progress, destination alignment, and centroid deviation, while penalizing nodes that deviate from the centroid of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic weights based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = 0.7 if remaining_nodes > 1 else 1.0\n    weight_dest = 0.2 if remaining_nodes > 1 else 0.0\n    weight_centroid = 0.1 if remaining_nodes > 1 else 0.0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score with dynamic weights\n        score = (weight_current * distance_to_current +\n                 weight_dest * distance_to_dest +\n                 weight_centroid * centroid_penalty)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.45822,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm combines centroid bias with proximity prioritization, dynamically adjusting weights to balance proximity to the current node, alignment with the centroid, and distance to the destination. Early in the search, it heavily favors proximity to the current node (weight_current = 0.6), while later it increasingly penalizes deviation from the centroid (weight_centroid = 0.1) and slightly considers distance to the destination (weight_dest = 0.3). The centroid is computed as the average distance of unvisited nodes from the destination.",
          "thought": "The new algorithm combines the centroid bias of No.1 with the simple weighted scoring of No.2, dynamically adjusting weights based on remaining nodes to prioritize proximity early and centroid alignment later, while penalizing deviation from the centroid.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = None\n    min_score = float('inf')\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    # Dynamic weights based on remaining nodes\n    remaining_nodes = len(unvisited_nodes)\n    weight_current = 0.6 if remaining_nodes > 1 else 1.0\n    weight_dest = 0.3 if remaining_nodes > 1 else 0.0\n    weight_centroid = 0.1 if remaining_nodes > 1 else 0.0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Weighted score with dynamic weights\n        score = (weight_current * distance_to_current +\n                 weight_dest * distance_to_dest +\n                 weight_centroid * centroid_penalty)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.4588,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node in TSP by dynamically weighting distances to the current node, destination node, and a normalized centroid penalty, with higher priority given to the current node\u2019s distance (dynamic_weight_current = 1.0 + 0.2 * remaining_nodes / (remaining_nodes + 1)), followed by the destination distance (dynamic_weight_dest = 0.5 + 0.1 * remaining_nodes / (remaining_nodes + 1)), and a lower-priority centroid penalty (dynamic_weight_centroid = 0.3 * remaining_nodes / (remaining_nodes + 2)). The centroid penalty is normalized by the number of unvisited nodes to balance exploration and exploitation.",
          "thought": "The new algorithm modifies the selection criterion by incorporating a dynamic weighting scheme that adjusts priorities based on the remaining path length and node density, using a normalized centroid penalty that scales with the number of unvisited nodes to balance exploration and exploitation.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return destination_node\n\n    min_score = float('inf')\n    next_node = None\n\n    # Compute dynamic weights based on remaining path length and node density\n    remaining_nodes = len(unvisited_nodes)\n    dynamic_weight_current = 1.0 + (0.2 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_dest = 0.5 + (0.1 * remaining_nodes / (remaining_nodes + 1))\n    dynamic_weight_centroid = 0.3 * (remaining_nodes / (remaining_nodes + 2))\n\n    # Compute centroid of unvisited nodes\n    if unvisited_nodes:\n        centroid_x = sum(distance_matrix[destination_node][node] for node in unvisited_nodes) / len(unvisited_nodes)\n    else:\n        centroid_x = 0\n\n    for node in unvisited_nodes:\n        distance_to_current = distance_matrix[current_node][node]\n        distance_to_dest = distance_matrix[node][destination_node]\n        centroid_penalty = abs(distance_matrix[node][destination_node] - centroid_x)\n\n        # Normalize centroid penalty by the number of unvisited nodes\n        normalized_centroid = centroid_penalty / (remaining_nodes + 1)\n\n        # Dynamic weighted score\n        score = (dynamic_weight_current * distance_to_current +\n                 dynamic_weight_dest * distance_to_dest +\n                 dynamic_weight_centroid * normalized_centroid)\n\n        if score < min_score:\n            min_score = score\n            next_node = node\n\n    return next_node",
          "objective": 7.47471,
          "other_inf": null
     }
]